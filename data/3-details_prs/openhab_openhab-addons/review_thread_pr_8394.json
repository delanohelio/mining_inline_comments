{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MzUzNDM4", "number": 8394, "reviewThreads": {"totalCount": 143, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MzozNVrOEkokCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOToyMjoyM1rOElFtbg==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ4Nzc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MzozNVrOHTsGMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozODowMFrOHTuH4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzQ3NQ==", "bodyText": "Same for the other fields.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n          \n          \n            \n                private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490407475", "createdAt": "2020-09-17T16:43:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MDY3Mg==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490440672", "createdAt": "2020-09-17T17:38:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzQ3NQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ5MTcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0NDozNFrOHTsIug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODowMzoxNFrOHTvA9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODEyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            public void onConnect(boolean connectedflag) {\n          \n          \n            \n                            public void onConnect(boolean connected) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408122", "createdAt": "2020-09-17T16:44:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NTI4Nw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490455287", "createdAt": "2020-09-17T18:03:14Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODEyMg=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ5MjUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0NDo0N1rOHTsJSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozODoyN1rOHTuI3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODI2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"Initialize web socket failed \" + e.getMessage());\n          \n          \n            \n                                    \"Initialize web socket failed: \" + e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408267", "createdAt": "2020-09-17T16:44:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MDkyNw==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490440927", "createdAt": "2020-09-17T17:38:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODI2Nw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ5NDY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0NToxN1rOHTsKqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozOTowMFrOHTuKNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODYxNw==", "bodyText": "Isn't this rather a CONFIGURATION_ERROR?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408617", "createdAt": "2020-09-17T16:45:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTI3MQ==", "bodyText": "right solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490441271", "createdAt": "2020-09-17T17:39:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODYxNw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUwMjU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0NzoxNVrOHTsPjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozOToyNlrOHTuLOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwOTg2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean decodereceivedMessage(JsonObject message) {\n          \n          \n            \n                private boolean decodeReceivedMessage(JsonObject message) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490409868", "createdAt": "2020-09-17T16:47:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTUzMQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490441531", "createdAt": "2020-09-17T17:39:26Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwOTg2OA=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUwNDgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0Nzo0NVrOHTsQ6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozOTo1NlrOHTuMaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDIxNg==", "bodyText": "Empty line\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n          \n          \n            \n            \n          \n          \n            \n                        {\n          \n          \n            \n                        } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490410216", "createdAt": "2020-09-17T16:47:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTgzNQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490441835", "createdAt": "2020-09-17T17:39:56Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDIxNg=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUwNzY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0ODoxOFrOHTsSmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToxODozM1rOHT14rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private JsonObject convertStringtoJsonObject(String jsonString) {\n          \n          \n            \n                private JsonObject convertStringToJsonObject(String jsonString) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490410649", "createdAt": "2020-09-17T16:48:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MjI3Mg==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490442272", "createdAt": "2020-09-17T17:40:42Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjIxMQ==", "bodyText": "Did you push your changes?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490466211", "createdAt": "2020-09-17T18:22:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2Nzg1Mg==", "bodyText": "Yes", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490567852", "createdAt": "2020-09-17T21:18:33Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU1Mjk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1OTozM1rOHTsuFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo0MTo0MVrOHTuQPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzY4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (command.toString().equals(\"ON\")) {\n          \n          \n            \n                            if (command == OnOffType.ON) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490417686", "createdAt": "2020-09-17T16:59:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MjgxMw==", "bodyText": "solved thanks to learn more and more about the librarys", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490442813", "createdAt": "2020-09-17T17:41:41Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzY4Ng=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU1NDk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowMDowNVrOHTsvYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo0Mjo0NFrOHTuSsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODAxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String ircode) {\n          \n          \n            \n                public void sendIRCode(@Nullable String irCode) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490418016", "createdAt": "2020-09-17T17:00:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MzQ0Mw==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490443443", "createdAt": "2020-09-17T17:42:44Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODAxNg=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU1OTI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowMToxMlrOHTsyJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo0MzowMVrOHTuTWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODcyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void startwebsocketpollingthread() {\n          \n          \n            \n                private void startWebsocketPollingThread() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490418726", "createdAt": "2020-09-17T17:01:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MzYxMA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490443610", "createdAt": "2020-09-17T17:43:01Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODcyNg=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU2NzgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowMzoyNVrOHTs3hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo0NDozOFrOHTuW2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMDEwMw==", "bodyText": "You could move the code within run() into a private method and then call the scheduler with this method:\nwebsocketpollingjob = scheduler.scheduleWithFixedDelay(this::myNewMethod, 0, 30, TimeUnit.SECONDS);\nThat avoids the boiler plate code of defining an anonymous class.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490420103", "createdAt": "2020-09-17T17:03:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NDUwNw==", "bodyText": "thanks", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490444507", "createdAt": "2020-09-17T17:44:38Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMDEwMw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU3NDQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNToxOFrOHTs7rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODowMTo0OFrOHTu90A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTE2Nw==", "bodyText": "This method is only used in this class. Is there a reason why you don't access the field directly?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421167", "createdAt": "2020-09-17T17:05:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NDQ4MA==", "bodyText": "sorry for that one missed it", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490454480", "createdAt": "2020-09-17T18:01:48Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTE2Nw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU3NzY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNjowOVrOHTs9mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo0NToyMFrOHTuYoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTY1Ng==", "bodyText": "You could clarify in the method's name, that this isn't simply a getter.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean getbooleanheartbeat() {\n          \n          \n            \n                public boolean getAndResetHeartbeat() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421656", "createdAt": "2020-09-17T17:06:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NDk2MQ==", "bodyText": "dones", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490444961", "createdAt": "2020-09-17T17:45:20Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTY1Ng=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU3OTE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNjozNlrOHTs-lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODowMDoxNlrOHTu6gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTkxMA==", "bodyText": "Same question as above.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421910", "createdAt": "2020-09-17T17:06:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1MzYzNQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490453635", "createdAt": "2020-09-17T18:00:16Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTkxMA=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU4MzYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNzo0M1rOHTtBRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MjoyOVrOHTuoUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjU5Nw==", "bodyText": "Better use a switch/case to check the enum fields. This way you get a compiler warning if you miss to handle any enum constant.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422597", "createdAt": "2020-09-17T17:07:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n+        if (messagetype.equals(YioRemoteMessages.AUTHENTICATE_MESSAGE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 356}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0ODk3OA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490448978", "createdAt": "2020-09-17T17:52:29Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n+        if (messagetype.equals(YioRemoteMessages.AUTHENTICATE_MESSAGE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjU5Nw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU4NDcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowODowNFrOHTtCBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MzowN1rOHTuprQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjc5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n          \n          \n            \n                public void sendMessage(YioRemoteMessages messageType, String messagePayload) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422791", "createdAt": "2020-09-17T17:08:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTMyNQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490449325", "createdAt": "2020-09-17T17:53:07Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjc5MQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU4NTIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowODoxN1rOHTtCYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MzozM1rOHTuqsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjg4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422880", "createdAt": "2020-09-17T17:08:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTU4Nw==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490449587", "createdAt": "2020-09-17T17:53:33Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjg4MA=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU5NzQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxMTozOVrOHTtJ_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODowMjoxMVrOHTu-og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDgyOQ==", "bodyText": "Is this class really necessary? It would reduce the complexity of the binding if you don't use this wrapper class but access the web socket directly with an inner class in the handler. Like you do it with this wrapper class now.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490424829", "createdAt": "2020-09-17T17:11:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+\n+public class YIOremoteDockWebsocket {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NDY5MA==", "bodyText": "for my current programming skills this is better to understand", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490454690", "createdAt": "2020-09-17T18:02:11Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+\n+public class YIOremoteDockWebsocket {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDgyOQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODYwMTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxMjo1MFrOHTtMnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMzoyMVrOHTt9vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNTUwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n          \n          \n            \n            \t\t\t<parameter name=\"accessToken\" type=\"text\" required=\"true\">", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490425503", "createdAt": "2020-09-17T17:12:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzODA3Ng==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490438076", "createdAt": "2020-09-17T17:33:21Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNTUwMw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODYwMjczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxMzoxM1rOHTtNdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozNDowN1rOHTt_RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNTcxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Access token of the YIO Remote Dock</label>\n          \n          \n            \n            \t\t\t\t<label>Access Token</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490425717", "createdAt": "2020-09-17T17:13:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzODQ2OA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490438468", "createdAt": "2020-09-17T17:34:07Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNTcxNw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODYwNTEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxMzo1OFrOHTtPFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozNDoyOVrOHTuACQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNjEzMg==", "bodyText": "Labels should be all upper case. The binding name could be removed, as it is redundant.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Network address of the YIO Remote Dock</label>\n          \n          \n            \n            \t\t\t\t<label>Network Address</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490426132", "createdAt": "2020-09-17T17:13:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzODY2NQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490438665", "createdAt": "2020-09-17T17:34:29Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNjEzMg=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgyOTg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNjoyMlrOHTvdkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozMjo1MVrOHTwBXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MjYwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonObject getauthenticationMessageJsonObject() {\n          \n          \n            \n                public JsonObject getAuthenticationMessageJsonObject() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490462608", "createdAt": "2020-09-17T18:16:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MTc3NA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490471774", "createdAt": "2020-09-17T18:32:51Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MjYwOA=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgzMDgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNjozN1rOHTveHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozMjo1OVrOHTwBlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mjc1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getauthenticationMessageString() {\n          \n          \n            \n                public String getAuthenticationMessageString() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490462750", "createdAt": "2020-09-17T18:16:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {\n+        JsonObject authenticationMessage = new JsonObject();\n+        authenticationMessage.addProperty(\"type\", type);\n+        authenticationMessage.addProperty(\"token\", token);\n+        return authenticationMessage;\n+    }\n+\n+    public String getauthenticationMessageString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MTgyOQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490471829", "createdAt": "2020-09-17T18:32:59Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {\n+        JsonObject authenticationMessage = new JsonObject();\n+        authenticationMessage.addProperty(\"type\", type);\n+        authenticationMessage.addProperty(\"token\", token);\n+        return authenticationMessage;\n+    }\n+\n+    public String getauthenticationMessageString() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mjc1MA=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgzMjMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNzowM1rOHTvfHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo1MDozNVrOHTwnXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzAwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonObject getIRcodesendMessageJsonObject() {\n          \n          \n            \n                public JsonObject getIRcodeSendMessageJsonObject() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463005", "createdAt": "2020-09-17T18:17:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MTUwMg==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490481502", "createdAt": "2020-09-17T18:50:35Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzAwNQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgzMjkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNzoxNFrOHTvfhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozMzo1NVrOHTwDfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzEwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject ircodesendmessage = new JsonObject();\n          \n          \n            \n                    JsonObject irCodeSendMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463109", "createdAt": "2020-09-17T18:17:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MjMxOA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490472318", "createdAt": "2020-09-17T18:33:55Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzEwOQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgzMzg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNzoyN1rOHTvgFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozNDowOFrOHTwD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzI1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject ircodesendmessage = new JsonObject();\n          \n          \n            \n                    JsonObject irCodeSendMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463254", "createdAt": "2020-09-17T18:17:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();\n+        ircodesendmessage.addProperty(\"type\", type);\n+        ircodesendmessage.addProperty(\"command\", command);\n+        ircodesendmessage.addProperty(\"code\", ircode.getCode());\n+        ircodesendmessage.addProperty(\"format\", ircode.getFormat());\n+        return ircodesendmessage;\n+    }\n+\n+    public String getIRcodesendMessageString() {\n+        JsonObject ircodesendmessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MjQzOA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490472438", "createdAt": "2020-09-17T18:34:08Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();\n+        ircodesendmessage.addProperty(\"type\", type);\n+        ircodesendmessage.addProperty(\"command\", command);\n+        ircodesendmessage.addProperty(\"code\", ircode.getCode());\n+        ircodesendmessage.addProperty(\"format\", ircode.getFormat());\n+        return ircodesendmessage;\n+    }\n+\n+    public String getIRcodesendMessageString() {\n+        JsonObject ircodesendmessage = new JsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzI1NA=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgzNTEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNzo0NlrOHTvgzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozOTo0MlrOHTwPtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzQzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject irreceivermessage = new JsonObject();\n          \n          \n            \n                    JsonObject irReceiverMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463437", "createdAt": "2020-09-17T18:17:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NTQ0NQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490475445", "createdAt": "2020-09-17T18:39:42Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzQzNw=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODgzNTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNzo1N1rOHTvhNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozOTo1MlrOHTwQCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzU0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject irreceivermessage = new JsonObject();\n          \n          \n            \n                    JsonObject irReceiverMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463541", "createdAt": "2020-09-17T18:17:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();\n+        irreceivermessage.addProperty(\"type\", type);\n+        irreceivermessage.addProperty(\"command\", command);\n+        return irreceivermessage;\n+    }\n+\n+    public String getIRreceiverMessageString() {\n+        JsonObject irreceivermessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NTUzMA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490475530", "createdAt": "2020-09-17T18:39:52Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();\n+        irreceivermessage.addProperty(\"type\", type);\n+        irreceivermessage.addProperty(\"command\", command);\n+        return irreceivermessage;\n+    }\n+\n+    public String getIRreceiverMessageString() {\n+        JsonObject irreceivermessage = new JsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzU0MQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg0MTAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxOTozM1rOHTvkoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo0NDoyOFrOHTwadw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDQxNw==", "bodyText": "Please see all other fields.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Future<?> authenticationjob;\n          \n          \n            \n                private @Nullable Future<?> authenticationJob;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490464417", "createdAt": "2020-09-17T18:19:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3ODE5OQ==", "bodyText": "removed never used", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490478199", "createdAt": "2020-09-17T18:44:28Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDQxNw=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg0ODk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyMTo1MlrOHTvpjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo0Nzo0MlrOHTwhiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NTY3OQ==", "bodyText": "I overlooked that during the first reviews. Sorry for that. Please check all other Enum comparisons in all classes.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n          \n          \n            \n                                                || yioRemoteDockActualStatus\n          \n          \n            \n                                                        .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n          \n          \n            \n                                        if (yioremotedockactualstatus == YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED\n          \n          \n            \n                                                || yioremotedockactualstatus == YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490465679", "createdAt": "2020-09-17T18:21:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MDAwOA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490480008", "createdAt": "2020-09-17T18:47:42Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NTY3OQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg1MzcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyMzoyMVrOHTvsnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozNDo0NlrOHTwFOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjQ2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else if (command.toString().equals(\"OFF\")) {\n          \n          \n            \n                            } else if (command == OnOffType.OFF) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490466461", "createdAt": "2020-09-17T18:23:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3Mjc2MA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490472760", "createdAt": "2020-09-17T18:34:46Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjQ2MQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg2MTY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNToyN1rOHTvxaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTozMjoyNFrOHUSCQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ==", "bodyText": "Can you access the field directly without using this method?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490467691", "createdAt": "2020-09-17T18:25:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendIRCode(@Nullable String irCode) {\n+        if (irCode != null) {\n+            if (irCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, irCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", irCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        switch (yioRemoteDockActualStatus) {\n+            case CONNECTION_ESTABLISHED:\n+                authenticationmessagehandler.setToken(localConfig.accessToken);\n+                sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+                break;\n+            case AUTHENTICATION_PROCESS:\n+                if (authenticationok) {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                    updateStatus(ThingStatus.ONLINE);\n+                    websocketpollingjob = scheduler.scheduleWithFixedDelay(this::pollingWebsocket, 0, 30,\n+                            TimeUnit.SECONDS);\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                } else {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+                }\n+                break;\n+            default:\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                break;\n+        }\n+    }\n+\n+    private void pollingWebsocket() {\n+        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+            if (getAndResetHeartbeat()) {\n+                updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                        ircodereceivedhandler.getCode() + ircodereceivedhandler.getFormat());\n+                logger.debug(\"heartbeat ok\");\n+                sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+            } else {\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                if (websocketpollingjob != null) {\n+                    websocketpollingjob.cancel(true);\n+                }\n+            }\n+        } else {\n+            if (websocketpollingjob != null) {\n+                websocketpollingjob.cancel(true);\n+            }\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    public boolean getAndResetHeartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioRemoteDockActualStatus() {\n+        return yioRemoteDockActualStatus;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MzkxMg==", "bodyText": "I learned thatis always better to have a get function instead of accessing directly. i use this also in the action handler therefore i have this with get", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490473912", "createdAt": "2020-09-17T18:36:47Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendIRCode(@Nullable String irCode) {\n+        if (irCode != null) {\n+            if (irCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, irCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", irCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        switch (yioRemoteDockActualStatus) {\n+            case CONNECTION_ESTABLISHED:\n+                authenticationmessagehandler.setToken(localConfig.accessToken);\n+                sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+                break;\n+            case AUTHENTICATION_PROCESS:\n+                if (authenticationok) {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                    updateStatus(ThingStatus.ONLINE);\n+                    websocketpollingjob = scheduler.scheduleWithFixedDelay(this::pollingWebsocket, 0, 30,\n+                            TimeUnit.SECONDS);\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                } else {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+                }\n+                break;\n+            default:\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                break;\n+        }\n+    }\n+\n+    private void pollingWebsocket() {\n+        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+            if (getAndResetHeartbeat()) {\n+                updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                        ircodereceivedhandler.getCode() + ircodereceivedhandler.getFormat());\n+                logger.debug(\"heartbeat ok\");\n+                sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+            } else {\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                if (websocketpollingjob != null) {\n+                    websocketpollingjob.cancel(true);\n+                }\n+            }\n+        } else {\n+            if (websocketpollingjob != null) {\n+                websocketpollingjob.cancel(true);\n+            }\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    public boolean getAndResetHeartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioRemoteDockActualStatus() {\n+        return yioRemoteDockActualStatus;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAyOTA1Nw==", "bodyText": "Private fields can be accessed directly within the same class to maintain code readability. As you use it in the Actions now, it's ok to keep the method.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491029057", "createdAt": "2020-09-18T15:32:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendIRCode(@Nullable String irCode) {\n+        if (irCode != null) {\n+            if (irCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, irCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", irCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        switch (yioRemoteDockActualStatus) {\n+            case CONNECTION_ESTABLISHED:\n+                authenticationmessagehandler.setToken(localConfig.accessToken);\n+                sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+                break;\n+            case AUTHENTICATION_PROCESS:\n+                if (authenticationok) {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                    updateStatus(ThingStatus.ONLINE);\n+                    websocketpollingjob = scheduler.scheduleWithFixedDelay(this::pollingWebsocket, 0, 30,\n+                            TimeUnit.SECONDS);\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                } else {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+                }\n+                break;\n+            default:\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                break;\n+        }\n+    }\n+\n+    private void pollingWebsocket() {\n+        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+            if (getAndResetHeartbeat()) {\n+                updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                        ircodereceivedhandler.getCode() + ircodereceivedhandler.getFormat());\n+                logger.debug(\"heartbeat ok\");\n+                sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+            } else {\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                if (websocketpollingjob != null) {\n+                    websocketpollingjob.cancel(true);\n+                }\n+            }\n+        } else {\n+            if (websocketpollingjob != null) {\n+                websocketpollingjob.cancel(true);\n+            }\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    public boolean getAndResetHeartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioRemoteDockActualStatus() {\n+        return yioRemoteDockActualStatus;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg2NTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNjozNlrOHTvz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozNzozNlrOHTwLcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODM0Mg==", "bodyText": "This method is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468342", "createdAt": "2020-09-17T18:26:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {\n+        if (yioremotedockwebsocketinterfacehandler != null) {\n+            yioremotedockwebsocketinterfacehandler.onMessage(stringreceivedmessage);\n+        }\n+    }\n+\n+    public String getstringreceivedmessage() {\n+        return this.stringreceivedmessage;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NDM1NQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490474355", "createdAt": "2020-09-17T18:37:36Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {\n+        if (yioremotedockwebsocketinterfacehandler != null) {\n+            yioremotedockwebsocketinterfacehandler.onMessage(stringreceivedmessage);\n+        }\n+    }\n+\n+    public String getstringreceivedmessage() {\n+        return this.stringreceivedmessage;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODM0Mg=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg2Njc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNjo1MlrOHTv0lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozODowNFrOHTwMVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODUwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onText(Session session, String stringreceivedmessage) {\n          \n          \n            \n                public void onText(Session session, String receivedMessage) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468501", "createdAt": "2020-09-17T18:26:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NDU4Mw==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490474583", "createdAt": "2020-09-17T18:38:04Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODUwMQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg2OTM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNzozOVrOHTv2Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozODo1N1rOHTwOPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODk1NQ==", "bodyText": "Please check all occurrences.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n          \n          \n            \n                private @Nullable YIOremoteDockWebsocketInterface websocketHandler;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468955", "createdAt": "2020-09-17T18:27:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NTA2OA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490475068", "createdAt": "2020-09-17T18:38:57Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODk1NQ=="}, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU0MDg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/DTOs/AuthenticationMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTozODoyN1rOHUSPtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxNzo1MFrOHUTqcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMjUwMA==", "bodyText": "Package names should be all lower case. The directory name is upper case in your case. Also it's good practice to make the names singular. So, dto would be good.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491032500", "createdAt": "2020-09-18T15:38:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/DTOs/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal.dtos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NTcyOQ==", "bodyText": "solved i pushed it first with DTOs than changed it to dtos but this was an error during pushung therefore put dto inside", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491055729", "createdAt": "2020-09-18T16:17:50Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/DTOs/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal.dtos;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMjUwMA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU0NjA3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTozOTo1MVrOHUSTAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDoyNzowMFrOHUa54g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA==", "bodyText": "As this class can be instantiated for multiple Docks, if the user adds multiple Things, this must not be static. Each Action object has its own handler.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491033344", "createdAt": "2020-09-18T15:39:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NTM0NA==", "bodyText": "okay but without static it shows me an error therefor i leave it as it is", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491055344", "createdAt": "2020-09-18T16:17:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzODg2OA==", "bodyText": "The error is caused, since you can't access a non-static field from within a static method as sendIRCode() is. But if you change the code as proposed in the other comment, it's gonna work: Invoking the other non-static method by using the actions argument.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491138868", "createdAt": "2020-09-18T19:05:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2MTI3Ng==", "bodyText": "Can you please simple write me the complete function correctly I don't get the point to do it right. Sorry. Thanks", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491161276", "createdAt": "2020-09-18T19:56:30Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDM3MA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491174370", "createdAt": "2020-09-18T20:27:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU1Mzg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo0MTo1NFrOHUSXuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxNTo1OVrOHUTm_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDU1NQ==", "bodyText": "Just for the records, if you only check one Enum constant, an if is sufficient. You can keep this.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491034555", "createdAt": "2020-09-18T15:41:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NDg0Nw==", "bodyText": "okay  ileve this", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491054847", "createdAt": "2020-09-18T16:15:59Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDU1NQ=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU2MTEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo0Mzo1MlrOHUScMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxNDozNlrOHUTj9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNTY5Nw==", "bodyText": "You can simply invoke the other method:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        switch (dockHandler.getyioRemoteDockActualStatus()) {\n          \n          \n            \n                            case AUTHENTICATION_COMPLETE:\n          \n          \n            \n                                dockHandler.sendIRCode(irCode);\n          \n          \n            \n                                break;\n          \n          \n            \n                        }\n          \n          \n            \n                        ((YIOremoteDockActions) actions).sendIRCode(irCode);", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491035697", "createdAt": "2020-09-18T15:43:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    public static void sendIRCode(@Nullable ThingActions actions, @Nullable String irCode) {\n+        if (actions instanceof YIOremoteDockActions && dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NDA3MA==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491054070", "createdAt": "2020-09-18T16:14:36Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    public static void sendIRCode(@Nullable ThingActions actions, @Nullable String irCode) {\n+        if (actions instanceof YIOremoteDockActions && dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNTY5Nw=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU2NDEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo0NDo0MFrOHUSeAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxNToyN1rOHUTl5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjE2Mw==", "bodyText": "As dockHandler is nullable, you need to store it to a local variable and do a null check on it.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491036163", "createdAt": "2020-09-18T15:44:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NDU2NA==", "bodyText": "dones", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491054564", "createdAt": "2020-09-18T16:15:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjE2Mw=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU2OTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo0NTo1N1rOHUShOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxMzoyN1rOHUThfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjk4NA==", "bodyText": "Please double check the capitalization, as mentioned in the previous reviews.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491036984", "createdAt": "2020-09-18T15:45:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1MzQzOA==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491053438", "createdAt": "2020-09-18T16:13:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjk4NA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjU3NjkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo0Nzo1NlrOHUSlyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxMzoxNVrOHUTg_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzODE1NA==", "bodyText": "Syntactical sugar\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            case CONNECTION_ESTABLISHED:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;\n          \n          \n            \n                                            case AUTHENTICATION_PROCESS:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;\n          \n          \n            \n                                            case CONNECTION_ESTABLISHED:\n          \n          \n            \n                                            case AUTHENTICATION_PROCESS:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491038154", "createdAt": "2020-09-18T15:47:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode irCodeReceivedHandler = new IRCode();\n+    private IRCode irCodeSendHandler = new IRCode();\n+    private IRCodeSendMessage irCodeSendMessageHandler = new IRCodeSendMessage(irCodeSendHandler);\n+    private AuthenticationMessage authenticationMessageHandler = new AuthenticationMessage();\n+    private IRReceiverMessage irReceiverMessageHandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new WebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringToJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            switch (yioRemoteDockActualStatus) {\n+                                case CONNECTION_ESTABLISHED:\n+                                    authenticate();\n+                                    break;\n+                                case AUTHENTICATION_PROCESS:\n+                                    authenticate();\n+                                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1MzMxMA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491053310", "createdAt": "2020-09-18T16:13:15Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode irCodeReceivedHandler = new IRCode();\n+    private IRCode irCodeSendHandler = new IRCode();\n+    private IRCodeSendMessage irCodeSendMessageHandler = new IRCodeSendMessage(irCodeSendHandler);\n+    private AuthenticationMessage authenticationMessageHandler = new AuthenticationMessage();\n+    private IRReceiverMessage irReceiverMessageHandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new WebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringToJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            switch (yioRemoteDockActualStatus) {\n+                                case CONNECTION_ESTABLISHED:\n+                                    authenticate();\n+                                    break;\n+                                case AUTHENTICATION_PROCESS:\n+                                    authenticate();\n+                                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzODE1NA=="}, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzI2MzE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOToyMjoyM1rOHUZOAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDoyNzoxOFrOHUa6Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Njc1NA==", "bodyText": "You need to store dockHandler to a local variable and do the null check on that to get rid of the compiler warning. As dockHandler is a field it could be modified by another thread exactly after the null check and before the access in the following lines.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491146754", "createdAt": "2020-09-18T19:22:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        if (dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+                default:\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df721cf32ddd8934a43fd4ad853bfdd163137ce4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDQ5NQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491174495", "createdAt": "2020-09-18T20:27:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        if (dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+                default:\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Njc1NA=="}, "originalCommit": {"oid": "df721cf32ddd8934a43fd4ad853bfdd163137ce4"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU2Njc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMToxNFrOHOsYIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0ODo0M1rOHQmTbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTE4Nw==", "bodyText": "Can you mention the Thing Type ID?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485169187", "createdAt": "2020-09-08T20:11:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNDk3Mg==", "bodyText": "Don't Understand what you mean?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486614972", "createdAt": "2020-09-10T20:29:37Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTE4Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjgyOQ==", "bodyText": "DOne", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487166829", "createdAt": "2020-09-11T16:48:43Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTE4Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU2OTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMTo1OVrOHOsZhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjowMzoyN1rOHO35aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTU0Mg==", "bodyText": "The \"yiodock\" prefix could be removed as it is redundant for all config parameters/channels.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485169542", "createdAt": "2020-09-08T20:11:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1NzkyOQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485357929", "createdAt": "2020-09-09T06:03:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTU0Mg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU3MTExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMjozOFrOHOsaxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMjozOFrOHOsaxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTg2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n          \n          \n            \n            | yiodockreceiverswitch     | Input         | Switch       | The switch to enable disable the IR receiving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485169862", "createdAt": "2020-09-08T20:12:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU3Mzk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMzozMlrOHOscdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozMDowNlrOHQEosg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDI5NA==", "bodyText": "This sounds rather an Action, than a Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485170294", "createdAt": "2020-09-08T20:13:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTIxOA==", "bodyText": "Action Handler is implemented", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615218", "createdAt": "2020-09-10T20:30:06Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDI5NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU3NjkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNDozMVrOHOseYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMzo0M1rOHQHiRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDc4Nw==", "bodyText": "This should be a trigger Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485170787", "createdAt": "2020-09-08T20:14:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodockstatus\t\t\t    | Output        | String       | The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise the IR send status is displayed of the last IR code send.\t|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjcyNQ==", "bodyText": "changed to trigger channel", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662725", "createdAt": "2020-09-10T22:13:43Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodockstatus\t\t\t    | Output        | String       | The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise the IR send status is displayed of the last IR code send.\t|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDc4Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU3ODM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNDo1OVrOHOsfRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoxMDowMFrOHO4CqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTAxMw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485171013", "createdAt": "2020-09-08T20:14:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+\n+    /**\n+     * Sample configuration parameter. Replace with your own.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MDI5Nw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485360297", "createdAt": "2020-09-09T06:10:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+\n+    /**\n+     * Sample configuration parameter. Replace with your own.\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTAxMw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU4MTQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNTozNVrOHOsg4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozMDo1NVrOHQEqNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTQyNQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485171425", "createdAt": "2020-09-08T20:15:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTYwNQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615605", "createdAt": "2020-09-10T20:30:55Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTQyNQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU4NjkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNzoyM1rOHOskKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoyMTowOFrOHO4TBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjI2NA==", "bodyText": "You could store config to a local variable and do a null check on that to eliminate the compiler warning.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    config = getConfigAs(YIOremoteConfiguration.class);\n          \n          \n            \n                    YIOremoteConfiguration localConfig = config = getConfigAs(YIOremoteConfiguration.class);", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172264", "createdAt": "2020-09-08T20:17:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NDQ4NQ==", "bodyText": "Cool Idea thanks for the Help :)", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485364485", "createdAt": "2020-09-09T06:21:08Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjI2NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU4NzY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNzo0M1rOHOskvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMzoyNVrOHQHh0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjQxMg==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172412", "createdAt": "2020-09-08T20:17:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjYxMQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662611", "createdAt": "2020-09-10T22:13:25Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjQxMg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU4OTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxODoyNFrOHOsmGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMzoxNlrOHQHhoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg==", "bodyText": "Can you use the debugger instead of logging this? Same for below", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172762", "createdAt": "2020-09-08T20:18:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTg5OA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615898", "createdAt": "2020-09-10T20:31:34Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjU2MA==", "bodyText": "yes solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662560", "createdAt": "2020-09-10T22:13:16Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU5MDc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxODo0NlrOHOsmtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMjoxOFrOHQHgNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjkxOA==", "bodyText": "Can you remove this?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172918", "createdAt": "2020-09-08T20:18:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjE5OQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662199", "createdAt": "2020-09-10T22:12:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjkxOA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU5OTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyMToyN1rOHOssQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozMTo1M1rOHQEsDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDMzOA==", "bodyText": "initialize() should return fast. This should be executed in a scheduler task, like in the generated skeleton code.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485174338", "createdAt": "2020-09-08T20:21:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjA3Nw==", "bodyText": "scheduler task implemented", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616077", "createdAt": "2020-09-10T20:31:53Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDMzOA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYwNDg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyMzowN1rOHOsvYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoxMTo0NVrOHO4FQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTEzNw==", "bodyText": "Please use camelCase. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n          \n          \n            \n                private WebSocketClient yioRemoteDockwebSocketClient = new WebSocketClient();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175137", "createdAt": "2020-09-08T20:23:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MDk2Mg==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485360962", "createdAt": "2020-09-09T06:11:45Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTEzNw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYwNjk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyMzo1MVrOHOswsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0OTo1NFrOHQmV1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw==", "bodyText": "What's the purpose of the sleep?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175473", "createdAt": "2020-09-08T20:23:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE5Mw==", "bodyText": "to wait for the message", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616193", "createdAt": "2020-09-10T20:32:11Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzQ0NQ==", "bodyText": "it's a YIO DOck Bug currently", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487167445", "createdAt": "2020-09-11T16:49:54Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYwODgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNDoyN1rOHOsxzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoyNDoxOFrOHO4X7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTc1OA==", "bodyText": "Can you fix the formatting?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175758", "createdAt": "2020-09-08T20:24:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NTc0Mg==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485365742", "createdAt": "2020-09-09T06:24:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTc1OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYxMDA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNDo1M1rOHOsykg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMjowNlrOHQHf1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTk1NA==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175954", "createdAt": "2020-09-08T20:24:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjEwMg==", "bodyText": "not sure which one....therefore leave it for the first release", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662102", "createdAt": "2020-09-10T22:12:06Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTk1NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYxNDYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNjoyOFrOHOs1fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozMjo1MVrOHQEtrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjcwMg==", "bodyText": "You could set the Thing to OFFLINE with updateStatus() instead of logging it. Then, the error message is logged and displayed in the UI. Same for above.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485176702", "createdAt": "2020-09-08T20:26:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjQ5NQ==", "bodyText": "removed the logging", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616495", "createdAt": "2020-09-10T20:32:51Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjcwMg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYxNzYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNzoyOVrOHOs3YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoyMzozMFrOHO4Wpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzE4NA==", "bodyText": "Better use the exception's message. Same for the others.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.warn(\"JSON convertion failure {}\", e.toString());\n          \n          \n            \n                                logger.warn(\"JSON convertion failure {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485177184", "createdAt": "2020-09-08T20:27:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NTQxNQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485365415", "createdAt": "2020-09-09T06:23:30Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzE4NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYxOTk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyODoxNFrOHOs4zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozMzowM1rOHQEuIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzU0OA==", "bodyText": "This logging could be removed, as updateStatus() does it already.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485177548", "createdAt": "2020-09-08T20:28:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjYwOQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616609", "createdAt": "2020-09-10T20:33:03Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzU0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYyMzc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyOTozMFrOHOs7HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjowODowOFrOHQHaDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODE0MQ==", "bodyText": "Better set the Channel to UnDefType.UNDEF instead of a custom string.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178141", "createdAt": "2020-09-08T20:29:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDYyMg==", "bodyText": "SOlved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486660622", "createdAt": "2020-09-10T22:08:08Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODE0MQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYyNjAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMDowN1rOHOs8eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMToxOFrOHQHezg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODQ5MA==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178490", "createdAt": "2020-09-08T20:30:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTgzOA==", "bodyText": "not sure therefore leve it as it is", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661838", "createdAt": "2020-09-10T22:11:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODQ5MA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYyODEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMDo0OFrOHOs9yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDo1ODo1MFrOHPLnZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODgyNQ==", "bodyText": "Please use the debugger instead of logging it.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178825", "createdAt": "2020-09-08T20:30:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4MDk5Ng==", "bodyText": "This is a very appropriate use of logging, and should not be complained about.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485680996", "createdAt": "2020-09-09T14:58:50Z", "author": {"login": "9037568"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODgyNQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYzMTExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMTo0NFrOHOs_ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMTozNVrOHQHfKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTI3NA==", "bodyText": "You could store pollingJob to a local variable an do a null check on that, to eliminate the compiler warning.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179274", "createdAt": "2020-09-08T20:31:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTkzMA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661930", "createdAt": "2020-09-10T22:11:35Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTI3NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYzMTQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMTo1MVrOHOs_xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwNjozMToyMlrOHT_y9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179334", "createdAt": "2020-09-08T20:31:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzU0NA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487167544", "createdAt": "2020-09-11T16:50:04Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTMxMA==", "bodyText": "I don't see a null check.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419310", "createdAt": "2020-09-12T15:15:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDIyOQ==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490730229", "createdAt": "2020-09-18T06:31:22Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYzMzczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMjozMVrOHOtBJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1MTowM1rOHQmYWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTY4NQ==", "bodyText": "The framework takes care of the Channel values when the Thing is disposed. This can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179685", "createdAt": "2020-09-08T20:32:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODA5MA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168090", "createdAt": "2020-09-11T16:51:03Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTY4NQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYzNDg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMjo1MVrOHOtB1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoyNToxOVrOHO4Zug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2MA==", "bodyText": "Can you do this?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179860", "createdAt": "2020-09-08T20:32:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NjIwMg==", "bodyText": "I deleted it...makes no sense", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485366202", "createdAt": "2020-09-09T06:25:19Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2MA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY0MDE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozNDo0NFrOHOtFMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1MToxOVrOHQmY1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDcyMw==", "bodyText": "If I see correctly this is a trigger channel. So a refresh doesn't need to be handled.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485180723", "createdAt": "2020-09-08T20:34:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODIxNQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168215", "createdAt": "2020-09-11T16:51:19Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDcyMw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY0MzA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozNTozMlrOHOtGyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwNjozMTowNVrOHT_ydA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ==", "bodyText": "No harm in updating an unlinked Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181131", "createdAt": "2020-09-08T20:35:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDk0Ng==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486660946", "createdAt": "2020-09-10T22:08:59Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTQ1Mg==", "bodyText": "I still see the if.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419452", "createdAt": "2020-09-12T15:17:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDEwMA==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490730100", "createdAt": "2020-09-18T06:31:05Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY0MzkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozNTo0OFrOHOtHTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjowOToyMVrOHQHb6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTI2MQ==", "bodyText": "See above. camelCase", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181261", "createdAt": "2020-09-08T20:35:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTA5OQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661099", "createdAt": "2020-09-10T22:09:21Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTI2MQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY0NTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozNjoyMFrOHOtIQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjowOTo0NVrOHQHcfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTUwNA==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181504", "createdAt": "2020-09-08T20:36:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTI0Nw==", "bodyText": "not sure", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661247", "createdAt": "2020-09-10T22:09:45Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTUwNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY0OTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozNzoyMVrOHOtKWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjowODozOFrOHO4Aaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjA0Mw==", "bodyText": "Please use underscores to separate the words.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum YIOREMOTEHANDLESTATUS {\n          \n          \n            \n                public static enum YIO_REMOTE_HANDLE_STATUS {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182043", "createdAt": "2020-09-08T20:37:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    private static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEHANDLESTATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1OTcyMw==", "bodyText": "Changed to correct YIO_REMOTE_DOCK_HANDLE_STATUS", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485359723", "createdAt": "2020-09-09T06:08:38Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    private static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjA0Mw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY1MTI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozODowNFrOHOtLvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjowOTozNVrOHQHcRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjM5Nw==", "bodyText": "The IOException is never thrown. So, this could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182397", "createdAt": "2020-09-08T20:38:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTE5MA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661190", "createdAt": "2020-09-10T22:09:35Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjM5Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY1MjIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozODoyMlrOHOtMTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMDoxN1rOHQHdQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjU0MQ==", "bodyText": "See above. null check", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182541", "createdAt": "2020-09-08T20:38:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTQ0MQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661441", "createdAt": "2020-09-10T22:10:17Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjU0MQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY1MzgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozODo1NVrOHOtNVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMDoyN1rOHQHdig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjgwNg==", "bodyText": "Please fix the formatting", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182806", "createdAt": "2020-09-08T20:38:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTUxNA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661514", "createdAt": "2020-09-10T22:10:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjgwNg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY1NDQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozOTowOVrOHOtNwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMDo1OVrOHQHeVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjkxMg==", "bodyText": "See above. camelCase", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182912", "createdAt": "2020-09-08T20:39:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    private boolean decode_receivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTcxNw==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661717", "createdAt": "2020-09-10T22:10:59Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    private boolean decode_receivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjkxMg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY2MDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteWebsocketPolling.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MToxMVrOHOtRrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1MTozMVrOHQmZTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzkxOQ==", "bodyText": "What's the purpose of this method?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485183919", "createdAt": "2020-09-08T20:41:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteWebsocketPolling.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link YIOremoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteWebsocketPolling implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODMzMw==", "bodyText": "deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168333", "createdAt": "2020-09-11T16:51:31Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteWebsocketPolling.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link YIOremoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteWebsocketPolling implements Runnable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzkxOQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY2MTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MToyM1rOHOtR-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1MTo0OVrOHQmaAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4Mzk5NA==", "bodyText": "Could you be a bit more verbose, so that somebody who hasn't heard about it gets a clue what this is about?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485183994", "createdAt": "2020-09-08T20:41:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"yioremote\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>YIOremote Binding</name>\n+\t<description>This is the binding for YIOremote.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODUxNA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168514", "createdAt": "2020-09-11T16:51:49Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"yioremote\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>YIOremote Binding</name>\n+\t<description>This is the binding for YIOremote.</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4Mzk5NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY2MTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MTozN1rOHOtSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1MTo0MFrOHQmZoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDExOA==", "bodyText": "Can these be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485184118", "createdAt": "2020-09-08T20:41:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODQxNw==", "bodyText": "deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168417", "createdAt": "2020-09-11T16:51:40Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDExOA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY2MjUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MTo1MFrOHOtS3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMDo0M1rOHQHd-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDIyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.yioremote.description = Diese Addon kontrolliert eine YIO Dock / Remote-Kombination\n          \n          \n            \n            binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485184220", "createdAt": "2020-09-08T20:41:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Diese Addon kontrolliert eine YIO Dock / Remote-Kombination", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTYyNg==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661626", "createdAt": "2020-09-10T22:10:43Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Diese Addon kontrolliert eine YIO Dock / Remote-Kombination", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDIyMA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY2NjYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MzowNVrOHOtVTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNTo1NzozMlrOHO3x6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDg0Ng==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485184846", "createdAt": "2020-09-08T20:43:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1NjAxMA==", "bodyText": "Yes, it's now deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485356010", "createdAt": "2020-09-09T05:57:32Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDg0Ng=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY2ODQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MzozN1rOHOtWVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjoyNzo0MlrOHO4d1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTExMQ==", "bodyText": "You could specify <context>network-address</context> to get a free validation.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485185111", "createdAt": "2020-09-08T20:43:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NzI1Mw==", "bodyText": "Cool thanks for the input changed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485367253", "createdAt": "2020-09-09T06:27:42Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTExMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY3MDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0NDoxNlrOHOtXpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0OToyMlrOHQmU3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTQ0Ng==", "bodyText": "Can you make this speaking, as this is displayed in the UI. Same for the description", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485185446", "createdAt": "2020-09-08T20:44:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>\n+\t\t\t\t<description>Host/IP Address of the YIO Dock</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"yiodockaccesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token for the YIO Dock</label>\n+\t\t\t\t<description>Access token for the YIO Dock</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"yiodockreceiverswitch\" typeId=\"yiodockreceiverswitch\"/>\n+\t\t\t<channel id=\"yiodocksendircode\" typeId=\"yiodocksendircode\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Results</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"yiodockstatus\" typeId=\"yiodockstatus\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"yiodockreceiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>yiodockreceiverswitch</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzE5Ng==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487167196", "createdAt": "2020-09-11T16:49:22Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>\n+\t\t\t\t<description>Host/IP Address of the YIO Dock</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"yiodockaccesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token for the YIO Dock</label>\n+\t\t\t\t<description>Access token for the YIO Dock</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"yiodockreceiverswitch\" typeId=\"yiodockreceiverswitch\"/>\n+\t\t\t<channel id=\"yiodocksendircode\" typeId=\"yiodocksendircode\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Results</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"yiodockstatus\" typeId=\"yiodockstatus\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"yiodockreceiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>yiodockreceiverswitch</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTQ0Ng=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY3MzA2OnYy", "diffSide": "RIGHT", "path": "bundles/pom.xml", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0NTowM1rOHOtZOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo1MDoxNlrOHUSreQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA==", "bodyText": "Can you leave the header as-is?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485185848", "createdAt": "2020-09-08T20:45:03Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1NjY3OQ==", "bodyText": "Yes of course but this changing during commit process I don't know why.....must be somewhere a wrong setting....", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485356679", "createdAt": "2020-09-09T05:59:44Z", "author": {"login": "miloit"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDgwOA==", "bodyText": "The header is still re-formatted by this PR.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250808", "createdAt": "2020-09-16T08:17:35Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcyOTg2Ng==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490729866", "createdAt": "2020-09-18T06:30:28Z", "author": {"login": "miloit"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzOTYwOQ==", "bodyText": "I still see the re-formatting in the header.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491039609", "createdAt": "2020-09-18T15:50:16Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODkyNTAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDo0Nzo0M1rOHQ0Vaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDo0Nzo0M1rOHQ0Vaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NjcxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Thing: YIOREMOTEDOCK\n          \n          \n            \n            * Thing Type ID: `yioremotedock`", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487396715", "createdAt": "2020-09-12T10:47:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,58 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIOREMOTEDOCK", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODkyNjg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDo1MDo0MlrOHQ0WXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMTozNjo1NVrOHQ0k8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng==", "bodyText": "Did you push all of your changes? I still see this without underscores.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487396956", "createdAt": "2020-09-12T10:50:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NzQ4MA==", "bodyText": "I see this YIOREMOTEDOCKHANDLESTATUS or do mean each possible state?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487397480", "createdAt": "2020-09-12T10:56:40Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NzcwNA==", "bodyText": "Sorry, my mistake. enum names should be camelCase.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487397704", "createdAt": "2020-09-12T10:59:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Nzk3OQ==", "bodyText": "No worries thanks for the review", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487397979", "createdAt": "2020-09-12T11:03:06Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQwMDY5MQ==", "bodyText": "There's a misunderstanding. The name of the Enum should be CamelCase and the members should be all uppercase and SNAKE_CASE.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487400691", "createdAt": "2020-09-12T11:36:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTEwMzg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowMTozN1rOHQ1oog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoxMDo0MFrOHQ2UUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODAxOA==", "bodyText": "Can the comment be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418018", "createdAt": "2020-09-12T15:01:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTIwMA==", "bodyText": "Deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429200", "createdAt": "2020-09-12T17:10:40Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODAxOA=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTEwNTIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowMzozOFrOHQ1pRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoxMDo1M1rOHQ2UbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODE4MA==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418180", "createdAt": "2020-09-12T15:03:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTIyOQ==", "bodyText": "Deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429229", "createdAt": "2020-09-12T17:10:53Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODE4MA=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTEwNjIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowNDozOVrOHQ1puQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoxMDoyOFrOHQ2UOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODI5Nw==", "bodyText": "The logger is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418297", "createdAt": "2020-09-12T15:04:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable YIOremoteDockHandler handler;\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockActions.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTE3OQ==", "bodyText": "Deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429179", "createdAt": "2020-09-12T17:10:28Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable YIOremoteDockHandler handler;\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockActions.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODI5Nw=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTEwNjQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowNDo1NFrOHQ1p0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoxMTowM1rOHQ2UdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODMyMw==", "bodyText": "This is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418323", "createdAt": "2020-09-12T15:04:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTIzNw==", "bodyText": "Deleted", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429237", "createdAt": "2020-09-12T17:11:03Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODMyMw=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTEwODQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowNzo1NFrOHQ1qzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxOToxNjozMlrOHQ29OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODU3NQ==", "bodyText": "What happens if the connection never gets established? As this is a thread of a shared thread pool, it shouldn't block for a long time. A better approach would be to execute the code below from within onConnect().", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418575", "createdAt": "2020-09-12T15:07:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzOTY3Mw==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487439673", "createdAt": "2020-09-12T19:16:32Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODU3NQ=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTEwOTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowOToyMFrOHQ1rQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoyNzo0MFrOHQ2Z-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODY4OA==", "bodyText": "If this sleep is really necessary, better schedule a task in 1sec. for executing the code below.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418688", "createdAt": "2020-09-12T15:09:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDY1MQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487430651", "createdAt": "2020-09-12T17:27:40Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODY4OA=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExMTMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxMToyNlrOHQ1sIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNToyMzo1MFrOHSglHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ==", "bodyText": "As this is nullable, you need to do a null check before. You can store pollingJob to a local variable and do the null check on that.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418915", "createdAt": "2020-09-12T15:11:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDcyOA==", "bodyText": "this is what i don't understand exactly can you explain it a bit more", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487430728", "createdAt": "2020-09-12T17:28:45Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMjIzMg==", "bodyText": "pollingJob can be null at this point, because it isn't inittialized in the constructor. So, you need to check if it is not null before accessing it: if (pollingJob != null).\nBut this would result in a compiler warning, as pollingJob is a field and could theoretically be modified by another thread exactly between the null check and the access in the next line.\nTo mitigate this, you can store pollingJob to a local variable before checking it:\n                                                        Future<?> localPollingJob = pollingJob;\n                                                        if (localPollingJob != null) {\n                                                            localPollingJob.cancel(true);\n                                                        }", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487432232", "createdAt": "2020-09-12T17:45:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MDIwNg==", "bodyText": "Resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489170206", "createdAt": "2020-09-16T05:23:50Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExMTk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxMjoxOVrOHQ1sdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToyMDozN1rOHT18Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODk5OQ==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418999", "createdAt": "2020-09-12T15:12:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODgwNg==", "bodyText": "There is no better way for this unfortunately", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568806", "createdAt": "2020-09-17T21:20:37Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODk5OQ=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExMjA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxMjoyN1rOHQ1sfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToyMDo1MlrOHT186w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTAwNg==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419006", "createdAt": "2020-09-12T15:12:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODkzOQ==", "bodyText": "Changed complete code", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568939", "createdAt": "2020-09-17T21:20:52Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTAwNg=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExMjU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxMzowNFrOHQ1suw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNToyNDoxNVrOHSglqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTA2Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419067", "createdAt": "2020-09-12T15:13:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MDM0Nw==", "bodyText": "I can't define an concret exception for this", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489170347", "createdAt": "2020-09-16T05:24:15Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTA2Nw=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExMzEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxNDowM1rOHQ1s_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoyOTo1MFrOHQ2asQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTEzNA==", "bodyText": "Instead of logging it, you could set the Thing state to OFFLINE.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419134", "createdAt": "2020-09-12T15:14:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDgzMw==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487430833", "createdAt": "2020-09-12T17:29:50Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTEzNA=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExMzQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxNDozNVrOHQ1tKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxOToxNjo0NlrOHQ29Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTE3OA==", "bodyText": "As this is fatal, better set the Thing to OFFLINE with an appropriate detail message.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419178", "createdAt": "2020-09-12T15:14:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzOTY4Mw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487439683", "createdAt": "2020-09-12T19:16:46Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTE3OA=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExNDI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxNToxNlrOHQ1thQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzozMjo0NFrOHQ2bxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTI2OQ==", "bodyText": "Instead of logging this, you could add the text as detail message to updateStatus().", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419269", "createdAt": "2020-09-12T15:15:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMTEwOQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487431109", "createdAt": "2020-09-12T17:32:44Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTI2OQ=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTExNTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxNjoyMFrOHQ1t7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzozMzoxMlrOHQ2b3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTM3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String string_ircode) {\n          \n          \n            \n                public void sendircode(@Nullable String stringIRCode) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419372", "createdAt": "2020-09-12T15:16:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());\n+            }\n+        });\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        if (isLinked(id)) {\n+            updateState(id, value);\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String string_ircode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMTEzNQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487431135", "createdAt": "2020-09-12T17:33:12Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());\n+            }\n+        });\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        if (isLinked(id)) {\n+            updateState(id, value);\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String string_ircode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTM3Mg=="}, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA0MDk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNjoyNVrOHSjqaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwOTo1ODozOFrOHSpeCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDcxMw==", "bodyText": "CamelCase and you don't need to repeat the name of the binding in the name necessarily as it is unique in the package.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum YIOREMOTEDOCKHANDLESTATUS {\n          \n          \n            \n                public static enum DockHandleStatus {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489220713", "createdAt": "2020-09-16T07:26:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNTg0OA==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489315848", "createdAt": "2020-09-16T09:58:38Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDcxMw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA0MTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNjozM1rOHSjqnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMzo1NFrOHSqX6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDc2Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489220767", "createdAt": "2020-09-16T07:26:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMDY2NQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489330665", "createdAt": "2020-09-16T10:23:54Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDc2Nw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA0NTUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNzo0MlrOHSjtKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwOTo1ODoxOFrOHSpdWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTQxNw==", "bodyText": "These should be SNAKE_CASE. The prefix could be dropped, too, as it is redundant. Suggestion for a more meaningful name. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";\n          \n          \n            \n                public static final String RECEIVER_SWITCH_CHANNEL = \"receiverswitch\";", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489221417", "createdAt": "2020-09-16T07:27:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,\n+        IRRECEIVEROFF;\n+    }\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_YIOREMOTEDOCK = new ThingTypeUID(BINDING_ID, \"yioremotedock\");\n+\n+    // List of all Channel Groups Group Channel ids\n+    public static final String GROUP_INPUT = \"input\";\n+    public static final String GROUP_OUTPUT = \"output\";\n+\n+    // List of all Channel ids\n+    public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNTY3NQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489315675", "createdAt": "2020-09-16T09:58:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,\n+        IRRECEIVEROFF;\n+    }\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_YIOREMOTEDOCK = new ThingTypeUID(BINDING_ID, \"yioremotedock\");\n+\n+    // List of all Channel Groups Group Channel ids\n+    public static final String GROUP_INPUT = \"input\";\n+    public static final String GROUP_OUTPUT = \"output\";\n+\n+    // List of all Channel ids\n+    public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTQxNw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA1ODc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMToxNlrOHSj1XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToxOTowOVrOHT15zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw==", "bodyText": "This method has no body. You might want to call sendircode().", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223517", "createdAt": "2020-09-16T07:31:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        yioremotedockhandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return yioremotedockhandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendircode(\n+            @ActionInput(name = \"ircode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String ircode) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDA5Ng==", "bodyText": "Can you comment on that?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490464096", "createdAt": "2020-09-17T18:18:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        yioremotedockhandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return yioremotedockhandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendircode(\n+            @ActionInput(name = \"ircode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String ircode) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODE0Mg==", "bodyText": "Changed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568142", "createdAt": "2020-09-17T21:19:09Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        yioremotedockhandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return yioremotedockhandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendircode(\n+            @ActionInput(name = \"ircode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String ircode) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA1OTY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMTozMlrOHSj15Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMDo1ODo0NlrOHT1T5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n          \n          \n            \n                private @Nullable static YIOremoteDockHandler dockHandler;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223653", "createdAt": "2020-09-16T07:31:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNjY0MQ==", "bodyText": "Why is \"yioremotedockhandler\" not oky? Because of the type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489316641", "createdAt": "2020-09-16T09:59:44Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMDczMA==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489330730", "createdAt": "2020-09-16T10:24:02Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mzg3NQ==", "bodyText": "I still see all lower case", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463875", "createdAt": "2020-09-17T18:18:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1ODQzNg==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490558436", "createdAt": "2020-09-17T20:58:46Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA2MTc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMjowM1rOHSj3Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDowMjowM1rOHSpmvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzk3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n          \n          \n            \n                private WebSocketClient webSocketClient = new WebSocketClient();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223975", "createdAt": "2020-09-16T07:32:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxODA3OA==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489318078", "createdAt": "2020-09-16T10:02:03Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzk3NQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA2NjQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMzoyN1rOHSj6DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDowMjozNFrOHSpoEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDcxNg==", "bodyText": "Please don't prefix the field name with the type and drop the binding's name as these are both redundant. Please also use camelCase. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable URI uriyiodockwebsocketaddress;\n          \n          \n            \n                private @Nullable URI websocketAddress;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489224716", "createdAt": "2020-09-16T07:33:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxODQxNg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489318416", "createdAt": "2020-09-16T10:02:34Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDcxNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA3MDQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozNDozM1rOHSj8ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDowMzo1N1rOHSprOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTMxNw==", "bodyText": "You could include the exception's message:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n          \n          \n            \n                                    \"Initialize web socket failed\");\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n          \n          \n            \n                                    \"Initialize web socket failed: \"+e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489225317", "createdAt": "2020-09-16T07:34:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxOTIyNQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489319225", "createdAt": "2020-09-16T10:03:57Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTMxNw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA3NTY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozNjowNlrOHSj_uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDowNzowMVrOHSpx8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjE2OA==", "bodyText": "Primitive types should be used where possible (boolean instead of Boolean).\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            public void onConnect(Boolean booleanconnectedflag) {\n          \n          \n            \n                            public void onConnect(boolean connected) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489226168", "createdAt": "2020-09-16T07:36:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMDk0NQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489320945", "createdAt": "2020-09-16T10:07:01Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjE2OA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTEwNTc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0NDoxN1rOHSkSJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDowNzo1NlrOHSp0JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDg4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n          \n          \n            \n                private boolean decodeReceivedMessage(JsonObject message) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489230884", "createdAt": "2020-09-16T07:44:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMTUwOQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489321509", "createdAt": "2020-09-16T10:07:56Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDg4NA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTEwNzg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0NDo0NlrOHSkTVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMzo0MVrOHSqXig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTE4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean booleanresult = false;\n          \n          \n            \n                    boolean success = false;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489231188", "createdAt": "2020-09-16T07:44:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMDU3MA==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489330570", "createdAt": "2020-09-16T10:23:41Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTE4OA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTExMTczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0NTo0N1rOHSkVrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNDoyNzoyOVrOHSzjtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ==", "bodyText": "What's the purpose of this assignment?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489231791", "createdAt": "2020-09-16T07:45:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMTkzNg==", "bodyText": "To have no problem with nullable", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489321936", "createdAt": "2020-09-16T10:08:48Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4MTE0MQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489481141", "createdAt": "2020-09-16T14:27:29Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTExMzM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0NjoxM1rOHSkWnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxMjowNlrOHSp8wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjAzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            yioremotedockhandler.booleanheartbeat = true;\n          \n          \n            \n                            booleanheartbeat = true;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232031", "createdAt": "2020-09-16T07:46:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMzcxMw==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489323713", "createdAt": "2020-09-16T10:12:06Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjAzMQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTExNTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0Njo0N1rOHSkX8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNDoyNzo0NFrOHSzkew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjM3MQ==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232371", "createdAt": "2020-09-16T07:46:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4MTMzOQ==", "bodyText": "resolved was a left over from some testing", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489481339", "createdAt": "2020-09-16T14:27:44Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjM3MQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTExOTA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0Nzo0NFrOHSkaCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxMjo1OFrOHSp-lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjkwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else\n          \n          \n            \n            \n          \n          \n            \n                    {\n          \n          \n            \n                    } else {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232905", "createdAt": "2020-09-16T07:47:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNDE4Mg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489324182", "createdAt": "2020-09-16T10:12:58Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjkwNQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTEyODEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1MDowNVrOHSkflg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyNjowNVrOHSqcwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDMyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    IRRECEIVERON,\n          \n          \n            \n                    IR_RECEIVER_ON,", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489234326", "createdAt": "2020-09-16T07:50:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMTkwNA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489331904", "createdAt": "2020-09-16T10:26:05Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDMyNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTEyOTMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1MDoyMlrOHSkgSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxMzo0MFrOHSqADQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDUwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String accesstoken = \"0\";\n          \n          \n            \n                public String accessToken = \"0\";", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489234506", "createdAt": "2020-09-16T07:50:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+    public @Nullable String host;\n+    public String accesstoken = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNDU1Nw==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489324557", "createdAt": "2020-09-16T10:13:40Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+    public @Nullable String host;\n+    public String accesstoken = \"0\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDUwNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTEzOTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1Mjo1MVrOHSkmRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMjozN1rOHSqVIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjAzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String stringIRCode) {\n          \n          \n            \n                public void sendIRCode(@Nullable String code) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489236038", "createdAt": "2020-09-16T07:52:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTk1NA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489329954", "createdAt": "2020-09-16T10:22:37Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjAzOA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE0MzY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1NDowN1rOHSkpKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxNTozN1rOHSqGJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjc3OA==", "bodyText": "The argument is not used in this method.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489236778", "createdAt": "2020-09-16T07:54:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjExNg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326116", "createdAt": "2020-09-16T10:15:37Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjc3OA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE2MjA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1ODo0M1rOHSk0aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxNjoxMlrOHSqHTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzOTY1Nw==", "bodyText": "Is it reasonable to send an authentication request every 5 sec.?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489239657", "createdAt": "2020-09-16T07:58:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjQxMw==", "bodyText": "to be faster and its normallz only running 2 after that the task is canceld", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326413", "createdAt": "2020-09-16T10:16:12Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzOTY1Nw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE3Mjg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowMToyOVrOHSk7Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMjowMlrOHSqTnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTM3NQ==", "bodyText": "Is there a reason this method is protected? You could also access the flag directly. I make a suggestion below.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489241375", "createdAt": "2020-09-16T08:01:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTU2NQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489329565", "createdAt": "2020-09-16T10:22:02Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTM3NQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE3NDE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowMTo0OFrOHSk76A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxNjoyNlrOHSqHyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTU3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (yioremotedockhandler.getbooleanauthenticationok()) {\n          \n          \n            \n                                if (booleanauthenticationok) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489241576", "createdAt": "2020-09-16T08:01:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjUzNg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326536", "createdAt": "2020-09-16T10:16:26Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTU3Ng=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE4MDE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowMzozOFrOHSk_xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxNjozN1rOHSqIGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected boolean getbooleanheartbeat() {\n          \n          \n            \n                    boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n          \n          \n            \n                    yioremotedockhandler.booleanheartbeat = false;\n          \n          \n            \n                    return booleanresult;\n          \n          \n            \n                }\n          \n          \n            \n                private boolean getbooleanheartbeat() {\n          \n          \n            \n                    boolean result = booleanheartbeat;\n          \n          \n            \n                    booleanheartbeat = false;\n          \n          \n            \n                    return result;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489242565", "createdAt": "2020-09-16T08:03:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjYxNg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326616", "createdAt": "2020-09-16T10:16:37Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjU2NQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE4Mjg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowNDoyNlrOHSlBfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMToxNVrOHSqR8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzAwNA==", "bodyText": "See above. Access directly.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489243004", "createdAt": "2020-09-16T08:04:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTEzNg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489329136", "createdAt": "2020-09-16T10:21:15Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzAwNA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 358}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTE5NzI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowODowNlrOHSlKNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNDozMjo0NVrOHSz0cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTIzNg==", "bodyText": "You could use JSON DTOs to send and receive JSON data. See here for example: https://github.com/openhab/openhab-addons/pull/8050/files#diff-904c4bebdb6a68e4a2c9d9c8289bdffdR99", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489245236", "createdAt": "2020-09-16T08:08:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+            logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\", messagepyload);\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+            stringlastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+            yioremoteDockwebSocketClient.sendMessage(\n+                    \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            logger.debug(\n+                    \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+            logger.debug(\"sending IR receiver on message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+            logger.debug(\"sending IR receiver off message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\"\n+                    + messagepyload + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            stringlastsendircode = messagepyload;\n+            logger.debug(\n+                    \"sending IR message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                    messagepyload);\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NTQyNw==", "bodyText": "I will look into this and keep it in mz mind for the next updated version is this okay for you?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489485427", "createdAt": "2020-09-16T14:32:45Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+            logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\", messagepyload);\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+            stringlastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+            yioremoteDockwebSocketClient.sendMessage(\n+                    \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            logger.debug(\n+                    \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+            logger.debug(\"sending IR receiver on message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+            logger.debug(\"sending IR receiver off message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\"\n+                    + messagepyload + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            stringlastsendircode = messagepyload;\n+            logger.debug(\n+                    \"sending IR message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                    messagepyload);\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTIzNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIwNjMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMDoyMlrOHSlPsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxODoxMVrOHSqLbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjY0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing\n          \n          \n            \n            thing-type.yioremote.yioremotedock.label = YIO Remote Dock", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489246643", "createdAt": "2020-09-16T08:10:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination\n+\n+# thing types\n+thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNzQ2OQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489327469", "createdAt": "2020-09-16T10:18:11Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination\n+\n+# thing types\n+thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjY0Mw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIwODA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMDo1MVrOHSlQ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxODowM1rOHSqLMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjkzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.yioremote.name = YIOremote Addon\n          \n          \n            \n            binding.yioremote.name = YIO Remote Binding", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489246937", "createdAt": "2020-09-16T08:10:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNzQxMQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489327411", "createdAt": "2020-09-16T10:18:03Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjkzNw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIxMjYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMjowM1rOHSlTmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxODozNFrOHSqMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NzY0Mg==", "bodyText": "Can you use the same notation over the whole binding?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO-Docks\n          \n          \n            \n            thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO Remote Docks", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489247642", "createdAt": "2020-09-16T08:12:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination\n+\n+# thing types\n+thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing\n+thing-type.yioremote.yioremotedock.description = Stellt das YIO Remote Dock Thing bereit\n+\n+# thing type config description\n+thing-type.config.yioremote.yioremotedock.host.label = IP-Adresse oder Hostname\n+thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO-Docks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNzY3Mw==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489327673", "createdAt": "2020-09-16T10:18:34Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination\n+\n+# thing types\n+thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing\n+thing-type.yioremote.yioremotedock.description = Stellt das YIO Remote Dock Thing bereit\n+\n+# thing type config description\n+thing-type.config.yioremote.yioremotedock.host.label = IP-Adresse oder Hostname\n+thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO-Docks", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NzY0Mg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIxNjM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMzowNFrOHSlV8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMDo0OVrOHSqRBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0ODI0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>YIOremote Dock Binding Thing</label>\n          \n          \n            \n            \t\t<label>YIO Remote Dock</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489248240", "createdAt": "2020-09-16T08:13:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyODkwMw==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489328903", "createdAt": "2020-09-16T10:20:49Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0ODI0MA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIxOTIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMzo1OFrOHSlXzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxOTowMFrOHSqNHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0ODcxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<thing-type id=\"yioremotedock\">\n          \n          \n            \n            \t<thing-type id=\"yioRemoteDock\">", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489248719", "createdAt": "2020-09-16T08:13:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNzkwMg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489327902", "createdAt": "2020-09-16T10:19:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0ODcxOQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIyNTQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxNTo0MFrOHSlbvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToyMDowNFrOHT17Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTcyNg==", "bodyText": "As you only have two Channels, you could add the Channels without groups, directly.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489249726", "createdAt": "2020-09-16T08:15:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyODEzNw==", "bodyText": "but than its better visible for the user or??", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489328137", "createdAt": "2020-09-16T10:19:23Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTcyNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwMTkyMw==", "bodyText": "I think it doesn't make any big difference in the UI. Do you have something special in mind?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490401923", "createdAt": "2020-09-17T16:35:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTcyNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODU1MQ==", "bodyText": "No I just thought about the overlook", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568551", "createdAt": "2020-09-17T21:20:04Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTcyNg=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIyNjI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxNTo1N1rOHSlcVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoxOTo0OFrOHSqO3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTg3OQ==", "bodyText": "You don't need to repeat the binding or Thing name here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>YIO Remote Dock receiverswitch</label>\n          \n          \n            \n            \t\t<label>Receiver Switch</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489249879", "createdAt": "2020-09-16T08:15:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyODM1MQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489328351", "createdAt": "2020-09-16T10:19:48Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTg3OQ=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIyODQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxNjozNFrOHSldtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDoyMDoxMVrOHSqPpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDIyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>YIO Remote Dock status</label>\n          \n          \n            \n            \t\t<label>Status</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250228", "createdAt": "2020-09-16T08:16:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyODU1MQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489328551", "createdAt": "2020-09-16T10:20:11Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDIyOA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIyOTMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxNjo0N1rOHSleNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxMDoxM1rOHTvQYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDM1Ng==", "bodyText": "Please remove these empty lines.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250356", "createdAt": "2020-09-16T08:16:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>\n+\t\t<description>The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise\n+\t\t\tthe IR send status is displayed of the last IR code send.</description>\n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyODQ5OQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489328499", "createdAt": "2020-09-16T10:20:04Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>\n+\t\t<description>The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise\n+\t\t\tthe IR send status is displayed of the last IR code send.</description>\n+\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDM1Ng=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNjg0Mw==", "bodyText": "Did you push your changes? I still see the empty lines.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490426843", "createdAt": "2020-09-17T17:15:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>\n+\t\t<description>The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise\n+\t\t\tthe IR send status is displayed of the last IR code send.</description>\n+\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDM1Ng=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1OTIzNQ==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490459235", "createdAt": "2020-09-17T18:10:13Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>\n+\t\t<description>The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise\n+\t\t\tthe IR send status is displayed of the last IR code send.</description>\n+\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDM1Ng=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIzMzAyOnYy", "diffSide": "RIGHT", "path": "bundles/pom.xml", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxNzo0OVrOHSlgdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo1MDoyN1rOHUSr6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw==", "bodyText": "Can you leave this as-is?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250933", "createdAt": "2020-09-16T08:17:49Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4MDIxOQ==", "bodyText": "Sorry for this but this must somewhere some configuration problem in my git explorer because I don't see this in my offline version only in the online version", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489480219", "createdAt": "2020-09-16T14:26:19Z", "author": {"login": "miloit"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwMjg4Mw==", "bodyText": "You can enable/disable ignoring of whitespaces in some Git UIs.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490402883", "createdAt": "2020-09-17T16:36:34Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1OTMyNg==", "bodyText": "resolved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490459326", "createdAt": "2020-09-17T18:10:23Z", "author": {"login": "miloit"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzOTcyMw==", "bodyText": "Here, too.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491039723", "createdAt": "2020-09-18T15:50:27Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIzNDIzOnYy", "diffSide": "LEFT", "path": "bundles/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxODowNVrOHSlhJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo1MDo0MVrOHUSscQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MTEwOA==", "bodyText": "Can you leave this as-is?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489251108", "createdAt": "2020-09-16T08:18:05Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -520,5 +523,4 @@\n       </build>\n     </profile>\n   </profiles>\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4MDMxMQ==", "bodyText": "Sorry for this but this must somewhere some configuration problem in my git explorer because I don't see this in my offline version only in the online version", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489480311", "createdAt": "2020-09-16T14:26:25Z", "author": {"login": "miloit"}, "path": "bundles/pom.xml", "diffHunk": "@@ -520,5 +523,4 @@\n       </build>\n     </profile>\n   </profiles>\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MTEwOA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzOTg1Nw==", "bodyText": "Here, too.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491039857", "createdAt": "2020-09-18T15:50:41Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -520,5 +523,4 @@\n       </build>\n     </profile>\n   </profiles>\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MTEwOA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ3MzU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MDowM1rOHTr9Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoyNzowNFrOHTts8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTE4Mw==", "bodyText": "Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String gettype() {\n          \n          \n            \n                public String getType() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405183", "createdAt": "2020-09-17T16:40:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzMzc3Ng==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490433776", "createdAt": "2020-09-17T17:27:04Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTE4Mw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ3NTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MDoyNlrOHTr-Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoyODozMlrOHTtxAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTQwNw==", "bodyText": "Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject authenticationmessagejsonobject = new JsonObject();\n          \n          \n            \n                    JsonObject authenticationMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405407", "createdAt": "2020-09-17T16:40:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {\n+        return type;\n+    }\n+\n+    public String gettoken() {\n+        return token;\n+    }\n+\n+    public void settoken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationmessagejsonobject() {\n+        JsonObject authenticationmessagejsonobject = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNDgxOQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490434819", "createdAt": "2020-09-17T17:28:32Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {\n+        return type;\n+    }\n+\n+    public String gettoken() {\n+        return token;\n+    }\n+\n+    public void settoken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationmessagejsonobject() {\n+        JsonObject authenticationmessagejsonobject = new JsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTQwNw=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ3ODI1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MTowOFrOHTsAEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMTo1MVrOHTt6bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTkwNg==", "bodyText": "Same for the others\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getformat() {\n          \n          \n            \n                public String getFormat() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405906", "createdAt": "2020-09-17T16:41:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCode.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link IRCode} the IRCode DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCode {\n+    private String code = \"0;0x0;0;0\";\n+    private String format = \"hex\";\n+\n+    public String getformat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNzIzMA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490437230", "createdAt": "2020-09-17T17:31:51Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCode.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link IRCode} the IRCode DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCode {\n+    private String code = \"0;0x0;0;0\";\n+    private String format = \"hex\";\n+\n+    public String getformat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTkwNg=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ3OTg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MTozMlrOHTsBFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMjoyNVrOHTt7xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjE2NQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490406165", "createdAt": "2020-09-17T16:41:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getircodesendmessagejsonobject() {\n+        JsonObject ircodesendmessagejsonobject = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNzU3Mg==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490437572", "createdAt": "2020-09-17T17:32:25Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getircodesendmessagejsonobject() {\n+        JsonObject ircodesendmessagejsonobject = new JsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjE2NQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODQ4MjE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MjowN1rOHTsCiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMjozM1rOHTt8EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjUzOQ==", "bodyText": "Same for below\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void seton() {\n          \n          \n            \n                public void setOn() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490406539", "createdAt": "2020-09-17T16:42:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void seton() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNzY0OQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490437649", "createdAt": "2020-09-17T17:32:33Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void seton() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjUzOQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4437, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}