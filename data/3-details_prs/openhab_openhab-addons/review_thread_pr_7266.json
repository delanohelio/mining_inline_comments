{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2Njc0MDIy", "number": 7266, "reviewThreads": {"totalCount": 82, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjozODo1NVrOD-qxPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyNzoxN1rOEIO_jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDM5MDM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjozODo1NVrOGY6QdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDozOToyOVrOGZZl6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3MzQ5Mg==", "bodyText": "Suggestion: Make it a Switch item-type to indicate the user overrode the setpoint.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428773492", "createdAt": "2020-05-21T16:38:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,211 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is 0.                       |\n+| disableHumidity | Disable retrieval of humidity information from the thermostat. Optional, the default is 0.                |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| name                   | String               | The name of the thermostat                                                |\n+| model                  | String               | The model number and firmware version of the thermostat                   |\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n+| mode                   | Number               | The current operating mode of the HVAC system                             |\n+| fan_mode               | Number               | The current operating mode of the fan                                     |\n+| program_mode           | Number               | The program schedule that the thermostat is running (CT80 Rev B only)     |\n+| set_point              | Number:Temperature   | The current temperature set point of the thermostat                       |\n+| status                 | Number               | Indicates the current running status of the HVAC system                   |\n+| fan_status             | Number               | Indicates the current fan status of the HVAC system                       |\n+| override               | Number               | Indicates if the normal program set-point has been manually overridden    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4Njg4OA==", "bodyText": "I did this to match the display on the thermostat (using transform in the example) and because it is read-only in the api. It can't be turned off so having a switch here would be confusing IMHO.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429286888", "createdAt": "2020-05-22T14:39:29Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,211 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is 0.                       |\n+| disableHumidity | Disable retrieval of humidity information from the thermostat. Optional, the default is 0.                |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| name                   | String               | The name of the thermostat                                                |\n+| model                  | String               | The model number and firmware version of the thermostat                   |\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n+| mode                   | Number               | The current operating mode of the HVAC system                             |\n+| fan_mode               | Number               | The current operating mode of the fan                                     |\n+| program_mode           | Number               | The program schedule that the thermostat is running (CT80 Rev B only)     |\n+| set_point              | Number:Temperature   | The current temperature set point of the thermostat                       |\n+| status                 | Number               | Indicates the current running status of the HVAC system                   |\n+| fan_status             | Number               | Indicates the current fan status of the HVAC system                       |\n+| override               | Number               | Indicates if the normal program set-point has been manually overridden    |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3MzQ5Mg=="}, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDQxNjk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThemostatHttpException.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjo0NjoxNVrOGY6hbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MTowM1rOGZZp8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3NzgzOQ==", "bodyText": "typo AND it's bad practice to throw unchecked (RuntimeException) Exceptions, because the compiler doesn't force you to catch the Exception. Better extend from Exception.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428777839", "createdAt": "2020-05-21T16:46:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThemostatHttpException.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+/**\n+ * The {@link RadioThemostatHttpException} extends RuntimeException\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThemostatHttpException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4NzkyMQ==", "bodyText": "@fwolter Thanks for reviewing this binding. I fixed everything that you flagged. Please take another look and let me know of any other problems.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429287921", "createdAt": "2020-05-22T14:41:03Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThemostatHttpException.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+/**\n+ * The {@link RadioThemostatHttpException} extends RuntimeException\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThemostatHttpException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3NzgzOQ=="}, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDU4MDQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozNDoxMlrOGY8LoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozNDoxMlrOGY8LoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNTAyNA==", "bodyText": "Better use scheduleWithFixedDelay", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428805024", "createdAt": "2020-05-21T17:34:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDU4NjkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozNjoxMFrOGY8PtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozNjoxMFrOGY8PtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNjA2OA==", "bodyText": "This will only work for Unix systems, better use isLoopback().", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428806068", "createdAt": "2020-05-21T17:36:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDYwMzc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo0MTozMFrOGY8a0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MjoxNVrOGZZtHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODkxNA==", "bodyText": "Are you sure you need this fine grained trace logging or can you use a debugger instead?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428808914", "createdAt": "2020-05-21T17:41:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.trace(\"Sending discovery broadcast\");\n+        // logger.trace(\"Considering {}\", ni.getName());\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.trace(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.trace(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.trace(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.trace(\"Match: {} \", response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODczMw==", "bodyText": "Agreed. The code was contributed by someone else and I thought it was production ready. I switched all of these to use debug.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429288733", "createdAt": "2020-05-22T14:42:15Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.trace(\"Sending discovery broadcast\");\n+        // logger.trace(\"Considering {}\", ni.getName());\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.trace(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.trace(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.trace(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.trace(\"Match: {} \", response);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODkxNA=="}, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDYzNDQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1MDoxMlrOGY8uVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MzoyMFrOGZZvqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxMzkwOQ==", "bodyText": "Are you sure you need this fine grained logging or can you use a debugger instead?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428813909", "createdAt": "2020-05-21T17:50:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTM4Nw==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429289387", "createdAt": "2020-05-22T14:43:20Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxMzkwOQ=="}, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY2MjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1ODozOVrOGY9A0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0ODozMVrOGZZ7Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODY0Mw==", "bodyText": "The initialize() method should return fast. No network interaction is allowed here. Schedule a task with scheduleWithFixedDelay or even better, use async HTTP client: https://www.eclipse.org/jetty/documentation/current/http-client-api.html#http-client-async", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428818643", "createdAt": "2020-05-21T17:58:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5MjM3MQ==", "bodyText": "I moved the initial query calls out into a different method and call it the first time the refresh job runs.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429292371", "createdAt": "2020-05-22T14:48:31Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODY0Mw=="}, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY2MzQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1ODo1OVrOGY9BlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1ODo1OVrOGY9BlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODgzNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428818837", "createdAt": "2020-05-21T17:58:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY2NzI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowMDowOFrOGY9EHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0Mzo1NlrOGZZxVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxOTQ4Ng==", "bodyText": "Bindings should only log to error, when they hit a bug. The correct log level would be warn. You also don't need to log the stacktrace when the connection fails, so remove the last parameter.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428819486", "createdAt": "2020-05-21T18:00:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTgxMw==", "bodyText": "Fixed and noted for future reference!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429289813", "createdAt": "2020-05-22T14:43:56Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxOTQ4Ng=="}, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY3NjY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowMjo1NFrOGY9KOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowMjo1NFrOGY9KOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMTA0OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428821048", "createdAt": "2020-05-21T18:02:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY5MzU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowNzo1N1rOGY9U7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowNzo1N1rOGY9U7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMzc4OQ==", "bodyText": "This will block one of openHAB's scheduler Threads. You should schedule another one-shot task with a 2 sec delay.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428823789", "createdAt": "2020-05-21T18:07:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY5NDU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowODoyMFrOGY9Vlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowODoyMFrOGY9Vlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMzk1OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428823958", "createdAt": "2020-05-21T18:08:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDcxMzk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoxNDozMFrOGY9iJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoxNDozMFrOGY9iJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzE3NQ==", "bodyText": "Consider doing this asynchronously (see Jetty link above), to not block a openHAB's scheduler Thread.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428827175", "createdAt": "2020-05-21T18:14:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDcxODcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoxNTo1NFrOGY9lJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoxNTo1NFrOGY9lJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzk0Mg==", "bodyText": "Should be warn, see above.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428827942", "createdAt": "2020-05-21T18:15:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDczMzU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyMDoxMlrOGY9udA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyMDoxMlrOGY9udA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDMyNA==", "bodyText": "You don't need to trim, if you specify network-address in the context tag of the hostname parameter in the XML files. This ensures your parameter is always a valid network address.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428830324", "createdAt": "2020-05-21T18:20:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDc3MTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMTo0OFrOGY-G-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMTo0OFrOGY-G-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjYwMw==", "bodyText": "Jetty is the preferred library to perform HTTP requests: https://www.openhab.org/docs/developer/guidelines.html#default-libraries", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428836603", "createdAt": "2020-05-21T18:31:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDc3NzIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMzo0M1rOGY-KpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMzo0M1rOGY-KpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzU0MQ==", "bodyText": "See Jetty hint above.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428837541", "createdAt": "2020-05-21T18:33:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());\n+                logger.debug(\"thermostatResponse = {}\", response);\n+\n+                // Map the JSON response to the correct object\n+                if (DEFAULT_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+                } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+                } else if (MODEL_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+                } else if (NAME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n+                }\n+                \n+            } finally {\n+                IOUtils.closeQuietly(connection.getInputStream());\n+            }\n+\n+            if (result != null ) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            errorMsg = e.getMessage();\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal, String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\"+ cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        byte[] out = postJson.getBytes(StandardCharsets.US_ASCII);\n+        String output = null;\n+        String errorMsg = null;\n+        \n+        try {\n+            URL url = new URL(urlStr);\n+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 503}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDc3OTIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozNDoyOFrOGY-L-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozNDoyOFrOGY-L-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzg4Mg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428837882", "createdAt": "2020-05-21T18:34:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());\n+                logger.debug(\"thermostatResponse = {}\", response);\n+\n+                // Map the JSON response to the correct object\n+                if (DEFAULT_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+                } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+                } else if (MODEL_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+                } else if (NAME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n+                }\n+                \n+            } finally {\n+                IOUtils.closeQuietly(connection.getInputStream());\n+            }\n+\n+            if (result != null ) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            errorMsg = e.getMessage();\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal, String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\"+ cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        byte[] out = postJson.getBytes(StandardCharsets.US_ASCII);\n+        String output = null;\n+        String errorMsg = null;\n+        \n+        try {\n+            URL url = new URL(urlStr);\n+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n+            conn.setRequestProperty(\"Content-Type\", \"text/plain\");\n+            conn.setFixedLengthStreamingMode(out.length);\n+            conn.setRequestMethod(\"POST\");\n+            conn.setDoOutput(true);\n+            conn.connect();\n+            \n+            OutputStream os = conn.getOutputStream();\n+            os.write(postJson.getBytes(StandardCharsets.US_ASCII));\n+            \n+            BufferedReader br = new BufferedReader(new InputStreamReader(\n+                    (conn.getInputStream())));\n+            try {\n+                if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n+                    throw new RadioThemostatHttpException(\"HTTP response code: \" + conn.getResponseCode());\n+                }\n+                output = br.readLine();\n+                \n+            } catch (IOException | RadioThemostatHttpException e) {\n+                logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+            } finally {\n+                br.close();\n+                os.close();\n+                conn.disconnect();\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat command: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 536}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDc5ODM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo0MDoxNlrOGY-YBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo0MDoxNlrOGY-YBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MDk2Ng==", "bodyText": "Add the context tag with network-address to validate the parameter automatically.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428840966", "createdAt": "2020-05-21T18:40:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,236 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to control the house's HVAC system\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\"/>\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\t\t\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDgwNzc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo0MzoxMVrOGY-d-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo0MzoxMVrOGY-d-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MjQ5MA==", "bodyText": "You don't need these checks, since you already specified min/max in the XML file.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428842490", "createdAt": "2020-05-21T18:43:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjkwODYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMjowMzowNVrOGax19Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNToyOVrOGa5izA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczMjc4OQ==", "bodyText": "You updated the binding version but did not rebase the current 2.5.x branch. I think this is the reason why the build fails.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430732789", "createdAt": "2020-05-26T22:03:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODk1Ng==", "bodyText": "Fixed!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430858956", "createdAt": "2020-05-27T05:05:29Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczMjc4OQ=="}, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjkzNTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMjoxNDoyM1rOGayG2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNTowMFrOGa5iSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNzExMg==", "bodyText": "There are some formatting errors. You can view them with mvn install -Dspotless.check.skip=false and fix them by running mvn spotless:apply.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430737112", "createdAt": "2020-05-26T22:14:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -417,30 +399,24 @@ private Object getRadioThermostatData(String resource) {\n \n         try {\n             // Run the HTTP request and get the JSON response from the thermostat\n-            URL url = new URL(urlStr);\n-            URLConnection connection = url.openConnection();\n-\n-            try {\n-                String response = IOUtils.toString(connection.getInputStream());\n-                logger.debug(\"thermostatResponse = {}\", response);\n-\n-                // Map the JSON response to the correct object\n-                if (DEFAULT_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n-                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n-                } else if (RUNTIME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n-                } else if (MODEL_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n-                } else if (NAME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n-                }\n-                \n-            } finally {\n-                IOUtils.closeQuietly(connection.getInputStream());\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n             }\n-\n+                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODgyNg==", "bodyText": "Done!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430858826", "createdAt": "2020-05-27T05:05:00Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -417,30 +399,24 @@ private Object getRadioThermostatData(String resource) {\n \n         try {\n             // Run the HTTP request and get the JSON response from the thermostat\n-            URL url = new URL(urlStr);\n-            URLConnection connection = url.openConnection();\n-\n-            try {\n-                String response = IOUtils.toString(connection.getInputStream());\n-                logger.debug(\"thermostatResponse = {}\", response);\n-\n-                // Map the JSON response to the correct object\n-                if (DEFAULT_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n-                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n-                } else if (RUNTIME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n-                } else if (MODEL_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n-                } else if (NAME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n-                }\n-                \n-            } finally {\n-                IOUtils.closeQuietly(connection.getInputStream());\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n             }\n-\n+                ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNzExMg=="}, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Mjk0MzQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMjoxNzo1MVrOGayL2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNDo0NlrOGa5iFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczODM5Mg==", "bodyText": "The words in labels should be capitalized: https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430738392", "createdAt": "2020-05-26T22:17:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,237 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to control the house's HVAC system\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\"/>\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\t\t\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host name or IP address of the thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the refresh interval in minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the run-time log and humidity refresh interval in minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable retrieval of run-time data</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODc3NQ==", "bodyText": "Fixed!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430858775", "createdAt": "2020-05-27T05:04:46Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,237 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to control the house's HVAC system\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\"/>\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\t\t\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host name or IP address of the thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the refresh interval in minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the run-time log and humidity refresh interval in minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable retrieval of run-time data</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczODM5Mg=="}, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzUyNjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo1NjoxOVrOGbf9vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo1NjoxOVrOGbf9vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODQ0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> scheduledFuture = null;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> scheduledFuture = null;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431488447", "createdAt": "2020-05-27T22:56:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzUyODEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo1Njo1N1rOGbf-oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDo1OTo0M1rOGcGg9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw==", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431488673", "createdAt": "2020-05-27T22:56:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyODM5Ng==", "bodyText": "I'm not sure I understand where it should be specified.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431528396", "createdAt": "2020-05-28T01:12:31Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAyNDEwMw==", "bodyText": "There are several different constructors for String, just use one that allows you to specify the charset like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    String response = new String(packet.getData());\n          \n          \n            \n                                    String response = new String(packet.getData(), StandardCharsets.UTF_8);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432024103", "createdAt": "2020-05-28T18:04:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NDExMg==", "bodyText": "Is this an issue for the other bindings that do discovery as well? It seems like only Feican specifies it?\nroot@Ratbert2:/mnt/d/openhab/openhab2-addons/bundles# egrep -Re 'new String.*packet.getData' *\norg.openhab.binding.feican/src/main/java/org/openhab/binding/feican/internal/FeicanDiscoveryService.java:                    new String(packet.getData(), 0, packet.getLength() - 1, StandardCharsets.UTF_8));\norg.openhab.binding.globalcache/src/main/java/org/openhab/binding/globalcache/internal/discovery/MulticastListener.java:        String beacon = (new String(packet.getData())).trim();\norg.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LutronMcastBridgeDiscoveryService.java:            String data = new String(packet.getData(), packet.getOffset(), packet.getLength(),\norg.openhab.binding.miele/src/main/java/org/openhab/binding/miele/internal/handler/MieleBridgeHandler.java:                                String event = new String(packet.getData());\norg.openhab.binding.milight/src/main/java/org/openhab/binding/milight/internal/handler/BridgeV3Handler.java:                final String received = new String(packet.getData());\norg.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java:                        String response = new String(packet.getData());", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432044112", "createdAt": "2020-05-28T18:41:30Z", "author": {"login": "billfor"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MzczOA==", "bodyText": "I think that is because you are searching for String(packet.getData() which I'm pretty sure a lot bindings don't use that exact text", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432053738", "createdAt": "2020-05-28T18:58:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTk0Nw==", "bodyText": "But yes, this would be an issue with other bindings as well. But the default charset is usually ok since it is US_ASCII or UTF-8, it only becomes a problem when running on machines with vastly different locales like arabic or chinese.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432055947", "createdAt": "2020-05-28T19:02:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1Nzg4NQ==", "bodyText": "@bobadair, one of them is Lutron.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432057885", "createdAt": "2020-05-28T19:06:13Z", "author": {"login": "billfor"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyMDA1NA==", "bodyText": "one of them is Lutron\n\nThanks Bill. I checked that file in the Lutron binding, and it actually does specify the US_ASCII charset. It just does it on the next line. :-)\n            String data = new String(packet.getData(), packet.getOffset(), packet.getLength(),\n                    StandardCharsets.US_ASCII);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432120054", "createdAt": "2020-05-28T20:59:43Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzUzMTA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo1ODoxMlrOGbgAXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMjowMFrOGblRuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTExOA==", "bodyText": "use it or lose it", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431489118", "createdAt": "2020-05-27T22:58:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n+                // .withProperty(RadioThermostatBindingConstants.PROPERTY_UUID, uuid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTQ4MQ==", "bodyText": "gone", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575481", "createdAt": "2020-05-28T04:32:00Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n+                // .withProperty(RadioThermostatBindingConstants.PROPERTY_UUID, uuid)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTExOA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzUzODA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzowMToyNVrOGbgEdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMjoxOFrOGblR9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDE2Nw==", "bodyText": "just use an if statement here instead.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431490167", "createdAt": "2020-05-27T23:01:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTU0Mg==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575542", "createdAt": "2020-05-28T04:32:18Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDE2Nw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU0MzE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzowMzoyM1rOGbgHQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMjoyN1rOGblSGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDg4MA==", "bodyText": "Don't forget to catch JsonSyntaxException", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431490880", "createdAt": "2020-05-27T23:03:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTU3Nw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575577", "createdAt": "2020-05-28T04:32:27Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDg4MA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU0NDA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzowMzo0NlrOGbgHvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMzozOVrOGblTPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAwNA==", "bodyText": "Please catch specific exceptions", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491004", "createdAt": "2020-05-27T23:03:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTg2OQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575869", "createdAt": "2020-05-28T04:33:39Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAwNA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU0NzIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzowNToxN1rOGbgJmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMToxNDoyNVrOGbibrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTQ4Mw==", "bodyText": "so you only care about the last url and ip that your find and discard the rest?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491483", "createdAt": "2020-05-27T23:05:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyODg3OA==", "bodyText": "Yes, the discovery message has several lines of output. I only care about the line that has \"location\" in it. The value will be the thermostat's IP address.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431528878", "createdAt": "2020-05-28T01:14:25Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTQ4Mw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU1MDg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzowNjoyOVrOGbgLhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMzo1NVrOGblTbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTk3NA==", "bodyText": "I assume it is supposed to be this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n          \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label)\n          \n          \n            \n                                  .withRepresentationProperty(RadioThermostatBindingConstants.PROPERTY_IP)", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491974", "createdAt": "2020-05-27T23:06:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTkxOQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575919", "createdAt": "2020-05-28T04:33:55Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTk3NA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU1OTgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxMDoxNVrOGbgQzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo0OTowNVrOGcPkIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzMyNA==", "bodyText": "might be useful to include what each of the status numbers mean.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431493324", "createdAt": "2020-05-27T23:10:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUzMTgxNw==", "bodyText": "The transform examples do that. I thought it best to expose the raw numbers for users who are migrating from doing rules based interactions with this thermostat.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431531817", "createdAt": "2020-05-28T01:26:08Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzMyNA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2ODMyMw==", "bodyText": "I just meant that you should explain what the numbers mean in the description.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432268323", "createdAt": "2020-05-29T05:49:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzMyNA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU3MTUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxNTozOVrOGbgXqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1NDoxOFrOGcPp5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTA4MQ==", "bodyText": "should this be a switch instead?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495081", "createdAt": "2020-05-27T23:15:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUzMjA4OA==", "bodyText": "It is a read only flag and cannot be turned off. The transform examples format the 0/1 for display in the UI.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431532088", "createdAt": "2020-05-28T01:27:15Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTA4MQ=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTc5Ng==", "bodyText": "I think this should be changed to a switch if there are only two possible values.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432269796", "createdAt": "2020-05-29T05:54:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTA4MQ=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU3MzgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxNjo1MFrOGbgZHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozNDo0MFrOGblUEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTQ1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Dimensionless</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495455", "createdAt": "2020-05-27T23:16:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NjA4Mw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431576083", "createdAt": "2020-05-28T04:34:40Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTQ1NQ=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU3NDU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxNzoxMFrOGbgZjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozNDo1NlrOGblUTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Temperature</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495565", "createdAt": "2020-05-27T23:17:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NjE0Mw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431576143", "createdAt": "2020-05-28T04:34:56Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTU2NQ=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU3NTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxNzozN1rOGbgaGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDozMFrOGcErdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTcwNA==", "bodyText": "This should be a thing property instead of a channel.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495704", "createdAt": "2020-05-27T23:17:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTk3Mw==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432089973", "createdAt": "2020-05-28T20:00:30Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTcwNA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU3NjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxNzo1OVrOGbgalA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMjo0MVrOGblSVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTgyOA==", "bodyText": "This should also be a property", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495828", "createdAt": "2020-05-27T23:17:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTYzNw==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575637", "createdAt": "2020-05-28T04:32:41Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTgyOA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU3OTQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/json/RadioThermostatJsonResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxOTozM1rOGbgcaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozMjo1NlrOGblSlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NjI5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Double temperature = new Double(0);\n          \n          \n            \n                private Double temperature = 0d;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431496297", "createdAt": "2020-05-27T23:19:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/json/RadioThermostatJsonResponse.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.json;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link RadioThermostatJsonResponse} is responsible for storing\n+ * the data from the thermostat 'tstat' JSON response\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatJsonResponse {\n+\n+    @SerializedName(\"temp\")\n+    private Double temperature = new Double(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTcwMA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575700", "createdAt": "2020-05-28T04:32:56Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/json/RadioThermostatJsonResponse.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.json;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link RadioThermostatJsonResponse} is responsible for storing\n+ * the data from the thermostat 'tstat' JSON response\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatJsonResponse {\n+\n+    @SerializedName(\"temp\")\n+    private Double temperature = new Double(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NjI5Nw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU5NjIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoyNzoyM1rOGbgmNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1OToyOFrOGcEoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw==", "bodyText": "It doesn't appear as if the discovery service is in any way tied to the ThingHandler instance. I also don't think there should be multiple discovery services either, so you should just make your RadioThermostatDiscoveryService a osgi service instead of initialize it here.\nPlease add this above your RadioThermostatDiscoveryService class:\n@Component(immediate=true, service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n\nthen remove all RadioThermostatDiscoveryService and ServiceRegistration logic from the RadioThrmostatHandlerFactory.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431498807", "createdAt": "2020-05-27T23:27:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUzNjk1OQ==", "bodyText": "I did this based on example that I found that passed the httpClient from the HandlerFactory into the DiscoveryService. Is there a better way to pass httpClient?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431536959", "createdAt": "2020-05-28T01:46:33Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNTYwOQ==", "bodyText": "My comments below will show exactly how to get an HttpClient into your DiscoveryService. It is the same way that you inject an HttpClient into this class.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432035609", "createdAt": "2020-05-28T18:25:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzMyOQ==", "bodyText": "Actually, per my latest comments, you don't need httpClient in your discovery service at all.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432047329", "createdAt": "2020-05-28T18:47:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTEyNA==", "bodyText": "yep. I removed it completely.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432089124", "createdAt": "2020-05-28T19:59:28Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzU5OTE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoyODo1NVrOGbgoBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozNTo1MFrOGblVFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5OTI3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n            \n          \n          \n            \n                public RadioThermostatDiscoveryService(HttpClient httpClient) {\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                \n          \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431499270", "createdAt": "2020-05-27T23:28:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NjM0MA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431576340", "createdAt": "2020-05-28T04:35:50Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5OTI3MA=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzYwNDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzozMTozNFrOGbgrVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDozNjoxN1rOGblVjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDExNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Override\n          \n          \n            \n                public void deactivate() {\n          \n          \n            \n                @Override\n          \n          \n            \n                @Deactivate\n          \n          \n            \n                public void deactivate() {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431500116", "createdAt": "2020-05-27T23:31:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NjQ2Mg==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431576462", "createdAt": "2020-05-28T04:36:17Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDExNg=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDg5ODE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODoyNjoyMlrOGcBYbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODoyNjoyMlrOGcBYbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNTk1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            @Component(immediate=true, service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n          \n          \n            \n            public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432035951", "createdAt": "2020-05-28T18:26:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDkxNzY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODozMjoyMlrOGcBlGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTozOTozN1rOGcDw6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzOTE5NA==", "bodyText": "I forgot that you can't inject a HttpClient, only a HttpClientFactory. So my apologies.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n          \n          \n            \n                    super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n          \n          \n            \n                    this.httpClient = httpClient;\n          \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClientFactory httpClientFactory) {\n          \n          \n            \n                    super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n          \n          \n            \n                    this.httpClient = httpClientFactory.getCommonHttpClient();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432039194", "createdAt": "2020-05-28T18:32:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDk4NA==", "bodyText": "removed and reverted the factory class back to the original incarnation.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074984", "createdAt": "2020-05-28T19:39:37Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzOTE5NA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDkzMjYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODozNzoxN1rOGcBvNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1ODoxNlrOGcEkYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTc4Mw==", "bodyText": "remove this loop", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432041783", "createdAt": "2020-05-28T18:37:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4ODE2MA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432088160", "createdAt": "2020-05-28T19:58:16Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTc4Mw=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDk2MTU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0NTo0OFrOGcCBrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTozODoyN1rOGcDupg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjUxMQ==", "bodyText": "Actually now that I look at it, you don't need an httpClient at all if this is all you are using it for.\nYou can replace this with:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n          \n          \n            \n                                .send();\n          \n          \n            \n                        sysinfo = contentResponse.getContentAsString();\n          \n          \n            \n                        sysinfo = HttpUtil.executeUrl(\"GET\", url, 20000);\n          \n      \n    \n    \n  \n\nYou can do the same for the code below as well.\nYeah, I think the best course of action would be to remove the httpClient field entirely from this class.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432046511", "createdAt": "2020-05-28T18:45:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            if (\"location\".equals(key)) {\n+                try {\n+                    url = value;\n+                    ip = new URL(value).getHost();\n+                } catch (MalformedURLException e) {\n+                    logger.debug(\"Malfored URL {}\", e.getMessage());\n+                }\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDQwNg==", "bodyText": "Cool that simplifies a lot of things!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074406", "createdAt": "2020-05-28T19:38:27Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            if (\"location\".equals(key)) {\n+                try {\n+                    url = value;\n+                    ip = new URL(value).getHost();\n+                } catch (MalformedURLException e) {\n+                    logger.debug(\"Malfored URL {}\", e.getMessage());\n+                }\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjUxMQ=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTEzMjQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTozODowMVrOGcDt-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMTo1NDoxMlrOGcMUnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA==", "bodyText": "@cpmeister is it ok to use a blocking HTTP request on a scheduler thread?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074234", "createdAt": "2020-05-28T19:38:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3ODQwMw==", "bodyText": "It is ok to use a blocking request on a scheduler thread.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432078403", "createdAt": "2020-05-28T19:45:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4MDgxNg==", "bodyText": "The only time that you wouldn't want to use the scheduler thread is when you are running a task that could take longer than a couple of seconds. In that case a dedicated thread/threadpool would be more appropriate.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432080816", "createdAt": "2020-05-28T19:49:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5ODc2OA==", "bodyText": "If I see correctly, the thread is blocked for 20 sec. if the device is not reachable. Is that acceptable?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432098768", "createdAt": "2020-05-28T20:16:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwNTUxMQ==", "bodyText": "Couldn't you set a timeout for the request so that it would only block for a couple of seconds at most?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432105511", "createdAt": "2020-05-28T20:30:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwNjE0OA==", "bodyText": "I think an http timeout of 20 seconds is a little unreasonable. Even in the worst conditions a timeout of 3 seconds should be more than sufficient.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432106148", "createdAt": "2020-05-28T20:31:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExMTI0OA==", "bodyText": "Ordinarily I would agree. But this thing is slow as molasses. It can only process one request at a time. And if it is busy doing other things, the response will take a while. But if you got past the point of the device responding with the SSDP packet, there is not any issue with reachability. The 20 seconds was for insurance because I saw it timeout frequently with the timeout set for 10 seconds.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432111248", "createdAt": "2020-05-28T20:42:04Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExMjc3OA==", "bodyText": "What about using Jetty's async API?\nhttpClient.newRequest(\"http://domain.com/path\")\n        .send(result -> { /* Your logic here */ });", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432112778", "createdAt": "2020-05-28T20:45:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNDEwMg==", "bodyText": "If it is going to be a problem I can get rid of the Http calls in the discovery. The IP address from the SSDP packet would be enough to create the thing. Getting additional info via Http was needed to provide the friendly name of the thermostat to the inbox.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432114102", "createdAt": "2020-05-28T20:47:43Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNTA2MA==", "bodyText": "What about using Jetty's async API?\n\nI though we had already gone down that road but the issues injecting openhab's httpClient instance into the discovery service was too much overhead.\n@cpmeister", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432125060", "createdAt": "2020-05-28T21:09:37Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTcyMw==", "bodyText": "I think discovery runs in a dedicated thread, which is not a problem. But the code we're talking about is in the handler. I just saw that this HTTP request is even invoked within initialize(), which should return fast.\nEDIT: Sorry, it's too late. This is ran via the scheduler thread.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432129723", "createdAt": "2020-05-28T21:19:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNDgzOA==", "bodyText": "Yep. initialize() just calls the scheduler now.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432134838", "createdAt": "2020-05-28T21:29:28Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5NQ==", "bodyText": "For the RT I wait 3 seconds, and retry 3 times before giving up. I haven't had any permanent timeouts in a month (I have 4 of the CT50 model).\n    private String getData(String path) throws RadioThermostatCommunicationException {\n        String content;\n        for (int i = 0; i < RETRY_ATTEMPTS; i++) {\n            try {\n                String requestString = baseURL + path;\n                logger.trace(\"Requesting {}\", requestString);\n\n                ContentResponse response = httpClient.newRequest(requestString)\n                        .timeout(TIMEOUT_SECONDS, TimeUnit.SECONDS).send();\n                logger.trace(\"Response code {}\", response.getStatus());\n                if (response.getStatus() != 200) {\n                    throw new RadioThermostatCommunicationException(\n                            \"Error communicating with thermostat. Error Code: \" + response.getStatus());\n                }\n                content = response.getContentAsString();\n                logger.trace(\"sendRequest: response {}\", content);\n                return content;\n            } catch (InterruptedException | ExecutionException e) {\n                throw new RadioThermostatCommunicationException(e);\n            } catch (TimeoutException e) {\n                logger.debug(\"Timeout\", e);\n            }\n        }\n        throw new RadioThermostatCommunicationException(\"All retries timed out.\");\n    }", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432143295", "createdAt": "2020-05-28T21:48:31Z", "author": {"login": "billfor"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MDA0Ng==", "bodyText": "Ok I'll change the timeout in the handler to 3 seconds and do some testing with it tonight. If I don't have issues with 3 second timeouts I will leave it synchronous. Otherwise I will do async as suggested by @fwolter.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432150046", "createdAt": "2020-05-28T22:04:30Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDIwMg==", "bodyText": "Using the async api is a completely viable alternative if you want to go that route.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432160202", "createdAt": "2020-05-28T22:32:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjIxMw==", "bodyText": "@billfor I have a CT-80 Rev A that I use as for testing. The connection failed the first time when I sent the timeout to 3 seconds. I think I might need to re-think the design of the binding to deal with async. Right now the getRadioThermostatData() calls expect an object to be returned by the method. I think it would work better for async if the calls send an event when they finally finish and then an event listener will receive the event and update the channels accordingly.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432182213", "createdAt": "2020-05-28T23:42:25Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNTE5OQ==", "bodyText": "It does time out a lot, but most of the time after three retries it seems to work for me.  I poll it at a frequency of 60 seconds, so it might always miss one entirely but pick up another and I don't notice. I didn't see anything in my logs.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432215199", "createdAt": "2020-05-29T01:54:12Z", "author": {"login": "billfor"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM2MTkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MDo1OVrOGcPmRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MDo1OVrOGcPmRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2ODg3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n          \n          \n            \n            \t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\" unit=\"min\">", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432268871", "createdAt": "2020-05-29T05:50:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM2MjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MToyN1rOGcPm0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MToyN1rOGcPm0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTAwOA==", "bodyText": "please change type to boolean", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432269008", "createdAt": "2020-05-29T05:51:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM2Mzc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MjowM1rOGcPndg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MjowM1rOGcPndg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTE3NA==", "bodyText": "please change type to boolean", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432269174", "createdAt": "2020-05-29T05:52:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM2OTcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1NToyN1rOGcPrMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTo1NjowNVrOGcqQvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDEzMQ==", "bodyText": "maybe it would be better to make a ThingAction for this?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432270131", "createdAt": "2020-05-29T05:55:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>\n+\t\t<state min=\"0\" max=\"2\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Status</label>\n+\t\t<description>Indicates the Current Fan Status of the HVAC System</description>\n+\t\t<state min=\"0\" max=\"2\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_day\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Day</label>\n+\t\t<description>The Current Day of the Week Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_hour\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Hour</label>\n+\t\t<description>The Current Hour of the Day Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_minute\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Minute</label>\n+\t\t<description>The Current Minute Past the Hour Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"dt_stamp\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Date</label>\n+\t\t<description>The Current Day of the Week and Time Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"last_update\" advanced=\"true\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Updated</label>\n+\t\t<description>Last Successful Contact With Thermostat</description>\n+\t\t<category>Date</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"today_heat_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Today's Heating Runtime</label>\n+\t\t<description>The Number of Minutes of Heating Run-time Today</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"today_cool_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Today's Cooling Runtime</label>\n+\t\t<description>The Number of Minutes of Cooling Run-time Today</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"yesterday_heat_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Yesterday's Heating Runtime</label>\n+\t\t<description>The Number of Minutes of Heating Run-time Yesterday</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"yesterday_cool_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Yesterday's Cooling Runtime</label>\n+\t\t<description>The Number of Minutes of Cooling Run-time Yesterday</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"json_cmd\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNTcyNA==", "bodyText": "I implemented this and all the other review changes. Latest commit is pushed up and ready for review.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432705724", "createdAt": "2020-05-29T19:56:05Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>\n+\t\t<state min=\"0\" max=\"2\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Status</label>\n+\t\t<description>Indicates the Current Fan Status of the HVAC System</description>\n+\t\t<state min=\"0\" max=\"2\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_day\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Day</label>\n+\t\t<description>The Current Day of the Week Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_hour\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Hour</label>\n+\t\t<description>The Current Hour of the Day Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_minute\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Minute</label>\n+\t\t<description>The Current Minute Past the Hour Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"dt_stamp\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Date</label>\n+\t\t<description>The Current Day of the Week and Time Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"last_update\" advanced=\"true\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Updated</label>\n+\t\t<description>Last Successful Contact With Thermostat</description>\n+\t\t<category>Date</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"today_heat_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Today's Heating Runtime</label>\n+\t\t<description>The Number of Minutes of Heating Run-time Today</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"today_cool_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Today's Cooling Runtime</label>\n+\t\t<description>The Number of Minutes of Cooling Run-time Today</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"yesterday_heat_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Yesterday's Heating Runtime</label>\n+\t\t<description>The Number of Minutes of Heating Run-time Yesterday</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"yesterday_cool_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Yesterday's Cooling Runtime</label>\n+\t\t<description>The Number of Minutes of Cooling Run-time Yesterday</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"json_cmd\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDEzMQ=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM3MjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1Njo1OFrOGcPs7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowODozNFrOGcjGhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDU3Mw==", "bodyText": "You could populate in the RadioThermostatHandlerFactory constructor the same way you do with the HttpClientFactory. It would allow you to make this field non-null and final as well as get rid of the set/unset methods.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432270573", "createdAt": "2020-05-29T05:56:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4ODQyMg==", "bodyText": "got it.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432588422", "createdAt": "2020-05-29T16:08:34Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDU3Mw=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM3NTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1ODo0MlrOGcPuzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1ODo0MlrOGcPuzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTA1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\" unit=\"min\">", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432271052", "createdAt": "2020-05-29T05:58:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM3ODMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowMDozMFrOGcPwtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowMDozMFrOGcPwtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTU0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                private Gson gson;\n          \n          \n            \n            \n          \n          \n            \n                private final Gson gson;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432271543", "createdAt": "2020-05-29T06:00:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM4Nzg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNToyMlrOGcP2mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyNzo0NVrOGchipQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzA1MQ==", "bodyText": "change this to a boolean", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273051", "createdAt": "2020-05-29T06:05:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2Mjg1Mw==", "bodyText": "it will be removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432562853", "createdAt": "2020-05-29T15:27:45Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzA1MQ=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM4ODM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNTozOFrOGcP26Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNTozOFrOGcP26Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzEyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273129", "createdAt": "2020-05-29T06:05:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM4OTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNjoxNlrOGcP3pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNjoxNlrOGcP3pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzMxOA==", "bodyText": "If you make the change I suggested in the ThingHandlerFactory you can make this non-null", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273318", "createdAt": "2020-05-29T06:06:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM5MjAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNzo0MFrOGcP5Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjowNzo0MFrOGcP5Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzY3OA==", "bodyText": "calling getConfigAs is a costly operation, so you should try to cache the parsed config in a field so that other parts of the code can use it.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273678", "createdAt": "2020-05-29T06:07:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjM5ODA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoxMDo1MFrOGcP8mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyODo0M1rOGchlBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NDU4Ng==", "bodyText": "What do you expect to throw an IllegalStateException?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432274586", "createdAt": "2020-05-29T06:10:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2MzQ2Mw==", "bodyText": "probably leftover from when I was doing regexes here. removed.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432563463", "createdAt": "2020-05-29T15:28:43Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NDU4Ng=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 436}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQwNjIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoxNTowOVrOGcQBkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMzowNVrOGci6LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NTg1OA==", "bodyText": "Right now you are trying to figure out the expected json return type based on the value of the resource parameter. Instead you should supply the expected return type class as a parameter so you can take advantage of generics.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Object getRadioThermostatData(String resource) {\n          \n          \n            \n                private <T> @Nullable T getRadioThermostatData(String resource, Class<T> returnType) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432275858", "createdAt": "2020-05-29T06:15:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NTI2MQ==", "bodyText": "I re-worked the data retrieval to be async. This will be OBE when the changes are pushed.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432585261", "createdAt": "2020-05-29T16:03:05Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NTg1OA=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQwNzU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoxNTo1MFrOGcQCYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTo0OTozNFrOGciWZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjA2NQ==", "bodyText": "What throws an Exception here?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432276065", "createdAt": "2020-05-29T06:15:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 501}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3NjEwMw==", "bodyText": "nothing; removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432576103", "createdAt": "2020-05-29T15:49:34Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjA2NQ=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 501}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQwODEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoxNjoxMlrOGcQCxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoxNjoxMlrOGcQCxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjE2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n          \n          \n            \n                            if (data.getThermostatData().getTemperature() != 0) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432276164", "createdAt": "2020-05-29T06:16:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 504}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjQxNjkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoyMDo0MVrOGcQIXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTo1MzoyMlrOGcigdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NzU5OA==", "bodyText": "Why are you always returning the current time? You shouldn't do this since a channel might be trying to refresh this value from a cached RadioThermostatData.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432277598", "createdAt": "2020-05-29T06:20:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case STATUS:\n+                return data.getThermostatData().getStatus();\n+            case FAN_STATUS:\n+                return data.getThermostatData().getFanStatus();\n+            case DAY:\n+                return data.getThermostatData().getTime().getDayOfWeek();\n+            case HOUR:\n+                return data.getThermostatData().getTime().getHour();\n+            case MINUTE:\n+                return data.getThermostatData().getTime().getMinute();\n+            case DATE_STAMP:\n+                return data.getThermostatData().getTime().getThemostatDateTime();\n+            case LAST_UPDATE:\n+                return ZonedDateTime.now();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 549}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3ODY3Ng==", "bodyText": "I think I did this as a hold over from the rules way of doing things. It's a clue to know if your thermostat connection is dead. It also displays in the official app to tell you the last time the thermostat phoned home. But I'll take it out since the binding will report offline if contact is lost.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432578676", "createdAt": "2020-05-29T15:53:22Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case STATUS:\n+                return data.getThermostatData().getStatus();\n+            case FAN_STATUS:\n+                return data.getThermostatData().getFanStatus();\n+            case DAY:\n+                return data.getThermostatData().getTime().getDayOfWeek();\n+            case HOUR:\n+                return data.getThermostatData().getTime().getHour();\n+            case MINUTE:\n+                return data.getThermostatData().getTime().getMinute();\n+            case DATE_STAMP:\n+                return data.getThermostatData().getTime().getThemostatDateTime();\n+            case LAST_UPDATE:\n+                return ZonedDateTime.now();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NzU5OA=="}, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 549}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTIyODIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowMzo0NFrOGcsABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowMzo0NFrOGcsABQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNDIxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        listeners.get(i).onNewMessageEvent(event);\n          \n          \n            \n                    }\n          \n          \n            \n                    for (RadioThermostatEventListener listener : listeners) {\n          \n          \n            \n                        listener.onNewMessageEvent(event);\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432734213", "createdAt": "2020-05-29T21:03:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;\n+\n+    private List<RadioThermostatEventListener> listeners = new ArrayList<>();\n+\n+    public RadioThermostatConnector(HttpClient httpClient, @Nullable String hostName) {\n+        this.httpClient = httpClient;\n+        this.hostName = hostName;\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(RadioThermostatEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(RadioThermostatEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Send an asynchronous http call to the thermostat, the response will be send to the\n+     * event listeners as a RadioThermostat event when it is finally received\n+     *\n+     * @param resouce the url of the json resource on the thermostat\n+     */\n+    public void getAsyncThermostatData(String resource) {\n+        String urlStr = buildRequestURL(resource);\n+\n+        httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @Override\n+            public void onComplete(@Nullable Result result) {\n+                if (!result.isFailed()) {\n+                    String response = getContentAsString();\n+                    logger.debug(\"thermostatResponse = {}\", response);\n+                    dispatchKeyValue(resource, response);\n+                } else {\n+                    dispatchKeyValue(KEY_ERROR, \"\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    public String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    public String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Dispatch an event (key, value) to the event listeners\n+     *\n+     * @param key the key\n+     * @param value the value\n+     */\n+    private void dispatchKeyValue(String key, String value) {\n+        RadioThermostatEvent event = new RadioThermostatEvent(this, key, value);\n+        for (int i = 0; i < listeners.size(); i++) {\n+            listeners.get(i).onNewMessageEvent(event);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI0MTIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowODo0MFrOGcsH_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowODo0MFrOGcsH_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNjI1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HttpClient httpClient;\n          \n          \n            \n                private @Nullable String hostName;\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                private final @Nullable String hostName;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432736254", "createdAt": "2020-05-29T21:08:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI0MzEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowOToxNFrOGcsJFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowOToxNFrOGcsJFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNjUzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<RadioThermostatEventListener> listeners = new ArrayList<>();\n          \n          \n            \n                private final List<RadioThermostatEventListener> listeners = new CopyOnWriteArrayList<>();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432736533", "createdAt": "2020-05-29T21:09:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;\n+\n+    private List<RadioThermostatEventListener> listeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI2NzY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatEventListener.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToxOTowMVrOGcsXxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToxOTowMVrOGcsXxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MDI5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event);\n          \n          \n            \n                public void onNewMessageEvent(RadioThermostatEvent event);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432740294", "createdAt": "2020-05-29T21:19:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatEventListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * RadtioThermostat Event Listener interface. Handles incoming RadioThermostat message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface RadioThermostatEventListener extends EventListener {\n+\n+    /**\n+     * Event handler method for incoming RadioThermostat message events\n+     *\n+     * @param event the event object\n+     */\n+    public void onNewMessageEvent(EventObject event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI2OTQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToxOTo1NVrOGcsY8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToxOTo1NVrOGcsY8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MDU5Mg==", "bodyText": "Please move final fields above the non-final fields", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432740592", "createdAt": "2020-05-29T21:19:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI3MjE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMDo1OVrOGcsajA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMDo1OVrOGcsajA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTAwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event) {\n          \n          \n            \n                    RadioThermostatEvent evt = (RadioThermostatEvent) event;\n          \n          \n            \n                public void onNewMessageEvent(RadioThermostatEvent evt) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741004", "createdAt": "2020-05-29T21:20:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI3MzYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMTo0NFrOGcsbfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMTo0NFrOGcsbfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTI0Nw==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741247", "createdAt": "2020-05-29T21:21:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI3NDQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMjowN1rOGcscCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMjowN1rOGcscCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTM4NA==", "bodyText": "this can be removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741384", "createdAt": "2020-05-29T21:22:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI3NTY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMjo0MVrOGcscyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMjo0MVrOGcscyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTU3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n          \n          \n            \n                                rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n          \n          \n            \n                                rthermData.setThermostatData(gson.fromJson(evtVal, RadioThermostatJsonResponse.class));", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741577", "createdAt": "2020-05-29T21:22:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI3Nzc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMzozNFrOGcseCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMzozNFrOGcseCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTg5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n          \n          \n            \n                                rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n          \n          \n            \n                                rthermData.setHumidity(gson.fromJson(evtVal, RadioThermostatJsonHumidity.class).getHumidity());", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741896", "createdAt": "2020-05-29T21:23:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI3ODQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMzo1NVrOGcsefA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyMzo1NVrOGcsefA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MjAxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n          \n          \n            \n                                rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n          \n          \n            \n                                rthermData.setRuntime(gson.fromJson(evtVal, RadioThermostatJsonRuntime.class));", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432742012", "createdAt": "2020-05-29T21:23:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n+                    rthermData.setRuntime((RadioThermostatJsonRuntime) result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI4NDQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyNjoyOVrOGcsiOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMDo0OTozOFrOGcvoiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA==", "bodyText": "Things might get wonky if the user supplies a value with a decimal point.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432742970", "createdAt": "2020-05-29T21:26:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc1ODgwMw==", "bodyText": "They shouldn't. The values are all constrained by the drop downs and set points.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432758803", "createdAt": "2020-05-29T22:01:11Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA=="}, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2NjgzMw==", "bodyText": "What if the command comes from someone's rules?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432766833", "createdAt": "2020-05-29T22:27:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA=="}, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzczNw==", "bodyText": "Alright, I improved it. A number with a decimal will be transformed into an appropriate integer value. If their rules are sending values outside the range of what the thermostat will accept, its on them.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432793737", "createdAt": "2020-05-30T00:49:38Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA=="}, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI4OTYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyODo1NlrOGcslhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyODo1NlrOGcslhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MzgxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (data.getThermostatData().getHold() == 1) {\n          \n          \n            \n                                return OnOffType.ON;\n          \n          \n            \n                            } else {\n          \n          \n            \n                                return OnOffType.OFF;\n          \n          \n            \n                            }\n          \n          \n            \n                            return OnOffType.from(data.getThermostatData().getHold() == 1);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432743814", "createdAt": "2020-05-29T21:28:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n+                    rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                    updateChannel(TODAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(TODAY_COOL_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_COOL_RUNTIME, rthermData);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data the RadioThermostat dto\n+     * @return the value to be set in the state\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(0d)) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 398}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTI5NTcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTozMTo0MFrOGcspVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTozMTo0MFrOGcspVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NDc4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private RadioThermostatData rthermData = new RadioThermostatData();\n          \n          \n            \n                private final RadioThermostatData rthermData = new RadioThermostatData();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432744788", "createdAt": "2020-05-29T21:31:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTQ2OTc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjo0ODoxM1rOGcuUiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjo0ODoxM1rOGcuUiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3MjIzMw==", "bodyText": "oops forgot to return! fixing...", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432772233", "createdAt": "2020-05-29T22:48:13Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final Gson gson;\n+    private final RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private @Nullable RadioThermostatConnector connector;\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(RadioThermostatEvent event) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", event.getKey(), event.getValue());\n+\n+        String evtKey = event.getKey();\n+        String evtVal = event.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    rthermData.setThermostatData(gson.fromJson(evtVal, RadioThermostatJsonResponse.class));\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    rthermData.setHumidity(gson.fromJson(evtVal, RadioThermostatJsonHumidity.class).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    rthermData.setRuntime(gson.fromJson(evtVal, RadioThermostatJsonRuntime.class));\n+                    updateChannel(TODAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(TODAY_COOL_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_COOL_RUNTIME, rthermData);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data the RadioThermostat dto\n+     * @return the value to be set in the state\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(0d)) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                OnOffType.from(data.getThermostatData().getHold() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74d92c01f6c9f586b656087420157351699fd693"}, "originalPosition": 384}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTY1MzQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMTo1ODo1N1rOGcwBFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMTo1ODo1N1rOGcwBFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDAyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                cmdInt = ((Number)NumberFormat.getInstance().parse(cmdStr)).intValue();\n          \n          \n            \n                                cmdInt = NumberFormat.getInstance().parse(cmdStr).intValue();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800022", "createdAt": "2020-05-30T01:58:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -193,9 +195,10 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             String cmdStr = command.toString();\n             if (cmdStr != null) {\n                 try {\n-                    // remove all non-numeric characters except negative '-' and parse int\n-                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n-                } catch (NumberFormatException e) {\n+                    // parse out an Integer from the string\n+                    // ie '70.5 F' becomes 70, also handles negative numbers \n+                    cmdInt = ((Number)NumberFormat.getInstance().parse(cmdStr)).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTY1NTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMjowMzozOFrOGcwCfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMjowMzozOFrOGcwCfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDM4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | today_heat_runtime     | Number               | The total number of minutes of heating run-time today                     |\n          \n          \n            \n            | today_cool_runtime     | Number               | The total number of minutes of cooling run-time today                     |\n          \n          \n            \n            | yesterday_heat_runtime | Number               | The total number of minutes of heating run-time yesterday                 |\n          \n          \n            \n            | yesterday_cool_runtime | Number               | The total number of minutes of cooling run-time yesterday                 |\n          \n          \n            \n            | today_heat_runtime     | Number:Time      | The total number of minutes of heating run-time today                     |\n          \n          \n            \n            | today_cool_runtime     | Number:Time      | The total number of minutes of cooling run-time today                     |\n          \n          \n            \n            | yesterday_heat_runtime | Number:Time   | The total number of minutes of heating run-time yesterday                 |\n          \n          \n            \n            | yesterday_cool_runtime | Number:Time   | The total number of minutes of cooling run-time yesterday                 |", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800383", "createdAt": "2020-05-30T02:03:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| isCT80          | Flag to enable additional features only available on the CT80 thermostat. Optional, the default is false. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is false.                   |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n+| mode                   | Number               | The current operating mode of the HVAC system                             |\n+| fan_mode               | Number               | The current operating mode of the fan                                     |\n+| program_mode           | Number               | The program schedule that the thermostat is running (CT80 Rev B only)     |\n+| set_point              | Number:Temperature   | The current temperature set point of the thermostat                       |\n+| status                 | Number               | Indicates the current running status of the HVAC system                   |\n+| fan_status             | Number               | Indicates the current fan status of the HVAC system                       |\n+| override               | Number               | Indicates if the normal program set-point has been manually overridden    |\n+| hold                   | Switch               | Indicates if the current set point temperature is to be held indefinitely |\n+| day                    | Number               | The current day of the week reported by the thermostat (0 = Monday)       |\n+| hour                   | Number               | The current hour of the day reported by the thermostat  (24 hr)           |\n+| minute                 | Number               | The current minute past the hour reported by the thermostat               |\n+| dt_stamp               | String               | The current day of the week and time reported by the thermostat (E HH:mm) |\n+| today_heat_runtime     | Number               | The total number of minutes of heating run-time today                     |\n+| today_cool_runtime     | Number               | The total number of minutes of cooling run-time today                     |\n+| yesterday_heat_runtime | Number               | The total number of minutes of heating run-time yesterday                 |\n+| yesterday_cool_runtime | Number               | The total number of minutes of cooling run-time yesterday                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTY1NjE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMjowNDowNFrOGcwCng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMjowNDowNFrOGcwCng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDQxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n          \n          \n            \n            | humidity               | Number:Dimensionless | The current humidity reading of the thermostat (CT80 only)                |", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800414", "createdAt": "2020-05-30T02:04:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| isCT80          | Flag to enable additional features only available on the CT80 thermostat. Optional, the default is false. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is false.                   |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDY5NDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyNjoxOVrOGoEksQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxMDo0M1rOGoT6Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTE1Mw==", "bodyText": "Please add a line break after every sentence throughout the README, thanks!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r444671153", "createdAt": "2020-06-24T06:26:19Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyMjM4Mg==", "bodyText": "got it", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r444922382", "createdAt": "2020-06-24T14:10:43Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTE1Mw=="}, "originalCommit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDY5NzA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyNzoxN1rOGoEmOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxMTowMVrOGoT62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTU0Ng==", "bodyText": "As 2.5.6 has just been release, we have to ask you to change this version for a very last time, promised ;-)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <version>2.5.6-SNAPSHOT</version>\n          \n          \n            \n                <version>2.5.7-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r444671546", "createdAt": "2020-06-24T06:27:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyMjU4NQ==", "bodyText": "Done! Thanks @kaikreuzer", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r444922585", "createdAt": "2020-06-24T14:11:01Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTU0Ng=="}, "originalCommit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 510, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}