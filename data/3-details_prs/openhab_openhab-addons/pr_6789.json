{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMjEyNzE3", "number": 6789, "title": "[telegram] Cleanup thing status handling and avoid log flooding when connection was lost", "bodyText": "Follow-up from #6620 (originally created by @radokristof)\nOld behavior:\n\nAfter setting up the  http client, the Thing was immediately set to ONLINE regardless if the connection was established successfully or errors were returned\nLater, in case of an error \"401\" (which usually means the token is wrong), the Thing was set to offline. If the error was an UnkownHostException or ConnectException, the error was logged AND the library did another attempt 100ms later resulting in many log entries (until the connection was fixed again)\n\nProblem:\n\nThe library doesn't give us any feedback if the connection was established successfully (I think that's the nature of the long polling operation). Only in case of an error or if a new message was received, we are notified.\n\nNew behavior:\n\nSet thing to UNKOWN after initialization, set to ONLINE after 10s if no error was received\nIn case of IOException, set thing to OFFLINE and set back to ONLINE after 10s if no further error was received (e.g. temporary connection lost)\nIf a Telegram message was received before the 10s countdown expired, the THING is immediately set to ONLINE.\n\nSorry for the whitespace changes, I think the code was not correctly formatted before (or maybe the Eclipse formatter behaves differently than the VS formatter).", "createdAt": "2020-01-07T23:09:57Z", "url": "https://github.com/openhab/openhab-addons/pull/6789", "merged": true, "mergeCommit": {"oid": "9734fa4df90f836a7e0ef8df0d488ce16c5bc536"}, "closed": true, "closedAt": "2020-01-13T09:28:58Z", "author": {"login": "ZzetT"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4I5yhgH2gAyMzYwMjEyNzE3OmIzN2YyYTA5MWMwNjMzZjA3YWJmNjk5MGViY2Y5ZmNlMDRmNGU5YmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb547wdAFqTM0MTcxNDY0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b37f2a091c0633f07abf6990ebcf9fce04f4e9bb", "author": {"user": {"login": "ZzetT", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b37f2a091c0633f07abf6990ebcf9fce04f4e9bb", "committedDate": "2020-01-07T22:57:03Z", "message": "cleanup thing status handling and avoid log flooding when there is no connection\n\nSigned-off-by: Alexander Krasnogolowy <alexkrasno@hotmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwMDUzNjU3", "url": "https://github.com/openhab/openhab-addons/pull/6789#pullrequestreview-340053657", "createdAt": "2020-01-08T18:21:43Z", "commit": {"oid": "b37f2a091c0633f07abf6990ebcf9fce04f4e9bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxODoyMTo0M1rOFbfqCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxODoyMTo0M1rOFbfqCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM3NDUzOQ==", "bodyText": "Are errors repeated every <10sec? Otherwise the thing would go back to online with this function call (like described in the initial post)", "url": "https://github.com/openhab/openhab-addons/pull/6789#discussion_r364374539", "createdAt": "2020-01-08T18:21:43Z", "author": {"login": "bjoernbrings"}, "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/internal/TelegramHandler.java", "diffHunk": "@@ -143,90 +148,115 @@ public void initialize() {\n \r\n         botLibClient = new OkHttpClient.Builder().connectTimeout(75, TimeUnit.SECONDS).readTimeout(75, TimeUnit.SECONDS)\r\n                 .build();\r\n-        updateStatus(ThingStatus.ONLINE);\r\n+        updateStatus(ThingStatus.UNKNOWN);\r\n+        delayThingOnlineStatus();\r\n         TelegramBot localBot = bot = new TelegramBot.Builder(botToken).okHttpClient(botLibClient).build();\r\n         localBot.setUpdatesListener(updates -> {\r\n-                for (Update update : updates) {\r\n-                    String lastMessageText = null;\r\n-                    Integer lastMessageDate = null;\r\n-                    String lastMessageFirstName = null;\r\n-                    String lastMessageLastName = null;\r\n-                    String lastMessageUsername = null;\r\n-                    Long chatId = null;\r\n-                    String replyId = null;\r\n-                    if (update.message() != null && update.message().text() != null) {\r\n-                        Message message = update.message();\r\n-                        chatId = message.chat().id();\r\n-                        if (!chatIds.contains(chatId)) {\r\n-                            logger.warn(\r\n-                                    \"Ignored message from unknown chat id {}. If you know the sender of that chat, add it to the list of chat ids in the thing configuration to authorize it\",\r\n-                                    chatId);\r\n-                            continue; // this is very important regarding security to avoid commands from an unknown\r\n-                                      // chat\r\n-                        }\r\n-\r\n-                        lastMessageText = message.text();\r\n-                        lastMessageDate = message.date();\r\n-                        lastMessageFirstName = message.from().firstName();\r\n-                        lastMessageLastName = message.from().lastName();\r\n-                        lastMessageUsername = message.from().username();\r\n-                    } else if (update.callbackQuery() != null && update.callbackQuery().message() != null\r\n-                            && update.callbackQuery().message().text() != null) {\r\n-                        String[] callbackData = update.callbackQuery().data().split(\" \", 2);\r\n-\r\n-                        if (callbackData.length == 2) {\r\n-                            replyId = callbackData[0];\r\n-                            lastMessageText = callbackData[1];\r\n-                            lastMessageDate = update.callbackQuery().message().date();\r\n-                            lastMessageFirstName = update.callbackQuery().from().firstName();\r\n-                            lastMessageLastName = update.callbackQuery().from().lastName();\r\n-                            lastMessageUsername = update.callbackQuery().from().username();\r\n-                            chatId = update.callbackQuery().message().chat().id();\r\n-                            replyIdToCallbackId.put(new ReplyKey(chatId, replyId), update.callbackQuery().id());\r\n-                            logger.debug(\"Received callbackId {} for chatId {} and replyId {}\",\r\n-                                    update.callbackQuery().id(), chatId, replyId);\r\n-                        } else {\r\n-                            logger.warn(\r\n-                                    \"The received callback query {} has not the right format (must be seperated by spaces)\",\r\n-                                    update.callbackQuery().data());\r\n-                        }\r\n+            cancelThingOnlineStatusJob();\r\n+            updateStatus(ThingStatus.ONLINE);\r\n+            for (Update update : updates) {\r\n+                String lastMessageText = null;\r\n+                Integer lastMessageDate = null;\r\n+                String lastMessageFirstName = null;\r\n+                String lastMessageLastName = null;\r\n+                String lastMessageUsername = null;\r\n+                Long chatId = null;\r\n+                String replyId = null;\r\n+                if (update.message() != null && update.message().text() != null) {\r\n+                    Message message = update.message();\r\n+                    chatId = message.chat().id();\r\n+                    if (!chatIds.contains(chatId)) {\r\n+                        logger.warn(\r\n+                                \"Ignored message from unknown chat id {}. If you know the sender of that chat, add it to the list of chat ids in the thing configuration to authorize it\",\r\n+                                chatId);\r\n+                        continue; // this is very important regarding security to avoid commands from an unknown\r\n+                                  // chat\r\n+                    }\r\n+\r\n+                    lastMessageText = message.text();\r\n+                    lastMessageDate = message.date();\r\n+                    lastMessageFirstName = message.from().firstName();\r\n+                    lastMessageLastName = message.from().lastName();\r\n+                    lastMessageUsername = message.from().username();\r\n+                } else if (update.callbackQuery() != null && update.callbackQuery().message() != null\r\n+                        && update.callbackQuery().message().text() != null) {\r\n+                    String[] callbackData = update.callbackQuery().data().split(\" \", 2);\r\n+\r\n+                    if (callbackData.length == 2) {\r\n+                        replyId = callbackData[0];\r\n+                        lastMessageText = callbackData[1];\r\n+                        lastMessageDate = update.callbackQuery().message().date();\r\n+                        lastMessageFirstName = update.callbackQuery().from().firstName();\r\n+                        lastMessageLastName = update.callbackQuery().from().lastName();\r\n+                        lastMessageUsername = update.callbackQuery().from().username();\r\n+                        chatId = update.callbackQuery().message().chat().id();\r\n+                        replyIdToCallbackId.put(new ReplyKey(chatId, replyId), update.callbackQuery().id());\r\n+                        logger.debug(\"Received callbackId {} for chatId {} and replyId {}\", update.callbackQuery().id(),\r\n+                                chatId, replyId);\r\n+                    } else {\r\n+                        logger.warn(\r\n+                                \"The received callback query {} has not the right format (must be seperated by spaces)\",\r\n+                                update.callbackQuery().data());\r\n                     }\r\n-                    updateChannel(LASTMESSAGETEXT,\r\n-                            lastMessageText != null ? new StringType(lastMessageText) : UnDefType.NULL);\r\n-                    updateChannel(LASTMESSAGEDATE,\r\n-                            lastMessageDate != null\r\n-                                    ? new DateTimeType(ZonedDateTime.ofInstant(\r\n-                                            Instant.ofEpochSecond(lastMessageDate.intValue()), ZoneOffset.UTC))\r\n-                                    : UnDefType.NULL);\r\n-                    updateChannel(LASTMESSAGENAME,\r\n-                            (lastMessageFirstName != null || lastMessageLastName != null)\r\n-                                    ? new StringType((lastMessageFirstName != null ? lastMessageFirstName + \" \" : \"\")\r\n-                                            + (lastMessageLastName != null ? lastMessageLastName : \"\"))\r\n-                                    : UnDefType.NULL);\r\n-                    updateChannel(LASTMESSAGEUSERNAME,\r\n-                            lastMessageUsername != null ? new StringType(lastMessageUsername) : UnDefType.NULL);\r\n-                    updateChannel(CHATID, chatId != null ? new StringType(chatId.toString()) : UnDefType.NULL);\r\n-                    updateChannel(REPLYID, replyId != null ? new StringType(replyId) : UnDefType.NULL);\r\n                 }\r\n-                return UpdatesListener.CONFIRMED_UPDATES_ALL;\r\n+                updateChannel(LASTMESSAGETEXT,\r\n+                        lastMessageText != null ? new StringType(lastMessageText) : UnDefType.NULL);\r\n+                updateChannel(LASTMESSAGEDATE,\r\n+                        lastMessageDate != null\r\n+                                ? new DateTimeType(ZonedDateTime\r\n+                                        .ofInstant(Instant.ofEpochSecond(lastMessageDate.intValue()), ZoneOffset.UTC))\r\n+                                : UnDefType.NULL);\r\n+                updateChannel(LASTMESSAGENAME, (lastMessageFirstName != null || lastMessageLastName != null)\r\n+                        ? new StringType((lastMessageFirstName != null ? lastMessageFirstName + \" \" : \"\")\r\n+                                + (lastMessageLastName != null ? lastMessageLastName : \"\"))\r\n+                        : UnDefType.NULL);\r\n+                updateChannel(LASTMESSAGEUSERNAME,\r\n+                        lastMessageUsername != null ? new StringType(lastMessageUsername) : UnDefType.NULL);\r\n+                updateChannel(CHATID, chatId != null ? new StringType(chatId.toString()) : UnDefType.NULL);\r\n+                updateChannel(REPLYID, replyId != null ? new StringType(replyId) : UnDefType.NULL);\r\n+            }\r\n+            return UpdatesListener.CONFIRMED_UPDATES_ALL;\r\n         }, exception -> {\r\n-                if (exception != null) {\r\n-                    logger.warn(\"Telegram exception: {}\", exception.getMessage());\r\n-                    if (exception.response() != null) {\r\n-                        BaseResponse localResponse = exception.response();\r\n-                        if (localResponse.errorCode() == 401) {\r\n-                            logger.error(\"Bot token invalid, disable thing {}\", getThing().getUID());\r\n-                            localBot.removeGetUpdatesListener();\r\n-                            updateStatus(ThingStatus.OFFLINE);\r\n-                        }\r\n+            if (exception != null) {\r\n+                if (exception.response() != null) {\r\n+                    BaseResponse localResponse = exception.response();\r\n+                    if (localResponse.errorCode() == 401) { // unauthorized\r\n+                        cancelThingOnlineStatusJob();\r\n+                        localBot.removeGetUpdatesListener();\r\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                                \"Unauthorized attempt to connect to the Telegram server, please check if the bot token is valid\");\r\n+                        return;\r\n                     }\r\n+                }\r\n+                if (exception.getCause() != null) { // cause is only non-null in case of an IOException\r\n+                    cancelThingOnlineStatusJob();\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, exception.getMessage());\r\n+                    delayThingOnlineStatus();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37f2a091c0633f07abf6990ebcf9fce04f4e9bb"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwMTYzOTQy", "url": "https://github.com/openhab/openhab-addons/pull/6789#pullrequestreview-340163942", "createdAt": "2020-01-08T21:43:02Z", "commit": {"oid": "b37f2a091c0633f07abf6990ebcf9fce04f4e9bb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2c0db6e92d6de10e4ec7117fd869b7729782294", "author": {"user": {"login": "ZzetT", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a2c0db6e92d6de10e4ec7117fd869b7729782294", "committedDate": "2020-01-12T11:53:08Z", "message": "run openhab code formatter\n\nSigned-off-by: Alexander Krasnogolowy <alexkrasno@hotmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTczMzc2", "url": "https://github.com/openhab/openhab-addons/pull/6789#pullrequestreview-341573376", "createdAt": "2020-01-12T12:52:23Z", "commit": {"oid": "a2c0db6e92d6de10e4ec7117fd869b7729782294"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff68f2e5161d95015a2f5854e71da0732e4dc800", "author": {"user": {"login": "ZzetT", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ff68f2e5161d95015a2f5854e71da0732e4dc800", "committedDate": "2020-01-12T18:25:23Z", "message": "Merge branch '2.5.x' into telegram_thing_handling_reduce_error_logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzE0NjQ2", "url": "https://github.com/openhab/openhab-addons/pull/6789#pullrequestreview-341714646", "createdAt": "2020-01-13T09:27:55Z", "commit": {"oid": "ff68f2e5161d95015a2f5854e71da0732e4dc800"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOToyNzo1NVrOFcw26w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOToyNzo1NVrOFcw26w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNDkzOQ==", "bodyText": "Is this message always set?", "url": "https://github.com/openhab/openhab-addons/pull/6789#discussion_r365704939", "createdAt": "2020-01-13T09:27:55Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/internal/TelegramHandler.java", "diffHunk": "@@ -143,90 +148,115 @@ public void initialize() {\n \r\n         botLibClient = new OkHttpClient.Builder().connectTimeout(75, TimeUnit.SECONDS).readTimeout(75, TimeUnit.SECONDS)\r\n                 .build();\r\n-        updateStatus(ThingStatus.ONLINE);\r\n+        updateStatus(ThingStatus.UNKNOWN);\r\n+        delayThingOnlineStatus();\r\n         TelegramBot localBot = bot = new TelegramBot.Builder(botToken).okHttpClient(botLibClient).build();\r\n         localBot.setUpdatesListener(updates -> {\r\n-                for (Update update : updates) {\r\n-                    String lastMessageText = null;\r\n-                    Integer lastMessageDate = null;\r\n-                    String lastMessageFirstName = null;\r\n-                    String lastMessageLastName = null;\r\n-                    String lastMessageUsername = null;\r\n-                    Long chatId = null;\r\n-                    String replyId = null;\r\n-                    if (update.message() != null && update.message().text() != null) {\r\n-                        Message message = update.message();\r\n-                        chatId = message.chat().id();\r\n-                        if (!chatIds.contains(chatId)) {\r\n-                            logger.warn(\r\n-                                    \"Ignored message from unknown chat id {}. If you know the sender of that chat, add it to the list of chat ids in the thing configuration to authorize it\",\r\n-                                    chatId);\r\n-                            continue; // this is very important regarding security to avoid commands from an unknown\r\n-                                      // chat\r\n-                        }\r\n-\r\n-                        lastMessageText = message.text();\r\n-                        lastMessageDate = message.date();\r\n-                        lastMessageFirstName = message.from().firstName();\r\n-                        lastMessageLastName = message.from().lastName();\r\n-                        lastMessageUsername = message.from().username();\r\n-                    } else if (update.callbackQuery() != null && update.callbackQuery().message() != null\r\n-                            && update.callbackQuery().message().text() != null) {\r\n-                        String[] callbackData = update.callbackQuery().data().split(\" \", 2);\r\n-\r\n-                        if (callbackData.length == 2) {\r\n-                            replyId = callbackData[0];\r\n-                            lastMessageText = callbackData[1];\r\n-                            lastMessageDate = update.callbackQuery().message().date();\r\n-                            lastMessageFirstName = update.callbackQuery().from().firstName();\r\n-                            lastMessageLastName = update.callbackQuery().from().lastName();\r\n-                            lastMessageUsername = update.callbackQuery().from().username();\r\n-                            chatId = update.callbackQuery().message().chat().id();\r\n-                            replyIdToCallbackId.put(new ReplyKey(chatId, replyId), update.callbackQuery().id());\r\n-                            logger.debug(\"Received callbackId {} for chatId {} and replyId {}\",\r\n-                                    update.callbackQuery().id(), chatId, replyId);\r\n-                        } else {\r\n-                            logger.warn(\r\n-                                    \"The received callback query {} has not the right format (must be seperated by spaces)\",\r\n-                                    update.callbackQuery().data());\r\n-                        }\r\n+            cancelThingOnlineStatusJob();\r\n+            updateStatus(ThingStatus.ONLINE);\r\n+            for (Update update : updates) {\r\n+                String lastMessageText = null;\r\n+                Integer lastMessageDate = null;\r\n+                String lastMessageFirstName = null;\r\n+                String lastMessageLastName = null;\r\n+                String lastMessageUsername = null;\r\n+                Long chatId = null;\r\n+                String replyId = null;\r\n+                if (update.message() != null && update.message().text() != null) {\r\n+                    Message message = update.message();\r\n+                    chatId = message.chat().id();\r\n+                    if (!chatIds.contains(chatId)) {\r\n+                        logger.warn(\r\n+                                \"Ignored message from unknown chat id {}. If you know the sender of that chat, add it to the list of chat ids in the thing configuration to authorize it\",\r\n+                                chatId);\r\n+                        continue; // this is very important regarding security to avoid commands from an unknown\r\n+                                  // chat\r\n+                    }\r\n+\r\n+                    lastMessageText = message.text();\r\n+                    lastMessageDate = message.date();\r\n+                    lastMessageFirstName = message.from().firstName();\r\n+                    lastMessageLastName = message.from().lastName();\r\n+                    lastMessageUsername = message.from().username();\r\n+                } else if (update.callbackQuery() != null && update.callbackQuery().message() != null\r\n+                        && update.callbackQuery().message().text() != null) {\r\n+                    String[] callbackData = update.callbackQuery().data().split(\" \", 2);\r\n+\r\n+                    if (callbackData.length == 2) {\r\n+                        replyId = callbackData[0];\r\n+                        lastMessageText = callbackData[1];\r\n+                        lastMessageDate = update.callbackQuery().message().date();\r\n+                        lastMessageFirstName = update.callbackQuery().from().firstName();\r\n+                        lastMessageLastName = update.callbackQuery().from().lastName();\r\n+                        lastMessageUsername = update.callbackQuery().from().username();\r\n+                        chatId = update.callbackQuery().message().chat().id();\r\n+                        replyIdToCallbackId.put(new ReplyKey(chatId, replyId), update.callbackQuery().id());\r\n+                        logger.debug(\"Received callbackId {} for chatId {} and replyId {}\", update.callbackQuery().id(),\r\n+                                chatId, replyId);\r\n+                    } else {\r\n+                        logger.warn(\r\n+                                \"The received callback query {} has not the right format (must be seperated by spaces)\",\r\n+                                update.callbackQuery().data());\r\n                     }\r\n-                    updateChannel(LASTMESSAGETEXT,\r\n-                            lastMessageText != null ? new StringType(lastMessageText) : UnDefType.NULL);\r\n-                    updateChannel(LASTMESSAGEDATE,\r\n-                            lastMessageDate != null\r\n-                                    ? new DateTimeType(ZonedDateTime.ofInstant(\r\n-                                            Instant.ofEpochSecond(lastMessageDate.intValue()), ZoneOffset.UTC))\r\n-                                    : UnDefType.NULL);\r\n-                    updateChannel(LASTMESSAGENAME,\r\n-                            (lastMessageFirstName != null || lastMessageLastName != null)\r\n-                                    ? new StringType((lastMessageFirstName != null ? lastMessageFirstName + \" \" : \"\")\r\n-                                            + (lastMessageLastName != null ? lastMessageLastName : \"\"))\r\n-                                    : UnDefType.NULL);\r\n-                    updateChannel(LASTMESSAGEUSERNAME,\r\n-                            lastMessageUsername != null ? new StringType(lastMessageUsername) : UnDefType.NULL);\r\n-                    updateChannel(CHATID, chatId != null ? new StringType(chatId.toString()) : UnDefType.NULL);\r\n-                    updateChannel(REPLYID, replyId != null ? new StringType(replyId) : UnDefType.NULL);\r\n                 }\r\n-                return UpdatesListener.CONFIRMED_UPDATES_ALL;\r\n+                updateChannel(LASTMESSAGETEXT,\r\n+                        lastMessageText != null ? new StringType(lastMessageText) : UnDefType.NULL);\r\n+                updateChannel(LASTMESSAGEDATE,\r\n+                        lastMessageDate != null\r\n+                                ? new DateTimeType(ZonedDateTime\r\n+                                        .ofInstant(Instant.ofEpochSecond(lastMessageDate.intValue()), ZoneOffset.UTC))\r\n+                                : UnDefType.NULL);\r\n+                updateChannel(LASTMESSAGENAME, (lastMessageFirstName != null || lastMessageLastName != null)\r\n+                        ? new StringType((lastMessageFirstName != null ? lastMessageFirstName + \" \" : \"\")\r\n+                                + (lastMessageLastName != null ? lastMessageLastName : \"\"))\r\n+                        : UnDefType.NULL);\r\n+                updateChannel(LASTMESSAGEUSERNAME,\r\n+                        lastMessageUsername != null ? new StringType(lastMessageUsername) : UnDefType.NULL);\r\n+                updateChannel(CHATID, chatId != null ? new StringType(chatId.toString()) : UnDefType.NULL);\r\n+                updateChannel(REPLYID, replyId != null ? new StringType(replyId) : UnDefType.NULL);\r\n+            }\r\n+            return UpdatesListener.CONFIRMED_UPDATES_ALL;\r\n         }, exception -> {\r\n-                if (exception != null) {\r\n-                    logger.warn(\"Telegram exception: {}\", exception.getMessage());\r\n-                    if (exception.response() != null) {\r\n-                        BaseResponse localResponse = exception.response();\r\n-                        if (localResponse.errorCode() == 401) {\r\n-                            logger.error(\"Bot token invalid, disable thing {}\", getThing().getUID());\r\n-                            localBot.removeGetUpdatesListener();\r\n-                            updateStatus(ThingStatus.OFFLINE);\r\n-                        }\r\n+            if (exception != null) {\r\n+                if (exception.response() != null) {\r\n+                    BaseResponse localResponse = exception.response();\r\n+                    if (localResponse.errorCode() == 401) { // unauthorized\r\n+                        cancelThingOnlineStatusJob();\r\n+                        localBot.removeGetUpdatesListener();\r\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                                \"Unauthorized attempt to connect to the Telegram server, please check if the bot token is valid\");\r\n+                        return;\r\n                     }\r\n+                }\r\n+                if (exception.getCause() != null) { // cause is only non-null in case of an IOException\r\n+                    cancelThingOnlineStatusJob();\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, exception.getMessage());\r\n+                    delayThingOnlineStatus();\r\n+                    return;\r\n+                }\r\n+                logger.warn(\"Telegram exception: {}\", exception.getMessage());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff68f2e5161d95015a2f5854e71da0732e4dc800"}, "originalPosition": 217}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1576, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}