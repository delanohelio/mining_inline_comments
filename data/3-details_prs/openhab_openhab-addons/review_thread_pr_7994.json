{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NzI5MjE1", "number": 7994, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDozMjoyOVrOEIhNTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoyNjozM1rOEMOwFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzY4MTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/AbstractModbusEndpointThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDozMjoyOVrOGoiFFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwOToyODo0M1rOGs6-Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NDU4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error closing modbus communication interface\", e);\n          \n          \n            \n                        logger.warn(\"Error closing modbus communication interface\", e);", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445154581", "createdAt": "2020-06-24T20:32:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/AbstractModbusEndpointThingHandler.java", "diffHunk": "@@ -92,33 +96,26 @@ public void initialize() {\n \n     @Override\n     public void dispose() {\n-        managerRef.get().removeListener(this);\n-    }\n-\n-    @Override\n-    public @Nullable ModbusSlaveEndpoint asSlaveEndpoint() {\n-        return endpoint;\n+        try {\n+            ModbusCommunicationInterface localComms = comms;\n+            if (localComms != null) {\n+                localComms.close();\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Error closing modbus communication interface\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1Njc2Nw==", "bodyText": "Coming in via mrbig@5599748", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756767", "createdAt": "2020-07-04T09:28:43Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/AbstractModbusEndpointThingHandler.java", "diffHunk": "@@ -92,33 +96,26 @@ public void initialize() {\n \n     @Override\n     public void dispose() {\n-        managerRef.get().removeListener(this);\n-    }\n-\n-    @Override\n-    public @Nullable ModbusSlaveEndpoint asSlaveEndpoint() {\n-        return endpoint;\n+        try {\n+            ModbusCommunicationInterface localComms = comms;\n+            if (localComms != null) {\n+                localComms.close();\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Error closing modbus communication interface\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NDU4MQ=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzY4NTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/AsyncModbusReadResult.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDozMzo0NVrOGoiHqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDozMzo0NVrOGoiHqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NTI0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private BitArray bits;\n          \n          \n            \n            \n          \n          \n            \n                @Nullable\n          \n          \n            \n                private ModbusRegisterArray registers;\n          \n          \n            \n            \n          \n          \n            \n                @Nullable\n          \n          \n            \n                private Exception cause;\n          \n          \n            \n                private @Nullable BitArray bits;\n          \n          \n            \n            \n          \n          \n            \n                private @Nullable ModbusRegisterArray registers;\n          \n          \n            \n            \n          \n          \n            \n                private @Nullable Exception cause;", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445155242", "createdAt": "2020-06-24T20:33:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/AsyncModbusReadResult.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.transport.modbus;\n+\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Encapsulates result of modbus read operations\n+ *\n+ * @author Sami Salonen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AsyncModbusReadResult {\n+\n+    private ModbusReadRequestBlueprint request;\n+\n+    @Nullable\n+    private BitArray bits;\n+\n+    @Nullable\n+    private ModbusRegisterArray registers;\n+\n+    @Nullable\n+    private Exception cause;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzcwMTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusReadRequestBlueprint.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDozODo0OFrOGoiR-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDozMDowMlrOGqnQuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1Nzg4MA==", "bodyText": "The Apache commons lang library will no longer be available to bindings in OH3. So we are in the process of migrating code away from using it. Please try to implement your code without that library, or if you really need it you will have to specify the dependency manually in the binding pom.", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445157880", "createdAt": "2020-06-24T20:38:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusReadRequestBlueprint.java", "diffHunk": "@@ -12,47 +12,121 @@\n  */\n package org.openhab.io.transport.modbus;\n \n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.StandardToStringStyle;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import net.wimpi.modbus.Modbus;\n \n /**\n- * Low-level interface representing a read request\n+ * Implementation of immutable representation of modbus read request\n+ *\n+ * Equals and hashCode implemented keeping {@link PollTask} in mind: two instances of this class are considered the same\n+ * if they have\n+ * the equal parameters (same slave id, start, length, function code and maxTries).\n  *\n  * @author Sami Salonen - Initial contribution\n  *\n  */\n @NonNullByDefault\n-public interface ModbusReadRequestBlueprint extends ModbusRequestBlueprint {\n+public class ModbusReadRequestBlueprint {\n+    private static StandardToStringStyle toStringStyle = new StandardToStringStyle();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2OTE3NA==", "bodyText": "This PR is not introducing it though.\nI am happy to make this change but perhaps we should move it to separate PR to get this big one going?", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445369174", "createdAt": "2020-06-25T07:46:29Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusReadRequestBlueprint.java", "diffHunk": "@@ -12,47 +12,121 @@\n  */\n package org.openhab.io.transport.modbus;\n \n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.StandardToStringStyle;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import net.wimpi.modbus.Modbus;\n \n /**\n- * Low-level interface representing a read request\n+ * Implementation of immutable representation of modbus read request\n+ *\n+ * Equals and hashCode implemented keeping {@link PollTask} in mind: two instances of this class are considered the same\n+ * if they have\n+ * the equal parameters (same slave id, start, length, function code and maxTries).\n  *\n  * @author Sami Salonen - Initial contribution\n  *\n  */\n @NonNullByDefault\n-public interface ModbusReadRequestBlueprint extends ModbusRequestBlueprint {\n+public class ModbusReadRequestBlueprint {\n+    private static StandardToStringStyle toStringStyle = new StandardToStringStyle();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1Nzg4MA=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNjYzMw==", "bodyText": "fine by me", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r447336633", "createdAt": "2020-06-30T00:30:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusReadRequestBlueprint.java", "diffHunk": "@@ -12,47 +12,121 @@\n  */\n package org.openhab.io.transport.modbus;\n \n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.StandardToStringStyle;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import net.wimpi.modbus.Modbus;\n \n /**\n- * Low-level interface representing a read request\n+ * Implementation of immutable representation of modbus read request\n+ *\n+ * Equals and hashCode implemented keeping {@link PollTask} in mind: two instances of this class are considered the same\n+ * if they have\n+ * the equal parameters (same slave id, start, length, function code and maxTries).\n  *\n  * @author Sami Salonen - Initial contribution\n  *\n  */\n @NonNullByDefault\n-public interface ModbusReadRequestBlueprint extends ModbusRequestBlueprint {\n+public class ModbusReadRequestBlueprint {\n+    private static StandardToStringStyle toStringStyle = new StandardToStringStyle();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1Nzg4MA=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzcwNTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusRegisterArray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0MDowMFrOGoiUYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo0NzowOVrOGovMqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1ODQ5Nw==", "bodyText": "Can you change this to use a StringBuilder instead of a StringBuffer?", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445158497", "createdAt": "2020-06-24T20:40:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusRegisterArray.java", "diffHunk": "@@ -70,7 +119,7 @@ default String toHexString() {\n      * Appends the register data as hex string to the given StringBuffer\n      *\n      */\n-    default StringBuffer appendHexString(StringBuffer buffer) {\n+    public StringBuffer appendHexString(StringBuffer buffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2OTUxMg==", "bodyText": "Same comment as above, would prefer this PR to move and introduce these general fixes separately", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445369512", "createdAt": "2020-06-25T07:47:09Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusRegisterArray.java", "diffHunk": "@@ -70,7 +119,7 @@ default String toHexString() {\n      * Appends the register data as hex string to the given StringBuffer\n      *\n      */\n-    default StringBuffer appendHexString(StringBuffer buffer) {\n+    public StringBuffer appendHexString(StringBuffer buffer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1ODQ5Nw=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzczNTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0OToyNFrOGoinOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwOToyNzowN1rOGs6-Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzMyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ScheduledFuture<?> future = executor.schedule(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, pollOperation);\n          \n          \n            \n                        }, 0L, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        ScheduledFuture<?> future = executor.submit(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, pollOperation);\n          \n          \n            \n                        });", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445163322", "createdAt": "2020-06-24T20:49:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1NjY3NQ==", "bodyText": "Coming in via mrbig@67f8eca", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756675", "createdAt": "2020-07-04T09:27:07Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzMyMg=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzczODA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo1MDoxNlrOGoio-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwOToyNTozMlrOGs69jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mzc3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n          \n          \n            \n                            future.cancel(true);\n          \n          \n            \n                            logger.info(\"Poll task {} canceled\", task);\n          \n          \n            \n                            logger.debug(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n          \n          \n            \n                            future.cancel(true);\n          \n          \n            \n                            logger.debug(\"Poll task {} canceled\", task);", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445163770", "createdAt": "2020-06-24T20:50:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (Exception e) {\n+                        // We want to catch all unexpected exceptions since all unhandled exceptions make\n+                        // ScheduledExecutorService halt the polling. It is better to print out the exception, and try\n+                        // again\n+                        // (on next poll cycle)\n+                        logger.warn(\n+                                \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n+                                pollPeriodMillis, task, e);\n+                    }\n+                    long finished = System.currentTimeMillis();\n+                    logger.debug(\n+                            \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n+                            pollPeriodMillis, task, finished, started, finished - started);\n+                }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+\n+                scheduledPollTasks.put(task, future);\n+                pollTasksRegisteredByThisCommInterface.add(task);\n+                logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                return task;\n             }\n-            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n-\n-            // Make sure connections to this endpoint are closed when they are returned to pool (which\n-            // is usually pretty soon as transactions should be relatively short-lived)\n-            factory.disconnectOnReturn(task.getEndpoint(), System.currentTimeMillis());\n+        }\n \n-            future.cancel(true);\n+        @SuppressWarnings({ \"null\", \"unused\" })\n+        @Override\n+        public boolean unregisterRegularPoll(PollTask task) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                pollTasksRegisteredByThisCommInterface.remove(task);\n+                ModbusSlaveConnectionFactoryImpl localConnectionFactory = connectionFactory;\n+                Objects.requireNonNull(localConnectionFactory, \"Not activated!\");\n+\n+                // cancel poller\n+                @Nullable\n+                ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n+                if (future == null) {\n+                    // No such poll task\n+                    logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n+                    return false;\n+                }\n+                logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n+                future.cancel(true);\n+                logger.info(\"Poll task {} canceled\", task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1NjU1Ng==", "bodyText": "Coming in via mrbig@e61a970", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756556", "createdAt": "2020-07-04T09:25:32Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (Exception e) {\n+                        // We want to catch all unexpected exceptions since all unhandled exceptions make\n+                        // ScheduledExecutorService halt the polling. It is better to print out the exception, and try\n+                        // again\n+                        // (on next poll cycle)\n+                        logger.warn(\n+                                \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n+                                pollPeriodMillis, task, e);\n+                    }\n+                    long finished = System.currentTimeMillis();\n+                    logger.debug(\n+                            \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n+                            pollPeriodMillis, task, finished, started, finished - started);\n+                }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+\n+                scheduledPollTasks.put(task, future);\n+                pollTasksRegisteredByThisCommInterface.add(task);\n+                logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                return task;\n             }\n-            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n-\n-            // Make sure connections to this endpoint are closed when they are returned to pool (which\n-            // is usually pretty soon as transactions should be relatively short-lived)\n-            factory.disconnectOnReturn(task.getEndpoint(), System.currentTimeMillis());\n+        }\n \n-            future.cancel(true);\n+        @SuppressWarnings({ \"null\", \"unused\" })\n+        @Override\n+        public boolean unregisterRegularPoll(PollTask task) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                pollTasksRegisteredByThisCommInterface.remove(task);\n+                ModbusSlaveConnectionFactoryImpl localConnectionFactory = connectionFactory;\n+                Objects.requireNonNull(localConnectionFactory, \"Not activated!\");\n+\n+                // cancel poller\n+                @Nullable\n+                ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n+                if (future == null) {\n+                    // No such poll task\n+                    logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n+                    return false;\n+                }\n+                logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n+                future.cancel(true);\n+                logger.info(\"Poll task {} canceled\", task);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mzc3MA=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzczODkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo1MDozM1rOGoipiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwOToyNDoyMVrOGs69KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzkxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ScheduledFuture<?> future = localScheduledThreadPoolExecutor.schedule(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, writeOperation);\n          \n          \n            \n                        }, 0L, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        ScheduledFuture<?> future = localScheduledThreadPoolExecutor.submit(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, writeOperation);\n          \n          \n            \n                        });", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445163912", "createdAt": "2020-06-24T20:50:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (Exception e) {\n+                        // We want to catch all unexpected exceptions since all unhandled exceptions make\n+                        // ScheduledExecutorService halt the polling. It is better to print out the exception, and try\n+                        // again\n+                        // (on next poll cycle)\n+                        logger.warn(\n+                                \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n+                                pollPeriodMillis, task, e);\n+                    }\n+                    long finished = System.currentTimeMillis();\n+                    logger.debug(\n+                            \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n+                            pollPeriodMillis, task, finished, started, finished - started);\n+                }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+\n+                scheduledPollTasks.put(task, future);\n+                pollTasksRegisteredByThisCommInterface.add(task);\n+                logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                return task;\n             }\n-            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n-\n-            // Make sure connections to this endpoint are closed when they are returned to pool (which\n-            // is usually pretty soon as transactions should be relatively short-lived)\n-            factory.disconnectOnReturn(task.getEndpoint(), System.currentTimeMillis());\n+        }\n \n-            future.cancel(true);\n+        @SuppressWarnings({ \"null\", \"unused\" })\n+        @Override\n+        public boolean unregisterRegularPoll(PollTask task) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                pollTasksRegisteredByThisCommInterface.remove(task);\n+                ModbusSlaveConnectionFactoryImpl localConnectionFactory = connectionFactory;\n+                Objects.requireNonNull(localConnectionFactory, \"Not activated!\");\n+\n+                // cancel poller\n+                @Nullable\n+                ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n+                if (future == null) {\n+                    // No such poll task\n+                    logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n+                    return false;\n+                }\n+                logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n+                future.cancel(true);\n+                logger.info(\"Poll task {} canceled\", task);\n+                return true;\n+            }\n+        }\n \n-            logger.info(\"Poll task {} canceled\", task);\n+        @Override\n+        public ScheduledFuture<?> submitOneTimeWrite(ModbusWriteRequestBlueprint request,\n+                @Nullable ModbusWriteCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService localScheduledThreadPoolExecutor = scheduledThreadPoolExecutor;\n+            Objects.requireNonNull(localScheduledThreadPoolExecutor, \"Not activated!\");\n+            WriteTask task = new BasicWriteTask(endpoint, request, callback);\n+            long scheduleTime = System.currentTimeMillis();\n+            logger.debug(\"Scheduling one-off write task {}\", task);\n+            ScheduledFuture<?> future = localScheduledThreadPoolExecutor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, writeOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1NjQ1Ng==", "bodyText": "Coming in via mrbig@8eb186d", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756456", "createdAt": "2020-07-04T09:24:21Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (Exception e) {\n+                        // We want to catch all unexpected exceptions since all unhandled exceptions make\n+                        // ScheduledExecutorService halt the polling. It is better to print out the exception, and try\n+                        // again\n+                        // (on next poll cycle)\n+                        logger.warn(\n+                                \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n+                                pollPeriodMillis, task, e);\n+                    }\n+                    long finished = System.currentTimeMillis();\n+                    logger.debug(\n+                            \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n+                            pollPeriodMillis, task, finished, started, finished - started);\n+                }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+\n+                scheduledPollTasks.put(task, future);\n+                pollTasksRegisteredByThisCommInterface.add(task);\n+                logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                return task;\n             }\n-            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n-\n-            // Make sure connections to this endpoint are closed when they are returned to pool (which\n-            // is usually pretty soon as transactions should be relatively short-lived)\n-            factory.disconnectOnReturn(task.getEndpoint(), System.currentTimeMillis());\n+        }\n \n-            future.cancel(true);\n+        @SuppressWarnings({ \"null\", \"unused\" })\n+        @Override\n+        public boolean unregisterRegularPoll(PollTask task) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                pollTasksRegisteredByThisCommInterface.remove(task);\n+                ModbusSlaveConnectionFactoryImpl localConnectionFactory = connectionFactory;\n+                Objects.requireNonNull(localConnectionFactory, \"Not activated!\");\n+\n+                // cancel poller\n+                @Nullable\n+                ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n+                if (future == null) {\n+                    // No such poll task\n+                    logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n+                    return false;\n+                }\n+                logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n+                future.cancel(true);\n+                logger.info(\"Poll task {} canceled\", task);\n+                return true;\n+            }\n+        }\n \n-            logger.info(\"Poll task {} canceled\", task);\n+        @Override\n+        public ScheduledFuture<?> submitOneTimeWrite(ModbusWriteRequestBlueprint request,\n+                @Nullable ModbusWriteCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService localScheduledThreadPoolExecutor = scheduledThreadPoolExecutor;\n+            Objects.requireNonNull(localScheduledThreadPoolExecutor, \"Not activated!\");\n+            WriteTask task = new BasicWriteTask(endpoint, request, callback);\n+            long scheduleTime = System.currentTimeMillis();\n+            logger.debug(\"Scheduling one-off write task {}\", task);\n+            ScheduledFuture<?> future = localScheduledThreadPoolExecutor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, writeOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzkxMg=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Mzc1MTUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo1NDozMFrOGoixZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo0MzoxOFrOGovExw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTkyNA==", "bodyText": "Why are you using assert here? Please remove them or throw a proper exception instead.", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445165924", "createdAt": "2020-06-24T20:54:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "diffHunk": "@@ -652,7 +653,36 @@ private boolean containsOpenClosed(List<Class<? extends State>> acceptedDataType\n     }\n \n     @Override\n-    public synchronized void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+    public synchronized void handle(AsyncModbusReadResult result) {\n+        if (result.hasError()) {\n+            Exception error = result.getCause();\n+            assert error != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2NzQ5NQ==", "bodyText": "Assert here is guaranteed to work or the API contract is violated, it is there for the developer.\nHowever, your suggestion regarding Optional is good, I think it will resolve this confusion as well.", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445367495", "createdAt": "2020-06-25T07:43:18Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "diffHunk": "@@ -652,7 +653,36 @@ private boolean containsOpenClosed(List<Class<? extends State>> acceptedDataType\n     }\n \n     @Override\n-    public synchronized void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+    public synchronized void handle(AsyncModbusReadResult result) {\n+        if (result.hasError()) {\n+            Exception error = result.getCause();\n+            assert error != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTkyNA=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Mzc2MDI1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo1NzowOVrOGoi27Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo0MzoyNVrOGovE_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzM0MQ==", "bodyText": "please remove", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445167341", "createdAt": "2020-06-24T20:57:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "diffHunk": "@@ -72,66 +63,33 @@\n      */\n     private class ReadCallbackDelegator implements ModbusReadCallback {\n \n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, ModbusRegisterArray> lastRegisters;\n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, BitArray> lastCoils;\n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, Exception> lastError;\n+        private volatile @Nullable AtomicStampedValue<AsyncModbusReadResult> lastResult;\n \n         @Override\n-        public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+        public synchronized void handle(AsyncModbusReadResult result) {\n             // Ignore all incoming data and errors if configuration is not correct\n             if (hasConfigurationError() || disposed) {\n                 return;\n             }\n             if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, ModbusRegisterArray> lastRegisters = this.lastRegisters;\n-                if (lastRegisters == null) {\n-                    this.lastRegisters = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, registers);\n+                AtomicStampedValue<AsyncModbusReadResult> localLastResult = this.lastResult;\n+                if (localLastResult == null) {\n+                    this.lastResult = new AtomicStampedValue<>(System.currentTimeMillis(), result);\n                 } else {\n-                    lastRegisters.update(System.currentTimeMillis(), request, registers);\n+                    localLastResult.update(System.currentTimeMillis(), result);\n+                    this.lastResult = localLastResult;\n                 }\n             }\n-            logger.debug(\"Thing {} received registers {} for request {}\", thing.getUID(), registers, request);\n-            resetCommunicationError();\n-            childCallbacks.forEach(handler -> handler.onRegisters(request, registers));\n-        }\n-\n-        @Override\n-        public void onBits(ModbusReadRequestBlueprint request, BitArray coils) {\n-            // Ignore all incoming data and errors if configuration is not correct\n-            if (hasConfigurationError() || disposed) {\n-                return;\n-            }\n-            if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, BitArray> lastCoils = this.lastCoils;\n-                if (lastCoils == null) {\n-                    this.lastCoils = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, coils);\n-                } else {\n-                    lastCoils.update(System.currentTimeMillis(), request, coils);\n-                }\n-            }\n-            logger.debug(\"Thing {} received coils {} for request {}\", thing.getUID(), coils, request);\n-            resetCommunicationError();\n-            childCallbacks.forEach(handler -> handler.onBits(request, coils));\n-        }\n-\n-        @Override\n-        public void onError(ModbusReadRequestBlueprint request, Exception error) {\n-            // Ignore all incoming data and errors if configuration is not correct\n-            if (hasConfigurationError() || disposed) {\n-                return;\n-            }\n-            if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, Exception> lastError = this.lastError;\n-                if (lastError == null) {\n-                    this.lastError = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, error);\n-                } else {\n-                    lastError.update(System.currentTimeMillis(), request, error);\n-                }\n+            logger.debug(\"Thing {} received response {}\", thing.getUID(), result);\n+            childCallbacks.forEach(handler -> handler.handle(result));\n+            if (result.hasError()) {\n+                Exception error = result.getCause();\n+                assert error != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2NzU1MQ==", "bodyText": "Assert here is guaranteed to work or the API contract is violated, it is there for the developer.\nHowever, your suggestion regarding Optional is good, I think it will resolve this confusion as well.", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445367551", "createdAt": "2020-06-25T07:43:25Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "diffHunk": "@@ -72,66 +63,33 @@\n      */\n     private class ReadCallbackDelegator implements ModbusReadCallback {\n \n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, ModbusRegisterArray> lastRegisters;\n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, BitArray> lastCoils;\n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, Exception> lastError;\n+        private volatile @Nullable AtomicStampedValue<AsyncModbusReadResult> lastResult;\n \n         @Override\n-        public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+        public synchronized void handle(AsyncModbusReadResult result) {\n             // Ignore all incoming data and errors if configuration is not correct\n             if (hasConfigurationError() || disposed) {\n                 return;\n             }\n             if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, ModbusRegisterArray> lastRegisters = this.lastRegisters;\n-                if (lastRegisters == null) {\n-                    this.lastRegisters = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, registers);\n+                AtomicStampedValue<AsyncModbusReadResult> localLastResult = this.lastResult;\n+                if (localLastResult == null) {\n+                    this.lastResult = new AtomicStampedValue<>(System.currentTimeMillis(), result);\n                 } else {\n-                    lastRegisters.update(System.currentTimeMillis(), request, registers);\n+                    localLastResult.update(System.currentTimeMillis(), result);\n+                    this.lastResult = localLastResult;\n                 }\n             }\n-            logger.debug(\"Thing {} received registers {} for request {}\", thing.getUID(), registers, request);\n-            resetCommunicationError();\n-            childCallbacks.forEach(handler -> handler.onRegisters(request, registers));\n-        }\n-\n-        @Override\n-        public void onBits(ModbusReadRequestBlueprint request, BitArray coils) {\n-            // Ignore all incoming data and errors if configuration is not correct\n-            if (hasConfigurationError() || disposed) {\n-                return;\n-            }\n-            if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, BitArray> lastCoils = this.lastCoils;\n-                if (lastCoils == null) {\n-                    this.lastCoils = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, coils);\n-                } else {\n-                    lastCoils.update(System.currentTimeMillis(), request, coils);\n-                }\n-            }\n-            logger.debug(\"Thing {} received coils {} for request {}\", thing.getUID(), coils, request);\n-            resetCommunicationError();\n-            childCallbacks.forEach(handler -> handler.onBits(request, coils));\n-        }\n-\n-        @Override\n-        public void onError(ModbusReadRequestBlueprint request, Exception error) {\n-            // Ignore all incoming data and errors if configuration is not correct\n-            if (hasConfigurationError() || disposed) {\n-                return;\n-            }\n-            if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, Exception> lastError = this.lastError;\n-                if (lastError == null) {\n-                    this.lastError = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, error);\n-                } else {\n-                    lastError.update(System.currentTimeMillis(), request, error);\n-                }\n+            logger.debug(\"Thing {} received response {}\", thing.getUID(), result);\n+            childCallbacks.forEach(handler -> handler.handle(result));\n+            if (result.hasError()) {\n+                Exception error = result.getCause();\n+                assert error != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzM0MQ=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Mzc3NzY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowMjozOVrOGojBrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo0NDowMVrOGovGOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDA5NQ==", "bodyText": "Why not just have getCause() return an optional so you can use it to replace hasError while also avoiding all of the @NonNull casting you are doing?", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445170095", "createdAt": "2020-06-24T21:02:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -280,30 +256,20 @@ private void modelBlockReceived(ModbusRegisterArray registers) {\n      * @param block\n      */\n     private void readCommonBlock(ModelBlock block) {\n-        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveId,\n                 ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, block.address, // Start address\n                 block.length, // number or words to return\n                 maxTries);\n \n-        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n-\n-            @Override\n-            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n-                parseCommonBlock(registers);\n-            }\n-\n-            @Override\n-            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+        comms.submitOneTimePoll(request, result -> {\n+            if (result.hasError()) {\n+                Exception error = (@NonNull Exception) result.getCause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2Nzg2NQ==", "bodyText": "Makes sense actually...\ud83d\udc4d", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445367865", "createdAt": "2020-06-25T07:44:01Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -280,30 +256,20 @@ private void modelBlockReceived(ModbusRegisterArray registers) {\n      * @param block\n      */\n     private void readCommonBlock(ModelBlock block) {\n-        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveId,\n                 ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, block.address, // Start address\n                 block.length, // number or words to return\n                 maxTries);\n \n-        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n-\n-            @Override\n-            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n-                parseCommonBlock(registers);\n-            }\n-\n-            @Override\n-            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+        comms.submitOneTimePoll(request, result -> {\n+            if (result.hasError()) {\n+                Exception error = (@NonNull Exception) result.getCause();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDA5NQ=="}, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Mzc3ODYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowMzowMFrOGojCVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowMzowMFrOGojCVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDI2Mg==", "bodyText": "same suggestion here", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445170262", "createdAt": "2020-06-24T21:03:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -158,30 +154,20 @@ public void detectModel() {\n         baseAddress = possibleAddresses.poll();\n         logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n \n-        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveId,\n                 ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n                 SUNSPEC_ID_SIZE, // number or words to return\n                 maxTries);\n \n-        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n-\n-            @Override\n-            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n-                headerReceived(registers);\n-            }\n-\n-            @Override\n-            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+        comms.submitOneTimePoll(request, result -> {\n+            if (result.hasError()) {\n+                Exception error = (@NonNull Exception) result.getCause();\n                 handleError(error);\n-            }\n-\n-            @Override\n-            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n-                // don't care, we don't expect this result\n+            } else {\n+                ModbusRegisterArray registers = (@NonNull ModbusRegisterArray) result.getRegisters();\n+                headerReceived(registers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a72b756192388fa760c71959ce198482ad25fee"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTkyMjY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODozOTo0MFrOGtOGhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODozOTo0MFrOGtOGhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3MDE0OQ==", "bodyText": "Cherry-picked 5bde9d6 during rebase in this commit.", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r450070149", "createdAt": "2020-07-06T08:39:40Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -739,136 +743,177 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(ModbusSlaveEndpoint endpoint, ModbusReadRequestBlueprint request,\n-            @Nullable ModbusReadCallback callback) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public PollTask registerRegularPoll(ModbusSlaveEndpoint endpoint, ModbusReadRequestBlueprint request,\n-            long pollPeriodMillis, long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasks = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n+            for (ModbusManagerListener listener : listeners) {\n+                listener.onEndpointPoolConfigurationSet(endpoint, configuration);\n             }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (RuntimeException e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n-\n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            return task;\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e1832636ac83c00cb5c9a493a41f1538c68ae99"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjU5NTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoyNDo1OVrOGuOUaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyNDozM1rOGudcLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMjI4MA==", "bodyText": "Could you return a Collection.emptyMap() here?", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451122280", "createdAt": "2020-07-07T20:24:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "diffHunk": "@@ -805,7 +820,13 @@ public synchronized void onWriteResponse(ModbusWriteRequestBlueprint request, Mo\n      * @return updated channel data\n      */\n     private Map<ChannelUID, State> processUpdatedValue(State numericState, boolean boolValue) {\n-        Map<@NonNull ChannelUID, @NonNull State> states = new HashMap<>();\n+        Transformation localReadTransformation = readTransformation;\n+        if (localReadTransformation == null) {\n+            // We should always have transformation available if thing is initalized properly\n+            logger.trace(\"No transformation available, aborting processUpdatedValue\");\n+            return new HashMap<ChannelUID, State>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a8df8dd20ea7cb011a029f4c47907188769b921"}, "originalPosition": 454}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDAzMA==", "bodyText": "Yup. 6a46de1", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451370030", "createdAt": "2020-07-08T08:24:33Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "diffHunk": "@@ -805,7 +820,13 @@ public synchronized void onWriteResponse(ModbusWriteRequestBlueprint request, Mo\n      * @return updated channel data\n      */\n     private Map<ChannelUID, State> processUpdatedValue(State numericState, boolean boolValue) {\n-        Map<@NonNull ChannelUID, @NonNull State> states = new HashMap<>();\n+        Transformation localReadTransformation = readTransformation;\n+        if (localReadTransformation == null) {\n+            // We should always have transformation available if thing is initalized properly\n+            logger.trace(\"No transformation available, aborting processUpdatedValue\");\n+            return new HashMap<ChannelUID, State>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMjI4MA=="}, "originalCommit": {"oid": "1a8df8dd20ea7cb011a029f4c47907188769b921"}, "originalPosition": 454}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjYwMDUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoyNjozM1rOGuOXuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyNDoxMlrOGudbMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMzEyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Nullable\n          \n          \n            \n                    public final AsyncModbusReadResult result;\n          \n          \n            \n                    @Nullable\n          \n          \n            \n                    public final AsyncModbusFailure<ModbusReadRequestBlueprint> failure;\n          \n          \n            \n                    public final @Nullable AsyncModbusReadResult result;\n          \n          \n            \n                    public final @Nullable AsyncModbusFailure<ModbusReadRequestBlueprint> failure;", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451123128", "createdAt": "2020-07-07T20:26:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "diffHunk": "@@ -246,21 +177,48 @@ public ModbusPollerReadRequest(ModbusPollerConfiguration config,\n         }\n     }\n \n-    private final Logger logger = LoggerFactory.getLogger(ModbusPollerThingHandlerImpl.class);\n+    /**\n+     * Immutable data object to cache the results of a poll request\n+     */\n+    private class PollResult {\n+        @Nullable\n+        public final AsyncModbusReadResult result;\n+        @Nullable\n+        public final AsyncModbusFailure<ModbusReadRequestBlueprint> failure;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a8df8dd20ea7cb011a029f4c47907188769b921"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTc3OQ==", "bodyText": "Resolved this, and many others in 00b7f76", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451369779", "createdAt": "2020-07-08T08:24:12Z", "author": {"login": "ssalonen"}, "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "diffHunk": "@@ -246,21 +177,48 @@ public ModbusPollerReadRequest(ModbusPollerConfiguration config,\n         }\n     }\n \n-    private final Logger logger = LoggerFactory.getLogger(ModbusPollerThingHandlerImpl.class);\n+    /**\n+     * Immutable data object to cache the results of a poll request\n+     */\n+    private class PollResult {\n+        @Nullable\n+        public final AsyncModbusReadResult result;\n+        @Nullable\n+        public final AsyncModbusFailure<ModbusReadRequestBlueprint> failure;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMzEyOA=="}, "originalCommit": {"oid": "1a8df8dd20ea7cb011a029f4c47907188769b921"}, "originalPosition": 280}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4856, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}