{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTIxNTAy", "number": 7858, "title": "[heliosventilation] Helios Ventilation Binding Initial contribution", "bodyText": "Add binding to access Helios Domestiic ventilation systems (KWL) via the Remote Control RS485 interface.\nThis is a rework of the previously abandoned #5831 which I messed up with merging the wrong branch.\nFixes #5752", "createdAt": "2020-06-04T22:23:59Z", "url": "https://github.com/openhab/openhab-addons/pull/7858", "merged": true, "mergeCommit": {"oid": "2f28304399b32628ed6354016aacd1dcb4c8b74e"}, "closed": true, "closedAt": "2020-06-27T19:07:39Z", "author": {"login": "ramack"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoFkmGgH2gAyNDI4MTIxNTAyOjk5OTBlNzk4ZjU4ODE2Y2Y1MTBhMDJjZjQ4YmU4NzFmNjk3ZjA1NDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvb1lIgFqTQzODcxNDgxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9990e798f58816cf510a02cf48be871f697f0548", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/9990e798f58816cf510a02cf48be871f697f0548", "committedDate": "2020-06-04T22:12:33Z", "message": "add new binding HelioVentilation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c52601f38abf32f88039fbedc8187dbdcd33644b", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/c52601f38abf32f88039fbedc8187dbdcd33644b", "committedDate": "2020-06-04T22:41:09Z", "message": "fix file encoding\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361703be6950354911240a431cfdce7604537cb6", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/361703be6950354911240a431cfdce7604537cb6", "committedDate": "2020-06-04T22:41:51Z", "message": "fix whitespace issue which failed travis\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODg3NzAz", "url": "https://github.com/openhab/openhab-addons/pull/7858#pullrequestreview-424887703", "createdAt": "2020-06-04T22:51:12Z", "commit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1MToxMlrOGfam1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToxNTo0N1rOGfgrEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDk2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n                private SerialPortManager serialPortManager;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435594964", "createdAt": "2020-06-04T22:51:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import static org.openhab.binding.heliosventilation.internal.HeliosVentilationBindingConstants.THING_TYPE_HELIOS_VENTILATION;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HeliosVentilationHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.heliosventilation\", service = ThingHandlerFactory.class)\n+public class HeliosVentilationHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .singleton(THING_TYPE_HELIOS_VENTILATION);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NzIyNQ==", "bodyText": "Why do you need to sleep here? Does InputStream.read not block for input?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435597225", "createdAt": "2020-06-04T22:57:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                IOUtils.closeQuietly(inputStream);\n+                IOUtils.closeQuietly(outputStream);\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);\n+        outputStream = null;\n+        inputStream = null;\n+        serialPort = null;\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+\n+                                if (cnt < 6 && in.available() < 1) {\n+                                    // frame not yet complete but no input available, let's wait a little to merge\n+                                    // interrupted transmissions\n+\n+                                    // 9600 baud yields about 1ms per byte, so let's wait the expected remaining time\n+                                    // for a frame\n+                                    try {\n+                                        Thread.sleep(1 * (6 - cnt));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyODc0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n          \n          \n            \n                private Map<Byte, Byte> memory = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435628745", "createdAt": "2020-06-05T00:31:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyOTI3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String channelName;\n          \n          \n            \n                private String fullSpec;\n          \n          \n            \n                private String reason;\n          \n          \n            \n                private final String channelName;\n          \n          \n            \n                private final String fullSpec;\n          \n          \n            \n                private final String reason;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435629278", "createdAt": "2020-06-05T00:34:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosPropertiesFormatException.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link HeliosPropertiesFormatException} class defines an exception to describe parsing format errors\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosPropertiesFormatException extends Exception {\n+    private static final long serialVersionUID = 8051109351111509577L;\n+    private String channelName;\n+    private String fullSpec;\n+    private String reason;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjkwMA==", "bodyText": "Is there a reason that you didn't store this data as an enum in the source code?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435692900", "createdAt": "2020-06-05T05:09:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/datapoints.properties", "diffHunk": "@@ -0,0 +1,48 @@\n+#\n+# datapoints.properties - This file defines the datapoints of the Helios ventilation system\n+#\n+# Format: <name> = <address(:bitspec)>,writable,type\n+#\n+#         bitspec is\n+#         - a single digit in range 0-7 or\n+#         - start:end (where start is the number of the LSB and end the number of the MSB of the field)\n+#\n+#         type is one of\n+#         - TEMPERATURE\n+#         - FANSPEED\n+#         - PERCENT\n+#         - BYTE_PERCENT\n+#         - SWITCH\n+#         - NUMBER\n+#         - HYSTERESIS\n+#\n+# on change of this file, ensure that the thing-types.xml is consistent\n+\n+fanspeed = 0x29,true,FANSPEED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MzU0MQ==", "bodyText": "We are trying to migrate away from using the apache util libraries. Can you implement this without using IOUtils?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435693541", "createdAt": "2020-06-05T05:12:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg==", "bodyText": "I'm not sure that this does a proper conversion if the QuantityType supplied here is of an unexpected unit.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435694352", "createdAt": "2020-06-05T05:15:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3090248d1c6e6ad826e8e9506a01eabf7b4c5015", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/3090248d1c6e6ad826e8e9506a01eabf7b4c5015", "committedDate": "2020-06-05T20:37:19Z", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/1a59f77d1c606a32180e2511e5df9e06ceb1807b", "committedDate": "2020-06-05T22:40:32Z", "message": "Convert QuantityType in expected unit Celcius\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzgwNjk2", "url": "https://github.com/openhab/openhab-addons/pull/7858#pullrequestreview-425780696", "createdAt": "2020-06-07T01:42:52Z", "commit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMTo0Mjo1MlrOGgGnnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo1NDo1NFrOGgLg6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxNjA2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static HashMap<Byte, HeliosVentilationDataPoint> readChannelProperties() {\n          \n          \n            \n                private static Map<Byte, HeliosVentilationDataPoint> readChannelProperties() {", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436316061", "createdAt": "2020-06-07T01:42:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n+\n+    private static final Logger LOGGER;\n+    static {\n+        /* logger is used by readChannelProperties() so we need to initialize logger first. */\n+        LOGGER = LoggerFactory.getLogger(HeliosVentilationBindingConstants.class);\n+        DATAPOINTS = readChannelProperties();\n+    }\n+    // List of all Channel ids\n+    // Channel ids are only in datapoints.properties and thing-types.xml\n+\n+    /**\n+     * parse datapoints from properties\n+     *\n+     */\n+    private static HashMap<Byte, HeliosVentilationDataPoint> readChannelProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxNjA2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n          \n          \n            \n                public static final Map<Byte, HeliosVentilationDataPoint> DATAPOINTS;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436316064", "createdAt": "2020-06-07T01:42:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTM4NQ==", "bodyText": "configuration errors should be done in the initialize method, try to move this logic there instead.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395385", "createdAt": "2020-06-07T19:43:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTczNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"pollPeriod\" type=\"integer\" min=\"0\">\n          \n          \n            \n            \t\t\t<parameter name=\"pollPeriod\" type=\"integer\" min=\"0\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395735", "createdAt": "2020-06-07T19:47:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,233 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"heliosventilation\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Ventilation Thing Type -->\n+\t<thing-type id=\"ventilation\">\n+\t\t<label>HeliosVentilation (KWL)</label>\n+\t\t<description>A domestic ventilation system (KWL) from Helios.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"outsideTemp\" typeId=\"outside_temperature\" />\n+\t\t\t<channel id=\"outgoingTemp\" typeId=\"outgoing_temperature\" />\n+\t\t\t<channel id=\"extractTemp\" typeId=\"extract_temperature\" />\n+\t\t\t<channel id=\"supplyTemp\" typeId=\"supply_temperature\" />\n+\t\t\t<channel id=\"setTemp\" typeId=\"set_temperature\" />\n+\t\t\t<channel id=\"bypassTemp\" typeId=\"bypass_temperature\" />\n+\t\t\t<channel id=\"supplyStopTemp\" typeId=\"supply_stop_temperature\" />\n+\t\t\t<channel id=\"preheatTemp\" typeId=\"preheat_temperature\" />\n+\t\t\t<channel id=\"minFanspeed\" typeId=\"min_fanspeed\" />\n+\t\t\t<channel id=\"maxFanspeed\" typeId=\"max_fanspeed\" />\n+\t\t\t<channel id=\"fanspeed\" typeId=\"fanspeed\" />\n+\t\t\t<channel id=\"rhLimit\" typeId=\"rh_limit\" />\n+\t\t\t<channel id=\"hysteresis\" typeId=\"hysteresis\" />\n+\t\t\t<channel id=\"DCFanExtract\" typeId=\"dc_fan_extract\" />\n+\t\t\t<channel id=\"DCFanSupply\" typeId=\"dc_fan_supply\" />\n+\t\t\t<channel id=\"maintenanceInterval\" typeId=\"maintenance_interval\" />\n+\n+\t\t\t<channel id=\"radiatorType\" typeId=\"radiator_type\" />\n+\t\t\t<channel id=\"switchType\" typeId=\"switch_type\" />\n+\t\t\t<channel id=\"cascade\" typeId=\"cascade_mode\" />\n+\t\t\t<channel id=\"RHLevelAuto\" typeId=\"rh_level_auto\" />\n+\t\t\t<channel id=\"powerState\" typeId=\"power_state\" />\n+\t\t\t<channel id=\"co2State\" typeId=\"co2_state\" />\n+\t\t\t<channel id=\"rhState\" typeId=\"rh_state\" />\n+\t\t\t<channel id=\"winterMode\" typeId=\"winter_state\" />\n+\t\t\t<channel id=\"adjustInveral\" typeId=\"adjust_interval\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>RS485 Interface Serial Port</label>\n+\t\t\t\t<description>The serial port name for the RS485 interfaces. Valid values are e.g. COM1 for Windows and /dev/ttyS0 or /dev/ttyUSB0 for Linux.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"pollPeriod\" type=\"integer\" min=\"0\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ==", "bodyText": "it doesn't look like this outer while loop serves any purpose.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395815", "createdAt": "2020-06-07T19:49:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+                            } while (in.available() > 0 && cnt < 6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjAwMA==", "bodyText": "why do you mean \"increase the likelihood\"? Is it possible to implement this in a foolproof manner?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396000", "createdAt": "2020-06-07T19:51:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjExMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            byte frame[] = { 0, 0, 0, 0, 0, 0 };\n          \n          \n            \n                            byte[] frame = { 0, 0, 0, 0, 0, 0 };", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396111", "createdAt": "2020-06-07T19:52:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjI2NA==", "bodyText": "There is a bug in the core that causes handleCommand to sometimes get called before the handler's initialize is called. So we recommend to just populate the configuration with a default instance to avoid NPE issues.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n          \n          \n            \n                private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396264", "createdAt": "2020-06-07T19:54:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "committedDate": "2020-06-12T21:05:01Z", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDg1NzMx", "url": "https://github.com/openhab/openhab-addons/pull/7858#pullrequestreview-430085731", "createdAt": "2020-06-12T23:44:10Z", "commit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0NDoxMFrOGjUB8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowMDo0NlrOGjUMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA==", "bodyText": "if thing.getStatus() == ThingStatus.REMOVING shouldn't you exit early?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681520", "createdAt": "2020-06-12T23:44:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTcyMw==", "bodyText": "I suspect this might be used by multiple threads at once, so lets make it thread-safe and final.\nThen move the final fields above all the non-final fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n          \n          \n            \n                private final Map<Byte, Byte> memory = new ConcurrentHashMap<Byte, Byte>();", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681723", "createdAt": "2020-06-12T23:45:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTk5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681998", "createdAt": "2020-06-12T23:47:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Mjc5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n          \n          \n            \n                private static final int[] FANSPEED_MAP = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439682791", "createdAt": "2020-06-12T23:52:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n          \n          \n            \n                private static final int[] TEMP_MAP = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439682812", "createdAt": "2020-06-12T23:52:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzM2NQ==", "bodyText": "QuantityType extend Number so you don't need to convert them to a DecimalType.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            value = quantvalue.as(DecimalType.class);\n          \n          \n            \n                            if (value != null) {\n          \n          \n            \n                                result = (byte) (value.intValue() * 3);\n          \n          \n            \n                            }\n          \n          \n            \n                            result = (byte) (quantvalue.intValue() * 3);", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439683365", "createdAt": "2020-06-12T23:55:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    int temp = (int) Math.round(value.doubleValue());\n+                    int i = 0;\n+                    while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                        i++;\n+                    }\n+                    result = (byte) i;\n+                }\n+            }\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = value.intValue();\n+            if (i < 0) {\n+                i = 0;\n+            } else if (i > 8) {\n+                i = 8;\n+            }\n+            result = (byte) FANSPEED_MAP[i];\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+        } else if (datatype == DataType.PERCENT) {\n+            double d = (Math.round(value.doubleValue()));\n+            if (d < 0.0) {\n+                d = 0.0;\n+            } else if (d > 100.0) {\n+                d = 100.0;\n+            }\n+            result = (byte) d;\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    result = (byte) (value.intValue() * 3);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzgyMg==", "bodyText": "This would be a good place to use a switch statement.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (datatype == DataType.TEMPERATURE) {\n          \n          \n            \n                    } else switch(datatype) {\n          \n          \n            \n                        case TEMPERATURE:", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439683822", "createdAt": "2020-06-12T23:58:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDA1Mw==", "bodyText": "I'd prefer if you renamed the field and this method to next.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable HeliosVentilationDataPoint link() {\n          \n          \n            \n                    return link;\n          \n          \n            \n                }\n          \n          \n            \n                public @Nullable HeliosVentilationDataPoint next() {\n          \n          \n            \n                    return next;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439684053", "createdAt": "2020-06-12T23:59:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    int temp = (int) Math.round(value.doubleValue());\n+                    int i = 0;\n+                    while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                        i++;\n+                    }\n+                    result = (byte) i;\n+                }\n+            }\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = value.intValue();\n+            if (i < 0) {\n+                i = 0;\n+            } else if (i > 8) {\n+                i = 8;\n+            }\n+            result = (byte) FANSPEED_MAP[i];\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+        } else if (datatype == DataType.PERCENT) {\n+            double d = (Math.round(value.doubleValue()));\n+            if (d < 0.0) {\n+                d = 0.0;\n+            } else if (d > 100.0) {\n+                d = 100.0;\n+            }\n+            result = (byte) d;\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    result = (byte) (value.intValue() * 3);\n+                }\n+            }\n+        } else if (datatype == DataType.SWITCH || datatype == DataType.NUMBER) {\n+            // those are the types supporting bit level specification\n+            // output only the relevant bits\n+            result = (byte) (value.intValue() << bitStart);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get further datapoint linked to the same address.\n+     *\n+     * @return sister datapoint\n+     */\n+    public @Nullable HeliosVentilationDataPoint link() {\n+        return link;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDE1Mw==", "bodyText": "You can use a switch statement here as well.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439684153", "createdAt": "2020-06-13T00:00:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "committedDate": "2020-06-14T15:18:34Z", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjM1MDUw", "url": "https://github.com/openhab/openhab-addons/pull/7858#pullrequestreview-430235050", "createdAt": "2020-06-14T16:53:50Z", "commit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTY1MDY0", "url": "https://github.com/openhab/openhab-addons/pull/7858#pullrequestreview-432565064", "createdAt": "2020-06-17T16:20:40Z", "commit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMDo0MFrOGlNUug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzowNzoxOVrOGlPFAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2ODc5NA==", "bodyText": "In the xml, this is Number:Dimensionless.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441668794", "createdAt": "2020-06-17T16:20:40Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/README.md", "diffHunk": "@@ -0,0 +1,111 @@\n+# HeliosVentilation Binding\n+\n+This is the binding for Helios Ventilation Systems KWL EC 200/300/500 Pro.\n+It requires a connection to the RS485 bus used by the original remote controls KWL-FB (9417) and does not use the Modbus/TCP interface of the newer EasyControl devices.\n+\n+For electrical connection it is recommended to use an USB-RS485 interface, but any RS485 interface that shows up as a serial port will do.\n+Setup the device as described in https://www.openhab.org/docs/administration/serial.html.\n+\n+The binding will use the remote control address 15 for communication, so make sure that this is not assigned to a physically present remote control.\n+\n+## Supported Things\n+\n+There is only one thing type supported by this binding: a Helios Ventilation System KWL EC 200/300/500 Pro from Helios.\n+The binding was developed and test on a KWL EC 200 Pro device.\n+\n+## Binding Configuration\n+\n+The binding requires access to the serial device connecting to the RS485 bus as described in https://www.openhab.org/docs/administration/serial.html.\n+Otherwise only thing configuration is needed.\n+\n+## Thing Configuration\n+\n+The binding supports only one thing and requires the configuration of the serial port (typically /dev/ttyUSB0 on Linux and COM3 on Windows) and optionally the polling time which is the cycle time after which the binding tries to reconnect to the bus and requests data updates.\n+\n+## Channels\n+\n+Supported operation channels:\n+\n+| channel            | type               | description                                   |\n+|--------------------|--------------------|-----------------------------------------------|\n+| outsideTemp        | Number:Temperature | Temperature sensor in the outside air flow    |\n+| outgoingTemp       | Number:Temperature | Temperature sensor in the outgoing air flow   |\n+| extractTemp        | Number:Temperature | Temperature sensor in the extract air flow    |\n+| supplyTemp         | Number:Temperature | Temperature sensor in the supply air flow     |\n+| setTemp            | Number:Temperature | Set temperature for supply (not always used)  |\n+| fanspeed           | Number             | Level of the fanspeed (1-8)                   |\n+| powerState         | Switch             | Main power switch                             |\n+| co2State           | Switch             | Switch for CO2 regulation                     |\n+| rhState            | Switch             | Switch for humidity regulation                |\n+| winterMode         | Switch             | Switch to set winter mode                     |\n+\n+Supported configuration channels:\n+\n+| channel            | type               | description                                   |\n+|--------------------|--------------------|-----------------------------------------------|\n+| bypassTemp         | Number:Temperature | Temperature to disable the bypass function    |\n+| supplyStopTemp     | Number:Temperature | Temperature to stop supply fan for defrosting |\n+| preheatTemp        | Number:Temperature | Temperature to enable the preheater           |\n+| minFanspeed        | Number             | Minimal level of the fanspeed (1-8)           |\n+| maxFanspeed        | Number             | Maximal level of the fanspeed (1-8)           |\n+| rhLimit            | Number             | Limit for relative humidity sensor            |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MTc2NA==", "bodyText": "Since this does not affect the stability of openHAB, ERROR is too much. Please reduce to WARN. The question is: if this can't be read, the binding won't work, correct? I wonder if we should throw an exception so that the binding initialization fails.\nSidenote: I know the log level is wrong in onewire. Will fix that.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441671764", "createdAt": "2020-06-17T16:25:28Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final Map<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n+\n+    private static final Logger LOGGER;\n+    static {\n+        /* logger is used by readChannelProperties() so we need to initialize logger first. */\n+        LOGGER = LoggerFactory.getLogger(HeliosVentilationBindingConstants.class);\n+        DATAPOINTS = readChannelProperties();\n+    }\n+    // List of all Channel ids\n+    // Channel ids are only in datapoints.properties and thing-types.xml\n+\n+    /**\n+     * parse datapoints from properties\n+     *\n+     */\n+    private static Map<Byte, HeliosVentilationDataPoint> readChannelProperties() {\n+        HashMap<Byte, HeliosVentilationDataPoint> result = new HashMap<Byte, HeliosVentilationDataPoint>();\n+\n+        URL resource = Thread.currentThread().getContextClassLoader().getResource(DATAPOINT_FILE);\n+        Properties properties = new Properties();\n+        try {\n+            properties.load(resource.openStream());\n+\n+            Enumeration<Object> keys = properties.keys();\n+            while (keys.hasMoreElements()) {\n+                String channel = (String) keys.nextElement();\n+                HeliosVentilationDataPoint dp;\n+                try {\n+                    dp = new HeliosVentilationDataPoint(channel, properties.getProperty(channel));\n+                    if (result.containsKey(dp.address())) {\n+                        result.get(dp.address()).append(dp);\n+                    } else {\n+                        result.put(dp.address(), dp);\n+                    }\n+                } catch (HeliosPropertiesFormatException e) {\n+                    LOGGER.error(\"could not read resource file {}, binding will probably fail: {}\", DATAPOINT_FILE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3Mjk4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return true iff writing to this datapoint requires a read-modify-write on the address\n          \n          \n            \n                 * @return true if writing to this datapoint requires a read-modify-write on the address", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441672989", "createdAt": "2020-06-17T16:27:26Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@next HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int[] TEMP_MAP = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int[] FANSPEED_MAP = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint next;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        switch (datatype) {\n+            case TEMPERATURE:\n+                return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+            case BYTE_PERCENT:\n+                return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                        SmartHomeUnits.PERCENT);\n+            case SWITCH:\n+                if (bitLength != 1) {\n+                    return UnDefType.UNDEF;\n+                } else if ((b & (1 << bitStart)) != 0) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case NUMBER:\n+                int value = (b & bitMask()) >> bitStart;\n+                return new DecimalType(value);\n+            case PERCENT:\n+                return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+            case FANSPEED:\n+                int i = 1;\n+                while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                    i++;\n+                }\n+                return new DecimalType(i);\n+            case HYSTERESIS:\n+                return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+            default:\n+                return UnDefType.UNDEF;\n+        }\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else {\n+            QuantityType<?> quantvalue;\n+            switch (datatype) {\n+                case TEMPERATURE:\n+                    quantvalue = ((QuantityType<?>) val);\n+                    quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+                    if (quantvalue != null) {\n+                        value = quantvalue.as(DecimalType.class);\n+                        if (value != null) {\n+                            int temp = (int) Math.round(value.doubleValue());\n+                            int i = 0;\n+                            while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                                i++;\n+                            }\n+                            result = (byte) i;\n+                        }\n+                    }\n+                    break;\n+                case FANSPEED:\n+                    int i = value.intValue();\n+                    if (i < 0) {\n+                        i = 0;\n+                    } else if (i > 8) {\n+                        i = 8;\n+                    }\n+                    result = (byte) FANSPEED_MAP[i];\n+                    break;\n+                case BYTE_PERCENT:\n+                    result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+                    break;\n+                case PERCENT:\n+                    double d = (Math.round(value.doubleValue()));\n+                    if (d < 0.0) {\n+                        d = 0.0;\n+                    } else if (d > 100.0) {\n+                        d = 100.0;\n+                    }\n+                    result = (byte) d;\n+                    break;\n+                case HYSTERESIS:\n+                    quantvalue = ((QuantityType<?>) val).toUnit(SIUnits.CELSIUS);\n+                    if (quantvalue != null) {\n+                        result = (byte) (quantvalue.intValue() * 3);\n+                    }\n+                    break;\n+                case SWITCH:\n+                case NUMBER:\n+                    // those are the types supporting bit level specification\n+                    // output only the relevant bits\n+                    result = (byte) (value.intValue() << bitStart);\n+                    break;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get further datapoint linked to the same address.\n+     *\n+     * @return sister datapoint\n+     */\n+    public @Nullable HeliosVentilationDataPoint next() {\n+        return next;\n+    }\n+\n+    /**\n+     * Add a next to a datapoint on the same address.\n+     * Caller has to ensure that identical datapoints are not added several times.\n+     *\n+     * @param next is the sister datapoint\n+     */\n+    public void append(HeliosVentilationDataPoint next) {\n+        HeliosVentilationDataPoint existing = this.next;\n+        if (this == next) {\n+            // this datapoint is already there, so we do nothing and return\n+            return;\n+        } else if (existing != null) {\n+            existing.append(next);\n+        } else {\n+            this.next = next;\n+        }\n+    }\n+\n+    /**\n+     * @return true iff writing to this datapoint requires a read-modify-write on the address", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NDc4OQ==", "bodyText": "Why do you do this? Wouldn't\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HeliosVentilationHandler.class);\n          \n      \n    \n    \n  \n\nalso work?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441694789", "createdAt": "2020-06-17T17:02:39Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NzUzOQ==", "bodyText": "Interesting. Before the thing is removed, it should have completed dispose() and nothing should be alive then. If this happens, either this is a bug in the framework or something from the serial handling is still alive when dispose() finished.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441697539", "createdAt": "2020-06-17T17:07:19Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 441}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b74408895bd3409705ecb810bc4fb274940d914", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/3b74408895bd3409705ecb810bc4fb274940d914", "committedDate": "2020-06-21T19:34:44Z", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bf1054e3713fc8265f6168ebfd0881c41450e78", "author": {"user": {"login": "ramack", "name": "Raphael Mack"}}, "url": "https://github.com/openhab/openhab-addons/commit/7bf1054e3713fc8265f6168ebfd0881c41450e78", "committedDate": "2020-06-27T17:52:09Z", "message": "adjusting version\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzE0ODEx", "url": "https://github.com/openhab/openhab-addons/pull/7858#pullrequestreview-438714811", "createdAt": "2020-06-27T18:06:29Z", "commit": {"oid": "7bf1054e3713fc8265f6168ebfd0881c41450e78"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 530, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}