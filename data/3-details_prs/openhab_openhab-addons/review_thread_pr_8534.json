{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNTg4ODA1", "number": 8534, "reviewThreads": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1MjozMlrOEqFPAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0OTowMVrOE0qmqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYxNDEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/.classpath", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1MjozM1rOHcGwRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1MjozM1rOHcGwRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMjgzOQ==", "bodyText": "Please remove this file from the PR. It will be generated by maven.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499232839", "createdAt": "2020-10-04T10:52:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/.classpath", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYxNDI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/.project", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1MjozOVrOHcGwVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1MjozOVrOHcGwVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMjg1NQ==", "bodyText": "Please remove this file from the PR. It will be generated by maven.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499232855", "createdAt": "2020-10-04T10:52:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/.project", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYxNTY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1NDozNFrOHcGxCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1NDozNFrOHcGxCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzAzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | plug1#watt         | Number | Contains currently used power of plug 1   |\n          \n          \n            \n            | plug1#watt         | Number:Power | Contains currently used power of plug 1   |", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233034", "createdAt": "2020-10-04T10:54:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/README.md", "diffHunk": "@@ -0,0 +1,68 @@\n+# Revogi Binding\n+\n+This binding is written to control Revogi devices. The first thing implemented is the [Revogi Smart Power Strip](https://www.revogi.com/smart-power/smart-power-strip-eu/#section6). The device has 6 power plugs that can be switched independently, or all together.\n+\n+It was hard to find out how to control it without internet access, but there's a way to use UDP packets. See `LAN UDP Control.pdf` in the `doc` folder for details. This was the only document the Revogi support provided. \n+\n+## Supported Things\n+\n+Currently only the model `SOW019` is supported.\n+\n+## Discovery\n+\n+If your smart strip is within your network (broadcast domain), discovery can work. The discovery service will send udp packets to the broadcast address and waits for a feedback.\n+\n+It is required to integrate your power strip into your network first, maybe with the official app.\n+\n+## Thing Configuration\n+\n+You need to know the serial number. Usually you can find it on the back. The serial number will also be discovered. The IP address of the device is also necessary, this address should be set static. There's a fallback to broadcast status and switch requests. That may be unreliable if you have more than one smart plug in your network. They all react on UDP packets.\n+\n+## Channels\n+\n+| channel            | type   | description                               |\n+|--------------------|--------|-------------------------------------------|\n+| overallPlug#switch | Switch | Switch all plugs                          |\n+| plug1#switch       | Switch | Switch plug 1                             |\n+| plug1#watt         | Number | Contains currently used power of plug 1   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYxNjAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1NToxMVrOHcGxPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1NToxMVrOHcGxPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzA4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | plug1#amp          | Number | Contains currently used current of plug 1 |\n          \n          \n            \n            | plug1#amp          | Number:ElectricCurrent | Contains currently used current of plug 1 |", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233085", "createdAt": "2020-10-04T10:55:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/README.md", "diffHunk": "@@ -0,0 +1,68 @@\n+# Revogi Binding\n+\n+This binding is written to control Revogi devices. The first thing implemented is the [Revogi Smart Power Strip](https://www.revogi.com/smart-power/smart-power-strip-eu/#section6). The device has 6 power plugs that can be switched independently, or all together.\n+\n+It was hard to find out how to control it without internet access, but there's a way to use UDP packets. See `LAN UDP Control.pdf` in the `doc` folder for details. This was the only document the Revogi support provided. \n+\n+## Supported Things\n+\n+Currently only the model `SOW019` is supported.\n+\n+## Discovery\n+\n+If your smart strip is within your network (broadcast domain), discovery can work. The discovery service will send udp packets to the broadcast address and waits for a feedback.\n+\n+It is required to integrate your power strip into your network first, maybe with the official app.\n+\n+## Thing Configuration\n+\n+You need to know the serial number. Usually you can find it on the back. The serial number will also be discovered. The IP address of the device is also necessary, this address should be set static. There's a fallback to broadcast status and switch requests. That may be unreliable if you have more than one smart plug in your network. They all react on UDP packets.\n+\n+## Channels\n+\n+| channel            | type   | description                               |\n+|--------------------|--------|-------------------------------------------|\n+| overallPlug#switch | Switch | Switch all plugs                          |\n+| plug1#switch       | Switch | Switch plug 1                             |\n+| plug1#watt         | Number | Contains currently used power of plug 1   |\n+| plug1#amp          | Number | Contains currently used current of plug 1 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYxNzY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMDo1NzozN1rOHcGyGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo0NjowMVrOHgJi6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzMwNQ==", "bodyText": "Did you insert the sapces by intention?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233305", "createdAt": "2020-10-04T10:57:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlBindingConstants.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link RevogiSmartStripControlBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlBindingConstants {\n+\n+    private static final String BINDING_ID = \"revogi    \";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3Mjg3Mw==", "bodyText": "oops, of course not ;)", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r503472873", "createdAt": "2020-10-12T18:46:01Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlBindingConstants.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link RevogiSmartStripControlBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlBindingConstants {\n+\n+    private static final String BINDING_ID = \"revogi    \";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzMwNQ=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYxOTYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowMDoyOFrOHcGzFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowMDoyOFrOHcGzFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzU1Nw==", "bodyText": "Logging to info should be used rarely. This could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233557", "createdAt": "2020-10-04T11:00:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyMDI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowMTo0NFrOHcGzdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTozNDoyMFrOHlN7aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzY1NA==", "bodyText": "Can you handle the REFRESH command?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233654", "createdAt": "2020-10-04T11:01:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MDIwOA==", "bodyText": "now it is handled, does it mean anything else?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508060208", "createdAt": "2020-10-19T21:02:22Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzY1NA=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc4NzU2MQ==", "bodyText": "Looks good.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508787561", "createdAt": "2020-10-20T19:34:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzY1NA=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyMjE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowNDozOVrOHcG0ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowNDozOVrOHcG0ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzg5Mg==", "bodyText": "Can this comment be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233892", "createdAt": "2020-10-04T11:04:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyMjkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowNTo0NlrOHcG0xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowNTo0NlrOHcG0xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMzk4OQ==", "bodyText": "You don't need to schedule another task if you use scheduleWithFixedDelay with an initial delay of 0 sec., as it is executed immediately.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499233989", "createdAt": "2020-10-04T11:05:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyMzgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowNzoxMVrOHcG1Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowNzoxMVrOHcG1Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNDEwNg==", "bodyText": "Since you already cancel the task in dispose(), this check is not needed. The framework takes care that disposed() is called when the Thing is disabled.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499234106", "createdAt": "2020-10-04T11:07:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyNDI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowODowMlrOHcG1fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowODowMlrOHcG1fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNDE3Mw==", "bodyText": "Is there a reason that you stored the lambda to a local variable and not using it directly here?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499234173", "createdAt": "2020-10-04T11:08:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyNDM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowODoyMVrOHcG1jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowODoyMVrOHcG1jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNDE4OQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499234189", "createdAt": "2020-10-04T11:08:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyNTQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowOTo0OFrOHcG2Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTowOTo0OFrOHcG2Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNDMyMw==", "bodyText": "Since config is Nullable, you need to store it to a local variable and check if it is null before using it. Same for below. Please check all compiler warnings.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499234323", "createdAt": "2020-10-04T11:09:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYyNTY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToxMDowOFrOHcG2MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToxMDowOFrOHcG2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNDM1Mg==", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null && !pollingJob.isCancelled()) {\n          \n          \n            \n                    if (pollingJob != null) {", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499234352", "createdAt": "2020-10-04T11:10:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzMjAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToxOToxOFrOHcG5hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToxOToxOFrOHcG5hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTIwNA==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235204", "createdAt": "2020-10-04T11:19:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponse;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponse;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n+@NonNullByDefault\n+public class RevogiSmartStripDiscoveryService extends AbstractDiscoveryService {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));\n+\n+    private final RevogiDiscoveryService revogiDiscoveryService;\n+\n+    private static final int SEARCH_TIME = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzMzMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyMToxMVrOHcG6IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyMToxMVrOHcG6IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTM2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .withRepresentationProperty(RevogiSmartStripControlBindingConstants.SERIAL_NUMBER).build();\n          \n          \n            \n                                    .withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER).build();", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235361", "createdAt": "2020-10-04T11:21:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponse;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponse;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n+@NonNullByDefault\n+public class RevogiSmartStripDiscoveryService extends AbstractDiscoveryService {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));\n+\n+    private final RevogiDiscoveryService revogiDiscoveryService;\n+\n+    private static final int SEARCH_TIME = 10;\n+\n+    public RevogiSmartStripDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, SEARCH_TIME);\n+        revogiDiscoveryService = new RevogiDiscoveryService(new UdpSenderService(new DatagramSocketWrapper()));\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        CompletableFuture<List<DiscoveryRawResponse>> discoveryResponses = revogiDiscoveryService.discoverSmartStrips();\n+        discoveryResponses.thenAccept(this::applyDiscoveryResults);\n+    }\n+\n+    private void applyDiscoveryResults(final List<DiscoveryRawResponse> discoveryRawResponses) {\n+        discoveryRawResponses.forEach(response -> {\n+            ThingUID thingUID = getThingUID(response.getData());\n+            if (thingUID != null) {\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(Thing.PROPERTY_MODEL_ID, response.getData().getRegId());\n+                properties.put(Thing.PROPERTY_MAC_ADDRESS, response.getData().getMacAddress());\n+                properties.put(Thing.PROPERTY_FIRMWARE_VERSION, response.getData().getVersion());\n+                properties.put(Thing.PROPERTY_SERIAL_NUMBER, response.getData().getSerialNumber());\n+                properties.put(\"ipAddress\", response.getIpAddress());\n+                DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID)\n+                        .withThingType(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE)\n+                        .withProperties(properties)\n+                        .withRepresentationProperty(RevogiSmartStripControlBindingConstants.SERIAL_NUMBER).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzNDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/DiscoveryRawResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyMzoxNFrOHcG6yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyMzoxNFrOHcG6yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTUyOA==", "bodyText": "You could move the DTOs into a package called dto to avoid warnings about the missing NonNullByDefault annotation.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235528", "createdAt": "2020-10-04T11:23:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/DiscoveryRawResponse.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.Objects;\n+\n+/**\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+public class DiscoveryRawResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzNTI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/RevogiDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNDoxMlrOHcG7Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNDoxMlrOHcG7Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTYxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CompletableFuture<List<UdpResponse>> responses = udpSenderService.broadcastUpdDatagram(UDP_DISCOVERY_QUERY);\n          \n          \n            \n                    CompletableFuture<List<UdpResponse>> responses = udpSenderService.broadcastUdpDatagram(UDP_DISCOVERY_QUERY);", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235615", "createdAt": "2020-10-04T11:24:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/RevogiDiscoveryService.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RevogiDiscoveryService} helps to discover smart strips within your network\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiDiscoveryService {\n+    private static final String UDP_DISCOVERY_QUERY = \"00sw=all,,,;\";\n+    private final Logger logger = LoggerFactory.getLogger(RevogiDiscoveryService.class);\n+\n+    private final Gson gson = new GsonBuilder().create();\n+    private final UdpSenderService udpSenderService;\n+\n+    public RevogiDiscoveryService(UdpSenderService udpSenderService) {\n+        this.udpSenderService = udpSenderService;\n+    }\n+\n+    public CompletableFuture<List<DiscoveryRawResponse>> discoverSmartStrips() {\n+        CompletableFuture<List<UdpResponse>> responses = udpSenderService.broadcastUpdDatagram(UDP_DISCOVERY_QUERY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzNTQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/RevogiDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNDozMFrOHcG7NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNDozMFrOHcG7NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTYzNg==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235636", "createdAt": "2020-10-04T11:24:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/RevogiDiscoveryService.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RevogiDiscoveryService} helps to discover smart strips within your network\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiDiscoveryService {\n+    private static final String UDP_DISCOVERY_QUERY = \"00sw=all,,,;\";\n+    private final Logger logger = LoggerFactory.getLogger(RevogiDiscoveryService.class);\n+\n+    private final Gson gson = new GsonBuilder().create();\n+    private final UdpSenderService udpSenderService;\n+\n+    public RevogiDiscoveryService(UdpSenderService udpSenderService) {\n+        this.udpSenderService = udpSenderService;\n+    }\n+\n+    public CompletableFuture<List<DiscoveryRawResponse>> discoverSmartStrips() {\n+        CompletableFuture<List<UdpResponse>> responses = udpSenderService.broadcastUpdDatagram(UDP_DISCOVERY_QUERY);\n+        return responses.thenApply(futureList -> {\n+            futureList.forEach(response -> logger.info(\"Received: {}\", response));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzNjc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/StatusService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNjozMFrOHcG72g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzoxMDozNlrOHkNh5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTgwMg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235802", "createdAt": "2020-10-04T11:26:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/StatusService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jetbrains.annotations.NotNull;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link StatusService} contains methods to get a status of a Revogi SmartStrip\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StatusService {\n+\n+    private static final String UDP_DISCOVERY_QUERY = \"V3{\\\"sn\\\":\\\"%s\\\", \\\"cmd\\\": 90}\";\n+    public static final String VERSION_STRING = \"V3\";\n+    private final Logger logger = LoggerFactory.getLogger(StatusService.class);\n+\n+    private final Gson gson = new GsonBuilder().create();\n+    private final UdpSenderService udpSenderService;\n+\n+    public StatusService(UdpSenderService udpSenderService) {\n+        this.udpSenderService = udpSenderService;\n+    }\n+\n+    public CompletableFuture<Status> queryStatus(String serialNumber, String ipAddress) {\n+        CompletableFuture<List<UdpResponse>> responses;\n+        if (ipAddress.trim().isEmpty()) {\n+            responses = udpSenderService.broadcastUpdDatagram(String.format(UDP_DISCOVERY_QUERY, serialNumber));\n+        } else {\n+            responses = udpSenderService.sendMessage(String.format(UDP_DISCOVERY_QUERY, serialNumber), ipAddress);\n+        }\n+        return responses.thenApply(this::getStatus);\n+    }\n+\n+    @NotNull\n+    private Status getStatus(final List<UdpResponse> singleResponse) {\n+        singleResponse.forEach(response -> logger.info(\"Received: {}\", response.getAnswer()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczMjQ1Mg==", "bodyText": "I know what you mean, but on github above and below doesn't seem to work as expected ;)", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r507732452", "createdAt": "2020-10-19T13:10:36Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/StatusService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jetbrains.annotations.NotNull;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link StatusService} contains methods to get a status of a Revogi SmartStrip\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StatusService {\n+\n+    private static final String UDP_DISCOVERY_QUERY = \"V3{\\\"sn\\\":\\\"%s\\\", \\\"cmd\\\": 90}\";\n+    public static final String VERSION_STRING = \"V3\";\n+    private final Logger logger = LoggerFactory.getLogger(StatusService.class);\n+\n+    private final Gson gson = new GsonBuilder().create();\n+    private final UdpSenderService udpSenderService;\n+\n+    public StatusService(UdpSenderService udpSenderService) {\n+        this.udpSenderService = udpSenderService;\n+    }\n+\n+    public CompletableFuture<Status> queryStatus(String serialNumber, String ipAddress) {\n+        CompletableFuture<List<UdpResponse>> responses;\n+        if (ipAddress.trim().isEmpty()) {\n+            responses = udpSenderService.broadcastUpdDatagram(String.format(UDP_DISCOVERY_QUERY, serialNumber));\n+        } else {\n+            responses = udpSenderService.sendMessage(String.format(UDP_DISCOVERY_QUERY, serialNumber), ipAddress);\n+        }\n+        return responses.thenApply(this::getStatus);\n+    }\n+\n+    @NotNull\n+    private Status getStatus(final List<UdpResponse> singleResponse) {\n+        singleResponse.forEach(response -> logger.info(\"Received: {}\", response.getAnswer()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTgwMg=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzNzU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNzozOVrOHcG8Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyNzozOVrOHcG8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTkxMA==", "bodyText": "As the unchecked exception is logged by the framework, the additional logging could be removed. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235910", "createdAt": "2020-10-04T11:27:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jetbrains.annotations.NotNull;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link SwitchService} enables the binding to actually switch plugs on and of\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SwitchService {\n+\n+    private static final String UDP_DISCOVERY_QUERY = \"V3{\\\"sn\\\":\\\"%s\\\", \\\"cmd\\\": 20, \\\"port\\\": %d, \\\"state\\\": %d}\";\n+    private static final String VERSION_STRING = \"V3\";\n+    private final Logger logger = LoggerFactory.getLogger(SwitchService.class);\n+\n+    private final Gson gson = new GsonBuilder().create();\n+    private final UdpSenderService udpSenderService;\n+\n+    public SwitchService(UdpSenderService udpSenderService) {\n+        this.udpSenderService = udpSenderService;\n+    }\n+\n+    public CompletableFuture<SwitchResponse> switchPort(String serialNumber, String ipAddress, int port, int state) {\n+        if (state < 0 || state > 1) {\n+            logger.warn(\"state value is not valid: {}\", state);\n+            throw new IllegalArgumentException(\"state has to be 0 or 1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzNzcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyODowNVrOHcG8WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyODowNVrOHcG8WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNTkyOQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499235929", "createdAt": "2020-10-04T11:28:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jetbrains.annotations.NotNull;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link SwitchService} enables the binding to actually switch plugs on and of\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SwitchService {\n+\n+    private static final String UDP_DISCOVERY_QUERY = \"V3{\\\"sn\\\":\\\"%s\\\", \\\"cmd\\\": 20, \\\"port\\\": %d, \\\"state\\\": %d}\";\n+    private static final String VERSION_STRING = \"V3\";\n+    private final Logger logger = LoggerFactory.getLogger(SwitchService.class);\n+\n+    private final Gson gson = new GsonBuilder().create();\n+    private final UdpSenderService udpSenderService;\n+\n+    public SwitchService(UdpSenderService udpSenderService) {\n+        this.udpSenderService = udpSenderService;\n+    }\n+\n+    public CompletableFuture<SwitchResponse> switchPort(String serialNumber, String ipAddress, int port, int state) {\n+        if (state < 0 || state > 1) {\n+            logger.warn(\"state value is not valid: {}\", state);\n+            throw new IllegalArgumentException(\"state has to be 0 or 1\");\n+        }\n+        if (port < 0) {\n+            logger.warn(\"port doesn't exist on device: {}\", port);\n+            throw new IllegalArgumentException(\"Given port doesn't exist\");\n+        }\n+\n+        CompletableFuture<List<UdpResponse>> responses;\n+        if (ipAddress.trim().isEmpty()) {\n+            responses = udpSenderService\n+                    .broadcastUpdDatagram(String.format(UDP_DISCOVERY_QUERY, serialNumber, port, state));\n+        } else {\n+            responses = udpSenderService.sendMessage(String.format(UDP_DISCOVERY_QUERY, serialNumber, port, state),\n+                    ipAddress);\n+        }\n+\n+        return responses.thenApply(this::getSwitchResponse);\n+    }\n+\n+    @NotNull\n+    private SwitchResponse getSwitchResponse(final List<UdpResponse> singleResponse) {\n+        singleResponse.forEach(response -> logger.info(\"Reveived {}\", response.getAnswer()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzODU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMToyOToyMlrOHcG8zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDozMTozN1rOHkRoWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjA0Nw==", "bodyText": "This class is very similar to StatusService. You could move the redundant code to a super class.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499236047", "createdAt": "2020-10-04T11:29:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jetbrains.annotations.NotNull;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link SwitchService} enables the binding to actually switch plugs on and of\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SwitchService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5OTY0Mg==", "bodyText": "I made a diff of these 2 classes, and in my opinion there are enough differences to leave it in 2 separate classes", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r507799642", "createdAt": "2020-10-19T14:31:37Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/api/SwitchService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.api;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jetbrains.annotations.NotNull;\n+import org.openhab.binding.revogi.internal.udp.UdpResponse;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link SwitchService} enables the binding to actually switch plugs on and of\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SwitchService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjA0Nw=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzOTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozMDoxMVrOHcG9FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzo0MDo0NVrOHkO5cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjExNg==", "bodyText": "You could append DTO to the class name to avoid the warnings about missing NonNullByDefault annotation.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499236116", "createdAt": "2020-10-04T11:30:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpResponse.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import java.util.Objects;\n+\n+/**\n+ * The class {@link UdpResponse} represents udp reponse we expect\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+public class UdpResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1NDg2Ng==", "bodyText": "thanks for that hint, I didn't know that", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r507754866", "createdAt": "2020-10-19T13:40:45Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpResponse.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import java.util.Objects;\n+\n+/**\n+ * The class {@link UdpResponse} represents udp reponse we expect\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+public class UdpResponse {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjExNg=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTYzOTc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozMTowMVrOHcG9YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozMTowMVrOHcG9YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjE5Mw==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499236193", "createdAt": "2020-10-04T11:31:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NDM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozNzo1M1rOHcG_sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozNzo1M1rOHcG_sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjc4Nw==", "bodyText": "Can you use the ScheduledExecutorService of the ThingHandler or the Thread of the DiscoveryService? I know this could result in quite extensive refactoring, but bindings should only create Threads if they really need to. E.g. listening on a socket permanently. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499236787", "createdAt": "2020-10-04T11:37:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NTAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozODo0OFrOHcHABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozODo0OFrOHcHABQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjg2OQ==", "bodyText": "It seems a bit unreasonable to log the stack trace when the network fails.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n          \n          \n            \n                        logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499236869", "createdAt": "2020-10-04T11:38:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NTI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozOToyMVrOHcHALg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozOToyMVrOHcHALg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjkxMA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499236910", "createdAt": "2020-10-04T11:39:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NjI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MDo0NVrOHcHArg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowMzo1OFrOHnWNDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzAzOA==", "bodyText": "When you change the threading to use the existing schedulers, better replace the sleep by scheduling another task to prevent blocking of the current task.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237038", "createdAt": "2020-10-04T11:40:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * TIMEOUT_BASE_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA0Mzg4Mw==", "bodyText": "I'm not sure what you mean what I should do. Somewhere I need to tell the software to wait a certain amount of time until it looks for udp responses again. I already refactored this part to not block the main thread.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508043883", "createdAt": "2020-10-19T20:31:22Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * TIMEOUT_BASE_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzAzOA=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc4NjYzNg==", "bodyText": "Your current implementation is blocking the current thread. You can avoid the blocking by using scheduler.scheduleWithFixedDelay(), which schedules the task after the specified time without blocking.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508786636", "createdAt": "2020-10-20T19:32:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * TIMEOUT_BASE_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzAzOA=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODI5OQ==", "bodyText": "This part is already called within a scheduled thread (see line 77 or 92). I did this, because it was already requested to not block the main thread. Should I really add another scheduled layer there? It feels like the movie Inception then.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r510408299", "createdAt": "2020-10-22T19:35:04Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * TIMEOUT_BASE_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzAzOA=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMDMwMw==", "bodyText": "I just saw, that the timeout is quite short. I don't see any problems if you keep it as is.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r511020303", "createdAt": "2020-10-23T17:03:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * TIMEOUT_BASE_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzAzOA=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NzE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MjoxNlrOHcHBJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MjoxNlrOHcHBJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzE1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n          \n          \n            \n                            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237156", "createdAt": "2020-10-04T11:42:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    public static final long TIMEOUT_BASE_VALUE = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> broadcastUpdDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+        Executors.newCachedThreadPool().submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponse>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponse>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponse>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            Executors.newCachedThreadPool().submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponse> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponse> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponse> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponse> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                logger.info(\"Socket receive time no. {}\", timeoutCounter);\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * TIMEOUT_BASE_VALUE);\n+                } catch (InterruptedException ex) {\n+                    logger.debug(\"Interrupted sleep\");\n+                    Thread.currentThread().interrupt();\n+                }\n+                continue;\n+            } catch (IOException e) {\n+                logger.warn(\"Error sending message or reading anwser {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NzMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MjozM1rOHcHBOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MjozM1rOHcHBOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzE3Ng==", "bodyText": "Could you be a bit more verbose, so that somebody who hasn't heard about it gets a clue what this is about?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237176", "createdAt": "2020-10-04T11:42:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"revogi\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Revogi Binding</name>\n+\t<description>This is the binding for Revogi devices.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0NzkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MzoyMFrOHcHBhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0MzoyMFrOHcHBhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzI1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>A Thi to control Revogi Smartstrip</description>\n          \n          \n            \n            \t\t<description>A Thing to control Revogi Smartstrip</description>", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237254", "createdAt": "2020-10-04T11:43:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thi to control Revogi Smartstrip</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0ODQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NDowMlrOHcHBwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NDowMlrOHcHBwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzMxMg==", "bodyText": "You might want to specify a reasonable min value to prevent negative numbers.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237312", "createdAt": "2020-10-04T11:44:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thi to control Revogi Smartstrip</description>\n+\t\t<category>PowerOutlet</category>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"overallPlug\" typeId=\"overallPlugActor\"/>\n+\t\t\t<channel-group id=\"plug1\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 1</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug2\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 2</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug3\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 3</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug4\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 4</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug5\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 5</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug6\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 6</label>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<representation-property>serialNumber</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialNumber\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Number</label>\n+\t\t\t\t<description>Serial number of your smart strip.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollInterval\" type=\"integer\" unit=\"s\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0ODkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NDozMVrOHcHB7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NDozMVrOHcHB7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzM1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>Switch a single plug and retrieve stats for it</description>\n          \n          \n            \n            \t\t<description>Switches a single plug and retrieve stats for it</description>", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237357", "createdAt": "2020-10-04T11:44:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thi to control Revogi Smartstrip</description>\n+\t\t<category>PowerOutlet</category>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"overallPlug\" typeId=\"overallPlugActor\"/>\n+\t\t\t<channel-group id=\"plug1\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 1</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug2\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 2</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug3\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 3</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug4\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 4</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug5\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 5</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug6\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 6</label>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<representation-property>serialNumber</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialNumber\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Number</label>\n+\t\t\t\t<description>Serial number of your smart strip.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollInterval\" type=\"integer\" unit=\"s\">\n+\t\t\t\t<label>Poll Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<description>How often (seconds) should the smart strip status be polled?</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your smart strip</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-group-type id=\"plugActor\">\n+\t\t<label>Single Plug Actor</label>\n+\t\t<description>Switch a single plug and retrieve stats for it</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0OTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NDo0MVrOHcHCDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NDo0MVrOHcHCDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzM4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Single Plug Actor</label>\n          \n          \n            \n            \t\t<label>Single Plug Actuator</label>", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237389", "createdAt": "2020-10-04T11:44:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thi to control Revogi Smartstrip</description>\n+\t\t<category>PowerOutlet</category>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"overallPlug\" typeId=\"overallPlugActor\"/>\n+\t\t\t<channel-group id=\"plug1\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 1</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug2\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 2</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug3\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 3</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug4\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 4</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug5\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 5</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug6\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 6</label>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<representation-property>serialNumber</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialNumber\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Number</label>\n+\t\t\t\t<description>Serial number of your smart strip.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollInterval\" type=\"integer\" unit=\"s\">\n+\t\t\t\t<label>Poll Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<description>How often (seconds) should the smart strip status be polled?</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your smart strip</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-group-type id=\"plugActor\">\n+\t\t<label>Single Plug Actor</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0OTY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NTozOVrOHcHCSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NTozOVrOHcHCSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzQ0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Watt</label>\n          \n          \n            \n            \t\t<label>Power</label>", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237449", "createdAt": "2020-10-04T11:45:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thi to control Revogi Smartstrip</description>\n+\t\t<category>PowerOutlet</category>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"overallPlug\" typeId=\"overallPlugActor\"/>\n+\t\t\t<channel-group id=\"plug1\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 1</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug2\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 2</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug3\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 3</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug4\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 4</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug5\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 5</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug6\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 6</label>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<representation-property>serialNumber</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialNumber\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Number</label>\n+\t\t\t\t<description>Serial number of your smart strip.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollInterval\" type=\"integer\" unit=\"s\">\n+\t\t\t\t<label>Poll Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<description>How often (seconds) should the smart strip status be polled?</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your smart strip</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-group-type id=\"plugActor\">\n+\t\t<label>Single Plug Actor</label>\n+\t\t<description>Switch a single plug and retrieve stats for it</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"switch\" typeId=\"single-plug\"/>\n+\t\t\t<channel id=\"watt\" typeId=\"watts\"/>\n+\t\t\t<channel id=\"amp\" typeId=\"amps\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"overallPlugActor\">\n+\t\t<label>Overall Plug Actor</label>\n+\t\t<description>Switch all plugs</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"switch\" typeId=\"single-plug\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"single-plug\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Switch</label>\n+\t\t<description>Switch a single plug</description>\n+\t</channel-type>\n+\t<channel-type id=\"watts\" advanced=\"true\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>Watt</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0OTg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NTo0NlrOHcHCYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0NTo0NlrOHcHCYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzQ3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Amp</label>\n          \n          \n            \n            \t\t<label>Current</label>", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237472", "createdAt": "2020-10-04T11:45:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thi to control Revogi Smartstrip</description>\n+\t\t<category>PowerOutlet</category>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"overallPlug\" typeId=\"overallPlugActor\"/>\n+\t\t\t<channel-group id=\"plug1\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 1</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug2\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 2</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug3\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 3</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug4\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 4</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug5\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 5</label>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"plug6\" typeId=\"plugActor\">\n+\t\t\t\t<label>Plug 6</label>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<representation-property>serialNumber</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialNumber\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Number</label>\n+\t\t\t\t<description>Serial number of your smart strip.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollInterval\" type=\"integer\" unit=\"s\">\n+\t\t\t\t<label>Poll Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<description>How often (seconds) should the smart strip status be polled?</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your smart strip</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-group-type id=\"plugActor\">\n+\t\t<label>Single Plug Actor</label>\n+\t\t<description>Switch a single plug and retrieve stats for it</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"switch\" typeId=\"single-plug\"/>\n+\t\t\t<channel id=\"watt\" typeId=\"watts\"/>\n+\t\t\t<channel id=\"amp\" typeId=\"amps\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"overallPlugActor\">\n+\t\t<label>Overall Plug Actor</label>\n+\t\t<description>Switch all plugs</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"switch\" typeId=\"single-plug\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"single-plug\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Switch</label>\n+\t\t<description>Switch a single plug</description>\n+\t</channel-type>\n+\t<channel-type id=\"watts\" advanced=\"true\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>Watt</label>\n+\t\t<description>Contains the current watt value for the given plug</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"amps\" advanced=\"true\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>Amp</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY1MTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTo0Nzo1MFrOHcHDJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxMDozMTo0MFrOHn4OdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzY2OQ==", "bodyText": "Is mW a reasonable default value? You might want to use Watts here, as you also specified one position after the decimal point in the XML.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r499237669", "createdAt": "2020-10-04T11:47:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+    }\n+\n+    private void updateStripInformation() {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        CompletableFuture<Status> futureStatus = statusService.queryStatus(config.getSerialNumber(),\n+                config.getIpAddress());\n+        futureStatus.thenAccept(this::updatePlugStatus);\n+    }\n+\n+    private void updatePlugStatus(Status status) {\n+        if (status.isOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            handleAllPlugsInformation(status);\n+            handleSinglePlugInformation(status);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE,\n+                    \"Retrieved status code: \" + status.getResponseCode());\n+        }\n+    }\n+\n+    private void handleSinglePlugInformation(Status status) {\n+        for (int i = 0; i < status.getSwitchValue().size(); i++) {\n+            int plugNumber = i + 1;\n+            updateState(\"plug\" + plugNumber + \"#switch\", OnOffType.from(status.getSwitchValue().get(i).toString()));\n+            updateState(\"plug\" + plugNumber + \"#watt\", new QuantityType<>(status.getWatt().get(i), MILLI(WATT)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MjI0MA==", "bodyText": "the raw value I receive from the device is milliwatt", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508062240", "createdAt": "2020-10-19T21:06:18Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+    }\n+\n+    private void updateStripInformation() {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        CompletableFuture<Status> futureStatus = statusService.queryStatus(config.getSerialNumber(),\n+                config.getIpAddress());\n+        futureStatus.thenAccept(this::updatePlugStatus);\n+    }\n+\n+    private void updatePlugStatus(Status status) {\n+        if (status.isOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            handleAllPlugsInformation(status);\n+            handleSinglePlugInformation(status);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE,\n+                    \"Retrieved status code: \" + status.getResponseCode());\n+        }\n+    }\n+\n+    private void handleSinglePlugInformation(Status status) {\n+        for (int i = 0; i < status.getSwitchValue().size(); i++) {\n+            int plugNumber = i + 1;\n+            updateState(\"plug\" + plugNumber + \"#switch\", OnOffType.from(status.getSwitchValue().get(i).toString()));\n+            updateState(\"plug\" + plugNumber + \"#watt\", new QuantityType<>(status.getWatt().get(i), MILLI(WATT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzY2OQ=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MTUzNg==", "bodyText": "the change was suggested by @Hilbrand on the old PR", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508071536", "createdAt": "2020-10-19T21:24:59Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+    }\n+\n+    private void updateStripInformation() {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        CompletableFuture<Status> futureStatus = statusService.queryStatus(config.getSerialNumber(),\n+                config.getIpAddress());\n+        futureStatus.thenAccept(this::updatePlugStatus);\n+    }\n+\n+    private void updatePlugStatus(Status status) {\n+        if (status.isOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            handleAllPlugsInformation(status);\n+            handleSinglePlugInformation(status);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE,\n+                    \"Retrieved status code: \" + status.getResponseCode());\n+        }\n+    }\n+\n+    private void handleSinglePlugInformation(Status status) {\n+        for (int i = 0; i < status.getSwitchValue().size(); i++) {\n+            int plugNumber = i + 1;\n+            updateState(\"plug\" + plugNumber + \"#switch\", OnOffType.from(status.getSwitchValue().get(i).toString()));\n+            updateState(\"plug\" + plugNumber + \"#watt\", new QuantityType<>(status.getWatt().get(i), MILLI(WATT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzY2OQ=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MDQ5Nw==", "bodyText": "You can do that. If I see correctly, the value is displayed in mW in the UI by default. So, I'd suggest to replace the %unit% in the XML file by W to achieve a reasonable default unit in the UI.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508790497", "createdAt": "2020-10-20T19:39:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+    }\n+\n+    private void updateStripInformation() {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        CompletableFuture<Status> futureStatus = statusService.queryStatus(config.getSerialNumber(),\n+                config.getIpAddress());\n+        futureStatus.thenAccept(this::updatePlugStatus);\n+    }\n+\n+    private void updatePlugStatus(Status status) {\n+        if (status.isOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            handleAllPlugsInformation(status);\n+            handleSinglePlugInformation(status);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE,\n+                    \"Retrieved status code: \" + status.getResponseCode());\n+        }\n+    }\n+\n+    private void handleSinglePlugInformation(Status status) {\n+        for (int i = 0; i < status.getSwitchValue().size(); i++) {\n+            int plugNumber = i + 1;\n+            updateState(\"plug\" + plugNumber + \"#switch\", OnOffType.from(status.getSwitchValue().get(i).toString()));\n+            updateState(\"plug\" + plugNumber + \"#watt\", new QuantityType<>(status.getWatt().get(i), MILLI(WATT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzY2OQ=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTQ3Ng==", "bodyText": "What's the source of the PDF in the doc folder?\nI got this document when I asked the revogi support on how to control this device if I don't want to use their AWS based app.\n\n\n\nAre you sure you may distribute this document? It's also uncommon to include a vendor documentation in the binding. Do you have the ability to store it somewhere else and reference it in the readme?\n\nI thought it was a good idea for tranparency reasons. But anyway, I can include it to my kotlin project and refernence the document here.\n(somehow this answer appears in a wrong thread now)", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508821476", "createdAt": "2020-10-20T20:34:18Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+    }\n+\n+    private void updateStripInformation() {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        CompletableFuture<Status> futureStatus = statusService.queryStatus(config.getSerialNumber(),\n+                config.getIpAddress());\n+        futureStatus.thenAccept(this::updatePlugStatus);\n+    }\n+\n+    private void updatePlugStatus(Status status) {\n+        if (status.isOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            handleAllPlugsInformation(status);\n+            handleSinglePlugInformation(status);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE,\n+                    \"Retrieved status code: \" + status.getResponseCode());\n+        }\n+    }\n+\n+    private void handleSinglePlugInformation(Status status) {\n+        for (int i = 0; i < status.getSwitchValue().size(); i++) {\n+            int plugNumber = i + 1;\n+            updateState(\"plug\" + plugNumber + \"#switch\", OnOffType.from(status.getSwitchValue().get(i).toString()));\n+            updateState(\"plug\" + plugNumber + \"#watt\", new QuantityType<>(status.getWatt().get(i), MILLI(WATT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzY2OQ=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3NzcxNg==", "bodyText": "units are done, too", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r511577716", "createdAt": "2020-10-25T10:31:40Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.Status;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing, StatusService statusService, SwitchService switchService) {\n+        super(thing);\n+        this.statusService = statusService;\n+        this.switchService = switchService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.info(\"Sometring went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(config.getSerialNumber(), config.ipAddress, port, state);\n+        }\n+    }\n+\n+    private int convertOnOffTypeToState(Command command) {\n+        if (command == OnOffType.ON) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RevogiSmartStripControlConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Example for background initialization:\n+        scheduler.execute(this::updateStripInformation);\n+        Runnable runnable = RevogiSmartStripControlHandler.this::updateStripInformation;\n+\n+        if (pollingJob == null || pollingJob.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(runnable, 0, config.getPollInterval(), TimeUnit.SECONDS);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+    }\n+\n+    private void updateStripInformation() {\n+        if (config == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        CompletableFuture<Status> futureStatus = statusService.queryStatus(config.getSerialNumber(),\n+                config.getIpAddress());\n+        futureStatus.thenAccept(this::updatePlugStatus);\n+    }\n+\n+    private void updatePlugStatus(Status status) {\n+        if (status.isOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            handleAllPlugsInformation(status);\n+            handleSinglePlugInformation(status);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE,\n+                    \"Retrieved status code: \" + status.getResponseCode());\n+        }\n+    }\n+\n+    private void handleSinglePlugInformation(Status status) {\n+        for (int i = 0; i < status.getSwitchValue().size(); i++) {\n+            int plugNumber = i + 1;\n+            updateState(\"plug\" + plugNumber + \"#switch\", OnOffType.from(status.getSwitchValue().get(i).toString()));\n+            updateState(\"plug\" + plugNumber + \"#watt\", new QuantityType<>(status.getWatt().get(i), MILLI(WATT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNzY2OQ=="}, "originalCommit": {"oid": "c8c25a6ee6174259f1e6fc02b9387ecb59006dab"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzE2MDY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo1MTowMVrOHlOfuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNzozN1rOHlPxIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5Njg1Nw==", "bodyText": "Please use the scheduler of the ThingHandler when invoked from there. When used in discovery, you can create your own thread pool. The name of the pool should be \"OH-binding-\".", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508796857", "createdAt": "2020-10-20T19:51:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNTY3Mg==", "bodyText": "So I need to pass through the scheduler instace of the ThingHandler to this service?\nI saw there's also a scheduler instance created by AbstractDiscoveryService. Maybe I should use that, in favour of creating a new scheduler for the discovery service?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508815672", "createdAt": "2020-10-20T20:24:55Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5Njg1Nw=="}, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNzY5Nw==", "bodyText": "Yes. Indeed, the scheduler of AbstractDiscoveryService should be preferred.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r508817697", "createdAt": "2020-10-20T20:27:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5Njg1Nw=="}, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODUwMjEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTozNzo0NlrOHla-Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1NzowMlrOHoiEIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTI2Mw==", "bodyText": "An interrupt usually means that the thread should exit, so you should terminate as quick as possible instead of continuing your timeout loop.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r509001263", "createdAt": "2020-10-21T05:37:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final long timeoutBaseValue;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n+        this.timeoutBaseValue = timeout;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> broadcastUdpDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+        scheduler.submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponseDTO>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            scheduler.submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponseDTO> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponseDTO> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponseDTO> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponseDTO> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * timeoutBaseValue);\n+                } catch (InterruptedException ex) {\n+                    logger.debug(\"Interrupted sleep\");\n+                    Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTU2MQ==", "bodyText": "In that case it's the sleep thread that would be interrupted. I see no reason to not continue the loop itself.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r510411561", "createdAt": "2020-10-22T19:41:07Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final long timeoutBaseValue;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n+        this.timeoutBaseValue = timeout;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> broadcastUdpDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+        scheduler.submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponseDTO>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            scheduler.submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponseDTO> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponseDTO> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponseDTO> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponseDTO> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * timeoutBaseValue);\n+                } catch (InterruptedException ex) {\n+                    logger.debug(\"Interrupted sleep\");\n+                    Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTI2Mw=="}, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwNjY1Mg==", "bodyText": "An interrupt is less a \"get back to work\" and more of a \"stop all work and go home\".", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r510506652", "createdAt": "2020-10-22T23:07:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final long timeoutBaseValue;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n+        this.timeoutBaseValue = timeout;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> broadcastUdpDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+        scheduler.submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponseDTO>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            scheduler.submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponseDTO> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponseDTO> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponseDTO> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponseDTO> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * timeoutBaseValue);\n+                } catch (InterruptedException ex) {\n+                    logger.debug(\"Interrupted sleep\");\n+                    Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTI2Mw=="}, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5NDAyMw==", "bodyText": "I agree with @cpmeister. A good approach to finish the thread is to simply throw the exception and handle it top level. Another option would be to return an empty list.\nThe thread is interrupted e.g. when the JVM is shutdown.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512194023", "createdAt": "2020-10-26T18:51:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final long timeoutBaseValue;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n+        this.timeoutBaseValue = timeout;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> broadcastUdpDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+        scheduler.submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponseDTO>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            scheduler.submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponseDTO> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponseDTO> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponseDTO> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponseDTO> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * timeoutBaseValue);\n+                } catch (InterruptedException ex) {\n+                    logger.debug(\"Interrupted sleep\");\n+                    Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTI2Mw=="}, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzIwMw==", "bodyText": "it's now implemented in a way it returns everything we have so far.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512263203", "createdAt": "2020-10-26T20:57:02Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n+    private static final int REVOGI_PORT = 8888;\n+\n+    private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n+    private final DatagramSocketWrapper datagramSocketWrapper;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final long timeoutBaseValue;\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+        this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n+        this.timeoutBaseValue = timeout;\n+        this.datagramSocketWrapper = datagramSocketWrapper;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> broadcastUdpDatagram(String content) {\n+        List<String> allBroadcastAddresses = NetUtil.getAllBroadcastAddresses();\n+        CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+        scheduler.submit(() -> future.complete(allBroadcastAddresses.stream().map(address -> {\n+            try {\n+                return sendMessage(content, InetAddress.getByName(address));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Could not find host with IP {}\", address);\n+                return new ArrayList<UdpResponseDTO>();\n+            }\n+        }).flatMap(Collection::stream).distinct().collect(toList())));\n+        return future;\n+    }\n+\n+    public CompletableFuture<List<UdpResponseDTO>> sendMessage(String content, String ipAddress) {\n+        try {\n+            CompletableFuture<List<UdpResponseDTO>> future = new CompletableFuture<>();\n+            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n+            scheduler.submit(() -> future.complete(sendMessage(content, inetAddress)));\n+            return future;\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Could not find host with IP {}\", ipAddress);\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+    }\n+\n+    private List<UdpResponseDTO> sendMessage(String content, InetAddress inetAddress) {\n+        logger.debug(\"Using address {}\", inetAddress);\n+        byte[] buf = content.getBytes(Charset.defaultCharset());\n+        DatagramPacket packet = new DatagramPacket(buf, buf.length, inetAddress, REVOGI_PORT);\n+        List<UdpResponseDTO> responses = Collections.emptyList();\n+        try {\n+            datagramSocketWrapper.initSocket();\n+            datagramSocketWrapper.sendPacket(packet);\n+            responses = getUdpResponses();\n+        } catch (IOException e) {\n+            logger.warn(\"Error sending message or reading anwser {}\", e.getMessage());\n+        } finally {\n+            datagramSocketWrapper.closeSocket();\n+        }\n+        return responses;\n+    }\n+\n+    private List<UdpResponseDTO> getUdpResponses() {\n+        int timeoutCounter = 0;\n+        List<UdpResponseDTO> list = new ArrayList<>();\n+        while (timeoutCounter < MAX_TIMEOUT_COUNT) {\n+            byte[] receivedBuf = new byte[512];\n+            DatagramPacket answer = new DatagramPacket(receivedBuf, receivedBuf.length);\n+            try {\n+                datagramSocketWrapper.receiveAnswer(answer);\n+            } catch (SocketTimeoutException | SocketException e) {\n+                timeoutCounter++;\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(timeoutCounter * timeoutBaseValue);\n+                } catch (InterruptedException ex) {\n+                    logger.debug(\"Interrupted sleep\");\n+                    Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTI2Mw=="}, "originalCommit": {"oid": "3fb3721b0206c54bc46d0badc2ed382972ca6d32"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzkwMDY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMzowOToyNFrOHm24ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNjoxMjowNlrOHm_xgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwNzEwOQ==", "bodyText": "Is this constructor used anymore?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r510507109", "createdAt": "2020-10-22T23:09:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -56,17 +56,19 @@\n \n     private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n     private final DatagramSocketWrapper datagramSocketWrapper;\n-    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final ScheduledExecutorService scheduler;\n     private final long timeoutBaseValue;\n \n-    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, ScheduledExecutorService scheduler) {\n         this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n         this.datagramSocketWrapper = datagramSocketWrapper;\n+        this.scheduler = scheduler;\n     }\n \n     public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n         this.timeoutBaseValue = timeout;\n         this.datagramSocketWrapper = datagramSocketWrapper;\n+        this.scheduler = ThreadPoolManager.getScheduledPool(\"test pool\");\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef360d241abe9a328ec35357670c24aaf38f8b69"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY1MjgwMA==", "bodyText": "yes, for testing", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r510652800", "createdAt": "2020-10-23T06:12:06Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -56,17 +56,19 @@\n \n     private final Logger logger = LoggerFactory.getLogger(UdpSenderService.class);\n     private final DatagramSocketWrapper datagramSocketWrapper;\n-    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"thingHandler\");\n+    private final ScheduledExecutorService scheduler;\n     private final long timeoutBaseValue;\n \n-    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper) {\n+    public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, ScheduledExecutorService scheduler) {\n         this.timeoutBaseValue = TIMEOUT_BASE_VALUE_SEC;\n         this.datagramSocketWrapper = datagramSocketWrapper;\n+        this.scheduler = scheduler;\n     }\n \n     public UdpSenderService(DatagramSocketWrapper datagramSocketWrapper, long timeout) {\n         this.timeoutBaseValue = timeout;\n         this.datagramSocketWrapper = datagramSocketWrapper;\n+        this.scheduler = ThreadPoolManager.getScheduledPool(\"test pool\");\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwNzEwOQ=="}, "originalCommit": {"oid": "ef360d241abe9a328ec35357670c24aaf38f8b69"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE4MjMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowNDoyNVrOHnWN3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowNDoyNVrOHnWN3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMDUxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final long TIMEOUT_BASE_VALUE_SEC = 800L;\n          \n          \n            \n                private static final long TIMEOUT_BASE_VALUE_MS = 800L;", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r511020511", "createdAt": "2020-10-23T17:04:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/UdpSenderService.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.net.NetUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UdpSenderService} is responsible for sending and receiving udp packets\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UdpSenderService {\n+\n+    /**\n+     * Limit timeout waiting time, as we have to deal with UDP\n+     *\n+     * How it works: for every loop, we'll wait a bit longer, so the timeout counter is multiplied with the timeout base\n+     * value. Let max timeout count be 2 and timeout base value 800, then we'll have a maximum of loops of 3, waiting\n+     * 800ms in the 1st loop, 1600ms in the 2nd loop and 2400ms in the third loop.\n+     */\n+    private static final int MAX_TIMEOUT_COUNT = 2;\n+    private static final long TIMEOUT_BASE_VALUE_SEC = 800L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "117ad55953ce53dc6a88ca9ca1f000bb4a0267d9"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTAyMTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODozNTo1M1rOHodPmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0Mjo1MlrOHohl7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4NDIxOQ==", "bodyText": "Please add the NonNullByDefault annotation. You could initialize the fields with default values to avoid the null checks.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512184219", "createdAt": "2020-10-26T18:35:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlConfiguration.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+/**\n+ * The {@link RevogiSmartStripControlConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+public class RevogiSmartStripControlConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTQ2OA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512255468", "createdAt": "2020-10-26T20:42:52Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlConfiguration.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+/**\n+ * The {@link RevogiSmartStripControlConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+public class RevogiSmartStripControlConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4NDIxOQ=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTAzNzU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODozOTo1NlrOHodZvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0MzowMVrOHohmNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4NjgxNQ==", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512186815", "createdAt": "2020-10-26T18:39:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.StatusDTO;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing) {\n+        super(thing);\n+        UdpSenderService udpSenderService = new UdpSenderService(new DatagramSocketWrapper(), scheduler);\n+        this.statusService = new StatusService(udpSenderService);\n+        this.switchService = new SwitchService(udpSenderService);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.debug(\"Something went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTU0MQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512255541", "createdAt": "2020-10-26T20:43:01Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.StatusDTO;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing) {\n+        super(thing);\n+        UdpSenderService udpSenderService = new UdpSenderService(new DatagramSocketWrapper(), scheduler);\n+        this.statusService = new StatusService(udpSenderService);\n+        this.switchService = new SwitchService(udpSenderService);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.debug(\"Something went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4NjgxNQ=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTA0NTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0MTozOFrOHodePA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNjowN1rOHohXWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4Nzk2NA==", "bodyText": "Would be good to make the access to the config parameters consistent. You could remove the getter and access the fields directly.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512187964", "createdAt": "2020-10-26T18:41:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.StatusDTO;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing) {\n+        super(thing);\n+        UdpSenderService udpSenderService = new UdpSenderService(new DatagramSocketWrapper(), scheduler);\n+        this.statusService = new StatusService(udpSenderService);\n+        this.switchService = new SwitchService(udpSenderService);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.debug(\"Something went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        @Nullable\n+        RevogiSmartStripControlConfiguration localConfig = this.config;\n+        if (localConfig == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(localConfig.getSerialNumber(), localConfig.ipAddress, port, state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1MDYxMA==", "bodyText": "hm, in my code the usage is consistent. Everywhere else the properties are accressed directly?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512250610", "createdAt": "2020-10-26T20:34:13Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.StatusDTO;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing) {\n+        super(thing);\n+        UdpSenderService udpSenderService = new UdpSenderService(new DatagramSocketWrapper(), scheduler);\n+        this.statusService = new StatusService(udpSenderService);\n+        this.switchService = new SwitchService(udpSenderService);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.debug(\"Something went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        @Nullable\n+        RevogiSmartStripControlConfiguration localConfig = this.config;\n+        if (localConfig == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(localConfig.getSerialNumber(), localConfig.ipAddress, port, state);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4Nzk2NA=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1MTczOA==", "bodyText": "In the first argument of switchPort() a getter is used and in the second argument, the field is accessed directly.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512251738", "createdAt": "2020-10-26T20:36:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import static org.openhab.core.library.unit.MetricPrefix.MILLI;\n+import static org.openhab.core.library.unit.SmartHomeUnits.AMPERE;\n+import static org.openhab.core.library.unit.SmartHomeUnits.WATT;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.StatusDTO;\n+import org.openhab.binding.revogi.internal.api.StatusService;\n+import org.openhab.binding.revogi.internal.api.SwitchService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RevogiSmartStripControlHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RevogiSmartStripControlHandler.class);\n+    private final StatusService statusService;\n+    private final SwitchService switchService;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable RevogiSmartStripControlConfiguration config;\n+\n+    public RevogiSmartStripControlHandler(Thing thing) {\n+        super(thing);\n+        UdpSenderService udpSenderService = new UdpSenderService(new DatagramSocketWrapper(), scheduler);\n+        this.statusService = new StatusService(udpSenderService);\n+        this.switchService = new SwitchService(udpSenderService);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case RevogiSmartStripControlBindingConstants.PLUG_1_SWITCH:\n+                switchPlug(command, 1);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_2_SWITCH:\n+                switchPlug(command, 2);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_3_SWITCH:\n+                switchPlug(command, 3);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_4_SWITCH:\n+                switchPlug(command, 4);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_5_SWITCH:\n+                switchPlug(command, 5);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.PLUG_6_SWITCH:\n+                switchPlug(command, 6);\n+                break;\n+            case RevogiSmartStripControlBindingConstants.ALL_PLUGS:\n+                switchPlug(command, 0);\n+                break;\n+            default:\n+                logger.debug(\"Something went wrong, we've got a message for {}\", channelUID.getId());\n+        }\n+    }\n+\n+    private void switchPlug(Command command, int port) {\n+        @Nullable\n+        RevogiSmartStripControlConfiguration localConfig = this.config;\n+        if (localConfig == null) {\n+            logger.warn(\"No config available, config object was null\");\n+            return;\n+        }\n+        if (command instanceof OnOffType) {\n+            int state = convertOnOffTypeToState(command);\n+            switchService.switchPort(localConfig.getSerialNumber(), localConfig.ipAddress, port, state);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4Nzk2NA=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTA4NDk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo1MjoyNFrOHod27g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0MzoxMFrOHohmfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5NDI4Ng==", "bodyText": "Remove the trailing line feed.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpower strips and sensors.\n          \n          \n            \n            \t</description>\n          \n          \n            \n            \t\tpower strips and sensors.</description>", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512194286", "createdAt": "2020-10-26T18:52:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"revogi\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Revogi Binding</name>\n+\t<description>This is the binding for Revogi devices. Revogi is a vendor of several smart home devices like light bulbs,\n+\t\tpower strips and sensors.\n+\t</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTYxMg==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512255612", "createdAt": "2020-10-26T20:43:10Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"revogi\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Revogi Binding</name>\n+\t<description>This is the binding for Revogi devices. Revogi is a vendor of several smart home devices like light bulbs,\n+\t\tpower strips and sensors.\n+\t</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5NDI4Ng=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTA4OTM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo1Mzo0M1rOHod5wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo0MzoxOVrOHohmyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5NTAwOA==", "bodyText": "Is it Smartstrip or SmartStrip?", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512195008", "createdAt": "2020-10-26T18:53:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thing to control Revogi Smartstrip</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTY4OA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512255688", "createdAt": "2020-10-26T20:43:19Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,91 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"revogi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- SmartStrip Thing Type -->\n+\t<thing-type id=\"smartstrip\">\n+\t\t<label>SmartStrip</label>\n+\t\t<description>A Thing to control Revogi Smartstrip</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5NTAwOA=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTEwMTg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/DatagramSocketWrapper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo1Njo1NlrOHoeBaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNjo0ODoyOFrOHotdOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5Njk2OA==", "bodyText": "datagramSocket needs to be stored to a local variable to fix the compiler warning. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512196968", "createdAt": "2020-10-26T18:56:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/DatagramSocketWrapper.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.SocketException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link DatagramSocketWrapper} wraps Java's DatagramSocket for better testing\n+ * UdpSenderService\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DatagramSocketWrapper {\n+\n+    @Nullable\n+    private DatagramSocket datagramSocket;\n+\n+    public void initSocket() throws SocketException {\n+        closeSocket();\n+        datagramSocket = new DatagramSocket();\n+        datagramSocket.setBroadcast(true);\n+        datagramSocket.setSoTimeout(3);\n+    }\n+\n+    public void closeSocket() {\n+        if (datagramSocket != null && !datagramSocket.isClosed()) {\n+            datagramSocket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5MDI3NA==", "bodyText": "done, even if I don't understand why that's a problem for the compiler. I still need to male a null check for the local variable. So in my opinion it's just more boilerplate code to write.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512290274", "createdAt": "2020-10-26T21:49:58Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/DatagramSocketWrapper.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.SocketException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link DatagramSocketWrapper} wraps Java's DatagramSocket for better testing\n+ * UdpSenderService\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DatagramSocketWrapper {\n+\n+    @Nullable\n+    private DatagramSocket datagramSocket;\n+\n+    public void initSocket() throws SocketException {\n+        closeSocket();\n+        datagramSocket = new DatagramSocket();\n+        datagramSocket.setBroadcast(true);\n+        datagramSocket.setSoTimeout(3);\n+    }\n+\n+    public void closeSocket() {\n+        if (datagramSocket != null && !datagramSocket.isClosed()) {\n+            datagramSocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5Njk2OA=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ0OTg1MA==", "bodyText": "The compiler complains because datagramSocket is a field and could theoretically be modified by another thread exactly between the null check and the access in the next line.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r512449850", "createdAt": "2020-10-27T06:48:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/udp/DatagramSocketWrapper.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal.udp;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.SocketException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link DatagramSocketWrapper} wraps Java's DatagramSocket for better testing\n+ * UdpSenderService\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DatagramSocketWrapper {\n+\n+    @Nullable\n+    private DatagramSocket datagramSocket;\n+\n+    public void initSocket() throws SocketException {\n+        closeSocket();\n+        datagramSocket = new DatagramSocket();\n+        datagramSocket.setBroadcast(true);\n+        datagramSocket.setSoTimeout(3);\n+    }\n+\n+    public void closeSocket() {\n+        if (datagramSocket != null && !datagramSocket.isClosed()) {\n+            datagramSocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5Njk2OA=="}, "originalCommit": {"oid": "f2eaafb547231d250bade8a83ad62c8fca3dddbc"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU4MjgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MDo1MlrOHsg0nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MDo1MlrOHsg0nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzE0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.revogi\")", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516437148", "createdAt": "2020-11-03T05:40:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponseDTO;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponseDTO;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU4NDQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MjowNFrOHsg1fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MjowNFrOHsg1fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzM3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(configurationPid = \"binding.revogismartstripcontrol\", service = ThingHandlerFactory.class)\n          \n          \n            \n            @Component(configurationPid = \"binding.revogi\", service = ThingHandlerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516437374", "createdAt": "2020-11-03T05:42:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripControlHandlerFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripControlHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.revogismartstripcontrol\", service = ThingHandlerFactory.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU4NDk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MjoyN1rOHsg1xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDo0Mjo1NlrOHspGOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzQ0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n          \n          \n            \n                        Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE);", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516437445", "createdAt": "2020-11-03T05:42:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponseDTO;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponseDTO;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n+@NonNullByDefault\n+public class RevogiSmartStripDiscoveryService extends AbstractDiscoveryService {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MDgyNg==", "bodyText": "that one is done by mvn spotless:apply. The build would fail if I do this change.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516560826", "createdAt": "2020-11-03T10:23:16Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponseDTO;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponseDTO;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n+@NonNullByDefault\n+public class RevogiSmartStripDiscoveryService extends AbstractDiscoveryService {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzQ0NQ=="}, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2Mzc5MA==", "bodyText": "The suggested change is to remove \"new HashSet<>(\".", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516563790", "createdAt": "2020-11-03T10:28:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponseDTO;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponseDTO;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n+@NonNullByDefault\n+public class RevogiSmartStripDiscoveryService extends AbstractDiscoveryService {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzQ0NQ=="}, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3MjcyOA==", "bodyText": "ah, I see", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516572728", "createdAt": "2020-11-03T10:42:56Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/src/main/java/org/openhab/binding/revogi/internal/RevogiSmartStripDiscoveryService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.revogi.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.revogi.internal.api.DiscoveryRawResponseDTO;\n+import org.openhab.binding.revogi.internal.api.DiscoveryResponseDTO;\n+import org.openhab.binding.revogi.internal.api.RevogiDiscoveryService;\n+import org.openhab.binding.revogi.internal.udp.DatagramSocketWrapper;\n+import org.openhab.binding.revogi.internal.udp.UdpSenderService;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link RevogiSmartStripDiscoveryService} helps to discover new smart strips\n+ *\n+ * @author Andi Br\u00e4u - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.revogismartstripcontrol\")\n+@NonNullByDefault\n+public class RevogiSmartStripDiscoveryService extends AbstractDiscoveryService {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Collections.singleton(RevogiSmartStripControlBindingConstants.SMART_STRIP_THING_TYPE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzQ0NQ=="}, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU5NDMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.revogi/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0OTowMVrOHsg7JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDoyNzoyOFrOHsohnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzODgyMA==", "bodyText": "Please put each sentence on a new line, it makes it easier to track changes and won't change how it is rendered.\nPlease change elsewhere as appropriate.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516438820", "createdAt": "2020-11-03T05:49:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.revogi/README.md", "diffHunk": "@@ -0,0 +1,68 @@\n+# Revogi Binding\n+\n+This binding is written to control Revogi devices. The first thing implemented is the [Revogi Smart Power Strip](https://www.revogi.com/smart-power/smart-power-strip-eu/#section6). The device has 6 power plugs that can be switched independently, or all together. It also provides information like power consumption and electric current for each plug.\n+\n+It was hard to find out how to control it without internet access, but there's a way to use UDP packets. See the following [support document](https://github.com/andibraeu/revogismartstripcontrol/blob/master/doc/LAN%20UDP%20Control.pdf) for details. This was the only document the Revogi support provided.\n+\n+## Supported Things\n+\n+Currently only the model `SOW019` is supported.\n+\n+## Discovery\n+\n+If your smart strip is within your network (broadcast domain), discovery can work. The discovery service will send udp packets to the broadcast address and waits for a feedback.\n+\n+It is required to integrate your power strip into your network first, maybe with the official app.\n+\n+## Thing Configuration\n+\n+You need to know the serial number. Usually you can find it on the back. The serial number will also be discovered. The IP address of the device is also necessary, this address should be set static. There's a fallback to broadcast status and switch requests. That may be unreliable if you have more than one smart plug in your network. They all react on UDP packets.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MzM1Ng==", "bodyText": "that's a strange rule, and it's nowhere written down. Every modern diff tool will show what really changed.", "url": "https://github.com/openhab/openhab-addons/pull/8534#discussion_r516563356", "createdAt": "2020-11-03T10:27:28Z", "author": {"login": "andibraeu"}, "path": "bundles/org.openhab.binding.revogi/README.md", "diffHunk": "@@ -0,0 +1,68 @@\n+# Revogi Binding\n+\n+This binding is written to control Revogi devices. The first thing implemented is the [Revogi Smart Power Strip](https://www.revogi.com/smart-power/smart-power-strip-eu/#section6). The device has 6 power plugs that can be switched independently, or all together. It also provides information like power consumption and electric current for each plug.\n+\n+It was hard to find out how to control it without internet access, but there's a way to use UDP packets. See the following [support document](https://github.com/andibraeu/revogismartstripcontrol/blob/master/doc/LAN%20UDP%20Control.pdf) for details. This was the only document the Revogi support provided.\n+\n+## Supported Things\n+\n+Currently only the model `SOW019` is supported.\n+\n+## Discovery\n+\n+If your smart strip is within your network (broadcast domain), discovery can work. The discovery service will send udp packets to the broadcast address and waits for a feedback.\n+\n+It is required to integrate your power strip into your network first, maybe with the official app.\n+\n+## Thing Configuration\n+\n+You need to know the serial number. Usually you can find it on the back. The serial number will also be discovered. The IP address of the device is also necessary, this address should be set static. There's a fallback to broadcast status and switch requests. That may be unreliable if you have more than one smart plug in your network. They all react on UDP packets.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzODgyMA=="}, "originalCommit": {"oid": "a0bd98b66c585b5bd67bc4589358a9f4279561a8"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4326, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}