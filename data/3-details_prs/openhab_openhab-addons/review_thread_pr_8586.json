{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNjExNjM1", "number": 8586, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMToyMlrOE8gshA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMzo1N1rOE9YBDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODg1NzAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverAPIConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMToyMlrOH4rMjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMToyMlrOH4rMjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDAyOA==", "bodyText": "Only call getCause() on the ExecutionException. The other exceptions don't have a cause.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529190028", "createdAt": "2020-11-24T04:11:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverAPIConnection.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link PushoverAPIConnection} is responsible for handling the connections to Pushover Messages API.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAPIConnection {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverAPIConnection.class);\n+\n+    private static final String VALIDATE_URL = \"https://api.pushover.net/1/users/validate.json\";\n+    private static final String MESSAGE_URL = \"https://api.pushover.net/1/messages.json\";\n+    private static final String CANCEL_MESSAGE_URL = \"https://api.pushover.net/1/receipts/{receipt}/cancel.json\";\n+    private static final String SOUNDS_URL = \"https://api.pushover.net/1/sounds.json\";\n+\n+    private final HttpClient httpClient;\n+    private final PushoverAccountConfiguration config;\n+\n+    private final ExpiringCacheMap<String, String> cache = new ExpiringCacheMap<>(TimeUnit.DAYS.toMillis(1));\n+\n+    private final JsonParser parser = new JsonParser();\n+\n+    public PushoverAPIConnection(HttpClient httpClient, PushoverAccountConfiguration config) {\n+        this.httpClient = httpClient;\n+        this.config = config;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean validateUser() throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(\n+                post(VALIDATE_URL, PushoverMessageBuilder.getInstance(config.apikey, config.user).build()));\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean sendMessage(PushoverMessageBuilder message)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(post(MESSAGE_URL, message.build()));\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public String sendPriorityMessage(PushoverMessageBuilder message)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        final JsonObject json = parser.parse(post(MESSAGE_URL, message.build())).getAsJsonObject();\n+        return getMessageStatus(json) && json.has(\"receipt\") ? json.get(\"receipt\").getAsString() : \"\";\n+    }\n+\n+    /**\n+     *\n+     * @param receipt\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean cancelPriorityMessage(String receipt)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(post(CANCEL_MESSAGE_URL.replace(\"{receipt}\", receipt),\n+                PushoverMessageBuilder.getInstance(config.apikey, config.user).build()));\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public List<Sound> getSounds() throws PushoverCommunicationException, PushoverConfigurationException {\n+        final String localApikey = config.apikey;\n+        if (localApikey == null || localApikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        final Map<String, String> params = new HashMap<>(1);\n+        params.put(PushoverMessageBuilder.MESSAGE_KEY_TOKEN, localApikey);\n+\n+        // TODO do not cache the response, cache the parsed list of sounds\n+        final JsonObject json = parser.parse(getFromCache(buildURL(SOUNDS_URL, params))).getAsJsonObject();\n+        if (json.has(\"sounds\")) {\n+            final JsonObject sounds = json.get(\"sounds\").getAsJsonObject();\n+            if (sounds != null) {\n+                return Collections.unmodifiableList(sounds.entrySet().stream()\n+                        .map(entry -> new Sound(entry.getKey(), entry.getValue().getAsString()))\n+                        .collect(Collectors.toList()));\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    private String buildURL(String url, Map<String, String> requestParams) {\n+        return requestParams.keySet().stream().map(key -> key + \"=\" + encodeParam(requestParams.get(key)))\n+                .collect(Collectors.joining(\"&\", url + \"?\", \"\"));\n+    }\n+\n+    private String encodeParam(@Nullable String value) {\n+        return value == null ? \"\" : URLEncoder.encode(value, StandardCharsets.UTF_8);\n+    }\n+\n+    private @Nullable String getFromCache(String url) {\n+        return cache.putIfAbsentAndGet(url, () -> get(url));\n+    }\n+\n+    private String get(String url) throws PushoverCommunicationException, PushoverConfigurationException {\n+        return executeRequest(HttpMethod.GET, url, null);\n+    }\n+\n+    private String post(String url, ContentProvider body)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        return executeRequest(HttpMethod.POST, url, body);\n+    }\n+\n+    private String executeRequest(HttpMethod httpMethod, String url, @Nullable ContentProvider body)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        logger.trace(\"Pushover request: {} - URL = '{}'\", httpMethod, url);\n+        try {\n+            final Request request = httpClient.newRequest(url).method(httpMethod).timeout(10, TimeUnit.SECONDS);\n+\n+            if (body != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"Pushover request body: '{}'\", body);\n+                }\n+                request.content(body);\n+            }\n+\n+            final ContentResponse contentResponse = request.send();\n+\n+            final int httpStatus = contentResponse.getStatus();\n+            final String content = contentResponse.getContentAsString();\n+            logger.trace(\"Pushover response: status = {}, content = '{}'\", httpStatus, content);\n+            switch (httpStatus) {\n+                case HttpStatus.OK_200:\n+                    return content;\n+                case HttpStatus.BAD_REQUEST_400:\n+                    logger.debug(\"Pushover server responded with status code {}: {}\", httpStatus, content);\n+                    throw new PushoverConfigurationException(getMessageError(content));\n+                default:\n+                    logger.debug(\"Pushover server responded with status code {}: {}\", httpStatus, content);\n+                    throw new PushoverCommunicationException(content);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+            logger.debug(\"Exception occurred during execution: {}\", e.getLocalizedMessage(), e);\n+            throw new PushoverCommunicationException(e.getLocalizedMessage(), e.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODg1OTU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverAPIConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMjo1N1rOH4rOFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMjo1N1rOH4rOFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDQyMA==", "bodyText": "If you aren't going to fill out the javadocs, then feel free to remove them.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529190420", "createdAt": "2020-11-24T04:12:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverAPIConnection.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link PushoverAPIConnection} is responsible for handling the connections to Pushover Messages API.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAPIConnection {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverAPIConnection.class);\n+\n+    private static final String VALIDATE_URL = \"https://api.pushover.net/1/users/validate.json\";\n+    private static final String MESSAGE_URL = \"https://api.pushover.net/1/messages.json\";\n+    private static final String CANCEL_MESSAGE_URL = \"https://api.pushover.net/1/receipts/{receipt}/cancel.json\";\n+    private static final String SOUNDS_URL = \"https://api.pushover.net/1/sounds.json\";\n+\n+    private final HttpClient httpClient;\n+    private final PushoverAccountConfiguration config;\n+\n+    private final ExpiringCacheMap<String, String> cache = new ExpiringCacheMap<>(TimeUnit.DAYS.toMillis(1));\n+\n+    private final JsonParser parser = new JsonParser();\n+\n+    public PushoverAPIConnection(HttpClient httpClient, PushoverAccountConfiguration config) {\n+        this.httpClient = httpClient;\n+        this.config = config;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean validateUser() throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(\n+                post(VALIDATE_URL, PushoverMessageBuilder.getInstance(config.apikey, config.user).build()));\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODk5MTkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNToyMzo1N1rOH4scew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0NToxN1rOH5H2qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMDQ5MQ==", "bodyText": "Can this TODO be done?", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529210491", "createdAt": "2020-11-24T05:23:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.util.MultiPartContentProvider;\n+import org.eclipse.jetty.client.util.PathContentProvider;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PushoverMessageBuilder} builds the body for Pushover Messages API requests.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverMessageBuilder {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverMessageBuilder.class);\n+\n+    public static final String MESSAGE_KEY_TOKEN = \"token\";\n+    private static final String MESSAGE_KEY_USER = \"user\";\n+    private static final String MESSAGE_KEY_MESSAGE = \"message\";\n+    private static final String MESSAGE_KEY_TITLE = \"title\";\n+    private static final String MESSAGE_KEY_DEVICE = \"device\";\n+    private static final String MESSAGE_KEY_PRIORITY = \"priority\";\n+    private static final String MESSAGE_KEY_RETRY = \"retry\";\n+    private static final String MESSAGE_KEY_EXPIRE = \"expire\";\n+    private static final String MESSAGE_KEY_URL = \"url\";\n+    private static final String MESSAGE_KEY_URL_TITLE = \"url_title\";\n+    private static final String MESSAGE_KEY_SOUND = \"sound\";\n+    private static final String MESSAGE_KEY_ATTACHMENT = \"attachment\";\n+    public static final String MESSAGE_KEY_HTML = \"html\";\n+    public static final String MESSAGE_KEY_MONOSPACE = \"monospace\";\n+\n+    private static final int MAX_MESSAGE_LENGTH = 1024;\n+    private static final int MAX_TITLE_LENGTH = 250;\n+    private static final int MAX_DEVICE_LENGTH = 25;\n+    private static final List<Integer> VALID_PRIORITY_LIST = Arrays.asList(-2, -1, 0, 1, 2);\n+    private static final int DEFAULT_PRIORITY = 0;\n+    public static final int EMERGENCY_PRIORITY = 2;\n+    private static final int MIN_RETRY_SECONDS = 30;\n+    private static final int MAX_EXPIRE_SECONDS = 10800;\n+    private static final int MAX_URL_LENGTH = 512;\n+    private static final int MAX_URL_TITLE_LENGTH = 100;\n+    public static final String DEFAULT_CONTENT_TYPE = \"image/jpeg\";\n+\n+    private final MultiPartContentProvider body = new MultiPartContentProvider();\n+\n+    private @Nullable String message;\n+    private @Nullable String title;\n+    private @Nullable String device;\n+    private int priority = DEFAULT_PRIORITY;\n+    private int retry = 300;\n+    private int expire = 3600;\n+    private @Nullable String url;\n+    private @Nullable String urlTitle;\n+    private @Nullable String sound;\n+    private @Nullable String attachment;\n+    private String contentType = DEFAULT_CONTENT_TYPE;\n+    private boolean html = false;\n+    private boolean monospace = false;\n+\n+    private PushoverMessageBuilder(String apikey, String user) throws PushoverConfigurationException {\n+        body.addFieldPart(MESSAGE_KEY_TOKEN, new StringContentProvider(apikey), null);\n+        body.addFieldPart(MESSAGE_KEY_USER, new StringContentProvider(user), null);\n+    }\n+\n+    public static PushoverMessageBuilder getInstance(@Nullable String apikey, @Nullable String user)\n+            throws PushoverConfigurationException {\n+        if (apikey == null || apikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        if (user == null || user.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-user\");\n+        }\n+\n+        return new PushoverMessageBuilder(apikey, user);\n+    }\n+\n+    public PushoverMessageBuilder withMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withDevice(String device) {\n+        this.device = device;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withPriority(int priority) {\n+        this.priority = priority;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withRetry(int retry) {\n+        this.retry = retry;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withExpire(int expire) {\n+        this.expire = expire;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrl(String url) {\n+        this.url = url;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrlTitle(String urlTitle) {\n+        this.urlTitle = urlTitle;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withSound(String sound) {\n+        this.sound = sound;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withAttachment(String attachment) {\n+        this.attachment = attachment;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withContentType(String contentType) {\n+        this.contentType = contentType;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withHtmlFormatting() {\n+        this.html = true;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withMonospaceFormatting() {\n+        this.monospace = true;\n+        return this;\n+    }\n+\n+    public ContentProvider build() {\n+        if (message != null) {\n+            if (message.length() > MAX_MESSAGE_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Skip sending the message as 'message' is longer than %d characters.\", MAX_MESSAGE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_MESSAGE, new StringContentProvider(message), null);\n+        }\n+\n+        if (title != null) {\n+            if (title.length() > MAX_TITLE_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'title' is longer than %d characters.\", MAX_TITLE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_TITLE, new StringContentProvider(title), null);\n+        }\n+\n+        if (device != null) {\n+            if (device.length() > MAX_DEVICE_LENGTH) {\n+                logger.warn(\"Skip 'device' as it is longer than {} characters. Got: {}.\", MAX_DEVICE_LENGTH, device);\n+            } else {\n+                // TODO [A-Za-z0-9_-]\n+                // TODO Messages may be addressed to multiple specific devices by joining them with a comma (such as\n+                // device=iphone,nexus5)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1OTU2MA==", "bodyText": "Not needed anymore. Can be passed by parameter directly.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529659560", "createdAt": "2020-11-24T15:45:17Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.util.MultiPartContentProvider;\n+import org.eclipse.jetty.client.util.PathContentProvider;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PushoverMessageBuilder} builds the body for Pushover Messages API requests.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverMessageBuilder {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverMessageBuilder.class);\n+\n+    public static final String MESSAGE_KEY_TOKEN = \"token\";\n+    private static final String MESSAGE_KEY_USER = \"user\";\n+    private static final String MESSAGE_KEY_MESSAGE = \"message\";\n+    private static final String MESSAGE_KEY_TITLE = \"title\";\n+    private static final String MESSAGE_KEY_DEVICE = \"device\";\n+    private static final String MESSAGE_KEY_PRIORITY = \"priority\";\n+    private static final String MESSAGE_KEY_RETRY = \"retry\";\n+    private static final String MESSAGE_KEY_EXPIRE = \"expire\";\n+    private static final String MESSAGE_KEY_URL = \"url\";\n+    private static final String MESSAGE_KEY_URL_TITLE = \"url_title\";\n+    private static final String MESSAGE_KEY_SOUND = \"sound\";\n+    private static final String MESSAGE_KEY_ATTACHMENT = \"attachment\";\n+    public static final String MESSAGE_KEY_HTML = \"html\";\n+    public static final String MESSAGE_KEY_MONOSPACE = \"monospace\";\n+\n+    private static final int MAX_MESSAGE_LENGTH = 1024;\n+    private static final int MAX_TITLE_LENGTH = 250;\n+    private static final int MAX_DEVICE_LENGTH = 25;\n+    private static final List<Integer> VALID_PRIORITY_LIST = Arrays.asList(-2, -1, 0, 1, 2);\n+    private static final int DEFAULT_PRIORITY = 0;\n+    public static final int EMERGENCY_PRIORITY = 2;\n+    private static final int MIN_RETRY_SECONDS = 30;\n+    private static final int MAX_EXPIRE_SECONDS = 10800;\n+    private static final int MAX_URL_LENGTH = 512;\n+    private static final int MAX_URL_TITLE_LENGTH = 100;\n+    public static final String DEFAULT_CONTENT_TYPE = \"image/jpeg\";\n+\n+    private final MultiPartContentProvider body = new MultiPartContentProvider();\n+\n+    private @Nullable String message;\n+    private @Nullable String title;\n+    private @Nullable String device;\n+    private int priority = DEFAULT_PRIORITY;\n+    private int retry = 300;\n+    private int expire = 3600;\n+    private @Nullable String url;\n+    private @Nullable String urlTitle;\n+    private @Nullable String sound;\n+    private @Nullable String attachment;\n+    private String contentType = DEFAULT_CONTENT_TYPE;\n+    private boolean html = false;\n+    private boolean monospace = false;\n+\n+    private PushoverMessageBuilder(String apikey, String user) throws PushoverConfigurationException {\n+        body.addFieldPart(MESSAGE_KEY_TOKEN, new StringContentProvider(apikey), null);\n+        body.addFieldPart(MESSAGE_KEY_USER, new StringContentProvider(user), null);\n+    }\n+\n+    public static PushoverMessageBuilder getInstance(@Nullable String apikey, @Nullable String user)\n+            throws PushoverConfigurationException {\n+        if (apikey == null || apikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        if (user == null || user.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-user\");\n+        }\n+\n+        return new PushoverMessageBuilder(apikey, user);\n+    }\n+\n+    public PushoverMessageBuilder withMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withDevice(String device) {\n+        this.device = device;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withPriority(int priority) {\n+        this.priority = priority;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withRetry(int retry) {\n+        this.retry = retry;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withExpire(int expire) {\n+        this.expire = expire;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrl(String url) {\n+        this.url = url;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrlTitle(String urlTitle) {\n+        this.urlTitle = urlTitle;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withSound(String sound) {\n+        this.sound = sound;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withAttachment(String attachment) {\n+        this.attachment = attachment;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withContentType(String contentType) {\n+        this.contentType = contentType;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withHtmlFormatting() {\n+        this.html = true;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withMonospaceFormatting() {\n+        this.monospace = true;\n+        return this;\n+    }\n+\n+    public ContentProvider build() {\n+        if (message != null) {\n+            if (message.length() > MAX_MESSAGE_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Skip sending the message as 'message' is longer than %d characters.\", MAX_MESSAGE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_MESSAGE, new StringContentProvider(message), null);\n+        }\n+\n+        if (title != null) {\n+            if (title.length() > MAX_TITLE_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'title' is longer than %d characters.\", MAX_TITLE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_TITLE, new StringContentProvider(title), null);\n+        }\n+\n+        if (device != null) {\n+            if (device.length() > MAX_DEVICE_LENGTH) {\n+                logger.warn(\"Skip 'device' as it is longer than {} characters. Got: {}.\", MAX_DEVICE_LENGTH, device);\n+            } else {\n+                // TODO [A-Za-z0-9_-]\n+                // TODO Messages may be addressed to multiple specific devices by joining them with a comma (such as\n+                // device=iphone,nexus5)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMDQ5MQ=="}, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODk5NjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/factory/PushoverHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNToyNTo0NFrOH4se6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNToyNTo0NFrOH4se6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTExNA==", "bodyText": "A thing with no handler?", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529211114", "createdAt": "2020-11-24T05:25:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/factory/PushoverHandlerFactory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.factory;\n+\n+import static org.openhab.binding.pushover.internal.PushoverBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link PushoverHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@Component(configurationPid = \"binding.pushover\", service = ThingHandlerFactory.class)\n+@NonNullByDefault\n+public class PushoverHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(PUSHOVER_ACCOUNT, PUSHOVER_USER);\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public PushoverHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        final ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (PUSHOVER_ACCOUNT.equals(thingTypeUID)) {\n+            return new PushoverAccountHandler(thing, httpClient);\n+        } else if (PUSHOVER_USER.equals(thingTypeUID)) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODk5ODEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNToyNjo1MVrOH4sf-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNToyNjo1MVrOH4sf-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTM4Nw==", "bodyText": "The authoring field is deprecated now.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529211387", "createdAt": "2020-11-24T05:26:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"pushover\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Pushover Binding</name>\n+\t<description>Pushover - Simple Notifications.</description>\n+\t<author>Christoph Weitkamp</author>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTAwMDU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNToyODoxOVrOH4shhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0NTowNVrOH5H1gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTc4MA==", "bodyText": "can this be done?", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529211780", "createdAt": "2020-11-24T05:28:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.util.MultiPartContentProvider;\n+import org.eclipse.jetty.client.util.PathContentProvider;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PushoverMessageBuilder} builds the body for Pushover Messages API requests.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverMessageBuilder {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverMessageBuilder.class);\n+\n+    public static final String MESSAGE_KEY_TOKEN = \"token\";\n+    private static final String MESSAGE_KEY_USER = \"user\";\n+    private static final String MESSAGE_KEY_MESSAGE = \"message\";\n+    private static final String MESSAGE_KEY_TITLE = \"title\";\n+    private static final String MESSAGE_KEY_DEVICE = \"device\";\n+    private static final String MESSAGE_KEY_PRIORITY = \"priority\";\n+    private static final String MESSAGE_KEY_RETRY = \"retry\";\n+    private static final String MESSAGE_KEY_EXPIRE = \"expire\";\n+    private static final String MESSAGE_KEY_URL = \"url\";\n+    private static final String MESSAGE_KEY_URL_TITLE = \"url_title\";\n+    private static final String MESSAGE_KEY_SOUND = \"sound\";\n+    private static final String MESSAGE_KEY_ATTACHMENT = \"attachment\";\n+    public static final String MESSAGE_KEY_HTML = \"html\";\n+    public static final String MESSAGE_KEY_MONOSPACE = \"monospace\";\n+\n+    private static final int MAX_MESSAGE_LENGTH = 1024;\n+    private static final int MAX_TITLE_LENGTH = 250;\n+    private static final int MAX_DEVICE_LENGTH = 25;\n+    private static final List<Integer> VALID_PRIORITY_LIST = Arrays.asList(-2, -1, 0, 1, 2);\n+    private static final int DEFAULT_PRIORITY = 0;\n+    public static final int EMERGENCY_PRIORITY = 2;\n+    private static final int MIN_RETRY_SECONDS = 30;\n+    private static final int MAX_EXPIRE_SECONDS = 10800;\n+    private static final int MAX_URL_LENGTH = 512;\n+    private static final int MAX_URL_TITLE_LENGTH = 100;\n+    public static final String DEFAULT_CONTENT_TYPE = \"image/jpeg\";\n+\n+    private final MultiPartContentProvider body = new MultiPartContentProvider();\n+\n+    private @Nullable String message;\n+    private @Nullable String title;\n+    private @Nullable String device;\n+    private int priority = DEFAULT_PRIORITY;\n+    private int retry = 300;\n+    private int expire = 3600;\n+    private @Nullable String url;\n+    private @Nullable String urlTitle;\n+    private @Nullable String sound;\n+    private @Nullable String attachment;\n+    private String contentType = DEFAULT_CONTENT_TYPE;\n+    private boolean html = false;\n+    private boolean monospace = false;\n+\n+    private PushoverMessageBuilder(String apikey, String user) throws PushoverConfigurationException {\n+        body.addFieldPart(MESSAGE_KEY_TOKEN, new StringContentProvider(apikey), null);\n+        body.addFieldPart(MESSAGE_KEY_USER, new StringContentProvider(user), null);\n+    }\n+\n+    public static PushoverMessageBuilder getInstance(@Nullable String apikey, @Nullable String user)\n+            throws PushoverConfigurationException {\n+        if (apikey == null || apikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        if (user == null || user.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-user\");\n+        }\n+\n+        return new PushoverMessageBuilder(apikey, user);\n+    }\n+\n+    public PushoverMessageBuilder withMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withDevice(String device) {\n+        this.device = device;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withPriority(int priority) {\n+        this.priority = priority;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withRetry(int retry) {\n+        this.retry = retry;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withExpire(int expire) {\n+        this.expire = expire;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrl(String url) {\n+        this.url = url;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrlTitle(String urlTitle) {\n+        this.urlTitle = urlTitle;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withSound(String sound) {\n+        this.sound = sound;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withAttachment(String attachment) {\n+        this.attachment = attachment;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withContentType(String contentType) {\n+        this.contentType = contentType;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withHtmlFormatting() {\n+        this.html = true;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withMonospaceFormatting() {\n+        this.monospace = true;\n+        return this;\n+    }\n+\n+    public ContentProvider build() {\n+        if (message != null) {\n+            if (message.length() > MAX_MESSAGE_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Skip sending the message as 'message' is longer than %d characters.\", MAX_MESSAGE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_MESSAGE, new StringContentProvider(message), null);\n+        }\n+\n+        if (title != null) {\n+            if (title.length() > MAX_TITLE_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'title' is longer than %d characters.\", MAX_TITLE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_TITLE, new StringContentProvider(title), null);\n+        }\n+\n+        if (device != null) {\n+            if (device.length() > MAX_DEVICE_LENGTH) {\n+                logger.warn(\"Skip 'device' as it is longer than {} characters. Got: {}.\", MAX_DEVICE_LENGTH, device);\n+            } else {\n+                // TODO [A-Za-z0-9_-]\n+                // TODO Messages may be addressed to multiple specific devices by joining them with a comma (such as\n+                // device=iphone,nexus5)\n+                body.addFieldPart(MESSAGE_KEY_DEVICE, new StringContentProvider(device), null);\n+            }\n+        }\n+\n+        if (priority != DEFAULT_PRIORITY) {\n+            if (VALID_PRIORITY_LIST.contains(priority)) {\n+                body.addFieldPart(MESSAGE_KEY_PRIORITY, new StringContentProvider(String.valueOf(priority)), null);\n+\n+                if (priority == EMERGENCY_PRIORITY) {\n+                    if (retry < MIN_RETRY_SECONDS) {\n+                        logger.warn(\"Retry value of {} is too small. Using default value of {}.\", retry,\n+                                MIN_RETRY_SECONDS);\n+                        body.addFieldPart(MESSAGE_KEY_RETRY,\n+                                new StringContentProvider(String.valueOf(MIN_RETRY_SECONDS)), null);\n+                    } else {\n+                        body.addFieldPart(MESSAGE_KEY_RETRY, new StringContentProvider(String.valueOf(retry)), null);\n+                    }\n+\n+                    if (0 < expire && expire <= MAX_EXPIRE_SECONDS) {\n+                        body.addFieldPart(MESSAGE_KEY_EXPIRE, new StringContentProvider(String.valueOf(expire)), null);\n+                    } else {\n+                        logger.warn(\"Expire value of {} is invalid. Using default value of {}.\", expire,\n+                                MAX_EXPIRE_SECONDS);\n+                        body.addFieldPart(MESSAGE_KEY_EXPIRE,\n+                                new StringContentProvider(String.valueOf(MAX_EXPIRE_SECONDS)), null);\n+                    }\n+                }\n+            } else {\n+                logger.warn(\"Invalid 'priority', skipping. Expected: {}. Got: {}.\",\n+                        VALID_PRIORITY_LIST.stream().map(i -> i.toString()).collect(Collectors.joining(\",\")), priority);\n+            }\n+        }\n+\n+        if (url != null) {\n+            if (url.length() > MAX_URL_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'url' is longer than %d characters.\", MAX_URL_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_URL, new StringContentProvider(url), null);\n+\n+            if (urlTitle != null) {\n+                if (urlTitle.length() > MAX_URL_TITLE_LENGTH) {\n+                    throw new IllegalArgumentException(\n+                            String.format(\"Skip sending the message as 'urlTitle' is longer than %d characters.\",\n+                                    MAX_URL_TITLE_LENGTH));\n+                }\n+                body.addFieldPart(MESSAGE_KEY_URL_TITLE, new StringContentProvider(urlTitle), null);\n+            }\n+        }\n+\n+        if (sound != null) {\n+            // TODO validate sound", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1OTI2NA==", "bodyText": "Not needed anymore. Sounds are now provided by a ConfigOptionsProvider.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529659264", "createdAt": "2020-11-24T15:45:05Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.util.MultiPartContentProvider;\n+import org.eclipse.jetty.client.util.PathContentProvider;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PushoverMessageBuilder} builds the body for Pushover Messages API requests.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverMessageBuilder {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverMessageBuilder.class);\n+\n+    public static final String MESSAGE_KEY_TOKEN = \"token\";\n+    private static final String MESSAGE_KEY_USER = \"user\";\n+    private static final String MESSAGE_KEY_MESSAGE = \"message\";\n+    private static final String MESSAGE_KEY_TITLE = \"title\";\n+    private static final String MESSAGE_KEY_DEVICE = \"device\";\n+    private static final String MESSAGE_KEY_PRIORITY = \"priority\";\n+    private static final String MESSAGE_KEY_RETRY = \"retry\";\n+    private static final String MESSAGE_KEY_EXPIRE = \"expire\";\n+    private static final String MESSAGE_KEY_URL = \"url\";\n+    private static final String MESSAGE_KEY_URL_TITLE = \"url_title\";\n+    private static final String MESSAGE_KEY_SOUND = \"sound\";\n+    private static final String MESSAGE_KEY_ATTACHMENT = \"attachment\";\n+    public static final String MESSAGE_KEY_HTML = \"html\";\n+    public static final String MESSAGE_KEY_MONOSPACE = \"monospace\";\n+\n+    private static final int MAX_MESSAGE_LENGTH = 1024;\n+    private static final int MAX_TITLE_LENGTH = 250;\n+    private static final int MAX_DEVICE_LENGTH = 25;\n+    private static final List<Integer> VALID_PRIORITY_LIST = Arrays.asList(-2, -1, 0, 1, 2);\n+    private static final int DEFAULT_PRIORITY = 0;\n+    public static final int EMERGENCY_PRIORITY = 2;\n+    private static final int MIN_RETRY_SECONDS = 30;\n+    private static final int MAX_EXPIRE_SECONDS = 10800;\n+    private static final int MAX_URL_LENGTH = 512;\n+    private static final int MAX_URL_TITLE_LENGTH = 100;\n+    public static final String DEFAULT_CONTENT_TYPE = \"image/jpeg\";\n+\n+    private final MultiPartContentProvider body = new MultiPartContentProvider();\n+\n+    private @Nullable String message;\n+    private @Nullable String title;\n+    private @Nullable String device;\n+    private int priority = DEFAULT_PRIORITY;\n+    private int retry = 300;\n+    private int expire = 3600;\n+    private @Nullable String url;\n+    private @Nullable String urlTitle;\n+    private @Nullable String sound;\n+    private @Nullable String attachment;\n+    private String contentType = DEFAULT_CONTENT_TYPE;\n+    private boolean html = false;\n+    private boolean monospace = false;\n+\n+    private PushoverMessageBuilder(String apikey, String user) throws PushoverConfigurationException {\n+        body.addFieldPart(MESSAGE_KEY_TOKEN, new StringContentProvider(apikey), null);\n+        body.addFieldPart(MESSAGE_KEY_USER, new StringContentProvider(user), null);\n+    }\n+\n+    public static PushoverMessageBuilder getInstance(@Nullable String apikey, @Nullable String user)\n+            throws PushoverConfigurationException {\n+        if (apikey == null || apikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        if (user == null || user.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-user\");\n+        }\n+\n+        return new PushoverMessageBuilder(apikey, user);\n+    }\n+\n+    public PushoverMessageBuilder withMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withDevice(String device) {\n+        this.device = device;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withPriority(int priority) {\n+        this.priority = priority;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withRetry(int retry) {\n+        this.retry = retry;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withExpire(int expire) {\n+        this.expire = expire;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrl(String url) {\n+        this.url = url;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrlTitle(String urlTitle) {\n+        this.urlTitle = urlTitle;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withSound(String sound) {\n+        this.sound = sound;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withAttachment(String attachment) {\n+        this.attachment = attachment;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withContentType(String contentType) {\n+        this.contentType = contentType;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withHtmlFormatting() {\n+        this.html = true;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withMonospaceFormatting() {\n+        this.monospace = true;\n+        return this;\n+    }\n+\n+    public ContentProvider build() {\n+        if (message != null) {\n+            if (message.length() > MAX_MESSAGE_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Skip sending the message as 'message' is longer than %d characters.\", MAX_MESSAGE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_MESSAGE, new StringContentProvider(message), null);\n+        }\n+\n+        if (title != null) {\n+            if (title.length() > MAX_TITLE_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'title' is longer than %d characters.\", MAX_TITLE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_TITLE, new StringContentProvider(title), null);\n+        }\n+\n+        if (device != null) {\n+            if (device.length() > MAX_DEVICE_LENGTH) {\n+                logger.warn(\"Skip 'device' as it is longer than {} characters. Got: {}.\", MAX_DEVICE_LENGTH, device);\n+            } else {\n+                // TODO [A-Za-z0-9_-]\n+                // TODO Messages may be addressed to multiple specific devices by joining them with a comma (such as\n+                // device=iphone,nexus5)\n+                body.addFieldPart(MESSAGE_KEY_DEVICE, new StringContentProvider(device), null);\n+            }\n+        }\n+\n+        if (priority != DEFAULT_PRIORITY) {\n+            if (VALID_PRIORITY_LIST.contains(priority)) {\n+                body.addFieldPart(MESSAGE_KEY_PRIORITY, new StringContentProvider(String.valueOf(priority)), null);\n+\n+                if (priority == EMERGENCY_PRIORITY) {\n+                    if (retry < MIN_RETRY_SECONDS) {\n+                        logger.warn(\"Retry value of {} is too small. Using default value of {}.\", retry,\n+                                MIN_RETRY_SECONDS);\n+                        body.addFieldPart(MESSAGE_KEY_RETRY,\n+                                new StringContentProvider(String.valueOf(MIN_RETRY_SECONDS)), null);\n+                    } else {\n+                        body.addFieldPart(MESSAGE_KEY_RETRY, new StringContentProvider(String.valueOf(retry)), null);\n+                    }\n+\n+                    if (0 < expire && expire <= MAX_EXPIRE_SECONDS) {\n+                        body.addFieldPart(MESSAGE_KEY_EXPIRE, new StringContentProvider(String.valueOf(expire)), null);\n+                    } else {\n+                        logger.warn(\"Expire value of {} is invalid. Using default value of {}.\", expire,\n+                                MAX_EXPIRE_SECONDS);\n+                        body.addFieldPart(MESSAGE_KEY_EXPIRE,\n+                                new StringContentProvider(String.valueOf(MAX_EXPIRE_SECONDS)), null);\n+                    }\n+                }\n+            } else {\n+                logger.warn(\"Invalid 'priority', skipping. Expected: {}. Got: {}.\",\n+                        VALID_PRIORITY_LIST.stream().map(i -> i.toString()).collect(Collectors.joining(\",\")), priority);\n+            }\n+        }\n+\n+        if (url != null) {\n+            if (url.length() > MAX_URL_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'url' is longer than %d characters.\", MAX_URL_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_URL, new StringContentProvider(url), null);\n+\n+            if (urlTitle != null) {\n+                if (urlTitle.length() > MAX_URL_TITLE_LENGTH) {\n+                    throw new IllegalArgumentException(\n+                            String.format(\"Skip sending the message as 'urlTitle' is longer than %d characters.\",\n+                                    MAX_URL_TITLE_LENGTH));\n+                }\n+                body.addFieldPart(MESSAGE_KEY_URL_TITLE, new StringContentProvider(urlTitle), null);\n+            }\n+        }\n+\n+        if (sound != null) {\n+            // TODO validate sound", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTc4MA=="}, "originalCommit": {"oid": "ace20af50e86750ad0209089578f2350e058ce75"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwODUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1OTo1NlrOH6CGlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1OTo1NlrOH6CGlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzkxMQ==", "bodyText": "please remove these if they aren't needed.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530613911", "createdAt": "2020-11-25T19:59:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendURLMessage\n+    @Test\n+    public void testSendURLMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class,\n+                () -> PushoverActions.sendURLMessage(thingActionsStub, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, message.get(), TITLE, URL, URL_TITLE));\n+    // }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutURL() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> url = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, url.get(), URL_TITLE));\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwODg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDowM1rOH6CG2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDowM1rOH6CG2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzk3OA==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530613978", "createdAt": "2020-11-25T20:00:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendURLMessage\n+    @Test\n+    public void testSendURLMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class,\n+                () -> PushoverActions.sendURLMessage(thingActionsStub, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, message.get(), TITLE, URL, URL_TITLE));\n+    // }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutURL() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> url = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, url.get(), URL_TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendURLMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, null, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageWithoutURLTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendPriorityMessage\n+    @Test\n+    public void testSendPriorityMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendPriorityMessage(thingActionsStub, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    @Test\n+    public void testSendPriorityMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    // @Test\n+    // public void testSendPriorityMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions,\n+    // message.get(), TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwOTI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDowOVrOH6CHFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDowOVrOH6CHFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDAzOA==", "bodyText": "and here", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530614038", "createdAt": "2020-11-25T20:00:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendURLMessage\n+    @Test\n+    public void testSendURLMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class,\n+                () -> PushoverActions.sendURLMessage(thingActionsStub, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, message.get(), TITLE, URL, URL_TITLE));\n+    // }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutURL() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> url = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, url.get(), URL_TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendURLMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, null, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageWithoutURLTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendPriorityMessage\n+    @Test\n+    public void testSendPriorityMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendPriorityMessage(thingActionsStub, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    @Test\n+    public void testSendPriorityMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    // @Test\n+    // public void testSendPriorityMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions,\n+    // message.get(), TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    // }\n+\n+    @Test\n+    public void testSendPriorityMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        String receipt = PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE, null,\n+                PushoverMessageBuilder.EMERGENCY_PRIORITY);\n+        assertThat(receipt, is(RECEIPT));\n+    }\n+\n+    @Test\n+    public void testSendPriorityMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        String receipt = PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE, TITLE,\n+                PushoverMessageBuilder.EMERGENCY_PRIORITY);\n+        assertThat(receipt, is(RECEIPT));\n+    }\n+\n+    // cancelPriorityMessage\n+    @Test\n+    public void testCancelPriorityMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.cancelPriorityMessage(thingActionsStub, RECEIPT));\n+    }\n+\n+    @Test\n+    public void testCancelPriorityMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.cancelPriorityMessage(pushoverThingActions, RECEIPT));\n+    }\n+\n+    // @Test\n+    // public void testCancelPriorityMessageWithoutReceipt() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> receipt = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.cancelPriorityMessage(pushoverThingActions, receipt.get()));\n+    // }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkxMDMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDoxOVrOH6CHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDoxOVrOH6CHnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDE3Mg==", "bodyText": "and here", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530614172", "createdAt": "2020-11-25T20:00:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkyMDc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/handler/PushoverAccountHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMzo1N1rOH6COGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxOToxMzo0MlrOH6llXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTgzMg==", "bodyText": "connection.validateUser might be slow, so please make this code asynchronous so the initialize() method remains speedy.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530615832", "createdAt": "2020-11-25T20:03:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/handler/PushoverAccountHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.handler;\n+\n+import static org.openhab.binding.pushover.internal.PushoverBindingConstants.DEFAULT_SOUND;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.pushover.internal.actions.PushoverActions;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.config.PushoverConfigOptionProvider;\n+import org.openhab.binding.pushover.internal.connection.PushoverAPIConnection;\n+import org.openhab.binding.pushover.internal.connection.PushoverCommunicationException;\n+import org.openhab.binding.pushover.internal.connection.PushoverConfigurationException;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link PushoverAccountHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAccountHandler extends BaseThingHandler {\n+\n+    private static final Collection<Class<? extends ThingHandlerService>> SUPPORTED_THING_ACTIONS = Set\n+            .of(PushoverActions.class, PushoverConfigOptionProvider.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private @NonNullByDefault({}) PushoverAccountConfiguration config;\n+    private @Nullable PushoverAPIConnection connection;\n+\n+    public PushoverAccountHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PushoverAccountConfiguration.class);\n+\n+        boolean configValid = true;\n+        final String apikey = config.apikey;\n+        if (apikey == null || apikey.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-missing-apikey\");\n+            configValid = false;\n+        }\n+        final String user = config.user;\n+        if (user == null || user.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-missing-user\");\n+            configValid = false;\n+        }\n+\n+        if (configValid) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            connection = new PushoverAPIConnection(httpClient, config);\n+            try {\n+                connection.validateUser();\n+                updateStatus(ThingStatus.ONLINE);\n+            } catch (PushoverCommunicationException | PushoverConfigurationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5NTIyOQ==", "bodyText": "Good catch. I somehow had in my mind I planned to do that.", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r531195229", "createdAt": "2020-11-26T19:13:42Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/handler/PushoverAccountHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.handler;\n+\n+import static org.openhab.binding.pushover.internal.PushoverBindingConstants.DEFAULT_SOUND;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.pushover.internal.actions.PushoverActions;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.config.PushoverConfigOptionProvider;\n+import org.openhab.binding.pushover.internal.connection.PushoverAPIConnection;\n+import org.openhab.binding.pushover.internal.connection.PushoverCommunicationException;\n+import org.openhab.binding.pushover.internal.connection.PushoverConfigurationException;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link PushoverAccountHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAccountHandler extends BaseThingHandler {\n+\n+    private static final Collection<Class<? extends ThingHandlerService>> SUPPORTED_THING_ACTIONS = Set\n+            .of(PushoverActions.class, PushoverConfigOptionProvider.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private @NonNullByDefault({}) PushoverAccountConfiguration config;\n+    private @Nullable PushoverAPIConnection connection;\n+\n+    public PushoverAccountHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PushoverAccountConfiguration.class);\n+\n+        boolean configValid = true;\n+        final String apikey = config.apikey;\n+        if (apikey == null || apikey.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-missing-apikey\");\n+            configValid = false;\n+        }\n+        final String user = config.user;\n+        if (user == null || user.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-missing-user\");\n+            configValid = false;\n+        }\n+\n+        if (configValid) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            connection = new PushoverAPIConnection(httpClient, config);\n+            try {\n+                connection.validateUser();\n+                updateStatus(ThingStatus.ONLINE);\n+            } catch (PushoverCommunicationException | PushoverConfigurationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTgzMg=="}, "originalCommit": {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4381, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}