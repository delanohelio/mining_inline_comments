{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NzIzNjYz", "number": 7749, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMTo1NzoxNFrODbCYvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjowMzo1NlrODbY2pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njc3MjQ3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMTo1NzoxNFrOFiS4oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMTo1NzoxNFrOFiS4oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwNTMxMg==", "bodyText": "Should log these and others", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371505312", "createdAt": "2020-01-27T21:57:14Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njc4MjkzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowMDo0OFrOFiS-7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowMDo0OFrOFiS-7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwNjkyNg==", "bodyText": "Should use splitToElements", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371506926", "createdAt": "2020-01-27T22:00:48Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -38,18 +89,29 @@ public FileSystem getFileSystem() {\n     }\n \n     /**\n+     * A path is considered absolute in this file system if it contains a root component.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean isAbsolute() {\n-        return false;\n+        return this.getRoot() != null;\n     }\n \n     /**\n+     * The root component of this path also identifies the Azure Storage Container in which the file is stored. This\n+     * method will not validate that the root component corresponds to an actual file store/container in this\n+     * file system. It will simply return the root component of the path if one is present and syntactically valid.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getRoot() {\n+        // Check if the first element of the path is formatted like a root directory.\n+        String firstElement = pathString.split(parentFileSystem.getSeparator())[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njc5Nzc4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNjoxNFrOFiTIOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNjoxNFrOFiTIOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTMwNg==", "bodyText": "Just use .equals. It's clear and safer and evidently equivalent.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371509306", "createdAt": "2020-01-27T22:06:14Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjgwMDc1OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNzowN1rOFiTJ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDowNDowOVrOFiywjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTc0MA==", "bodyText": "What about a path with \"..\"? In other words, should we normalize first?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371509740", "createdAt": "2020-01-27T22:07:07Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTMxOQ==", "bodyText": "I think it makes sense to normalize before comparing", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372021319", "createdAt": "2020-01-28T19:51:34Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTc0MA=="}, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzUzMw==", "bodyText": "It looks like the default system (which I'm generally trying to follow) doesn't normalize and will return false for \"foo/bar\" starts with \"foo/.\", so I'll leave this as is.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372027533", "createdAt": "2020-01-28T20:04:09Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTc0MA=="}, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjgwNDQ0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowODozNVrOFiTMXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowODozNVrOFiTMXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMDM2NQ==", "bodyText": "Can remove the todo as the root validity check is gone.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371510365", "createdAt": "2020-01-27T22:08:35Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot(); // Refactor so this doesn't access the fs per docs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjgxNDEwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjoxMjoyNFrOFiTSYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjoxMjoyNFrOFiTSYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMTkwNg==", "bodyText": "Add a comment here to explain that this is the special case where we split after removing the root of a path that is just the root.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371511906", "createdAt": "2020-01-27T22:12:24Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -226,14 +451,89 @@ public WatchKey register(WatchService watchService, WatchEvent.Kind<?>... kinds)\n      */\n     @Override\n     public Iterator<Path> iterator() {\n-        return null;\n+        return Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .map(s -> this.parentFileSystem.getPath(s))\n+            .toIterable()\n+            .iterator();\n     }\n \n     /**\n+     * This result of this method is identical to a string comparison on the underlying path strings.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public int compareTo(Path path) {\n-        return 0;\n+        if (!(path instanceof AzurePath)) {\n+            throw Utility.logError(logger, new ClassCastException(\"Other path is not an instance of AzurePath.\"));\n+        }\n+\n+        return this.pathString.compareTo(((AzurePath) path).pathString);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.pathString;\n+    }\n+\n+    /**\n+     * A path is considered equal to another path if it is associated with the same file system instance and if the\n+     * path strings are equivalent.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        AzurePath paths = (AzurePath) o;\n+        return Objects.equals(parentFileSystem, paths.parentFileSystem)\n+            && Objects.equals(pathString, paths.pathString);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(parentFileSystem, pathString);\n+    }\n+\n+    // Used to ensure we only try to access containers that are mounted.\n+    boolean validRoot(String fileStoreName) {\n+        Boolean validRootName = Flux.fromIterable(parentFileSystem.getFileStores())\n+            .map(FileStore::name)\n+            .hasElement(fileStoreName)\n+            .block();\n+        return validRootName != null && validRootName;\n+    }\n+\n+    private String withoutRoot() {\n+        Path root = this.getRoot();\n+        String str = this.pathString;\n+        if (root != null) {\n+            str = this.pathString.substring(root.toString().length());\n+        }\n+        if (str.startsWith(this.parentFileSystem.getSeparator())) {\n+            str = str.substring(1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private String[] splitToElements() {\n+        return this.splitToElements(this.pathString);\n+    }\n+\n+    private String[] splitToElements(String str) {\n+        String[] arr = str.split(this.parentFileSystem.getSeparator());\n+        if (arr.length == 1 && arr[0].isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 548}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njk0MzUzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/ci.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNDozOFrOFiUg_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNDozOFrOFiUg_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMjAzMA==", "bodyText": "This needs the groupId entry which should be\ngroupId: com.azure", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371532030", "createdAt": "2020-01-27T23:04:38Z", "author": {"login": "JimSuplizio"}, "path": "sdk/storage/ci.yml", "diffHunk": "@@ -57,6 +57,9 @@ stages:\n           groupId: com.azure\n           safeName: azurestorageblobcryptography\n           stagingProfileId: 88192f04117501\n+        - name: azure-storage-blob-nio\n+          safeName: azurestorageblobnio", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njk0ODEwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/DesignDoc.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNjo0N1rOFiUj0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNjo0N1rOFiUj0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMjc1Mg==", "bodyText": "This doesn't need to be reviewed, just a translation of the original design doc", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371532752", "createdAt": "2020-01-27T23:06:47Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/DesignDoc.md", "diffHunk": "@@ -0,0 +1,235 @@\n+# Azure Storage NIO Design Doc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njk1MjgxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowOTowNlrOFiUmuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowOTowNlrOFiUmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMzQ5OQ==", "bodyText": "is there a reason for the ? or am I misreading this sentence.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371533499", "createdAt": "2020-01-27T23:09:06Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "diffHunk": "@@ -215,6 +215,9 @@ public String getSeparator() {\n     }\n \n     /**\n+     * ':' is only allowed in the root component. Root component will be validated against the list of\n+     * file shares?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njk3MjU2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoxNzo0NFrOFiUyrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoxNzo0NFrOFiUyrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzNjU1OQ==", "bodyText": "Could this be made into more of a bulleted list, kind of like\nAn error will only be thrown for\n\nan invalid root when trying to access a file in that root if it does not exist\na nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371536559", "createdAt": "2020-01-27T23:17:44Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Njk3ODc1OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoyMDozNFrOFiU2OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoyMDozNFrOFiU2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzNzQ2NA==", "bodyText": "can the name of the strings and s variable be more descriptive? are they paths?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371537464", "createdAt": "2020-01-27T23:20:34Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * only be thrown for an invalid root when trying to access a file in that root if it does not exist and for an\n+ * nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n     AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzAwMDc4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzozMDoyMVrOFiVCxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzozMDoyMVrOFiVCxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0MDY3OA==", "bodyText": "Add Unsupported in javadoc", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371540678", "createdAt": "2020-01-27T23:30:21Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot(); // Refactor so this doesn't access the fs per docs\n+        String rootStr = root == null ? null : root.toString();\n+        for (String element : pathElements) {\n+            if (element.equals(\".\")) {\n+                continue;\n+            } else if (element.equals(\"..\")) {\n+                if (rootStr != null) {\n+                    // Root path. We never push \"..\".\n+                    if (!stack.isEmpty() && stack.peekLast().equals(rootStr)) {\n+                        // Cannot go higher than root. Ignore.\n+                        continue;\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                } else {\n+                    // Relative paths can have an arbitrary number of \"..\" at the beginning.\n+                    if (stack.isEmpty()) {\n+                        stack.addLast(element);\n+                    } else if (stack.peek().equals(\"..\")) {\n+                        stack.addLast(element);\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                }\n+            } else {\n+                stack.addLast(element);\n+            }\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(stack.toArray(), stack.size(), String[].class));\n     }\n \n     /**\n+     * If the other path has a root component, it is considered absolute, and it is returned.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+        if (path.getNameCount() == 0) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getPath(this.toString(), path.toString());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(String s) {\n-        return null;\n+        return this.resolve(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+\n+        Path parent = this.getParent();\n+        return parent == null ? path : parent.resolve(path);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(String s) {\n-        return null;\n+        return this.resolveSibling(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * If both paths have a root component, it is still to relativize one against the other.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path relativize(Path path) {\n-        return null;\n+        if (path.getRoot() == null ^ this.getRoot() == null) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(\"Both paths must be absolute or neither can be\"));\n+        }\n+\n+        AzurePath thisNormalized = (AzurePath) this.normalize();\n+        Path otherNormalized = path.normalize();\n+\n+        Deque<String> deque = new ArrayDeque<>(\n+            Arrays.asList(otherNormalized.toString().split(this.parentFileSystem.getSeparator())));\n+\n+        int i = 0;\n+        String[] thisElements = thisNormalized.splitToElements();\n+        while (i < thisElements.length && !deque.isEmpty() && thisElements[i].equals(deque.peekFirst())) {\n+            deque.removeFirst();\n+            i++;\n+        }\n+        while (i < thisElements.length) {\n+            deque.addFirst(\"..\");\n+            i++;\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(deque.toArray(), deque.size(), String[].class));\n     }\n \n     /**\n+     * No authority component is defined for the {@code URI} returned by this method. This implementation offers the\n+     * same equivalence guarantee as the default provider.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public URI toUri() {\n-        return null;\n+        try {\n+            return new URI(this.parentFileSystem.provider().getScheme(), null, \"/\" + this.toAbsolutePath().toString(),\n+                null, null);\n+        } catch (URISyntaxException e) {\n+            throw Utility.logError(logger, new IllegalStateException(\"Unable to create valid URI from path\", e));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toAbsolutePath() {\n-        return null;\n+        if (this.isAbsolute()) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getDefaultDirectory().resolve(this);\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toRealPath(LinkOption... linkOptions) throws IOException {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 435}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDMzNDE2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToyMzowMFrOFi1DVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjoyNjo1NFrOFi2z9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2NTExMA==", "bodyText": "Does this need to be a Flux? Instead could we use a synchronous Stream? I'm always hesitant on blocking reactive streams as this may be used in a reactive stream which could cause an exception to be thrown.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372065110", "createdAt": "2020-01-28T21:23:00Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * only be thrown for an invalid root when trying to access a file in that root if it does not exist and for an\n+ * nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n     AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+        if (strings == null) {\n+            strings = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5Mzk0MQ==", "bodyText": "Doesn't have to be a Flux. I can look into switching to a Stream. I'm just more familiar with Flux apis. That's a good point about possible usage in a reactive context.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372093941", "createdAt": "2020-01-28T22:26:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * only be thrown for an invalid root when trying to access a file in that root if it does not exist and for an\n+ * nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n     AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+        if (strings == null) {\n+            strings = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2NTExMA=="}, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDQyODY0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo1NToxNlrOFi1_LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjozMjoxM1rOFi28mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MDQyOA==", "bodyText": "Could this be simplified to an iterative approach such as the following?\nList<String> elements = Arrays.asList(first.split(parentFileSystem.getSeparator()));\n\nfor (String next : more) {\n  elements.addAll(Arrays.asList(more.split(parentFileSystem.getSeparator())));\n}\n\nStream elementStream = elements.stream().filter(CoreUtils::isNullOrEmpty);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372080428", "createdAt": "2020-01-28T21:55:16Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5NjE1NQ==", "bodyText": "I'll switch over this implementation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372096155", "createdAt": "2020-01-28T22:32:13Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MDQyOA=="}, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDQ0MDg0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo1OToyMVrOFi2GzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjozNjo1NlrOFi3DvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MjM4MQ==", "bodyText": "I'm a bit confused on the logic happening here. Is this validating that other than the first element in the stream none may match ROOT_DIR_SUFFIX, then validate that the first element contains ROOT_DIR_SUFFIX and it's last character is that value?\nBased on my other suggestion of using a list instead of a reactive stream would that make this validation much simpler? Would need to access the last element and first element only.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372082381", "createdAt": "2020-01-28T21:59:21Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());\n+\n+        this.pathString = String.join(this.parentFileSystem.getSeparator(), elementFlux.toIterable());\n+\n+        // No element but the first may contain \":\"\n+        elementFlux.skip(1)\n+            .flatMap(str -> str.contains(ROOT_DIR_SUFFIX)\n+                ? Mono.error(Utility.logError(logger, new InvalidPathException(this.pathString, ROOT_DIR_SUFFIX\n+                + \" is an invalid character except to identify the root element of this path if there is one.\")))\n+            : Mono.just(str)).blockLast();\n+\n+        // There may only be at most one instance of \":\" in the root component, and it must be the last character.\n+        elementFlux.take(1)\n+            .flatMap(str -> str.contains(ROOT_DIR_SUFFIX) && str.indexOf(ROOT_DIR_SUFFIX) < str.length() - 1\n+            ? Mono.error(Utility.logError(logger, new InvalidPathException(this.pathString, ROOT_DIR_SUFFIX + \" may\"\n+                + \" only be used as the last character in the root component of a path\")))\n+            : Mono.just(str)).blockLast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5Nzk4MA==", "bodyText": "Basically I'm mimicking what windows does with its drives/root directories--using : to double as the name of the root directory. The ':' helps identify that an element is meant to be the root instead of just any old path element. The offshoot as that ':' can only appear in the first element, otherwise it loses its value in distinguishing the root. If it does appear in the first element, it can only appear as the last character in that element. Does that answer your question? The FileSystem.getPath() test cases may also help clarify this. I can clean up the inline docs, too, if you think that would help clarify the logic", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372097980", "createdAt": "2020-01-28T22:36:56Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());\n+\n+        this.pathString = String.join(this.parentFileSystem.getSeparator(), elementFlux.toIterable());\n+\n+        // No element but the first may contain \":\"\n+        elementFlux.skip(1)\n+            .flatMap(str -> str.contains(ROOT_DIR_SUFFIX)\n+                ? Mono.error(Utility.logError(logger, new InvalidPathException(this.pathString, ROOT_DIR_SUFFIX\n+                + \" is an invalid character except to identify the root element of this path if there is one.\")))\n+            : Mono.just(str)).blockLast();\n+\n+        // There may only be at most one instance of \":\" in the root component, and it must be the last character.\n+        elementFlux.take(1)\n+            .flatMap(str -> str.contains(ROOT_DIR_SUFFIX) && str.indexOf(ROOT_DIR_SUFFIX) < str.length() - 1\n+            ? Mono.error(Utility.logError(logger, new InvalidPathException(this.pathString, ROOT_DIR_SUFFIX + \" may\"\n+                + \" only be used as the last character in the root component of a path\")))\n+            : Mono.just(str)).blockLast();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MjM4MQ=="}, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDQ0MTk0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo1OTo0MVrOFi2Hag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjozMToxN1rOFi27Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MjUzOA==", "bodyText": "What happens here if there is only a single element in the reactive stream?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372082538", "createdAt": "2020-01-28T21:59:41Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());\n+\n+        this.pathString = String.join(this.parentFileSystem.getSeparator(), elementFlux.toIterable());\n+\n+        // No element but the first may contain \":\"\n+        elementFlux.skip(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5NTc3MA==", "bodyText": "I do have tests that cover creating a path with only one element, just a root component, and the root component plus one name element. None of them have any problems, so I'm guessing the Flux just completes if it skips 1 and there's only one element.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372095770", "createdAt": "2020-01-28T22:31:17Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());\n+\n+        this.pathString = String.join(this.parentFileSystem.getSeparator(), elementFlux.toIterable());\n+\n+        // No element but the first may contain \":\"\n+        elementFlux.skip(1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MjUzOA=="}, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDQ0NTYyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjowMTowM1rOFi2JyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjoyNzoyN1rOFi21CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MzE0NA==", "bodyText": "Any reason to use a reactive stream here only to block it? Instead could a Stream be used? Another option, based on the logic here, we could have a local instance of the String[] and just access and return the last element in the list.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372083144", "createdAt": "2020-01-28T22:01:03Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5NDIxNg==", "bodyText": "I think I addressed the Stream concern above and the String[] concern below :)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372094216", "createdAt": "2020-01-28T22:27:27Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MzE0NA=="}, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDQ1MzQ4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjowMzo1NlrOFi2Opg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoyODowMFrOFi4KdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4NDM5MA==", "bodyText": "Given there is numerous calls to this method should the split pathString be stored as a field on the instance?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372084390", "createdAt": "2020-01-28T22:03:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw Utility.logError(logger, new IllegalArgumentException(String.format(\"Index %d is out of bounds\", i)));\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\", begin, end)));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        if (!path.getFileSystem().equals(this.parentFileSystem)) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot();\n+        String rootStr = root == null ? null : root.toString();\n+        for (String element : pathElements) {\n+            if (element.equals(\".\")) {\n+                continue;\n+            } else if (element.equals(\"..\")) {\n+                if (rootStr != null) {\n+                    // Root path. We never push \"..\".\n+                    if (!stack.isEmpty() && stack.peekLast().equals(rootStr)) {\n+                        // Cannot go higher than root. Ignore.\n+                        continue;\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                } else {\n+                    // Relative paths can have an arbitrary number of \"..\" at the beginning.\n+                    if (stack.isEmpty()) {\n+                        stack.addLast(element);\n+                    } else if (stack.peek().equals(\"..\")) {\n+                        stack.addLast(element);\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                }\n+            } else {\n+                stack.addLast(element);\n+            }\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(stack.toArray(), stack.size(), String[].class));\n     }\n \n     /**\n+     * If the other path has a root component, it is considered absolute, and it is returned.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+        if (path.getNameCount() == 0) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getPath(this.toString(), path.toString());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(String s) {\n-        return null;\n+        return this.resolve(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+\n+        Path parent = this.getParent();\n+        return parent == null ? path : parent.resolve(path);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(String s) {\n-        return null;\n+        return this.resolveSibling(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * If both paths have a root component, it is still to relativize one against the other.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path relativize(Path path) {\n-        return null;\n+        if (path.getRoot() == null ^ this.getRoot() == null) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(\"Both paths must be absolute or neither can be\"));\n+        }\n+\n+        AzurePath thisNormalized = (AzurePath) this.normalize();\n+        Path otherNormalized = path.normalize();\n+\n+        Deque<String> deque = new ArrayDeque<>(\n+            Arrays.asList(otherNormalized.toString().split(this.parentFileSystem.getSeparator())));\n+\n+        int i = 0;\n+        String[] thisElements = thisNormalized.splitToElements();\n+        while (i < thisElements.length && !deque.isEmpty() && thisElements[i].equals(deque.peekFirst())) {\n+            deque.removeFirst();\n+            i++;\n+        }\n+        while (i < thisElements.length) {\n+            deque.addFirst(\"..\");\n+            i++;\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(deque.toArray(), deque.size(), String[].class));\n     }\n \n     /**\n+     * No authority component is defined for the {@code URI} returned by this method. This implementation offers the\n+     * same equivalence guarantee as the default provider.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public URI toUri() {\n-        return null;\n+        try {\n+            return new URI(this.parentFileSystem.provider().getScheme(), null, \"/\" + this.toAbsolutePath().toString(),\n+                null, null);\n+        } catch (URISyntaxException e) {\n+            throw Utility.logError(logger, new IllegalStateException(\"Unable to create valid URI from path\", e));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toAbsolutePath() {\n-        return null;\n+        if (this.isAbsolute()) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getDefaultDirectory().resolve(this);\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toRealPath(LinkOption... linkOptions) throws IOException {\n-        return null;\n+        throw new UnsupportedOperationException(\"Symbolic links are not supported.\");\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public File toFile() {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n-    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers) throws IOException {\n-        throw new UnsupportedOperationException();\n+    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers)\n+        throws IOException {\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public WatchKey register(WatchService watchService, WatchEvent.Kind<?>... kinds) throws IOException {\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Iterator<Path> iterator() {\n-        return null;\n+        return Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .map(s -> this.parentFileSystem.getPath(s))\n+            .toIterable()\n+            .iterator();\n     }\n \n     /**\n+     * This result of this method is identical to a string comparison on the underlying path strings.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public int compareTo(Path path) {\n-        return 0;\n+        if (!(path instanceof AzurePath)) {\n+            throw Utility.logError(logger, new ClassCastException(\"Other path is not an instance of AzurePath.\"));\n+        }\n+\n+        return this.pathString.compareTo(((AzurePath) path).pathString);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.pathString;\n+    }\n+\n+    /**\n+     * A path is considered equal to another path if it is associated with the same file system instance and if the\n+     * path strings are equivalent.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        AzurePath paths = (AzurePath) o;\n+        return Objects.equals(parentFileSystem, paths.parentFileSystem)\n+            && Objects.equals(pathString, paths.pathString);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(parentFileSystem, pathString);\n+    }\n+\n+    // Used to ensure we only try to access containers that are mounted.\n+    boolean validRoot(String fileStoreName) {\n+        Boolean validRootName = Flux.fromIterable(parentFileSystem.getFileStores())\n+            .map(FileStore::name)\n+            .hasElement(fileStoreName)\n+            .block();\n+        return validRootName != null && validRootName;\n+    }\n+\n+    private String withoutRoot() {\n+        Path root = this.getRoot();\n+        String str = this.pathString;\n+        if (root != null) {\n+            str = this.pathString.substring(root.toString().length());\n+        }\n+        if (str.startsWith(this.parentFileSystem.getSeparator())) {\n+            str = str.substring(1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private String[] splitToElements() {\n+        return this.splitToElements(this.pathString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 548}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5MzU5Ng==", "bodyText": "I was wondering that as I wrote it. The consequence is that these objects basically double their memory usage, right? Since we would then store the pathString as one object and then all of its components again separately. I didn't feel like I had enough knowledge of customer scenarios to know if they were cpu or memory bound, so I was going to defer that decision until we hear one way or the other from customers unless you feel strongly about it. Does that make sense?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372093596", "createdAt": "2020-01-28T22:26:02Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw Utility.logError(logger, new IllegalArgumentException(String.format(\"Index %d is out of bounds\", i)));\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\", begin, end)));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        if (!path.getFileSystem().equals(this.parentFileSystem)) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot();\n+        String rootStr = root == null ? null : root.toString();\n+        for (String element : pathElements) {\n+            if (element.equals(\".\")) {\n+                continue;\n+            } else if (element.equals(\"..\")) {\n+                if (rootStr != null) {\n+                    // Root path. We never push \"..\".\n+                    if (!stack.isEmpty() && stack.peekLast().equals(rootStr)) {\n+                        // Cannot go higher than root. Ignore.\n+                        continue;\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                } else {\n+                    // Relative paths can have an arbitrary number of \"..\" at the beginning.\n+                    if (stack.isEmpty()) {\n+                        stack.addLast(element);\n+                    } else if (stack.peek().equals(\"..\")) {\n+                        stack.addLast(element);\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                }\n+            } else {\n+                stack.addLast(element);\n+            }\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(stack.toArray(), stack.size(), String[].class));\n     }\n \n     /**\n+     * If the other path has a root component, it is considered absolute, and it is returned.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+        if (path.getNameCount() == 0) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getPath(this.toString(), path.toString());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(String s) {\n-        return null;\n+        return this.resolve(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+\n+        Path parent = this.getParent();\n+        return parent == null ? path : parent.resolve(path);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(String s) {\n-        return null;\n+        return this.resolveSibling(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * If both paths have a root component, it is still to relativize one against the other.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path relativize(Path path) {\n-        return null;\n+        if (path.getRoot() == null ^ this.getRoot() == null) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(\"Both paths must be absolute or neither can be\"));\n+        }\n+\n+        AzurePath thisNormalized = (AzurePath) this.normalize();\n+        Path otherNormalized = path.normalize();\n+\n+        Deque<String> deque = new ArrayDeque<>(\n+            Arrays.asList(otherNormalized.toString().split(this.parentFileSystem.getSeparator())));\n+\n+        int i = 0;\n+        String[] thisElements = thisNormalized.splitToElements();\n+        while (i < thisElements.length && !deque.isEmpty() && thisElements[i].equals(deque.peekFirst())) {\n+            deque.removeFirst();\n+            i++;\n+        }\n+        while (i < thisElements.length) {\n+            deque.addFirst(\"..\");\n+            i++;\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(deque.toArray(), deque.size(), String[].class));\n     }\n \n     /**\n+     * No authority component is defined for the {@code URI} returned by this method. This implementation offers the\n+     * same equivalence guarantee as the default provider.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public URI toUri() {\n-        return null;\n+        try {\n+            return new URI(this.parentFileSystem.provider().getScheme(), null, \"/\" + this.toAbsolutePath().toString(),\n+                null, null);\n+        } catch (URISyntaxException e) {\n+            throw Utility.logError(logger, new IllegalStateException(\"Unable to create valid URI from path\", e));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toAbsolutePath() {\n-        return null;\n+        if (this.isAbsolute()) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getDefaultDirectory().resolve(this);\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toRealPath(LinkOption... linkOptions) throws IOException {\n-        return null;\n+        throw new UnsupportedOperationException(\"Symbolic links are not supported.\");\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public File toFile() {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n-    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers) throws IOException {\n-        throw new UnsupportedOperationException();\n+    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers)\n+        throws IOException {\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public WatchKey register(WatchService watchService, WatchEvent.Kind<?>... kinds) throws IOException {\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Iterator<Path> iterator() {\n-        return null;\n+        return Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .map(s -> this.parentFileSystem.getPath(s))\n+            .toIterable()\n+            .iterator();\n     }\n \n     /**\n+     * This result of this method is identical to a string comparison on the underlying path strings.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public int compareTo(Path path) {\n-        return 0;\n+        if (!(path instanceof AzurePath)) {\n+            throw Utility.logError(logger, new ClassCastException(\"Other path is not an instance of AzurePath.\"));\n+        }\n+\n+        return this.pathString.compareTo(((AzurePath) path).pathString);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.pathString;\n+    }\n+\n+    /**\n+     * A path is considered equal to another path if it is associated with the same file system instance and if the\n+     * path strings are equivalent.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        AzurePath paths = (AzurePath) o;\n+        return Objects.equals(parentFileSystem, paths.parentFileSystem)\n+            && Objects.equals(pathString, paths.pathString);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(parentFileSystem, pathString);\n+    }\n+\n+    // Used to ensure we only try to access containers that are mounted.\n+    boolean validRoot(String fileStoreName) {\n+        Boolean validRootName = Flux.fromIterable(parentFileSystem.getFileStores())\n+            .map(FileStore::name)\n+            .hasElement(fileStoreName)\n+            .block();\n+        return validRootName != null && validRootName;\n+    }\n+\n+    private String withoutRoot() {\n+        Path root = this.getRoot();\n+        String str = this.pathString;\n+        if (root != null) {\n+            str = this.pathString.substring(root.toString().length());\n+        }\n+        if (str.startsWith(this.parentFileSystem.getSeparator())) {\n+            str = str.substring(1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private String[] splitToElements() {\n+        return this.splitToElements(this.pathString);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4NDM5MA=="}, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 548}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExNjA4NA==", "bodyText": "That makes sense to me", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372116084", "createdAt": "2020-01-28T23:28:00Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw Utility.logError(logger, new IllegalArgumentException(String.format(\"Index %d is out of bounds\", i)));\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\", begin, end)));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        if (!path.getFileSystem().equals(this.parentFileSystem)) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot();\n+        String rootStr = root == null ? null : root.toString();\n+        for (String element : pathElements) {\n+            if (element.equals(\".\")) {\n+                continue;\n+            } else if (element.equals(\"..\")) {\n+                if (rootStr != null) {\n+                    // Root path. We never push \"..\".\n+                    if (!stack.isEmpty() && stack.peekLast().equals(rootStr)) {\n+                        // Cannot go higher than root. Ignore.\n+                        continue;\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                } else {\n+                    // Relative paths can have an arbitrary number of \"..\" at the beginning.\n+                    if (stack.isEmpty()) {\n+                        stack.addLast(element);\n+                    } else if (stack.peek().equals(\"..\")) {\n+                        stack.addLast(element);\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                }\n+            } else {\n+                stack.addLast(element);\n+            }\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(stack.toArray(), stack.size(), String[].class));\n     }\n \n     /**\n+     * If the other path has a root component, it is considered absolute, and it is returned.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+        if (path.getNameCount() == 0) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getPath(this.toString(), path.toString());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(String s) {\n-        return null;\n+        return this.resolve(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+\n+        Path parent = this.getParent();\n+        return parent == null ? path : parent.resolve(path);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(String s) {\n-        return null;\n+        return this.resolveSibling(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * If both paths have a root component, it is still to relativize one against the other.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path relativize(Path path) {\n-        return null;\n+        if (path.getRoot() == null ^ this.getRoot() == null) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(\"Both paths must be absolute or neither can be\"));\n+        }\n+\n+        AzurePath thisNormalized = (AzurePath) this.normalize();\n+        Path otherNormalized = path.normalize();\n+\n+        Deque<String> deque = new ArrayDeque<>(\n+            Arrays.asList(otherNormalized.toString().split(this.parentFileSystem.getSeparator())));\n+\n+        int i = 0;\n+        String[] thisElements = thisNormalized.splitToElements();\n+        while (i < thisElements.length && !deque.isEmpty() && thisElements[i].equals(deque.peekFirst())) {\n+            deque.removeFirst();\n+            i++;\n+        }\n+        while (i < thisElements.length) {\n+            deque.addFirst(\"..\");\n+            i++;\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(deque.toArray(), deque.size(), String[].class));\n     }\n \n     /**\n+     * No authority component is defined for the {@code URI} returned by this method. This implementation offers the\n+     * same equivalence guarantee as the default provider.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public URI toUri() {\n-        return null;\n+        try {\n+            return new URI(this.parentFileSystem.provider().getScheme(), null, \"/\" + this.toAbsolutePath().toString(),\n+                null, null);\n+        } catch (URISyntaxException e) {\n+            throw Utility.logError(logger, new IllegalStateException(\"Unable to create valid URI from path\", e));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toAbsolutePath() {\n-        return null;\n+        if (this.isAbsolute()) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getDefaultDirectory().resolve(this);\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toRealPath(LinkOption... linkOptions) throws IOException {\n-        return null;\n+        throw new UnsupportedOperationException(\"Symbolic links are not supported.\");\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public File toFile() {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n-    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers) throws IOException {\n-        throw new UnsupportedOperationException();\n+    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers)\n+        throws IOException {\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public WatchKey register(WatchService watchService, WatchEvent.Kind<?>... kinds) throws IOException {\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Iterator<Path> iterator() {\n-        return null;\n+        return Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .map(s -> this.parentFileSystem.getPath(s))\n+            .toIterable()\n+            .iterator();\n     }\n \n     /**\n+     * This result of this method is identical to a string comparison on the underlying path strings.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public int compareTo(Path path) {\n-        return 0;\n+        if (!(path instanceof AzurePath)) {\n+            throw Utility.logError(logger, new ClassCastException(\"Other path is not an instance of AzurePath.\"));\n+        }\n+\n+        return this.pathString.compareTo(((AzurePath) path).pathString);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.pathString;\n+    }\n+\n+    /**\n+     * A path is considered equal to another path if it is associated with the same file system instance and if the\n+     * path strings are equivalent.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        AzurePath paths = (AzurePath) o;\n+        return Objects.equals(parentFileSystem, paths.parentFileSystem)\n+            && Objects.equals(pathString, paths.pathString);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(parentFileSystem, pathString);\n+    }\n+\n+    // Used to ensure we only try to access containers that are mounted.\n+    boolean validRoot(String fileStoreName) {\n+        Boolean validRootName = Flux.fromIterable(parentFileSystem.getFileStores())\n+            .map(FileStore::name)\n+            .hasElement(fileStoreName)\n+            .block();\n+        return validRootName != null && validRootName;\n+    }\n+\n+    private String withoutRoot() {\n+        Path root = this.getRoot();\n+        String str = this.pathString;\n+        if (root != null) {\n+            str = this.pathString.substring(root.toString().length());\n+        }\n+        if (str.startsWith(this.parentFileSystem.getSeparator())) {\n+            str = str.substring(1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private String[] splitToElements() {\n+        return this.splitToElements(this.pathString);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4NDM5MA=="}, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 548}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3770, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}