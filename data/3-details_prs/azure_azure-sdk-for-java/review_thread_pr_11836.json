{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4ODA4NDg1", "number": 11836, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoyMDoxMlrOEDHPQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxNDoxNVrOEDIKrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjk5Nzc2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoyMDoxMlrOGf-6Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoyMDoxMlrOGf-6Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4OTc4Mg==", "bodyText": "Deletes a queue with matching {@code queueName}.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11836#discussion_r436189782", "createdAt": "2020-06-05T22:20:12Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClient.java", "diffHunk": "@@ -0,0 +1,202 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.messaging.servicebus.models.QueueDescription;\n+import com.azure.messaging.servicebus.models.QueueRuntimeInfo;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A <b>synchronous</b> client for managing a Service Bus namespace.\n+ *\n+ * @see ServiceBusManagementAsyncClient ServiceBusManagementAsyncClient for an asynchronous client.\n+ */\n+@ServiceClient(builder = ServiceBusManagementClientBuilder.class)\n+public class ServiceBusManagementClient {\n+    private final ServiceBusManagementAsyncClient asyncClient;\n+\n+    /**\n+     * Creates a new instance with the given client.\n+     *\n+     * @param asyncClient Asynchronous client to perform management calls through.\n+     */\n+    ServiceBusManagementClient(ServiceBusManagementAsyncClient asyncClient) {\n+        this.asyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+    }\n+\n+    /**\n+     * Creates a queue the {@link QueueDescription}.\n+     *\n+     * @param queue Information about the queue to create.\n+     *\n+     * @return The created queue.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public QueueDescription createQueue(QueueDescription queue) {\n+        return asyncClient.createQueue(queue).block();\n+    }\n+\n+    /**\n+     * Creates a queue and returns the created queue in addition to the HTTP response.\n+     *\n+     * @param queue The queue to create.\n+     * @param context Additional context that is passed through the HTTP pipeline during the service call.\n+     *\n+     * @return The created queue in addition to the HTTP response.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Response<QueueDescription> createQueueWithResponse(QueueDescription queue, Context context) {\n+        return asyncClient.createQueueWithResponse(queue, context).block();\n+    }\n+\n+    /**\n+     * Deletes a queue the matching {@code queueName}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9261853cf8c100b2405a51ddcf3210272055a3da"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE0NTAyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDowOToxNVrOGgAS4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDowOToxNVrOGgAS4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMjQ0OA==", "bodyText": "Package-private method  : I have never seen that writing in java doc, it is evident from the fact that there is no qualifier.\nI am fine with this but it is not usual.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11836#discussion_r436212448", "createdAt": "2020-06-06T00:09:15Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementAsyncClient.java", "diffHunk": "@@ -0,0 +1,619 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedResponse;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.QueuesImpl;\n+import com.azure.messaging.servicebus.implementation.ServiceBusManagementClientImpl;\n+import com.azure.messaging.servicebus.implementation.ServiceBusManagementSerializer;\n+import com.azure.messaging.servicebus.implementation.models.CreateQueueBody;\n+import com.azure.messaging.servicebus.implementation.models.CreateQueueBodyContent;\n+import com.azure.messaging.servicebus.implementation.models.QueueDescriptionFeed;\n+import com.azure.messaging.servicebus.implementation.models.ResponseLink;\n+import com.azure.messaging.servicebus.models.QueueDescription;\n+import com.azure.messaging.servicebus.models.QueueRuntimeInfo;\n+import reactor.core.Exceptions;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+/**\n+ * An <b>asynchronous</b> client for managing a Service Bus namespace.\n+ *\n+ * @see ServiceBusManagementClient ServiceBusManagementClient for a synchronous client.\n+ */\n+@ServiceClient(builder = ServiceBusManagementClientBuilder.class, isAsync = true)\n+public final class ServiceBusManagementAsyncClient {\n+    // See https://docs.microsoft.com/azure/azure-resource-manager/management/azure-services-resource-providers\n+    // for more information on Azure resource provider namespaces.\n+    private static final String SERVICE_BUS_TRACING_NAMESPACE_VALUE = \"Microsoft.ServiceBus\";\n+    // Name of the entity type when listing queues.\n+    private static final String QUEUES_ENTITY_TYPE = \"queues\";\n+    private static final int NUMBER_OF_ELEMENTS = 10;\n+\n+    private final ServiceBusManagementClientImpl managementClient;\n+    private final QueuesImpl queuesClient;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusManagementAsyncClient.class);\n+    private final ServiceBusManagementSerializer serializer;\n+\n+    /**\n+     * Creates a new instance with the given management client and serializer.\n+     *\n+     * @param managementClient Client to make management calls.\n+     * @param serializer Serializer to deserialize ATOM XML responses.\n+     */\n+    ServiceBusManagementAsyncClient(ServiceBusManagementClientImpl managementClient,\n+        ServiceBusManagementSerializer serializer) {\n+        this.managementClient = Objects.requireNonNull(managementClient, \"'managementClient' cannot be null.\");\n+        this.queuesClient = managementClient.getQueues();\n+        this.serializer = serializer;\n+    }\n+\n+    /**\n+     * Creates a queue the {@link QueueDescription}.\n+     *\n+     * @param queue Information about the queue to create.\n+     *\n+     * @return A Mono that completes with information about the created queue.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<QueueDescription> createQueue(QueueDescription queue) {\n+        return createQueueWithResponse(queue).map(Response::getValue);\n+    }\n+\n+    /**\n+     * Creates a queue and returns the created queue in addition to the HTTP response.\n+     *\n+     * @param queue The queue to create.\n+     *\n+     * @return A Mono that returns the created queue in addition to the HTTP response.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<QueueDescription>> createQueueWithResponse(QueueDescription queue) {\n+        return withContext(context -> createQueueWithResponse(queue, context));\n+    }\n+\n+    /**\n+     * Deletes a queue the matching {@code queueName}.\n+     *\n+     * @param queueName Name of queue to delete.\n+     *\n+     * @return A Mono that completes when the queue is deleted.\n+     * @throws NullPointerException if {@code queueName} is null.\n+     * @throws IllegalArgumentException if {@code queueName} is an empty string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> deleteQueue(String queueName) {\n+        return deleteQueueWithResponse(queueName).then();\n+    }\n+\n+    /**\n+     * Deletes a queue the matching {@code queueName} and returns the HTTP response.\n+     *\n+     * @param queueName Name of queue to delete.\n+     *\n+     * @return A Mono that completes when the queue is deleted and returns the HTTP response.\n+     * @throws NullPointerException if {@code queueName} is null.\n+     * @throws IllegalArgumentException if {@code queueName} is an empty string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<Void>> deleteQueueWithResponse(String queueName) {\n+        return withContext(context -> deleteQueueWithResponse(queueName, context));\n+    }\n+\n+    /**\n+     * Gets information about the queue.\n+     *\n+     * @param queueName Name of queue to get information about.\n+     *\n+     * @return A Mono that completes with information about the queue.\n+     * @throws NullPointerException if {@code queueName} is null or an empty string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<QueueDescription> getQueue(String queueName) {\n+        return getQueueWithResponse(queueName).map(Response::getValue);\n+    }\n+\n+    /**\n+     * Gets information about the queue along with its HTTP response.\n+     *\n+     * @param queueName Name of queue to get information about.\n+     *\n+     * @return A Mono that completes with information about the queue and the associated HTTP response.\n+     * @throws NullPointerException if {@code queueName} is null or an empty string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<QueueDescription>> getQueueWithResponse(String queueName) {\n+        return withContext(context -> getQueueWithResponse(queueName, context));\n+    }\n+\n+    /**\n+     * Gets runtime information about the queue.\n+     *\n+     * @param queueName Name of queue to get information about.\n+     *\n+     * @return A Mono that completes with runtime information about the queue.\n+     * @throws NullPointerException if {@code queueName} is null or an empty string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<QueueRuntimeInfo> getQueueRuntimeInfo(String queueName) {\n+        return getQueueWithResponse(queueName).map(response -> new QueueRuntimeInfo(response.getValue()));\n+    }\n+\n+    /**\n+     * Gets runtime information about the queue along with its HTTP response.\n+     *\n+     * @param queueName Name of queue to get information about.\n+     *\n+     * @return A Mono that completes with runtime information about the queue and the associated HTTP response.\n+     * @throws NullPointerException if {@code queueName} is null or an empty string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<QueueRuntimeInfo>> getQueueRuntimeInfoWithResponse(String queueName) {\n+        return withContext(context -> getQueueRuntimeInfoWithResponse(queueName, context));\n+    }\n+\n+    /**\n+     * Fetches all the queues in the Service Bus namespace.\n+     *\n+     * @return A Flux of {@link QueueDescription queues} in the Service Bus namespace.\n+     */\n+    @ServiceMethod(returns = ReturnType.COLLECTION)\n+    public PagedFlux<QueueDescription> listQueues() {\n+        return new PagedFlux<>(\n+            () -> withContext(context -> listQueuesFirstPage(context)),\n+            token -> withContext(context -> listQueuesNextPage(token, context)));\n+    }\n+\n+    /**\n+     * Creates a queue the {@link QueueDescription}.\n+     *\n+     * @param queue Information about the queue to create.\n+     *\n+     * @return A Mono that completes with information about the created queue.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<QueueDescription> updateQueue(QueueDescription queue) {\n+        return updateQueueWithResponse(queue).map(Response::getValue);\n+    }\n+\n+    /**\n+     * Creates a queue and returns the created queue in addition to the HTTP response.\n+     *\n+     * @param queue The queue to create.\n+     *\n+     * @return A Mono that returns the created queue in addition to the HTTP response.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<QueueDescription>> updateQueueWithResponse(QueueDescription queue) {\n+        return withContext(context -> updateQueueWithResponse(queue, context));\n+    }\n+\n+    /**\n+     * Package-private method that creates a queue with its context.\n+     *\n+     * @param queue Queue to create.\n+     * @param context Context to pass into request.\n+     *\n+     * @return A Mono that completes with the created {@link QueueDescription}.\n+     */\n+    Mono<Response<QueueDescription>> createQueueWithResponse(QueueDescription queue, Context context) {\n+        if (queue == null) {\n+            return monoError(logger, new NullPointerException(\"'queue' cannot be null\"));\n+        } else if (queue.getName() == null || queue.getName().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'queue.getName' cannot be null or empty.\"));\n+        } else if (context == null) {\n+            return monoError(logger, new NullPointerException(\"'context' cannot be null.\"));\n+        }\n+\n+        final CreateQueueBodyContent content = new CreateQueueBodyContent()\n+            .setType(\"application/xml\")\n+            .setQueueDescription(queue);\n+        final CreateQueueBody createEntity = new CreateQueueBody()\n+            .setContent(content);\n+\n+        context.addData(AZ_TRACING_NAMESPACE_KEY, SERVICE_BUS_TRACING_NAMESPACE_VALUE);\n+\n+        try {\n+            return queuesClient.putWithResponseAsync(queue.getName(), createEntity, null, context)\n+                .map(response -> deserializeQueue(response, queue.getName()));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Package-private method that deletes a queue with its context.\n+     *\n+     * @param queueName Name of queue to delete.\n+     * @param context Context to pass into request.\n+     *\n+     * @return A Mono that completes with the created {@link QueueDescription}.\n+     */\n+    Mono<Response<Void>> deleteQueueWithResponse(String queueName, Context context) {\n+        if (queueName == null) {\n+            return monoError(logger, new NullPointerException(\"'queueName' cannot be null\"));\n+        } else if (queueName.isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'queueName' cannot be empty.\"));\n+        } else if (context == null) {\n+            return monoError(logger, new NullPointerException(\"'context' cannot be null.\"));\n+        }\n+\n+        context.addData(AZ_TRACING_NAMESPACE_KEY, SERVICE_BUS_TRACING_NAMESPACE_VALUE);\n+\n+        try {\n+            return queuesClient.deleteWithResponseAsync(queueName, context)\n+                .map(response -> {\n+                    return new SimpleResponse<>(response.getRequest(), response.getStatusCode(),\n+                        response.getHeaders(), null);\n+                });\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Package-private method that gets a queue with its context.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfb2d50c717903d673dd86ca697e033e52b7bc2c"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE0ODI2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxMjoyMVrOGgAUuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMzo0OTozMVrOGgBpJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMjkyMQ==", "bodyText": "queueDescription  as  arg name will be more appropriate ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11836#discussion_r436212921", "createdAt": "2020-06-06T00:12:21Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClient.java", "diffHunk": "@@ -0,0 +1,202 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.messaging.servicebus.models.QueueDescription;\n+import com.azure.messaging.servicebus.models.QueueRuntimeInfo;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A <b>synchronous</b> client for managing a Service Bus namespace.\n+ *\n+ * @see ServiceBusManagementAsyncClient ServiceBusManagementAsyncClient for an asynchronous client.\n+ */\n+@ServiceClient(builder = ServiceBusManagementClientBuilder.class)\n+public final class ServiceBusManagementClient {\n+    private final ServiceBusManagementAsyncClient asyncClient;\n+\n+    /**\n+     * Creates a new instance with the given client.\n+     *\n+     * @param asyncClient Asynchronous client to perform management calls through.\n+     */\n+    ServiceBusManagementClient(ServiceBusManagementAsyncClient asyncClient) {\n+        this.asyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+    }\n+\n+    /**\n+     * Creates a queue the {@link QueueDescription}.\n+     *\n+     * @param queue Information about the queue to create.\n+     *\n+     * @return The created queue.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public QueueDescription createQueue(QueueDescription queue) {\n+        return asyncClient.createQueue(queue).block();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfb2d50c717903d673dd86ca697e033e52b7bc2c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzNDUzNQ==", "bodyText": "Went with .NET's parameter name.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11836#discussion_r436234535", "createdAt": "2020-06-06T03:49:31Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClient.java", "diffHunk": "@@ -0,0 +1,202 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.messaging.servicebus.models.QueueDescription;\n+import com.azure.messaging.servicebus.models.QueueRuntimeInfo;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A <b>synchronous</b> client for managing a Service Bus namespace.\n+ *\n+ * @see ServiceBusManagementAsyncClient ServiceBusManagementAsyncClient for an asynchronous client.\n+ */\n+@ServiceClient(builder = ServiceBusManagementClientBuilder.class)\n+public final class ServiceBusManagementClient {\n+    private final ServiceBusManagementAsyncClient asyncClient;\n+\n+    /**\n+     * Creates a new instance with the given client.\n+     *\n+     * @param asyncClient Asynchronous client to perform management calls through.\n+     */\n+    ServiceBusManagementClient(ServiceBusManagementAsyncClient asyncClient) {\n+        this.asyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+    }\n+\n+    /**\n+     * Creates a queue the {@link QueueDescription}.\n+     *\n+     * @param queue Information about the queue to create.\n+     *\n+     * @return The created queue.\n+     * @throws NullPointerException if {@code queue} is null.\n+     * @throws IllegalArgumentException if {@link QueueDescription#getName() queue.getName()} is null or an empty\n+     *     string.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public QueueDescription createQueue(QueueDescription queue) {\n+        return asyncClient.createQueue(queue).block();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMjkyMQ=="}, "originalCommit": {"oid": "cfb2d50c717903d673dd86ca697e033e52b7bc2c"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE0OTkwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxNDoxNVrOGgAVvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxNDoxNVrOGgAVvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzE4Mg==", "bodyText": "Should we check for endpoint could be null and throw NPE ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11836#discussion_r436213182", "createdAt": "2020-06-06T00:14:15Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusManagementClientBuilder.java", "diffHunk": "@@ -0,0 +1,326 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersFromContextPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusManagementClientImpl;\n+import com.azure.messaging.servicebus.implementation.ServiceBusManagementClientImplBuilder;\n+import com.azure.messaging.servicebus.implementation.ServiceBusManagementSerializer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import com.azure.messaging.servicebus.implementation.ServiceBusTokenCredentialHttpPolicy;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * This class provides a fluent builder API to help aid the configuration and instantiation of {@link\n+ * ServiceBusManagementClient} and {@link ServiceBusManagementAsyncClient}. Call {@link #buildClient() buildClient} and\n+ * {@link #buildAsyncClient() buildAsyncClient} respectively to construct an instance of the desired client.\n+ *\n+ * @see ServiceBusManagementClient\n+ * @see ServiceBusManagementAsyncClient\n+ */\n+@ServiceClientBuilder(serviceClients = {ServiceBusManagementClient.class, ServiceBusManagementAsyncClient.class})\n+public class ServiceBusManagementClientBuilder {\n+    // We only allow one service version because the ATOM API was brought forward for legacy reasons.\n+    private static final String API_VERSION = \"2017-04\";\n+    private final ClientLogger logger = new ClientLogger(ServiceBusManagementClientBuilder.class);\n+    private final ServiceBusManagementSerializer serializer = new ServiceBusManagementSerializer();\n+    private final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+    private final Map<String, String> properties =\n+        CoreUtils.getProperties(\"azure-messaging-servicebus.properties\");\n+\n+    private Configuration configuration;\n+\n+    // Endpoint of the Service Bus resource. It will be the fully-qualified domain name of the Service Bus namespace.\n+    private String endpoint;\n+    private HttpClient httpClient;\n+    private HttpLogOptions httpLogOptions = new HttpLogOptions();\n+    private HttpPipeline pipeline;\n+    private HttpPipelinePolicy retryPolicy;\n+    private TokenCredential tokenCredential;\n+\n+    /**\n+     * Constructs a builder with the default parameters.\n+     */\n+    public ServiceBusManagementClientBuilder() {\n+    }\n+\n+    /**\n+     * Creates a {@link ServiceBusManagementAsyncClient} based on options set in the builder. Every time {@code\n+     * buildAsyncClient} is invoked, a new instance of the client is created.\n+     *\n+     * <p>If {@link #pipeline(HttpPipeline) pipeline} is set, then the {@code pipeline} and\n+     * {@link #endpoint(String) endpoint} are used to create the {@link ServiceBusManagementAsyncClient client}. All\n+     * other builder settings are ignored.</p>\n+     *\n+     * @return A {@link ServiceBusManagementAsyncClient} with the options set in the builder.\n+     * @throws NullPointerException if {@code endpoint} has not been set. This is automatically set when {@link\n+     *     #connectionString(String) connectionString} is set. Or, explicitly through {@link #endpoint(String)}.\n+     * @throws IllegalStateException If {@link #connectionString(String) connectionString} has not been set.\n+     */\n+    public ServiceBusManagementAsyncClient buildAsyncClient() {\n+        if (endpoint == null) {\n+            throw new NullPointerException(\"'endpoint' cannot be null.\");\n+        }\n+\n+        final HttpPipeline httpPipeline = buildPipeline();\n+        final ServiceBusManagementClientImpl client = new ServiceBusManagementClientImplBuilder()\n+            .pipeline(httpPipeline)\n+            .serializer(serializer)\n+            .endpoint(endpoint)\n+            .apiVersion(API_VERSION)\n+            .buildClient();\n+\n+        return new ServiceBusManagementAsyncClient(client, serializer);\n+    }\n+\n+    /**\n+     * Creates a {@link ServiceBusManagementClient} based on options set in the builder. Every time {@code\n+     * buildAsyncClient} is invoked, a new instance of the client is created.\n+     *\n+     * <p>If {@link #pipeline(HttpPipeline) pipeline} is set, then the {@code pipeline} and\n+     * {@link #endpoint(String) endpoint} are used to create the {@link ServiceBusManagementClient client}. All other\n+     * builder settings are ignored.</p>\n+     *\n+     * @return A {@link ServiceBusManagementClient} with the options set in the builder.\n+     * @throws NullPointerException if {@code endpoint} has not been set. This is automatically set when {@link\n+     *     #connectionString(String) connectionString} is set. Or it can be set explicitly through {@link\n+     *     #endpoint(String)}.\n+     * @throws IllegalStateException If {@link #connectionString(String) connectionString} has not been set.\n+     */\n+    public ServiceBusManagementClient buildClient() {\n+        return new ServiceBusManagementClient(buildAsyncClient());\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     *\n+     * @return The updated {@link ServiceBusManagementClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public ServiceBusManagementClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        Objects.requireNonNull(policy);\n+        policies.add(policy);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Service Bus namespace.\n+     *\n+     * @param endpoint The URL of the Service Bus namespace.\n+     *\n+     * @return The updated {@link ServiceBusManagementClientBuilder} object.\n+     * @throws IllegalArgumentException if {@code endpoint} is null or it cannot be parsed into a valid URL.\n+     */\n+    public ServiceBusManagementClientBuilder endpoint(String endpoint) {\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfb2d50c717903d673dd86ca697e033e52b7bc2c"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4010, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}