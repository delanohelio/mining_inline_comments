{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjE1MDQ2", "number": 9194, "title": "Add APIs to Log Checked Exceptions as Warning and Error", "bodyText": "Fixes #7633 and #9190\nThis PR adds two new APIs to ClientLogger to support logging checked exceptions as either a warning or error, logCheckedExceptionAsWarning and logCheckedExceptionAsError. These APIs fill a gap in functionality where it is expected that exceptions are logged but there was no APIs to support logging Throwable based exceptions, there was only support for RuntimeException subclasses.\nThis PR has a few additional minor changes that were added as well.\n\nFixed an issue where logExceptionAsError was using VERBOSE as the log level instead of the expected ERROR level.\nRemoved slf4j-simple test dependencies from all Azure Core modules. This fixes part of a long term goal to completely remove this from all modules.\nAdds 5 as a supported environment variable for AZURE_LOG_LEVEL to configure the NOT_SET log level.", "createdAt": "2020-03-18T19:08:14Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194", "merged": true, "mergeCommit": {"oid": "dff992ba8ce6772de8b2c9c32265b6dad92af79c"}, "closed": true, "closedAt": "2020-03-19T01:07:19Z", "author": {"login": "alzimmermsft"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOrHeJAH2gAyMzkwNjE1MDQ2OmVkMjIyN2Q1ZDZjMzE3OGU4YWM0NjkzMTExNDNhMjhhNTllMDlhZTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcO_jm2AH2gAyMzkwNjE1MDQ2OmM5MDVmODY1ZWFjYzA5YzI2YTA4ZTFjZDA1YmRhZTlkYWUzNGNmOWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ed2227d5d6c3178e8ac469311143a28a59e09ae4", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed2227d5d6c3178e8ac469311143a28a59e09ae4", "committedDate": "2020-03-17T23:15:06Z", "message": "Add APIs to log checked exceptions as warning or errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a449baea071c7d7debb3f8c2ae54fc588c003cd", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a449baea071c7d7debb3f8c2ae54fc588c003cd", "committedDate": "2020-03-18T16:17:45Z", "message": "Merge branch 'master' into AzCore_EnhanceClientLogger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d0a5174257d1ad764ea0435febbe8e03f220040c", "committedDate": "2020-03-18T19:01:43Z", "message": "Enhanced tests, added '5' as a valid LogLevel environment configuration to support 'NOT_SET'"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTYxNjA5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#pullrequestreview-377161609", "createdAt": "2020-03-18T19:13:24Z", "commit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToxMzoyNFrOF4TUdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToxNzowM1rOF4Tbuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTExMA==", "bodyText": "Can this be changed to catch IOException instead?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394581110", "createdAt": "2020-03-18T19:13:24Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/util/logging/ClientLoggerTests.java", "diffHunk": "@@ -57,233 +58,167 @@ public void revertLoggingConfiguration() throws Exception {\n         logCaptureStream.close();\n     }\n \n-    private void setPropertyToOriginalOrClear(String propertyName, String originalValue) {\n-        if (CoreUtils.isNullOrEmpty(originalValue)) {\n-            System.clearProperty(propertyName);\n-        } else {\n-            System.setProperty(propertyName, originalValue);\n-        }\n-    }\n-\n     /**\n-     * Tests that logging at the same level as the environment logging level will log.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether the logger supports a given log level based on its configured log level.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3, 4 })\n-    public void logAtSupportedLevel(int logLevel) {\n-        String logMessage = \"This is a test\";\n-\n-        String originalLogLevel = setupLogLevel(logLevel);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void canLogAtLevel(LogLevel logLevelToConfigure, LogLevel logLevelToValidate, boolean expected) {\n+        setupLogLevel(logLevelToConfigure.getLogLevel());\n+        assertEquals(expected, new ClientLogger(ClientLoggerTests.class).canLogAtLevel(logLevelToValidate));\n     }\n \n     /**\n-     * Tests that logging at a level that is less than the environment logging level doesn't log anything.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether a log will be captured when the ClientLogger and message are configured to the passed log levels.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3 })\n-    public void logAtUnsupportedLevel(int logLevel) {\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void log(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage) {\n         String logMessage = \"This is a test\";\n \n-        String originalLogLevel = setupLogLevel(logLevel + 1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertFalse(logValues.contains(logMessage));\n-    }\n-\n-    /**\n-     * Tests that logging when the environment log level is disabled nothing is logged.\n-     */\n-    @Test\n-    public void logWhenLoggingNotSet() {\n-        assertEquals(LogLevel.NOT_SET, LogLevel.fromString(null));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level isn't VERBOSE only log the exception message.\n-     */\n-    @Test\n-    public void onlyLogExceptionMessage() {\n-        String logMessage = \"This is an exception\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n-\n-        String originalLogLevel = setupLogLevel(2);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level is VERBOSE the stack trace is logged.\n-     */\n-    @Test\n-    public void logExceptionStackTrace() {\n-        String logMessage = \"This is an exception fdsafdafdomcklamfd fdsafdafmlkdfmalsf fdsafdcacdalmd\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests whether a log will contain the exception message when the ClientLogger and message are configured to the\n+     * passed log levels.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithErrorLevel() {\n+    @ParameterizedTest\n+    @MethodSource(\"multiLevelCheckSupplier\")\n+    public void logException(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String logMessage = \"This is an exception\";\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        RuntimeException runtimeException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 4, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage, runtimeException);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n+        assertEquals(logContainsStackTrace, logValues.contains(runtimeException.getStackTrace()[0].toString()));\n     }\n \n-\n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a RuntimeException as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithNoLogLevel() {\n-        String logMessage = \"This is an exception\";\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 5, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.isEmpty());\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a Throwable as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionWithInvalidLogLevel() {\n-        String logMessage = \"This is an exception\";\n-        Object runtimeException = new Object();\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logCheckedExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n+        String exceptionMessage = \"An exception message\";\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsWarning(ioException);\n+        } catch (Throwable throwable) {\n+            assertTrue(throwable instanceof IOException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(ioException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning won't include the stack trace when the environment log level isn't\n-     * VERBOSE. Additionally, this tests that the exception message isn't logged twice as logging an exception uses\n-     * the exception message as the format string.\n+     * Tests that logging a RuntimeException as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningOnlyExceptionMessage() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(2);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsError(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(exceptionMessage + System.lineSeparator()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning will include the stack trace when the environment log level is set to\n-     * VERBOSE.\n+     * Tests that logging a Throwable as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningStackTrace() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logCheckedExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsError(ioException);\n+        } catch (Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Mjk3MQ==", "bodyText": "Since this applies to all throwables, we can name this logThrowableAsError", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394582971", "createdAt": "2020-03-18T19:17:03Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -134,37 +135,76 @@ public void error(String format, Object... args) {\n \n     /**\n      * Logs the {@link RuntimeException} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsWarning(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n-     * @return The passed {@code RuntimeException}.\n+     * @return The passed {@link RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsWarning(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsWarning(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsWarning(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsWarning(T checkedException) {\n+        Objects.requireNonNull(checkedException, \"'checkedException' cannot be null.\");\n         if (!logger.isWarnEnabled()) {\n-            return runtimeException;\n+            return checkedException;\n         }\n \n-        performLogging(LogLevel.WARNING, true, runtimeException.getMessage(), runtimeException);\n-        return runtimeException;\n+        performLogging(LogLevel.WARNING, true, checkedException.getMessage(), checkedException);\n+        return checkedException;\n     }\n \n     /**\n      * Logs the {@link RuntimeException} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsError(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n      * @return The passed {@code RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsError(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsError(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsError(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsError(T checkedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05f35e4188b54b5c470d4c218d70c57588b715c0", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/05f35e4188b54b5c470d4c218d70c57588b715c0", "committedDate": "2020-03-18T19:33:58Z", "message": "Rename new APIs to something better, add opens for logging package, added missing property reset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9fa6ad49644228454940e228ff7b0b6797ac06c", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9fa6ad49644228454940e228ff7b0b6797ac06c", "committedDate": "2020-03-18T19:49:19Z", "message": "Merge branch 'master' into AzCore_EnhanceClientLogger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cfd97169027587356b48074ba340420a714e4df", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0cfd97169027587356b48074ba340420a714e4df", "committedDate": "2020-03-18T20:36:16Z", "message": "Merge branch 'master' into AzCore_EnhanceClientLogger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffd5a2e92505883f18fff50103d505cef614c70e", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffd5a2e92505883f18fff50103d505cef614c70e", "committedDate": "2020-03-18T20:57:23Z", "message": "Additional logging changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c905f865eacc09c26a08e1cd05bdae9dae34cf9f", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c905f865eacc09c26a08e1cd05bdae9dae34cf9f", "committedDate": "2020-03-18T23:03:56Z", "message": "Update logging tests to mutate global configuration"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 724, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}