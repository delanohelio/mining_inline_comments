{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NzIzNjYz", "number": 7749, "title": "Nio path2", "bodyText": "", "createdAt": "2020-01-27T21:55:09Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749", "merged": true, "mergeCommit": {"oid": "9de161181f6e6d1f95ee33a39df536676b1f9183"}, "closed": true, "closedAt": "2020-01-29T00:19:42Z", "author": {"login": "rickle-msft"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9oDqpgH2gAyMzY3NzIzNjYzOjdjZTU3MTQ0ZWVhODdiYjgxNzE2YTRiMDE1MmIxZmZhMWIyNDkwMTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-6X9jAFqTM0OTc4NzcxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7ce57144eea87bb81716a4b0152b1ffa1b249017", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ce57144eea87bb81716a4b0152b1ffa1b249017", "committedDate": "2020-01-25T00:04:31Z", "message": "Started on path impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e947fa6000077020207adbd2474bf442907aac2", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0e947fa6000077020207adbd2474bf442907aac2", "committedDate": "2020-01-25T00:04:48Z", "message": "more methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bad0d4101c05b53fc704365af799963c4241fc6", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4bad0d4101c05b53fc704365af799963c4241fc6", "committedDate": "2020-01-25T00:05:06Z", "message": "More path methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38fae9ace938be29b776e8e4f4809f42d9decba4", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/38fae9ace938be29b776e8e4f4809f42d9decba4", "committedDate": "2020-01-25T00:05:23Z", "message": "Finished path method impls and docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5645689129f2ab09111b2434ba90ae3dcf8a2d48", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5645689129f2ab09111b2434ba90ae3dcf8a2d48", "committedDate": "2020-01-25T00:05:42Z", "message": "path tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d563cb1692f462da79858d0048dcfbf9c5d31b08", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d563cb1692f462da79858d0048dcfbf9c5d31b08", "committedDate": "2020-01-25T00:12:38Z", "message": "Pom update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dba893acc0d20a015489e79055eaf3a0259798b3", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dba893acc0d20a015489e79055eaf3a0259798b3", "committedDate": "2020-01-25T00:21:52Z", "message": "Added design doc to package root"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e0df6409d325e71cee00f1b4690bc0c9634d779", "committedDate": "2020-01-27T21:52:23Z", "message": "checkstyle and spotbugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDAzOTgx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349003981", "createdAt": "2020-01-27T21:57:14Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMTo1NzoxNFrOFiS4oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMTo1NzoxNFrOFiS4oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwNTMxMg==", "bodyText": "Should log these and others", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371505312", "createdAt": "2020-01-27T21:57:14Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDA2MDAz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349006003", "createdAt": "2020-01-27T22:00:48Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowMDo0OFrOFiS-7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowMDo0OFrOFiS-7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwNjkyNg==", "bodyText": "Should use splitToElements", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371506926", "createdAt": "2020-01-27T22:00:48Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -38,18 +89,29 @@ public FileSystem getFileSystem() {\n     }\n \n     /**\n+     * A path is considered absolute in this file system if it contains a root component.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean isAbsolute() {\n-        return false;\n+        return this.getRoot() != null;\n     }\n \n     /**\n+     * The root component of this path also identifies the Azure Storage Container in which the file is stored. This\n+     * method will not validate that the root component corresponds to an actual file store/container in this\n+     * file system. It will simply return the root component of the path if one is present and syntactically valid.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getRoot() {\n+        // Check if the first element of the path is formatted like a root directory.\n+        String firstElement = pathString.split(parentFileSystem.getSeparator())[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDA5MDQ2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349009046", "createdAt": "2020-01-27T22:06:14Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNjoxNFrOFiTIOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNjoxNFrOFiTIOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTMwNg==", "bodyText": "Just use .equals. It's clear and safer and evidently equivalent.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371509306", "createdAt": "2020-01-27T22:06:14Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 200}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDA5NTcz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349009573", "createdAt": "2020-01-27T22:07:07Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNzowN1rOFiTJ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNzowN1rOFiTJ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTc0MA==", "bodyText": "What about a path with \"..\"? In other words, should we normalize first?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371509740", "createdAt": "2020-01-27T22:07:07Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 210}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDEwMzYw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349010360", "createdAt": "2020-01-27T22:08:35Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowODozNVrOFiTMXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowODozNVrOFiTMXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMDM2NQ==", "bodyText": "Can remove the todo as the root validity check is gone.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371510365", "createdAt": "2020-01-27T22:08:35Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot(); // Refactor so this doesn't access the fs per docs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 281}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDEyMzAy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349012302", "createdAt": "2020-01-27T22:12:24Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjoxMjoyNFrOFiTSYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjoxMjoyNFrOFiTSYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMTkwNg==", "bodyText": "Add a comment here to explain that this is the special case where we split after removing the root of a path that is just the root.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371511906", "createdAt": "2020-01-27T22:12:24Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -226,14 +451,89 @@ public WatchKey register(WatchService watchService, WatchEvent.Kind<?>... kinds)\n      */\n     @Override\n     public Iterator<Path> iterator() {\n-        return null;\n+        return Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .map(s -> this.parentFileSystem.getPath(s))\n+            .toIterable()\n+            .iterator();\n     }\n \n     /**\n+     * This result of this method is identical to a string comparison on the underlying path strings.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public int compareTo(Path path) {\n-        return 0;\n+        if (!(path instanceof AzurePath)) {\n+            throw Utility.logError(logger, new ClassCastException(\"Other path is not an instance of AzurePath.\"));\n+        }\n+\n+        return this.pathString.compareTo(((AzurePath) path).pathString);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.pathString;\n+    }\n+\n+    /**\n+     * A path is considered equal to another path if it is associated with the same file system instance and if the\n+     * path strings are equivalent.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        AzurePath paths = (AzurePath) o;\n+        return Objects.equals(parentFileSystem, paths.parentFileSystem)\n+            && Objects.equals(pathString, paths.pathString);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(parentFileSystem, pathString);\n+    }\n+\n+    // Used to ensure we only try to access containers that are mounted.\n+    boolean validRoot(String fileStoreName) {\n+        Boolean validRootName = Flux.fromIterable(parentFileSystem.getFileStores())\n+            .map(FileStore::name)\n+            .hasElement(fileStoreName)\n+            .block();\n+        return validRootName != null && validRootName;\n+    }\n+\n+    private String withoutRoot() {\n+        Path root = this.getRoot();\n+        String str = this.pathString;\n+        if (root != null) {\n+            str = this.pathString.substring(root.toString().length());\n+        }\n+        if (str.startsWith(this.parentFileSystem.getSeparator())) {\n+            str = str.substring(1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private String[] splitToElements() {\n+        return this.splitToElements(this.pathString);\n+    }\n+\n+    private String[] splitToElements(String str) {\n+        String[] arr = str.split(this.parentFileSystem.getSeparator());\n+        if (arr.length == 1 && arr[0].isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 548}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDM3MzI0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349037324", "createdAt": "2020-01-27T23:04:38Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNDozOFrOFiUg_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNDozOFrOFiUg_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMjAzMA==", "bodyText": "This needs the groupId entry which should be\ngroupId: com.azure", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371532030", "createdAt": "2020-01-27T23:04:38Z", "author": {"login": "JimSuplizio"}, "path": "sdk/storage/ci.yml", "diffHunk": "@@ -57,6 +57,9 @@ stages:\n           groupId: com.azure\n           safeName: azurestorageblobcryptography\n           stagingProfileId: 88192f04117501\n+        - name: azure-storage-blob-nio\n+          safeName: azurestorageblobnio", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDM4MjAy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349038202", "createdAt": "2020-01-27T23:06:47Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNjo0N1rOFiUj0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowNjo0N1rOFiUj0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMjc1Mg==", "bodyText": "This doesn't need to be reviewed, just a translation of the original design doc", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371532752", "createdAt": "2020-01-27T23:06:47Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/DesignDoc.md", "diffHunk": "@@ -0,0 +1,235 @@\n+# Azure Storage NIO Design Doc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDM5MTkx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349039191", "createdAt": "2020-01-27T23:09:06Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowOTowNlrOFiUmuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzowOTowNlrOFiUmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMzQ5OQ==", "bodyText": "is there a reason for the ? or am I misreading this sentence.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371533499", "createdAt": "2020-01-27T23:09:06Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "diffHunk": "@@ -215,6 +215,9 @@ public String getSeparator() {\n     }\n \n     /**\n+     * ':' is only allowed in the root component. Root component will be validated against the list of\n+     * file shares?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDQyODA3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349042807", "createdAt": "2020-01-27T23:17:44Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoxNzo0NFrOFiUyrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoxNzo0NFrOFiUyrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzNjU1OQ==", "bodyText": "Could this be made into more of a bulleted list, kind of like\nAn error will only be thrown for\n\nan invalid root when trying to access a file in that root if it does not exist\na nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371536559", "createdAt": "2020-01-27T23:17:44Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDQzODc0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349043874", "createdAt": "2020-01-27T23:20:34Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoyMDozNFrOFiU2OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzoyMDozNFrOFiU2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzNzQ2NA==", "bodyText": "can the name of the strings and s variable be more descriptive? are they paths?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371537464", "createdAt": "2020-01-27T23:20:34Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * only be thrown for an invalid root when trying to access a file in that root if it does not exist and for an\n+ * nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n     AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDQ3NTgw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349047580", "createdAt": "2020-01-27T23:30:20Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzozMDoyMVrOFiVCxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMzozMDoyMVrOFiVCxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0MDY3OA==", "bodyText": "Add Unsupported in javadoc", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r371540678", "createdAt": "2020-01-27T23:30:21Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,162 +120,325 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\",\n+                begin, end));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot(); // Refactor so this doesn't access the fs per docs\n+        String rootStr = root == null ? null : root.toString();\n+        for (String element : pathElements) {\n+            if (element.equals(\".\")) {\n+                continue;\n+            } else if (element.equals(\"..\")) {\n+                if (rootStr != null) {\n+                    // Root path. We never push \"..\".\n+                    if (!stack.isEmpty() && stack.peekLast().equals(rootStr)) {\n+                        // Cannot go higher than root. Ignore.\n+                        continue;\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                } else {\n+                    // Relative paths can have an arbitrary number of \"..\" at the beginning.\n+                    if (stack.isEmpty()) {\n+                        stack.addLast(element);\n+                    } else if (stack.peek().equals(\"..\")) {\n+                        stack.addLast(element);\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                }\n+            } else {\n+                stack.addLast(element);\n+            }\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(stack.toArray(), stack.size(), String[].class));\n     }\n \n     /**\n+     * If the other path has a root component, it is considered absolute, and it is returned.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+        if (path.getNameCount() == 0) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getPath(this.toString(), path.toString());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(String s) {\n-        return null;\n+        return this.resolve(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+\n+        Path parent = this.getParent();\n+        return parent == null ? path : parent.resolve(path);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(String s) {\n-        return null;\n+        return this.resolveSibling(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * If both paths have a root component, it is still to relativize one against the other.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path relativize(Path path) {\n-        return null;\n+        if (path.getRoot() == null ^ this.getRoot() == null) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(\"Both paths must be absolute or neither can be\"));\n+        }\n+\n+        AzurePath thisNormalized = (AzurePath) this.normalize();\n+        Path otherNormalized = path.normalize();\n+\n+        Deque<String> deque = new ArrayDeque<>(\n+            Arrays.asList(otherNormalized.toString().split(this.parentFileSystem.getSeparator())));\n+\n+        int i = 0;\n+        String[] thisElements = thisNormalized.splitToElements();\n+        while (i < thisElements.length && !deque.isEmpty() && thisElements[i].equals(deque.peekFirst())) {\n+            deque.removeFirst();\n+            i++;\n+        }\n+        while (i < thisElements.length) {\n+            deque.addFirst(\"..\");\n+            i++;\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(deque.toArray(), deque.size(), String[].class));\n     }\n \n     /**\n+     * No authority component is defined for the {@code URI} returned by this method. This implementation offers the\n+     * same equivalence guarantee as the default provider.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public URI toUri() {\n-        return null;\n+        try {\n+            return new URI(this.parentFileSystem.provider().getScheme(), null, \"/\" + this.toAbsolutePath().toString(),\n+                null, null);\n+        } catch (URISyntaxException e) {\n+            throw Utility.logError(logger, new IllegalStateException(\"Unable to create valid URI from path\", e));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toAbsolutePath() {\n-        return null;\n+        if (this.isAbsolute()) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getDefaultDirectory().resolve(this);\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toRealPath(LinkOption... linkOptions) throws IOException {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 435}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NjU3NDg0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349657484", "createdAt": "2020-01-28T19:52:25Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f848159fd983542bfb4c5ce2ca176ff813ef08f8", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f848159fd983542bfb4c5ce2ca176ff813ef08f8", "committedDate": "2020-01-28T21:23:24Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4f708f160b50e181c7bc9aedc39d7d878b1b0353", "committedDate": "2020-01-28T21:26:31Z", "message": "ci.yml update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NzE1NzU0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349715754", "createdAt": "2020-01-28T21:27:44Z", "commit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NzEyOTMz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349712933", "createdAt": "2020-01-28T21:22:59Z", "commit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToyMzowMFrOFi1DVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjowMzo1NlrOFi2Opg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2NTExMA==", "bodyText": "Does this need to be a Flux? Instead could we use a synchronous Stream? I'm always hesitant on blocking reactive streams as this may be used in a reactive stream which could cause an exception to be thrown.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372065110", "createdAt": "2020-01-28T21:23:00Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,81 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * only be thrown for an invalid root when trying to access a file in that root if it does not exist and for an\n+ * nonexistent path when trying to access the resource at that location if it does not exist or is inaccessible.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n     AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+        if (strings == null) {\n+            strings = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e0df6409d325e71cee00f1b4690bc0c9634d779"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MDQyOA==", "bodyText": "Could this be simplified to an iterative approach such as the following?\nList<String> elements = Arrays.asList(first.split(parentFileSystem.getSeparator()));\n\nfor (String next : more) {\n  elements.addAll(Arrays.asList(more.split(parentFileSystem.getSeparator())));\n}\n\nStream elementStream = elements.stream().filter(CoreUtils::isNullOrEmpty);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372080428", "createdAt": "2020-01-28T21:55:16Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MjM4MQ==", "bodyText": "I'm a bit confused on the logic happening here. Is this validating that other than the first element in the stream none may match ROOT_DIR_SUFFIX, then validate that the first element contains ROOT_DIR_SUFFIX and it's last character is that value?\nBased on my other suggestion of using a list instead of a reactive stream would that make this validation much simpler? Would need to access the last element and first element only.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372082381", "createdAt": "2020-01-28T21:59:21Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());\n+\n+        this.pathString = String.join(this.parentFileSystem.getSeparator(), elementFlux.toIterable());\n+\n+        // No element but the first may contain \":\"\n+        elementFlux.skip(1)\n+            .flatMap(str -> str.contains(ROOT_DIR_SUFFIX)\n+                ? Mono.error(Utility.logError(logger, new InvalidPathException(this.pathString, ROOT_DIR_SUFFIX\n+                + \" is an invalid character except to identify the root element of this path if there is one.\")))\n+            : Mono.just(str)).blockLast();\n+\n+        // There may only be at most one instance of \":\" in the root component, and it must be the last character.\n+        elementFlux.take(1)\n+            .flatMap(str -> str.contains(ROOT_DIR_SUFFIX) && str.indexOf(ROOT_DIR_SUFFIX) < str.length() - 1\n+            ? Mono.error(Utility.logError(logger, new InvalidPathException(this.pathString, ROOT_DIR_SUFFIX + \" may\"\n+                + \" only be used as the last character in the root component of a path\")))\n+            : Mono.just(str)).blockLast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MjUzOA==", "bodyText": "What happens here if there is only a single element in the reactive stream?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372082538", "createdAt": "2020-01-28T21:59:41Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -3,30 +3,80 @@\n \n package com.azure.storage.blob.nio;\n \n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.nio.implementation.util.Utility;\n import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n \n import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileStore;\n import java.nio.file.FileSystem;\n+import java.nio.file.InvalidPathException;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.WatchEvent;\n import java.nio.file.WatchKey;\n import java.nio.file.WatchService;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n import java.util.Iterator;\n+import java.util.Objects;\n \n /**\n+ * The root component, if it is present, is the first element of the path and is denoted by a {@code ':'} as the last\n+ * character. Hence, only one instance of {@code ':'} may appear in a path string and it may only be the last character\n+ * of the first element in the path. The root component is used to identify which container a path belongs to.\n+ * <p>\n+ * Constructing a syntactically valid path does not ensure a resource exists at the given path. An error will\n+ * not be thrown until trying to access an invalid resource, e.g. trying to access a resource that does not exist.\n+ * <p>\n+ * Path names are case sensitive.\n+ * <p>\n+ * If a resource is accessed via a relative path, it will be resolved against the default directory of the file system.\n+ * The default directory is as defined in the {@link AzureFileSystem} docs.\n+ * <p>\n+ * Leading and trailing separators will be stripped. This has the effect of making \"foo/\" and \"foo\" equivalent paths.\n+ *\n  * {@inheritDoc}\n  */\n public final class AzurePath implements Path {\n+    private final ClientLogger logger = new ClientLogger(AzurePath.class);\n+    private static final String ROOT_DIR_SUFFIX = \":\";\n+\n     private final AzureFileSystem parentFileSystem;\n     private final String pathString;\n \n-    AzurePath(AzureFileSystem parentFileSystem, String s, String... strings) {\n+    AzurePath(AzureFileSystem parentFileSystem, String first, String... more) {\n+        if (more == null) {\n+            more = new String[0]; // Just to make processing easier later. This wont affect the result.\n+        }\n         this.parentFileSystem = parentFileSystem;\n-        this.pathString = String.join(this.parentFileSystem.getSeparator(),\n-                Flux.just(s).concatWith(Flux.just(strings)).toIterable());\n+        Flux<String> elementFlux =\n+            // Strip any trailing, leading, or internal delimiters so there are no duplicates when we join.\n+            Flux.fromArray(first.split(this.parentFileSystem.getSeparator()))\n+                .concatWith(Flux.fromArray(more)\n+                    .flatMap(str -> Flux.fromArray(str.split(this.parentFileSystem.getSeparator()))))\n+                .filter(str -> !str.isEmpty());\n+\n+        this.pathString = String.join(this.parentFileSystem.getSeparator(), elementFlux.toIterable());\n+\n+        // No element but the first may contain \":\"\n+        elementFlux.skip(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MzE0NA==", "bodyText": "Any reason to use a reactive stream here only to block it? Instead could a Stream be used? Another option, based on the logic here, we could have a local instance of the String[] and just access and return the last element in the list.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372083144", "createdAt": "2020-01-28T22:01:03Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4NDM5MA==", "bodyText": "Given there is numerous calls to this method should the split pathString be stored as a field on the instance?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#discussion_r372084390", "createdAt": "2020-01-28T22:03:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzurePath.java", "diffHunk": "@@ -58,182 +119,422 @@ public Path getRoot() {\n      */\n     @Override\n     public Path getFileName() {\n-        return null;\n+        if (this.withoutRoot().isEmpty()) {\n+            return null;\n+        } else {\n+            return this.parentFileSystem.getPath(Flux.fromArray(this.splitToElements()).last().block());\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getParent() {\n-        return null;\n+        /*\n+        If this path only has one element, there is no parent. Note the root is included in the parent, so we don't\n+        use getNameCount here.\n+         */\n+        if (this.splitToElements().length == 1) {\n+            return null;\n+        }\n+\n+        return this.parentFileSystem.getPath(\n+            this.pathString.substring(0, this.pathString.lastIndexOf(this.parentFileSystem.getSeparator())));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public int getNameCount() {\n-        return 0;\n+        return this.splitToElements(this.withoutRoot()).length;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path getName(int i) {\n-        return null;\n+        if (i < 0 || i >= this.getNameCount()) {\n+            throw Utility.logError(logger, new IllegalArgumentException(String.format(\"Index %d is out of bounds\", i)));\n+        }\n+        return this.parentFileSystem.getPath(this.splitToElements(this.withoutRoot())[i]);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Path subpath(int i, int i1) {\n-        return null;\n+    public Path subpath(int begin, int end) {\n+        if (begin < 0 || begin >= this.getNameCount()\n+            || end <= begin || end > this.getNameCount()) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(String.format(\"Values of begin: %d and end: %d are invalid\", begin, end)));\n+        }\n+\n+        Iterable<String> subnames = Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .skip(begin)\n+            .take(end - begin)\n+            .toIterable();\n+\n+        return this.parentFileSystem.getPath(String.join(this.parentFileSystem.getSeparator(), subnames));\n     }\n \n     /**\n+     * In this implementation, a root component starts with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(Path path) {\n-        return false;\n+        if (!path.getFileSystem().equals(this.parentFileSystem)) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).splitToElements();\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < otherPathElements.length; i++) {\n+            if (!otherPathElements[i].equals(thisPathElements[i])) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean startsWith(String s) {\n-        return false;\n+        return this.startsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * In this implementation, a root component ends with another root component if the two root components are\n+     * equivalent strings. In other words, if the files are stored in the same container.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(Path path) {\n-        return false;\n+        /*\n+        There can only be one instance of a file system with a given id, so comparing object identity is equivalent\n+        to checking ids here.\n+         */\n+        if (path.getFileSystem() != this.parentFileSystem) {\n+            return false;\n+        }\n+\n+        String[] thisPathElements = this.splitToElements();\n+        String[] otherPathElements = ((AzurePath) path).pathString.split(this.parentFileSystem.getSeparator());\n+        if (otherPathElements.length > thisPathElements.length) {\n+            return false;\n+        }\n+        // If the given path has a root component, the paths must be equal.\n+        if (path.getRoot() != null && otherPathElements.length != thisPathElements.length) {\n+            return false;\n+        }\n+        for (int i = 1; i <= otherPathElements.length; i++) {\n+            if (!otherPathElements[otherPathElements.length - i]\n+                .equals(thisPathElements[thisPathElements.length - i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean endsWith(String s) {\n-        return false;\n+        return this.endsWith(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * This file system follows the standard practice mentioned in the original docs.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path normalize() {\n-        return null;\n+        Deque<String> stack = new ArrayDeque<>();\n+        String[] pathElements = this.splitToElements();\n+        Path root = this.getRoot();\n+        String rootStr = root == null ? null : root.toString();\n+        for (String element : pathElements) {\n+            if (element.equals(\".\")) {\n+                continue;\n+            } else if (element.equals(\"..\")) {\n+                if (rootStr != null) {\n+                    // Root path. We never push \"..\".\n+                    if (!stack.isEmpty() && stack.peekLast().equals(rootStr)) {\n+                        // Cannot go higher than root. Ignore.\n+                        continue;\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                } else {\n+                    // Relative paths can have an arbitrary number of \"..\" at the beginning.\n+                    if (stack.isEmpty()) {\n+                        stack.addLast(element);\n+                    } else if (stack.peek().equals(\"..\")) {\n+                        stack.addLast(element);\n+                    } else {\n+                        stack.removeLast();\n+                    }\n+                }\n+            } else {\n+                stack.addLast(element);\n+            }\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(stack.toArray(), stack.size(), String[].class));\n     }\n \n     /**\n+     * If the other path has a root component, it is considered absolute, and it is returned.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+        if (path.getNameCount() == 0) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getPath(this.toString(), path.toString());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolve(String s) {\n-        return null;\n+        return this.resolve(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(Path path) {\n-        return null;\n+        if (path.isAbsolute()) {\n+            return path;\n+        }\n+\n+        Path parent = this.getParent();\n+        return parent == null ? path : parent.resolve(path);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path resolveSibling(String s) {\n-        return null;\n+        return this.resolveSibling(this.parentFileSystem.getPath(s));\n     }\n \n     /**\n+     * If both paths have a root component, it is still to relativize one against the other.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Path relativize(Path path) {\n-        return null;\n+        if (path.getRoot() == null ^ this.getRoot() == null) {\n+            throw Utility.logError(logger,\n+                new IllegalArgumentException(\"Both paths must be absolute or neither can be\"));\n+        }\n+\n+        AzurePath thisNormalized = (AzurePath) this.normalize();\n+        Path otherNormalized = path.normalize();\n+\n+        Deque<String> deque = new ArrayDeque<>(\n+            Arrays.asList(otherNormalized.toString().split(this.parentFileSystem.getSeparator())));\n+\n+        int i = 0;\n+        String[] thisElements = thisNormalized.splitToElements();\n+        while (i < thisElements.length && !deque.isEmpty() && thisElements[i].equals(deque.peekFirst())) {\n+            deque.removeFirst();\n+            i++;\n+        }\n+        while (i < thisElements.length) {\n+            deque.addFirst(\"..\");\n+            i++;\n+        }\n+\n+        return this.parentFileSystem.getPath(\"\", Arrays.copyOf(deque.toArray(), deque.size(), String[].class));\n     }\n \n     /**\n+     * No authority component is defined for the {@code URI} returned by this method. This implementation offers the\n+     * same equivalence guarantee as the default provider.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public URI toUri() {\n-        return null;\n+        try {\n+            return new URI(this.parentFileSystem.provider().getScheme(), null, \"/\" + this.toAbsolutePath().toString(),\n+                null, null);\n+        } catch (URISyntaxException e) {\n+            throw Utility.logError(logger, new IllegalStateException(\"Unable to create valid URI from path\", e));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toAbsolutePath() {\n-        return null;\n+        if (this.isAbsolute()) {\n+            return this;\n+        }\n+        return this.parentFileSystem.getDefaultDirectory().resolve(this);\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Path toRealPath(LinkOption... linkOptions) throws IOException {\n-        return null;\n+        throw new UnsupportedOperationException(\"Symbolic links are not supported.\");\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public File toFile() {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n-    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers) throws IOException {\n-        throw new UnsupportedOperationException();\n+    public WatchKey register(WatchService watchService, WatchEvent.Kind<?>[] kinds, WatchEvent.Modifier... modifiers)\n+        throws IOException {\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported.\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public WatchKey register(WatchService watchService, WatchEvent.Kind<?>... kinds) throws IOException {\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"WatchEvents are not supported.\");\n     }\n \n     /**\n+     * Unsupported\n+     * <p>\n      * {@inheritDoc}\n      */\n     @Override\n     public Iterator<Path> iterator() {\n-        return null;\n+        return Flux.fromArray(this.splitToElements(this.withoutRoot()))\n+            .map(s -> this.parentFileSystem.getPath(s))\n+            .toIterable()\n+            .iterator();\n     }\n \n     /**\n+     * This result of this method is identical to a string comparison on the underlying path strings.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public int compareTo(Path path) {\n-        return 0;\n+        if (!(path instanceof AzurePath)) {\n+            throw Utility.logError(logger, new ClassCastException(\"Other path is not an instance of AzurePath.\"));\n+        }\n+\n+        return this.pathString.compareTo(((AzurePath) path).pathString);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.pathString;\n+    }\n+\n+    /**\n+     * A path is considered equal to another path if it is associated with the same file system instance and if the\n+     * path strings are equivalent.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        AzurePath paths = (AzurePath) o;\n+        return Objects.equals(parentFileSystem, paths.parentFileSystem)\n+            && Objects.equals(pathString, paths.pathString);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(parentFileSystem, pathString);\n+    }\n+\n+    // Used to ensure we only try to access containers that are mounted.\n+    boolean validRoot(String fileStoreName) {\n+        Boolean validRootName = Flux.fromIterable(parentFileSystem.getFileStores())\n+            .map(FileStore::name)\n+            .hasElement(fileStoreName)\n+            .block();\n+        return validRootName != null && validRootName;\n+    }\n+\n+    private String withoutRoot() {\n+        Path root = this.getRoot();\n+        String str = this.pathString;\n+        if (root != null) {\n+            str = this.pathString.substring(root.toString().length());\n+        }\n+        if (str.startsWith(this.parentFileSystem.getSeparator())) {\n+            str = str.substring(1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private String[] splitToElements() {\n+        return this.splitToElements(this.pathString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f708f160b50e181c7bc9aedc39d7d878b1b0353"}, "originalPosition": 548}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64a4e9412eee015ce19efce69d67e56ef66bb852", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/64a4e9412eee015ce19efce69d67e56ef66bb852", "committedDate": "2020-01-28T23:18:42Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bee4e9483eddaf56d7345ce3918b5385c9b68875", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bee4e9483eddaf56d7345ce3918b5385c9b68875", "committedDate": "2020-01-28T23:48:19Z", "message": "Fixed some ci errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5Nzg3NzE4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7749#pullrequestreview-349787718", "createdAt": "2020-01-28T23:58:54Z", "commit": {"oid": "bee4e9483eddaf56d7345ce3918b5385c9b68875"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2603, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}