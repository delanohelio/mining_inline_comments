{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzU4MjYz", "number": 14781, "title": "Add models operations to twin lifecycle sample", "bodyText": "Add models operations to twin lifecycle sample", "createdAt": "2020-09-03T16:44:48Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781", "merged": true, "mergeCommit": {"oid": "f5fbc857e9d99d336bf20de80990a8376da27395"}, "closed": true, "closedAt": "2020-09-03T22:29:12Z", "author": {"login": "abhipsaMisra"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFTcn3gFqTQ4MjAyNDM0Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFX7v2AH2gAyNDc4NzU4MjYzOmM5NGU1ZDk4YWE2ODczNTdhMTZjM2FmY2I1NDk3MDY1ZTM2NmUxMjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDI0MzQy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482024342", "createdAt": "2020-09-03T16:46:19Z", "commit": {"oid": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0NjoxOVrOHMvMYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0NjoxOVrOHMvMYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExODE3Nw==", "bodyText": ".map(Response::getValue) returns null, which is not a valid return item from a Mono. So we need to map it to Mono.empty() instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483118177", "createdAt": "2020-09-03T16:46:19Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "diffHunk": "@@ -909,7 +909,7 @@ public HttpPipeline getHttpPipeline() {\n     @ServiceMethod(returns = ReturnType.SINGLE)\n     public Mono<Void> deleteModel(String modelId) {\n         return deleteModelWithResponse(modelId)\n-            .map(Response::getValue);\n+            .flatMap(voidResponse -> Mono.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDI1NjI2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482025626", "createdAt": "2020-09-03T16:48:07Z", "commit": {"oid": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0ODowOFrOHMvQQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0ODowOFrOHMvQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExOTE2OQ==", "bodyText": "This implementation is very long and verbose. I am trying to see how I could chain the list and delete operations together, I'll put up an update in the next PR.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483119169", "createdAt": "2020-09-03T16:48:08Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +98,250 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "committedDate": "2020-09-03T16:49:54Z", "message": "samples(adt): Add model operations to twin sample"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e65c336925e24ebcbc974559ec88a6188f9d3725", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e65c336925e24ebcbc974559ec88a6188f9d3725", "committedDate": "2020-09-03T16:49:00Z", "message": "minor"}, "afterCommit": {"oid": "48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "committedDate": "2020-09-03T16:49:54Z", "message": "samples(adt): Add model operations to twin sample"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f48f680a71b1923b7773bb1092fc2672e571519", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f48f680a71b1923b7773bb1092fc2672e571519", "committedDate": "2020-09-03T16:53:07Z", "message": "typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDMwNjcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482030672", "createdAt": "2020-09-03T16:54:52Z", "commit": {"oid": "3f48f680a71b1923b7773bb1092fc2672e571519"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo1NDo1MlrOHMvf2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo1NDo1MlrOHMvf2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyMzE2Mg==", "bodyText": "We should have been able to schedule the async API on a single thread, and forced them to run sequentially; however, I didn't have success with that.\nI am blocking the async API call for now, until I figure that out.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483123162", "createdAt": "2020-09-03T16:54:52Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +98,249 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(throwable -> {\n+                    if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"List relationships error: \" + throwable);\n+                    }\n+                })\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(throwable -> {\n+                    if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"List incoming relationships error: \" + throwable);\n+                    }\n+                })\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(throwable -> {\n+                            if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                                System.err.println(\"List relationships error: \" + throwable);\n+                            }\n+                        })\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n                     .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n+                        if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                            System.err.println(\"Delete twin error: \" + throwable);\n                         }\n                     })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.\n+                deleteTwinsLatch.await(MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+    }\n \n+    /**\n+     * Delete models created by FullLifecycleSample for the ADT service instance.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n+     */\n+    public static void deleteAllModels() throws InterruptedException {\n+        System.out.println(\"DELETING MODELS\");\n+\n+        // This is to ensure models are deleted in an order such that no other models are referencing it.\n+        List<String> models = asList(RoomModelId, WifiModelId, BuildingModelId, FloorModelId, HvacModelId);\n+\n+        // Call APIs to delete the models.\n+        // Note that we are blocking the async API call. This is to ensure models are deleted in an order such that no other models are referencing it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f48f680a71b1923b7773bb1092fc2672e571519"}, "originalPosition": 196}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fec01ea7b1d05a4c9efe7d5ada1b2f66b069ecbf", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fec01ea7b1d05a4c9efe7d5ada1b2f66b069ecbf", "committedDate": "2020-09-03T17:05:05Z", "message": "cannot infer type args in anonymous inner classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2ccee82ee92d5bc8620b347a631fe45ce0ccc33", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2ccee82ee92d5bc8620b347a631fe45ce0ccc33", "committedDate": "2020-09-03T19:23:31Z", "message": "add static func criteria for ignorning errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f02069ded426dc9f8028c6ca8b439650871d2f1f", "committedDate": "2020-09-03T19:26:16Z", "message": "remove latch assertions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTc0NzA1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482174705", "createdAt": "2020-09-03T20:20:14Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyMDoxNFrOHM2IUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyMDoxNFrOHM2IUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA==", "bodyText": "For each async delete? Can you elaborate what you mean here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483231824", "createdAt": "2020-09-03T20:20:14Z", "author": {"login": "bikamani"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 168}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTc4Mjkz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482178293", "createdAt": "2020-09-03T20:25:43Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyNTo0M1rOHM2VHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyNTo0M1rOHM2VHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTEwMw==", "bodyText": "Does Java support string interpolation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483235103", "createdAt": "2020-09-03T20:25:43Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTgwODA3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482180807", "createdAt": "2020-09-03T20:29:46Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyOTo0NlrOHM2c6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyOTo0NlrOHM2c6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzA5OA==", "bodyText": "Unfortunate that you have to know ahead of time how many items you are counting down. This presents a \"magic\" number, which can be confusing to someone else reviewing the code who doesn't realize the significance (this will be used to asynchronously delete 1 dt).\nAlso, in C# we have a general rule of not declaring a variable until it is needed (so it is more contextual). Does Java have a different standard of all variables at the top?\nFWIW, I think this could at least use a comment.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237098", "createdAt": "2020-09-03T20:29:46Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTgxNjQ5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482181649", "createdAt": "2020-09-03T20:31:08Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMTowOFrOHM2fUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMTowOFrOHM2fUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzcxMw==", "bodyText": "If Java doesn't have string interpolation, I'd think this would be much more readable as a string format (like below).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237713", "createdAt": "2020-09-03T20:31:08Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.\n+                deleteTwinsLatch.await(MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Delete models created by FullLifecycleSample for the ADT service instance.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n+     */\n+    public static void deleteAllModels() throws InterruptedException {\n+        System.out.println(\"DELETING MODELS\");\n+\n+        // This is to ensure models are deleted in an order such that no other models are referencing it.\n+        List<String> models = asList(RoomModelId, WifiModelId, BuildingModelId, FloorModelId, HvacModelId);\n \n+        // Call APIs to delete the models.\n+        // Note that we are blocking the async API call. This is to ensure models are deleted in an order such that no other models are referencing it.\n+        models\n+            .forEach(modelId -> {\n                 try {\n-                    // Verify that the list relationships and list incoming relationships async operations have completed.\n-                    if (deleteRelationshipsSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n-                        // Now the digital twin should be safe to delete\n-\n-                        // Call APIs to delete the twins.\n-                        client.deleteDigitalTwin(twinId)\n-                            .doOnSuccess(aVoid -> {\n-                                System.out.println(\"Deleted digital twin: \" + twinId);\n-                                deleteTwinsSemaphore.release();\n-                            })\n-                            .doOnError(throwable -> {\n-                                if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                                    deleteTwinsSemaphore.release();\n-                                } else {\n-                                    System.err.println(\"Could not delete digital twin \" + twinId + \" due to \" + throwable);\n-                                }\n-                            })\n-                            .subscribe();\n+                    client.deleteModel(modelId).block();\n+                    System.out.println(\"Deleted model: \" + modelId);\n+                } catch (ErrorResponseException ex) {\n+                    if (ex.getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"Could not delete model \" + modelId + \" due to \" + ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTgyNDcx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482182471", "createdAt": "2020-09-03T20:32:32Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTU5MDA5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482159009", "createdAt": "2020-09-03T19:59:39Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo1OTo0MFrOHM1fUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo1OTo0MFrOHM1fUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyMTMzMQ==", "bodyText": "Oops", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483221331", "createdAt": "2020-09-03T19:59:40Z", "author": {"login": "azabbasi"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "diffHunk": "@@ -788,7 +788,7 @@ public HttpPipeline getHttpPipeline() {\n                         objectPagedResponse.getHeaders(),\n                         convertedList,\n                         null,\n-                        ((PagedResponseBase) objectPagedResponse).getDeserializedHeaders());\n+                        ((ResponseBase) objectPagedResponse).getDeserializedHeaders());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTg1NDc1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#pullrequestreview-482185475", "createdAt": "2020-09-03T20:37:28Z", "commit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "committedDate": "2020-09-03T21:51:37Z", "message": "added additional comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "267370dcc1c6a32bfa56e8c7b90beb2a5fb41711", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/267370dcc1c6a32bfa56e8c7b90beb2a5fb41711", "committedDate": "2020-09-03T21:57:43Z", "message": "typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c94e5d98aa687357a16c3afcb5497065e366e126", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c94e5d98aa687357a16c3afcb5497065e366e126", "committedDate": "2020-09-03T21:59:56Z", "message": "add comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4859, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}