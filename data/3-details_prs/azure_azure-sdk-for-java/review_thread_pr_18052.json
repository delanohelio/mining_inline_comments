{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1MzgyNTM3", "number": 18052, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozODowMFrOFDE7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo1Nzo1MFrOFDvkoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzcwODU1OnYy", "diffSide": "RIGHT", "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozODowMFrOICjo0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTowOTowOFrOICpkOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MTk1Mw==", "bodyText": "This class name reads a bit funny to me. What about TokenAccessor? English is my second language though. :-)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18052#discussion_r539551953", "createdAt": "2020-12-09T18:38:00Z", "author": {"login": "JianpingChen"}, "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "diffHunk": "@@ -92,52 +58,85 @@ public CommunicationTokenCredential(TokenRefresher tokenRefresher) {\n \n     /**\n      * Create with serialized JWT token and a token supplier to auto-refresh the\n-     * token before it expires. Callback function tokenRefresher will be called ahead\n-     * of the token expiry by the number of minutes specified by\n+     * token before it expires. Callback function tokenRefresher will be called\n+     * ahead of the token expiry by the number of minutes specified by\n      * CallbackOffsetMinutes defaulted to two minutes. To modify this default, call\n      * setCallbackOffsetMinutes after construction\n      * \n      * @param tokenRefresher implementation to supply fresh token when reqested\n      * @param initialToken serialized JWT token\n-     * @param refreshProactively when set to true, turn on proactive fetching to\n-     *                           call tokenRefresher before token expiry by minutes\n-     *                           set with setCallbackOffsetMinutes or default value\n-     *                           of two minutes\n+     * @param refreshProactively when set to true, turn on proactive fetching to call\n+     *                           tokenRefresher before token expiry by minutes set\n+     *                           with setCallbackOffsetMinutes or default value of\n+     *                           two minutes\n      */\n-    public CommunicationTokenCredential(\n-        TokenRefresher tokenRefresher, \n-        String initialToken,\n-        boolean refreshProactively) \n-    {\n+    public CommunicationTokenCredential(TokenRefresher tokenRefresher, String initialToken,\n+            boolean refreshProactively) {\n         this(tokenRefresher);\n         Objects.requireNonNull(initialToken, \"'initialToken' cannot be null.\");\n         setToken(initialToken);\n-        tokenFuture = new TokenImmediate(accessToken);\n         if (refreshProactively) {\n             OffsetDateTime nextFetchTime = accessToken.getExpiresAt().minusMinutes(DEFAULT_EXPIRING_OFFSET_MINUTES);\n             fetchingTask = new FetchingTask(this, nextFetchTime);\n         }\n     }\n \n+    private class TokenNext extends Mono<AccessToken> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ced247712ad5bee4b53025a1024a63e78366680"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTA4Mg==", "bodyText": "Updated to TokenRetriever, hope that makes sense too", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18052#discussion_r539649082", "createdAt": "2020-12-09T21:09:08Z", "author": {"login": "minnieliu"}, "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "diffHunk": "@@ -92,52 +58,85 @@ public CommunicationTokenCredential(TokenRefresher tokenRefresher) {\n \n     /**\n      * Create with serialized JWT token and a token supplier to auto-refresh the\n-     * token before it expires. Callback function tokenRefresher will be called ahead\n-     * of the token expiry by the number of minutes specified by\n+     * token before it expires. Callback function tokenRefresher will be called\n+     * ahead of the token expiry by the number of minutes specified by\n      * CallbackOffsetMinutes defaulted to two minutes. To modify this default, call\n      * setCallbackOffsetMinutes after construction\n      * \n      * @param tokenRefresher implementation to supply fresh token when reqested\n      * @param initialToken serialized JWT token\n-     * @param refreshProactively when set to true, turn on proactive fetching to\n-     *                           call tokenRefresher before token expiry by minutes\n-     *                           set with setCallbackOffsetMinutes or default value\n-     *                           of two minutes\n+     * @param refreshProactively when set to true, turn on proactive fetching to call\n+     *                           tokenRefresher before token expiry by minutes set\n+     *                           with setCallbackOffsetMinutes or default value of\n+     *                           two minutes\n      */\n-    public CommunicationTokenCredential(\n-        TokenRefresher tokenRefresher, \n-        String initialToken,\n-        boolean refreshProactively) \n-    {\n+    public CommunicationTokenCredential(TokenRefresher tokenRefresher, String initialToken,\n+            boolean refreshProactively) {\n         this(tokenRefresher);\n         Objects.requireNonNull(initialToken, \"'initialToken' cannot be null.\");\n         setToken(initialToken);\n-        tokenFuture = new TokenImmediate(accessToken);\n         if (refreshProactively) {\n             OffsetDateTime nextFetchTime = accessToken.getExpiresAt().minusMinutes(DEFAULT_EXPIRING_OFFSET_MINUTES);\n             fetchingTask = new FetchingTask(this, nextFetchTime);\n         }\n     }\n \n+    private class TokenNext extends Mono<AccessToken> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MTk1Mw=="}, "originalCommit": {"oid": "8ced247712ad5bee4b53025a1024a63e78366680"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Nzc0NDMwOnYy", "diffSide": "RIGHT", "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/TokenRefresher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0NTo1OVrOICj9_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTowOToyMFrOICpktA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NzM3Mg==", "bodyText": "This is a public interface. IMHO, we'd need a better name. getTokenAsync?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18052#discussion_r539557372", "createdAt": "2020-12-09T18:45:59Z", "author": {"login": "JianpingChen"}, "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/TokenRefresher.java", "diffHunk": "@@ -12,5 +12,5 @@\n      * Asynchronous call to fetch a fresh token\n      * @return Wrapper for asynchronous call\n      */\n-    Future<String> getFetchTokenFuture();\n+    Mono<String> getFetchTokenNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ced247712ad5bee4b53025a1024a63e78366680"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTIwNA==", "bodyText": "Updated to getTokenAsync", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18052#discussion_r539649204", "createdAt": "2020-12-09T21:09:20Z", "author": {"login": "minnieliu"}, "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/TokenRefresher.java", "diffHunk": "@@ -12,5 +12,5 @@\n      * Asynchronous call to fetch a fresh token\n      * @return Wrapper for asynchronous call\n      */\n-    Future<String> getFetchTokenFuture();\n+    Mono<String> getFetchTokenNext();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NzM3Mg=="}, "originalCommit": {"oid": "8ced247712ad5bee4b53025a1024a63e78366680"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQwMzQ2OnYy", "diffSide": "RIGHT", "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNDo0NVrOIDXRNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNDo0NVrOIDXRNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5Nzg3Nw==", "bodyText": "We have a SimpleTokenCache that can be used here. It refreshes the token when it expires and also ensures that the refresh happens only once after each expiration period.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18052#discussion_r540397877", "createdAt": "2020-12-10T18:24:45Z", "author": {"login": "srnagar"}, "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "diffHunk": "@@ -92,52 +55,54 @@ public CommunicationTokenCredential(TokenRefresher tokenRefresher) {\n \n     /**\n      * Create with serialized JWT token and a token supplier to auto-refresh the\n-     * token before it expires. Callback function tokenRefresher will be called ahead\n-     * of the token expiry by the number of minutes specified by\n+     * token before it expires. Callback function tokenRefresher will be called\n+     * ahead of the token expiry by the number of minutes specified by\n      * CallbackOffsetMinutes defaulted to two minutes. To modify this default, call\n      * setCallbackOffsetMinutes after construction\n      * \n      * @param tokenRefresher implementation to supply fresh token when reqested\n      * @param initialToken serialized JWT token\n-     * @param refreshProactively when set to true, turn on proactive fetching to\n-     *                           call tokenRefresher before token expiry by minutes\n-     *                           set with setCallbackOffsetMinutes or default value\n-     *                           of two minutes\n+     * @param refreshProactively when set to true, turn on proactive fetching to call\n+     *                           tokenRefresher before token expiry by minutes set\n+     *                           with setCallbackOffsetMinutes or default value of\n+     *                           two minutes\n      */\n-    public CommunicationTokenCredential(\n-        TokenRefresher tokenRefresher, \n-        String initialToken,\n-        boolean refreshProactively) \n-    {\n+    public CommunicationTokenCredential(TokenRefresher tokenRefresher, String initialToken,\n+            boolean refreshProactively) {\n         this(tokenRefresher);\n         Objects.requireNonNull(initialToken, \"'initialToken' cannot be null.\");\n         setToken(initialToken);\n-        tokenFuture = new TokenImmediate(accessToken);\n         if (refreshProactively) {\n             OffsetDateTime nextFetchTime = accessToken.getExpiresAt().minusMinutes(DEFAULT_EXPIRING_OFFSET_MINUTES);\n             fetchingTask = new FetchingTask(this, nextFetchTime);\n         }\n     }\n \n+\n     /**\n      * Get Azure core access token from credential\n      * \n      * @return Asynchronous call to fetch actual token\n      * @throws ExecutionException when supplier throws this exception\n      * @throws InterruptedException when supplier throws this exception\n      */\n-    public Future<AccessToken> getToken() throws InterruptedException, ExecutionException {\n+    public Mono<AccessToken> getToken() throws InterruptedException, ExecutionException {\n         if (isClosed) {\n             throw logger.logExceptionAsError(\n                 new RuntimeException(\"getToken called on closed CommunicationTokenCredential object\"));\n         }\n-        if ((accessToken == null || accessToken.isExpired()) // no valid token to return\n-            && refresher != null // can refresh\n-            && (tokenFuture == null || tokenFuture.isDone())) { // no fetching in progress, proactive or on-demand \n-            fetchFreshToken();\n+        synchronized (this) {\n+            // no valid token to return and can refresh\n+            if ((accessToken == null || accessToken.isExpired()) && refresher != null) {\n+                return fetchFreshToken()\n+                    .map(token -> {\n+                        accessToken = tokenParser.parseJWTToken(token);\n+                        return accessToken;\n+                    });\n+                \n+            }\n+            return Mono.just(accessToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cacbfa6e5f3c40ccd3c92cc42e07fd196686d96"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NDY5NDczOnYy", "diffSide": "RIGHT", "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo1Nzo1MFrOIDi7fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo1Nzo1MFrOIDi7fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4ODkyNQ==", "bodyText": "As discussed, return a Mono.error() here instead of throwing an exception.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18052#discussion_r540588925", "createdAt": "2020-12-10T23:57:50Z", "author": {"login": "srnagar"}, "path": "sdk/communication/azure-communication-common/src/main/java/com/azure/communication/common/CommunicationTokenCredential.java", "diffHunk": "@@ -92,52 +55,55 @@ public CommunicationTokenCredential(TokenRefresher tokenRefresher) {\n \n     /**\n      * Create with serialized JWT token and a token supplier to auto-refresh the\n-     * token before it expires. Callback function tokenRefresher will be called ahead\n-     * of the token expiry by the number of minutes specified by\n+     * token before it expires. Callback function tokenRefresher will be called\n+     * ahead of the token expiry by the number of minutes specified by\n      * CallbackOffsetMinutes defaulted to two minutes. To modify this default, call\n      * setCallbackOffsetMinutes after construction\n      * \n      * @param tokenRefresher implementation to supply fresh token when reqested\n      * @param initialToken serialized JWT token\n-     * @param refreshProactively when set to true, turn on proactive fetching to\n-     *                           call tokenRefresher before token expiry by minutes\n-     *                           set with setCallbackOffsetMinutes or default value\n-     *                           of two minutes\n+     * @param refreshProactively when set to true, turn on proactive fetching to call\n+     *                           tokenRefresher before token expiry by minutes set\n+     *                           with setCallbackOffsetMinutes or default value of\n+     *                           two minutes\n      */\n-    public CommunicationTokenCredential(\n-        TokenRefresher tokenRefresher, \n-        String initialToken,\n-        boolean refreshProactively) \n-    {\n+    public CommunicationTokenCredential(TokenRefresher tokenRefresher, String initialToken,\n+            boolean refreshProactively) {\n         this(tokenRefresher);\n         Objects.requireNonNull(initialToken, \"'initialToken' cannot be null.\");\n         setToken(initialToken);\n-        tokenFuture = new TokenImmediate(accessToken);\n         if (refreshProactively) {\n             OffsetDateTime nextFetchTime = accessToken.getExpiresAt().minusMinutes(DEFAULT_EXPIRING_OFFSET_MINUTES);\n             fetchingTask = new FetchingTask(this, nextFetchTime);\n         }\n     }\n \n+\n     /**\n      * Get Azure core access token from credential\n      * \n      * @return Asynchronous call to fetch actual token\n      * @throws ExecutionException when supplier throws this exception\n      * @throws InterruptedException when supplier throws this exception\n      */\n-    public Future<AccessToken> getToken() throws InterruptedException, ExecutionException {\n+    public Mono<AccessToken> getToken() throws InterruptedException, ExecutionException {\n         if (isClosed) {\n             throw logger.logExceptionAsError(\n                 new RuntimeException(\"getToken called on closed CommunicationTokenCredential object\"));\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf63ccf4921469fae685c3ae579edf22feac73cb"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2682, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}