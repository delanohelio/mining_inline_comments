{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxODkxNzg4", "number": 14344, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyMTowN1rOEbq3RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNToyM1rOEbq9Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDQ5Mjg1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/AzureKeyVaultKeyWrapProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyMTowN1rOHFvASg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjo1MzozOFrOHGJ_hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NTA1MA==", "bodyText": "We should add some description to these class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475775050", "createdAt": "2020-08-24T17:21:07Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/AzureKeyVaultKeyWrapProvider.java", "diffHunk": "@@ -0,0 +1,94 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.encryption.EncryptionUtils;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+// TODO: moderakh remove blocking calls\n+public class AzureKeyVaultKeyWrapProvider implements EncryptionKeyWrapProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzIyMw==", "bodyText": "thanks. addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r476217223", "createdAt": "2020-08-25T06:53:38Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/AzureKeyVaultKeyWrapProvider.java", "diffHunk": "@@ -0,0 +1,94 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.encryption.EncryptionUtils;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+// TODO: moderakh remove blocking calls\n+public class AzureKeyVaultKeyWrapProvider implements EncryptionKeyWrapProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NTA1MA=="}, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDQ5OTY2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyMjo1N1rOHFvEoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjo1Mzo1NFrOHGKACg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjE2MA==", "bodyText": "logger ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475776160", "createdAt": "2020-08-24T17:22:57Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.cosmos.implementation.caches.AsyncCache;\n+import com.azure.security.keyvault.keys.KeyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.models.UnwrapResult;\n+import com.azure.security.keyvault.keys.cryptography.models.WrapResult;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import reactor.core.publisher.Mono;\n+\n+import java.net.URI;\n+\n+/**\n+ * Implements Core KeyVault access methods that uses the TODO: moderakh this doesn't need to be public. it is public due\n+ * to tests. FIXME\n+ * TODO: methods should be async moderakh\n+ */\n+public class KeyVaultAccessClient {\n+    private final AsyncCache<URI, KeyAsyncClient> akvClientCache;\n+    private final AsyncCache<URI, CryptographyAsyncClient> akvCryptoClientCache;\n+    private final KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory;\n+    private final KeyClientFactory keyClientFactory;\n+    private final CryptographyClientFactory cryptographyClientFactory;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultAccessClient}\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredentials factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = new KeyClientFactory();\n+        this.cryptographyClientFactory = new CryptographyClientFactory();\n+    }\n+\n+    /**\n+     * TODO: this doesn't need to be public moderakh Initializes a new instance of the {@link KeyVaultAccessClient}\n+     * class Invokes internal factory Methods.\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredential\n+     * @param keyClientFactory KeyClient Factory\n+     * @param cryptographyClientFactory KeyClient Factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory,\n+                                KeyClientFactory keyClientFactory,\n+                                CryptographyClientFactory cryptographyClientFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = keyClientFactory;\n+        this.cryptographyClientFactory = cryptographyClientFactory;\n+    }\n+\n+    /**\n+     * Unwrap the encrypted Key. Only supports encrypted bytes in base64 format.\n+     *\n+     * Note: this may return an empty Mono if cryptoClient returns empty/null\n+     *\n+     * @param wrappedKey encrypted bytes.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and decrypted bytes in base64 string format, can be convert to\n+     * bytes using Convert.FromBase64String().\n+     */\n+    public Mono<byte[]> unwrapKeyAsync(\n+        byte[] wrappedKey,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        UnwrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        Mono<CryptographyAsyncClient> cryptoClientMono = this.getCryptoClientAsync(keyVaultUriProperties);\n+\n+        // TODO: moderakh change to async\n+        CryptographyAsyncClient cryptoClient = cryptoClientMono.block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.unwrapKey(KeyVaultConstants.RsaOaep256, wrappedKey).block();\n+        } catch (AzureException ex) {\n+\n+            throw new KeyVaultAccessException();\n+            // TODO: set proper exception moderakh\n+            //            throw new KeyVaultAccessException(\n+            //                ex.Status,\n+            //                ex.ErrorCode,\n+            //                \"UnwrapKeyAsync:Failed to Unwrap the encrypted key.\",\n+            //                ex);\n+        }\n+\n+        if (keyOpResult == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"keyOpResult cannot be null\"));\n+        }\n+\n+        // may return null\n+        return Mono.justOrEmpty(keyOpResult.getKey());\n+    }\n+\n+    /**\n+     * Wrap the Key with latest Key version. Only supports bytes in base64 format.\n+     *\n+     * @param key plain text key.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and encrypted bytes in base64 string format.\n+     */\n+    public Mono<byte[]> wrapKeyAsync(\n+        byte[] key,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        WrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        CryptographyAsyncClient cryptoClient = this.getCryptoClientAsync(keyVaultUriProperties).block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.wrapKey(KeyVaultConstants.RsaOaep256, key).block();\n+        }\n+        // TODO: set proper exception moderakh moderakh\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"WrapKeyAsync: Failed to Wrap the data encryption key.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzM1NA==", "bodyText": "thanks addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r476217354", "createdAt": "2020-08-25T06:53:54Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.cosmos.implementation.caches.AsyncCache;\n+import com.azure.security.keyvault.keys.KeyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.models.UnwrapResult;\n+import com.azure.security.keyvault.keys.cryptography.models.WrapResult;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import reactor.core.publisher.Mono;\n+\n+import java.net.URI;\n+\n+/**\n+ * Implements Core KeyVault access methods that uses the TODO: moderakh this doesn't need to be public. it is public due\n+ * to tests. FIXME\n+ * TODO: methods should be async moderakh\n+ */\n+public class KeyVaultAccessClient {\n+    private final AsyncCache<URI, KeyAsyncClient> akvClientCache;\n+    private final AsyncCache<URI, CryptographyAsyncClient> akvCryptoClientCache;\n+    private final KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory;\n+    private final KeyClientFactory keyClientFactory;\n+    private final CryptographyClientFactory cryptographyClientFactory;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultAccessClient}\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredentials factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = new KeyClientFactory();\n+        this.cryptographyClientFactory = new CryptographyClientFactory();\n+    }\n+\n+    /**\n+     * TODO: this doesn't need to be public moderakh Initializes a new instance of the {@link KeyVaultAccessClient}\n+     * class Invokes internal factory Methods.\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredential\n+     * @param keyClientFactory KeyClient Factory\n+     * @param cryptographyClientFactory KeyClient Factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory,\n+                                KeyClientFactory keyClientFactory,\n+                                CryptographyClientFactory cryptographyClientFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = keyClientFactory;\n+        this.cryptographyClientFactory = cryptographyClientFactory;\n+    }\n+\n+    /**\n+     * Unwrap the encrypted Key. Only supports encrypted bytes in base64 format.\n+     *\n+     * Note: this may return an empty Mono if cryptoClient returns empty/null\n+     *\n+     * @param wrappedKey encrypted bytes.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and decrypted bytes in base64 string format, can be convert to\n+     * bytes using Convert.FromBase64String().\n+     */\n+    public Mono<byte[]> unwrapKeyAsync(\n+        byte[] wrappedKey,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        UnwrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        Mono<CryptographyAsyncClient> cryptoClientMono = this.getCryptoClientAsync(keyVaultUriProperties);\n+\n+        // TODO: moderakh change to async\n+        CryptographyAsyncClient cryptoClient = cryptoClientMono.block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.unwrapKey(KeyVaultConstants.RsaOaep256, wrappedKey).block();\n+        } catch (AzureException ex) {\n+\n+            throw new KeyVaultAccessException();\n+            // TODO: set proper exception moderakh\n+            //            throw new KeyVaultAccessException(\n+            //                ex.Status,\n+            //                ex.ErrorCode,\n+            //                \"UnwrapKeyAsync:Failed to Unwrap the encrypted key.\",\n+            //                ex);\n+        }\n+\n+        if (keyOpResult == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"keyOpResult cannot be null\"));\n+        }\n+\n+        // may return null\n+        return Mono.justOrEmpty(keyOpResult.getKey());\n+    }\n+\n+    /**\n+     * Wrap the Key with latest Key version. Only supports bytes in base64 format.\n+     *\n+     * @param key plain text key.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and encrypted bytes in base64 string format.\n+     */\n+    public Mono<byte[]> wrapKeyAsync(\n+        byte[] key,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        WrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        CryptographyAsyncClient cryptoClient = this.getCryptoClientAsync(keyVaultUriProperties).block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.wrapKey(KeyVaultConstants.RsaOaep256, key).block();\n+        }\n+        // TODO: set proper exception moderakh moderakh\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"WrapKeyAsync: Failed to Wrap the data encryption key.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjE2MA=="}, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUwMDQzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyMzoxMlrOHFvFHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjo1Mzo0OVrOHGJ_0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjI4NQ==", "bodyText": "logger ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475776285", "createdAt": "2020-08-24T17:23:12Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.cosmos.implementation.caches.AsyncCache;\n+import com.azure.security.keyvault.keys.KeyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.models.UnwrapResult;\n+import com.azure.security.keyvault.keys.cryptography.models.WrapResult;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import reactor.core.publisher.Mono;\n+\n+import java.net.URI;\n+\n+/**\n+ * Implements Core KeyVault access methods that uses the TODO: moderakh this doesn't need to be public. it is public due\n+ * to tests. FIXME\n+ * TODO: methods should be async moderakh\n+ */\n+public class KeyVaultAccessClient {\n+    private final AsyncCache<URI, KeyAsyncClient> akvClientCache;\n+    private final AsyncCache<URI, CryptographyAsyncClient> akvCryptoClientCache;\n+    private final KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory;\n+    private final KeyClientFactory keyClientFactory;\n+    private final CryptographyClientFactory cryptographyClientFactory;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultAccessClient}\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredentials factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = new KeyClientFactory();\n+        this.cryptographyClientFactory = new CryptographyClientFactory();\n+    }\n+\n+    /**\n+     * TODO: this doesn't need to be public moderakh Initializes a new instance of the {@link KeyVaultAccessClient}\n+     * class Invokes internal factory Methods.\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredential\n+     * @param keyClientFactory KeyClient Factory\n+     * @param cryptographyClientFactory KeyClient Factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory,\n+                                KeyClientFactory keyClientFactory,\n+                                CryptographyClientFactory cryptographyClientFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = keyClientFactory;\n+        this.cryptographyClientFactory = cryptographyClientFactory;\n+    }\n+\n+    /**\n+     * Unwrap the encrypted Key. Only supports encrypted bytes in base64 format.\n+     *\n+     * Note: this may return an empty Mono if cryptoClient returns empty/null\n+     *\n+     * @param wrappedKey encrypted bytes.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and decrypted bytes in base64 string format, can be convert to\n+     * bytes using Convert.FromBase64String().\n+     */\n+    public Mono<byte[]> unwrapKeyAsync(\n+        byte[] wrappedKey,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        UnwrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        Mono<CryptographyAsyncClient> cryptoClientMono = this.getCryptoClientAsync(keyVaultUriProperties);\n+\n+        // TODO: moderakh change to async\n+        CryptographyAsyncClient cryptoClient = cryptoClientMono.block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.unwrapKey(KeyVaultConstants.RsaOaep256, wrappedKey).block();\n+        } catch (AzureException ex) {\n+\n+            throw new KeyVaultAccessException();\n+            // TODO: set proper exception moderakh\n+            //            throw new KeyVaultAccessException(\n+            //                ex.Status,\n+            //                ex.ErrorCode,\n+            //                \"UnwrapKeyAsync:Failed to Unwrap the encrypted key.\",\n+            //                ex);\n+        }\n+\n+        if (keyOpResult == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"keyOpResult cannot be null\"));\n+        }\n+\n+        // may return null\n+        return Mono.justOrEmpty(keyOpResult.getKey());\n+    }\n+\n+    /**\n+     * Wrap the Key with latest Key version. Only supports bytes in base64 format.\n+     *\n+     * @param key plain text key.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and encrypted bytes in base64 string format.\n+     */\n+    public Mono<byte[]> wrapKeyAsync(\n+        byte[] key,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        WrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        CryptographyAsyncClient cryptoClient = this.getCryptoClientAsync(keyVaultUriProperties).block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.wrapKey(KeyVaultConstants.RsaOaep256, key).block();\n+        }\n+        // TODO: set proper exception moderakh moderakh\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"WrapKeyAsync: Failed to Wrap the data encryption key.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new KeyVaultAccessException();\n+        }\n+\n+        // key vault may return null\n+        return Mono.justOrEmpty(keyOpResult.getEncryptedKey());\n+    }\n+\n+    /**\n+     * Validate the Purge Protection AndSoft Delete Settings.\n+     *\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.\n+     * @return Whether The Customer has the correct Deletion Level.\n+     */\n+    public Mono<Boolean> validatePurgeProtectionAndSoftDeleteSettingsAsync(\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        KeyAsyncClient akvClient = this.getAkvClientAsync(keyVaultUriProperties).block();\n+        if (akvClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+        try {\n+            KeyVaultKey getKeyResponse = akvClient.getKey(keyVaultUriProperties.getKeyName()).block();\n+\n+            String keyDeletionRecoveryLevel = null;\n+            if (getKeyResponse != null && getKeyResponse.getProperties() != null) {\n+                keyDeletionRecoveryLevel = getKeyResponse.getProperties().getRecoveryLevel();\n+            }\n+\n+            return Mono.just(keyDeletionRecoveryLevel != null && (\n+                keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.Recoverable)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.RecoverableProtectedSubscription)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.CustomizedRecoverable)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.CustomizedRecoverableProtectedSubscription)));\n+        }\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"ValidatePurgeProtectionAndSoftDeleteSettingsAsync: Failed to fetch Key from Key Vault.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzI5OA==", "bodyText": "thanks. addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r476217298", "createdAt": "2020-08-25T06:53:49Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.cosmos.implementation.caches.AsyncCache;\n+import com.azure.security.keyvault.keys.KeyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.models.UnwrapResult;\n+import com.azure.security.keyvault.keys.cryptography.models.WrapResult;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import reactor.core.publisher.Mono;\n+\n+import java.net.URI;\n+\n+/**\n+ * Implements Core KeyVault access methods that uses the TODO: moderakh this doesn't need to be public. it is public due\n+ * to tests. FIXME\n+ * TODO: methods should be async moderakh\n+ */\n+public class KeyVaultAccessClient {\n+    private final AsyncCache<URI, KeyAsyncClient> akvClientCache;\n+    private final AsyncCache<URI, CryptographyAsyncClient> akvCryptoClientCache;\n+    private final KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory;\n+    private final KeyClientFactory keyClientFactory;\n+    private final CryptographyClientFactory cryptographyClientFactory;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultAccessClient}\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredentials factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = new KeyClientFactory();\n+        this.cryptographyClientFactory = new CryptographyClientFactory();\n+    }\n+\n+    /**\n+     * TODO: this doesn't need to be public moderakh Initializes a new instance of the {@link KeyVaultAccessClient}\n+     * class Invokes internal factory Methods.\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredential\n+     * @param keyClientFactory KeyClient Factory\n+     * @param cryptographyClientFactory KeyClient Factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory,\n+                                KeyClientFactory keyClientFactory,\n+                                CryptographyClientFactory cryptographyClientFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = keyClientFactory;\n+        this.cryptographyClientFactory = cryptographyClientFactory;\n+    }\n+\n+    /**\n+     * Unwrap the encrypted Key. Only supports encrypted bytes in base64 format.\n+     *\n+     * Note: this may return an empty Mono if cryptoClient returns empty/null\n+     *\n+     * @param wrappedKey encrypted bytes.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and decrypted bytes in base64 string format, can be convert to\n+     * bytes using Convert.FromBase64String().\n+     */\n+    public Mono<byte[]> unwrapKeyAsync(\n+        byte[] wrappedKey,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        UnwrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        Mono<CryptographyAsyncClient> cryptoClientMono = this.getCryptoClientAsync(keyVaultUriProperties);\n+\n+        // TODO: moderakh change to async\n+        CryptographyAsyncClient cryptoClient = cryptoClientMono.block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.unwrapKey(KeyVaultConstants.RsaOaep256, wrappedKey).block();\n+        } catch (AzureException ex) {\n+\n+            throw new KeyVaultAccessException();\n+            // TODO: set proper exception moderakh\n+            //            throw new KeyVaultAccessException(\n+            //                ex.Status,\n+            //                ex.ErrorCode,\n+            //                \"UnwrapKeyAsync:Failed to Unwrap the encrypted key.\",\n+            //                ex);\n+        }\n+\n+        if (keyOpResult == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"keyOpResult cannot be null\"));\n+        }\n+\n+        // may return null\n+        return Mono.justOrEmpty(keyOpResult.getKey());\n+    }\n+\n+    /**\n+     * Wrap the Key with latest Key version. Only supports bytes in base64 format.\n+     *\n+     * @param key plain text key.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and encrypted bytes in base64 string format.\n+     */\n+    public Mono<byte[]> wrapKeyAsync(\n+        byte[] key,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        WrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        CryptographyAsyncClient cryptoClient = this.getCryptoClientAsync(keyVaultUriProperties).block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.wrapKey(KeyVaultConstants.RsaOaep256, key).block();\n+        }\n+        // TODO: set proper exception moderakh moderakh\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"WrapKeyAsync: Failed to Wrap the data encryption key.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new KeyVaultAccessException();\n+        }\n+\n+        // key vault may return null\n+        return Mono.justOrEmpty(keyOpResult.getEncryptedKey());\n+    }\n+\n+    /**\n+     * Validate the Purge Protection AndSoft Delete Settings.\n+     *\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.\n+     * @return Whether The Customer has the correct Deletion Level.\n+     */\n+    public Mono<Boolean> validatePurgeProtectionAndSoftDeleteSettingsAsync(\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        KeyAsyncClient akvClient = this.getAkvClientAsync(keyVaultUriProperties).block();\n+        if (akvClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+        try {\n+            KeyVaultKey getKeyResponse = akvClient.getKey(keyVaultUriProperties.getKeyName()).block();\n+\n+            String keyDeletionRecoveryLevel = null;\n+            if (getKeyResponse != null && getKeyResponse.getProperties() != null) {\n+                keyDeletionRecoveryLevel = getKeyResponse.getProperties().getRecoveryLevel();\n+            }\n+\n+            return Mono.just(keyDeletionRecoveryLevel != null && (\n+                keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.Recoverable)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.RecoverableProtectedSubscription)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.CustomizedRecoverable)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.CustomizedRecoverableProtectedSubscription)));\n+        }\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"ValidatePurgeProtectionAndSoftDeleteSettingsAsync: Failed to fetch Key from Key Vault.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjI4NQ=="}, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUwMTUyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyMzozMFrOHFvFwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjo1NDowN1rOHGKAbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjQ0OA==", "bodyText": "new line at the end of file.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475776448", "createdAt": "2020-08-24T17:23:30Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessException.java", "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.exception.AzureException;\n+\n+// TODO: moderakh we should extend CosmosException. dotnet has problem too\n+// TODO also we should set proper error message, status code\n+class KeyVaultAccessException extends AzureException {\n+    public KeyVaultAccessException() {\n+        // TODO: remove this\n+    }\n+\n+    public KeyVaultAccessException(int statusCode,\n+                                   String keyVaultErrorCode,\n+                                   String errorMessage,\n+                                   Exception innerException) {\n+        // TODO: CosmosException as super class?\n+        //super(statusCode, keyVaultErrorCode, errorMessage, innerException)\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzQ1Mg==", "bodyText": "thanks addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r476217452", "createdAt": "2020-08-25T06:54:07Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessException.java", "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.exception.AzureException;\n+\n+// TODO: moderakh we should extend CosmosException. dotnet has problem too\n+// TODO also we should set proper error message, status code\n+class KeyVaultAccessException extends AzureException {\n+    public KeyVaultAccessException() {\n+        // TODO: remove this\n+    }\n+\n+    public KeyVaultAccessException(int statusCode,\n+                                   String keyVaultErrorCode,\n+                                   String errorMessage,\n+                                   Exception innerException) {\n+        // TODO: CosmosException as super class?\n+        //super(statusCode, keyVaultErrorCode, errorMessage, innerException)\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjQ0OA=="}, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUwNTY0OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultKeyUriProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNDo0MFrOHFvIRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjo1NDoxN1rOHGKAuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzA5Mw==", "bodyText": "Do we need some sort of debug / warn error level logging here ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475777093", "createdAt": "2020-08-24T17:24:40Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultKeyUriProperties.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+//  TODO: this also doesn't need to be public, it is public because of test FIXME\n+public class KeyVaultKeyUriProperties {\n+    private final URI keyUri;\n+    private String keyName;\n+    private URI keyVaultUri;\n+    private String keyVersion;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultKeyUriProperties} Helper Class to fetch frequently used Uri\n+     * parsed information for KeyVault.\n+     *\n+     * @param keyUri\n+     */\n+    private KeyVaultKeyUriProperties(URI keyUri) {\n+        this.keyUri = keyUri;\n+    }\n+\n+    public URI getKeyUri() {\n+        return keyUri;\n+    }\n+\n+    public String getKeyName() {\n+        return keyName;\n+    }\n+\n+    public String getKeyVersion() {\n+        return keyVersion;\n+    }\n+\n+    public URI getKeyVaultUri() {\n+        return keyVaultUri;\n+    }\n+\n+    private static String[] getSegments(URI uri) {\n+        return StringUtils.split(uri.getPath(), \"/\");\n+    }\n+\n+    public static boolean tryParse(URI keyUri,\n+                                   AtomicReference<KeyVaultKeyUriProperties> keyVaultUriPropertiesReference) {\n+        KeyVaultKeyUriProperties keyVaultUriProperties = null;\n+\n+        String[] segments = getSegments(keyUri);\n+        // https://testdemo1.vault.azure.net/keys/testkey1/47d306aeaae74baab294672354603ca3\n+\n+        // https://testdemo1.vault.azure.net/keys/testkey1/47d306aeaae74baab294672354603ca3\n+        if (!((segments.length == 3) && StringUtils.equalsIgnoreCase(segments[0], KeyVaultConstants.KeysSegment))) {\n+            return false;\n+        }\n+\n+        try {\n+            // TODO: shifted the index wrt dot net and keyName is \"testKey1 instead of testkey1/\n+            keyVaultUriProperties = new KeyVaultKeyUriProperties(keyUri);\n+            keyVaultUriProperties.keyName = segments[1]; // \"testKey1/\"\n+            keyVaultUriProperties.keyVersion = segments[2]; // \"47d306aeaae74baab294672354603ca3\"\n+            //keyVaultUriProperties.keyVaultUri = new URI(keyVaultUriProperties.KeyUri.GetLeftPart(UriPartial.Scheme\n+            // | UriPartial.Authority)); // https://testdemo1.vault.azure.net/\n+            keyVaultUriProperties.keyVaultUri = new URI(keyUri.getScheme(), keyUri.getAuthority(), null, null, null); // https://testdemo1.vault.azure.net/\n+\n+            keyVaultUriPropertiesReference.set(keyVaultUriProperties);\n+        } catch (URISyntaxException e) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzUyOQ==", "bodyText": "thanks. addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r476217529", "createdAt": "2020-08-25T06:54:17Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultKeyUriProperties.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+//  TODO: this also doesn't need to be public, it is public because of test FIXME\n+public class KeyVaultKeyUriProperties {\n+    private final URI keyUri;\n+    private String keyName;\n+    private URI keyVaultUri;\n+    private String keyVersion;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultKeyUriProperties} Helper Class to fetch frequently used Uri\n+     * parsed information for KeyVault.\n+     *\n+     * @param keyUri\n+     */\n+    private KeyVaultKeyUriProperties(URI keyUri) {\n+        this.keyUri = keyUri;\n+    }\n+\n+    public URI getKeyUri() {\n+        return keyUri;\n+    }\n+\n+    public String getKeyName() {\n+        return keyName;\n+    }\n+\n+    public String getKeyVersion() {\n+        return keyVersion;\n+    }\n+\n+    public URI getKeyVaultUri() {\n+        return keyVaultUri;\n+    }\n+\n+    private static String[] getSegments(URI uri) {\n+        return StringUtils.split(uri.getPath(), \"/\");\n+    }\n+\n+    public static boolean tryParse(URI keyUri,\n+                                   AtomicReference<KeyVaultKeyUriProperties> keyVaultUriPropertiesReference) {\n+        KeyVaultKeyUriProperties keyVaultUriProperties = null;\n+\n+        String[] segments = getSegments(keyUri);\n+        // https://testdemo1.vault.azure.net/keys/testkey1/47d306aeaae74baab294672354603ca3\n+\n+        // https://testdemo1.vault.azure.net/keys/testkey1/47d306aeaae74baab294672354603ca3\n+        if (!((segments.length == 3) && StringUtils.equalsIgnoreCase(segments[0], KeyVaultConstants.KeysSegment))) {\n+            return false;\n+        }\n+\n+        try {\n+            // TODO: shifted the index wrt dot net and keyName is \"testKey1 instead of testkey1/\n+            keyVaultUriProperties = new KeyVaultKeyUriProperties(keyUri);\n+            keyVaultUriProperties.keyName = segments[1]; // \"testKey1/\"\n+            keyVaultUriProperties.keyVersion = segments[2]; // \"47d306aeaae74baab294672354603ca3\"\n+            //keyVaultUriProperties.keyVaultUri = new URI(keyVaultUriProperties.KeyUri.GetLeftPart(UriPartial.Scheme\n+            // | UriPartial.Authority)); // https://testdemo1.vault.azure.net/\n+            keyVaultUriProperties.keyVaultUri = new URI(keyUri.getScheme(), keyUri.getAuthority(), null, null, null); // https://testdemo1.vault.azure.net/\n+\n+            keyVaultUriPropertiesReference.set(keyVaultUriProperties);\n+        } catch (URISyntaxException e) {\n+            return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzA5Mw=="}, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUwODM1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/encryption/KeyModelFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNToyM1rOHFvJ8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwNjo1NDoyNlrOHGKA8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzUyMQ==", "bodyText": "Please add public description of the class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475777521", "createdAt": "2020-08-24T17:25:23Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/encryption/KeyModelFactory.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.guava25.base.Function;\n+import com.azure.security.keyvault.keys.models.JsonWebKey;\n+import com.azure.security.keyvault.keys.models.KeyOperation;\n+import com.azure.security.keyvault.keys.models.KeyProperties;\n+import com.azure.security.keyvault.keys.models.KeyType;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.List;\n+\n+public class KeyModelFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzU4NA==", "bodyText": "thanks addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r476217584", "createdAt": "2020-08-25T06:54:26Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/encryption/KeyModelFactory.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.guava25.base.Function;\n+import com.azure.security.keyvault.keys.models.JsonWebKey;\n+import com.azure.security.keyvault.keys.models.KeyOperation;\n+import com.azure.security.keyvault.keys.models.KeyProperties;\n+import com.azure.security.keyvault.keys.models.KeyType;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.List;\n+\n+public class KeyModelFactory {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzUyMQ=="}, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1595, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}