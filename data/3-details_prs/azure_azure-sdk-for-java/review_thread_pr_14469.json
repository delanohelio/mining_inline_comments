{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczNjUxODA4", "number": 14469, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNToyMzoxNFrOEcarhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMjoyMVrOEdgWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjMyNzExOnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNToyMzoxNFrOHG8RHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMzo1NVrOHHAkFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MDkyNg==", "bodyText": "Here we adopt com.microsoft.azure: azure-storage to com.azure: azure-storage-blob, comparing to previous code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477040926", "createdAt": "2020-08-26T05:23:14Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                    final String containerName) {\n+            return getBlobClientAsync(storageAccount)\n+                .flatMap(blobServiceAsyncClient -> blobServiceAsyncClient\n+                    .getBlobContainerAsyncClient(containerName)\n+                    .exists()\n+                    .flatMap(aBoolean -> {\n+                        if (aBoolean) {\n+                            return Mono.empty();\n+                        }\n+                        return blobServiceAsyncClient.getBlobContainerAsyncClient(containerName).create();\n+                    }));\n+        }\n+\n+        private Mono<BlobServiceAsyncClient> getBlobClientAsync(final StorageAccount storageAccount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTMxOQ==", "bodyText": "Remove this as we can do in mgmt storage.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477111319", "createdAt": "2020-08-26T08:03:55Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                    final String containerName) {\n+            return getBlobClientAsync(storageAccount)\n+                .flatMap(blobServiceAsyncClient -> blobServiceAsyncClient\n+                    .getBlobContainerAsyncClient(containerName)\n+                    .exists()\n+                    .flatMap(aBoolean -> {\n+                        if (aBoolean) {\n+                            return Mono.empty();\n+                        }\n+                        return blobServiceAsyncClient.getBlobContainerAsyncClient(containerName).create();\n+                    }));\n+        }\n+\n+        private Mono<BlobServiceAsyncClient> getBlobClientAsync(final StorageAccount storageAccount) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MDkyNg=="}, "originalCommit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "originalPosition": 497}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjM4MDA0OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNTo0OToxMFrOHG8wGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMTo0MlrOHHAfFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0ODg1OA==", "bodyText": "Please copy another latest readme, which contains  For documentation on how to use this package, please see [Azure Management Libraries for Java](https://aka.ms/azure-sdk-java-mgmt).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477048858", "createdAt": "2020-08-26T05:49:10Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/README.md", "diffHunk": "@@ -0,0 +1,40 @@\n+# Azure Resource Manager EventHubs client library for Java\n+\n+Azure Resource Manager EventHubs client library for Java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7d6ba14af0bcbcaa302a189d0a16b41b354984"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMDAzOQ==", "bodyText": "Added.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477110039", "createdAt": "2020-08-26T08:01:42Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/README.md", "diffHunk": "@@ -0,0 +1,40 @@\n+# Azure Resource Manager EventHubs client library for Java\n+\n+Azure Resource Manager EventHubs client library for Java", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0ODg1OA=="}, "originalCommit": {"oid": "5e7d6ba14af0bcbcaa302a189d0a16b41b354984"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjQzOTI1OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjoxNToyMlrOHG9TkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowNDoxMFrOHHAkpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzkzNg==", "bodyText": "Mgmt should be able to create a storage blob container?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477057936", "createdAt": "2020-08-26T06:15:22Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "originalPosition": 483}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTQ2Mw==", "bodyText": "Changed to mgmt storage.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477111463", "createdAt": "2020-08-26T08:04:10Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzkzNg=="}, "originalCommit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "originalPosition": 483}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzA5MDg3OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOToxOToxMlrOHHDhqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTo0NToxNFrOHHEegg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1OTg1MA==", "bodyText": "blobContainer is a indexable, don't flatmap to void", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477159850", "createdAt": "2020-08-26T09:19:12Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -383,7 +383,7 @@ public CaptureSettings withNewStorageAccountForCapturedData(\n                     StorageAccount storageAccount = (StorageAccount) indexable;\n                     ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n                     return createContainerIfNotExistsAsync(storageAccount, containerName)\n-                        .flatMap(aVoid -> context.voidMono());\n+                        .flatMap(blobContainer -> context.voidMono());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3NTQyNg==", "bodyText": "updated.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477175426", "createdAt": "2020-08-26T09:45:14Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -383,7 +383,7 @@ public CaptureSettings withNewStorageAccountForCapturedData(\n                     StorageAccount storageAccount = (StorageAccount) indexable;\n                     ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n                     return createContainerIfNotExistsAsync(storageAccount, containerName)\n-                        .flatMap(aVoid -> context.voidMono());\n+                        .flatMap(blobContainer -> context.voidMono());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1OTg1MA=="}, "originalCommit": {"oid": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NzY3NTA1OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1NjozNVrOHHxNoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1NjozNVrOHHxNoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwODM4NA==", "bodyText": "I think it better throws exception when else, due to it need such properties in request.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477908384", "createdAt": "2020-08-27T01:56:35Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "diffHunk": "@@ -70,10 +66,13 @@ public ProvisioningStateDR provisioningState() {\n     }\n \n     @Override\n-    public EventHubDisasterRecoveryPairingImpl withNewPrimaryNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+    public EventHubDisasterRecoveryPairingImpl withNewPrimaryNamespace(\n+        Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NzY3NjQ2OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1Njo0NVrOHHxOgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1Njo0NVrOHHxOgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwODYwOQ==", "bodyText": "same as above", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477908609", "createdAt": "2020-08-27T01:56:45Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "diffHunk": "@@ -96,10 +96,13 @@ public EventHubDisasterRecoveryPairingImpl withExistingPrimaryNamespaceId(String\n     }\n \n     @Override\n-    public EventHubDisasterRecoveryPairingImpl withNewSecondaryNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+    public EventHubDisasterRecoveryPairingImpl withNewSecondaryNamespace(\n+        Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.inner().withPartnerNamespace(namespace.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.inner().withPartnerNamespace(namespace.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NzY4MzY4OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1NzozOVrOHHxTbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1NzozOVrOHHxTbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwOTg2OA==", "bodyText": "same as above", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477909868", "createdAt": "2020-08-27T01:57:39Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -153,8 +139,10 @@ public int messageRetentionPeriodInDays() {\n     @Override\n     public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4ODg3MzEyOnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNDo1NzoyMVrOHH-B8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNDo1NzoyMVrOHH-B8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODExODM4NA==", "bodyText": "@weidongxu-microsoft This is the main changes after migration. I apply azure-resourcemanager-storage for the scenario to create a container if not exists instead of using azure-storage/azure-storage-blob. The rest part keeps as it is.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478118384", "createdAt": "2020-08-27T04:57:21Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName);\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName);\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Indexable> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                final String containerName) {\n+            return storageManager.blobContainers()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 483}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4ODk1NjkzOnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNToxODo0NFrOHH-3Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjo0NDo0NlrOHIrhFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw==", "bodyText": "Please try test case which do both (NewSend and NewListen) in one Create/Update. I remember service not able to handle concurrent requests under eventhub, so these had to be done in sequence.\nAzure/azure-libraries-for-net#891", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478132043", "createdAt": "2020-08-27T05:18:44Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMzUwNg==", "bodyText": "Do they have without method?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478133506", "createdAt": "2020-08-27T05:20:59Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE2NTkzMw==", "bodyText": "I will add new method withNewSendAndListenRule(ruleName). There is withoutAuthorizationRule(ruleName) to remove the authorization rule no matter what access it has.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478165933", "createdAt": "2020-08-27T06:11:17Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE3MzUzMQ==", "bodyText": "Eh, I didn't get it. What I mean is these REST requests under \"eventhub\" might need to be called sequentially, it might not be limited to this 2.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478173531", "createdAt": "2020-08-27T06:21:46Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MzYzOA==", "bodyText": "After discuss offline, we decide to concat the post run tasks in eventhubs.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478863638", "createdAt": "2020-08-28T06:44:46Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzczNjg3OnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMDozNVrOHIsbUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMDozNVrOHIsbUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3ODU0NA==", "bodyText": "postRunTasks = null;\nreturn Mono.empty();", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478878544", "createdAt": "2020-08-28T07:20:35Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -333,6 +340,15 @@ public void beforeGroupCreateOrUpdate() {\n                 .map(innerToFluentMap(this));\n     }\n \n+    @Override\n+    public Mono<Void> afterPostRunAsync(boolean isGroupFaulted) {\n+        return Mono.just(true)\n+            .map(aBoolean -> {\n+                postRunTasks = null;\n+                return aBoolean;\n+            }).then();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Mzc0MjAwOnYy", "diffSide": "RIGHT", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubNamespaceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMjoyMVrOHIseYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMjoyMVrOHIseYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3OTMzMQ==", "bodyText": "same above", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478879331", "createdAt": "2020-08-28T07:22:21Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubNamespaceImpl.java", "diffHunk": "@@ -204,13 +210,29 @@ public EventHubNamespaceImpl withThroughputUnitsUpperLimit(int units) {\n         return this;\n     }\n \n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        if (postRunTasks != null) {\n+            addPostRunDependent(context -> postRunTasks.last());\n+        }\n+    }\n+\n     @Override\n     public Mono<EventHubNamespace> createResourceAsync() {\n         return this.manager().inner().getNamespaces()\n                 .createOrUpdateAsync(resourceGroupName(), name(), this.inner())\n                 .map(innerToFluentMap(this));\n     }\n \n+    @Override\n+    public Mono<Void> afterPostRunAsync(boolean isGroupFaulted) {\n+        return Mono.just(true)\n+            .map(aBoolean -> {\n+                postRunTasks = null;\n+                return aBoolean;\n+            }).then();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f"}, "originalPosition": 130}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1538, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}