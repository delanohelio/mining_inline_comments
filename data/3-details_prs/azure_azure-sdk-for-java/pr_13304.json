{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxNDY5NjA1", "number": 13304, "title": "Update Reactor Netty Proxy Handling", "bodyText": "Fixes #13222 and #13199\nThis PR updates how our custom ProxyHandler is added into a ChannelPipeline. The logic changes from eagerly adding it to using a deferred supplier. The root reason for why a connection wasn't being reused is that the eager handling triggered the connection pooling key to change per request. Using the deferred handler allows for a hashing overload to be added to the deferred supplier, which is made consistent by hashing the proxying information.\nAdditionally, minor changes were made to how proxies are added into the pipeline. When using a SOCKS4, SOCKS5, or an anonymous HTTP proxy the built-in Reactor Netty proxying configuration will be used. Only when using an authenticated HTTP proxy will our custom handler be used.", "createdAt": "2020-07-17T21:13:22Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13304", "merged": true, "mergeCommit": {"oid": "a85e4dba7f1c3ba6ac982188684ea3ae72b59ebd"}, "closed": true, "closedAt": "2020-07-21T16:55:01Z", "author": {"login": "alzimmermsft"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc16XZVgH2gAyNDUxNDY5NjA1OjdiNjY0ZTEwNmEzMzc3YmNlMmNkOTQyMjAwZTI4MmMxZTM0ZDk1MzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc27_WNgFqTQ1MjA2NDkzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7b664e106a3377bce2cd942200e282c1e34d9533", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7b664e106a3377bce2cd942200e282c1e34d9533", "committedDate": "2020-07-17T21:04:07Z", "message": "Fix how the custom proxy handler is added to the ChannelPipeline to ensure the connection can be reused"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDY0OTM4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13304#pullrequestreview-452064938", "createdAt": "2020-07-21T01:30:13Z", "commit": {"oid": "7b664e106a3377bce2cd942200e282c1e34d9533"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTozMDoxM1rOG0k1eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTozMDoxM1rOG0k1eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MjY1MA==", "bodyText": "Do we need to consider (now or later) extending the pattern-matching algorithm to cover standard java networking properties formats? Reactor-netty claims to cover those cases here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13304#discussion_r457782650", "createdAt": "2020-07-21T01:30:13Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core-http-netty/src/main/java/com/azure/core/http/netty/implementation/DeferredHttpProxyProvider.java", "diffHunk": "@@ -0,0 +1,96 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.http.netty.implementation;\n+\n+import com.azure.core.http.ProxyOptions;\n+import com.azure.core.util.AuthorizationChallengeHandler;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.Channel;\n+import reactor.netty.ConnectionObserver;\n+import reactor.netty.NettyPipeline;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This class defers supplying a channel pipeline with a proxy handler.\n+ */\n+public class DeferredHttpProxyProvider implements Function<Bootstrap, BiConsumer<ConnectionObserver, Channel>> {\n+    private final AuthorizationChallengeHandler challengeHandler;\n+    private final AtomicReference<ChallengeHolder> proxyChallengeHolderReference;\n+    private final InetSocketAddress proxyAddress;\n+    private final String username;\n+    private final String password;\n+    private final String nonProxyHosts;\n+\n+    private final Pattern nonProxyHostsPattern;\n+\n+    public DeferredHttpProxyProvider(AuthorizationChallengeHandler challengeHandler,\n+        AtomicReference<ChallengeHolder> proxyChallengeHolderReference, ProxyOptions proxyOptions) {\n+        this.challengeHandler = challengeHandler;\n+        this.proxyChallengeHolderReference = proxyChallengeHolderReference;\n+        this.proxyAddress = proxyOptions.getAddress();\n+        this.username = proxyOptions.getUsername();\n+        this.password = proxyOptions.getPassword();\n+        this.nonProxyHosts = proxyOptions.getNonProxyHosts();\n+\n+        this.nonProxyHostsPattern = (nonProxyHosts == null)\n+            ? null\n+            : Pattern.compile(nonProxyHosts, Pattern.CASE_INSENSITIVE);\n+    }\n+\n+    @Override\n+    public BiConsumer<ConnectionObserver, Channel> apply(Bootstrap bootstrap) {\n+        return ((connectionObserver, channel) -> {\n+            if (shouldApplyProxy(bootstrap.config().remoteAddress())) {\n+                channel.pipeline()\n+                    .addFirst(NettyPipeline.ProxyHandler, new HttpProxyHandler(proxyAddress, challengeHandler,\n+                        proxyChallengeHolderReference))\n+                    .addLast(\"azure.proxy.exceptionHandler\", new HttpProxyExceptionHandler());\n+            }\n+        });\n+    }\n+\n+    private boolean shouldApplyProxy(SocketAddress socketAddress) {\n+        if (nonProxyHostsPattern == null) {\n+            return true;\n+        }\n+\n+        if (!(socketAddress instanceof  InetSocketAddress)) {\n+            return true;\n+        }\n+\n+        InetSocketAddress inetSocketAddress = (InetSocketAddress) socketAddress;\n+\n+        return !nonProxyHostsPattern.matcher(inetSocketAddress.getHostName()).matches();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b664e106a3377bce2cd942200e282c1e34d9533"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1166, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}