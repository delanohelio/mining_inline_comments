{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1ODAzNTY4", "number": 12890, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODozOTo0OVrOENAxLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMjowNDozNFrOEhejwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc5NTM1OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/SwaggerMethodParser.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODozOTo0OVrOGvdTRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMTo0MTo0NFrOGwXTSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNjMyNw==", "bodyText": "This method appears to only be used in tests and in one case where we check if a status code is valid. Thoughts on removing this method since it is non-public API and making callers of this use the boolean isExpectedResponseStatusCode(int statusCode) method? This will be more performant as we can completely remove the int[] cloning.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452416327", "createdAt": "2020-07-09T18:39:49Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/SwaggerMethodParser.java", "diffHunk": "@@ -223,7 +234,8 @@ public HttpMethod getHttpMethod() {\n      */\n     @Override\n     public int[] getExpectedStatusCodes() {\n-        return CoreUtils.clone(expectedStatusCodes);\n+//        return expectedStatusCodes;\n+        return expectedStatusCodes == null ? null : expectedStatusCodes.stream().toArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNjYzNQ==", "bodyText": "The only caller to this is HttpResponseBodyDecoder.isErrorStatus", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452416635", "createdAt": "2020-07-09T18:40:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/SwaggerMethodParser.java", "diffHunk": "@@ -223,7 +234,8 @@ public HttpMethod getHttpMethod() {\n      */\n     @Override\n     public int[] getExpectedStatusCodes() {\n-        return CoreUtils.clone(expectedStatusCodes);\n+//        return expectedStatusCodes;\n+        return expectedStatusCodes == null ? null : expectedStatusCodes.stream().toArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNjMyNw=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2NjI1NQ==", "bodyText": "This is unfortunately public API, otherwise I would have done what you suggested. I rearranged the code internally so that the only things calling this code is test code, which is why I pay the price for int[] cloning here, rather than in the constructor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453366255", "createdAt": "2020-07-12T21:37:52Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/SwaggerMethodParser.java", "diffHunk": "@@ -223,7 +234,8 @@ public HttpMethod getHttpMethod() {\n      */\n     @Override\n     public int[] getExpectedStatusCodes() {\n-        return CoreUtils.clone(expectedStatusCodes);\n+//        return expectedStatusCodes;\n+        return expectedStatusCodes == null ? null : expectedStatusCodes.stream().toArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNjMyNw=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2NjYwMQ==", "bodyText": "My mistake - SwaggerMethodParser is itself a non-public class. I will revise the code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453366601", "createdAt": "2020-07-12T21:41:44Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/SwaggerMethodParser.java", "diffHunk": "@@ -223,7 +234,8 @@ public HttpMethod getHttpMethod() {\n      */\n     @Override\n     public int[] getExpectedStatusCodes() {\n-        return CoreUtils.clone(expectedStatusCodes);\n+//        return expectedStatusCodes;\n+        return expectedStatusCodes == null ? null : expectedStatusCodes.stream().toArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNjMyNw=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDgyNzE2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/serializer/HttpResponseDecodeData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo0OToyNVrOGvdm_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMTo0NTo0OVrOGwXU4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyMTM3NQ==", "bodyText": "This interface is in implementation, so we should be able to remove it completely.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452421375", "createdAt": "2020-07-09T18:49:25Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/serializer/HttpResponseDecodeData.java", "diffHunk": "@@ -59,11 +59,24 @@ default Type getHeadersType() {\n      * 2. If the returned int[] is not-null, only the codes in the array are considered as success code.\n      *\n      * @return the expected HTTP response status codes\n+     * @deprecated Use {@link #isExpectedResponseStatusCode(int)} instead.\n      */\n+    @Deprecated // This is only used in tests now - all uses should go via isExpectedResponseStatusCode instead", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2NzAwOA==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453367008", "createdAt": "2020-07-12T21:45:49Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/serializer/HttpResponseDecodeData.java", "diffHunk": "@@ -59,11 +59,24 @@ default Type getHeadersType() {\n      * 2. If the returned int[] is not-null, only the codes in the array are considered as success code.\n      *\n      * @return the expected HTTP response status codes\n+     * @deprecated Use {@link #isExpectedResponseStatusCode(int)} instead.\n      */\n+    @Deprecated // This is only used in tests now - all uses should go via isExpectedResponseStatusCode instead", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyMTM3NQ=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDgzMDk3OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/serializer/HttpResponseDecodeData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1MDozMFrOGvdpVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMTo0NzozNVrOGwXVgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyMTk3Mg==", "bodyText": "In implementation so I don't think we need a default. If we want to keep a default we should check is the status code is in the 200 range.\nreturn (statusCode / 100) == 2;", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452421972", "createdAt": "2020-07-09T18:50:30Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/serializer/HttpResponseDecodeData.java", "diffHunk": "@@ -59,11 +59,24 @@ default Type getHeadersType() {\n      * 2. If the returned int[] is not-null, only the codes in the array are considered as success code.\n      *\n      * @return the expected HTTP response status codes\n+     * @deprecated Use {@link #isExpectedResponseStatusCode(int)} instead.\n      */\n+    @Deprecated // This is only used in tests now - all uses should go via isExpectedResponseStatusCode instead\n     default int[] getExpectedStatusCodes() {\n         return null;\n     }\n \n+    /**\n+     * This method returns {@code true} if the given {@code statusCode} is in the list of expected HTTP resposne\n+     * codes returned by {@link #getExpectedStatusCodes()}, {@code false} otherwise.\n+     *\n+     * @param statusCode The HTTP response status code to evaluate.\n+     * @return {@code true} if the given status code is expected.\n+     */\n+    default boolean isExpectedResponseStatusCode(int statusCode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2NzE2OQ==", "bodyText": "I agree - I thought this was public API so I added it, but I have now removed it again.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453367169", "createdAt": "2020-07-12T21:47:35Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/serializer/HttpResponseDecodeData.java", "diffHunk": "@@ -59,11 +59,24 @@ default Type getHeadersType() {\n      * 2. If the returned int[] is not-null, only the codes in the array are considered as success code.\n      *\n      * @return the expected HTTP response status codes\n+     * @deprecated Use {@link #isExpectedResponseStatusCode(int)} instead.\n      */\n+    @Deprecated // This is only used in tests now - all uses should go via isExpectedResponseStatusCode instead\n     default int[] getExpectedStatusCodes() {\n         return null;\n     }\n \n+    /**\n+     * This method returns {@code true} if the given {@code statusCode} is in the list of expected HTTP resposne\n+     * codes returned by {@link #getExpectedStatusCodes()}, {@code false} otherwise.\n+     *\n+     * @param statusCode The HTTP response status code to evaluate.\n+     * @return {@code true} if the given status code is expected.\n+     */\n+    default boolean isExpectedResponseStatusCode(int statusCode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyMTk3Mg=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg0MTM0OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1MzoyN1rOGvdv4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMjowNDozNFrOGwXbyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyMzY1MA==", "bodyText": "Could this call createParameterizedType?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452423650", "createdAt": "2020-07-09T18:53:27Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "diffHunk": "@@ -75,46 +79,52 @@ public static Type getTypeArgument(Type type) {\n      * @param type the input type\n      * @return the direct super type\n      */\n-    public static Type getSuperType(Type type) {\n-        if (type instanceof ParameterizedType) {\n-            ParameterizedType parameterizedType = (ParameterizedType) type;\n-            Type genericSuperClass = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();\n-            if (genericSuperClass instanceof ParameterizedType) {\n-                /*\n-                 * Find erased generic types for the super class and replace\n-                 * with actual type arguments from the parameterized type\n-                 */\n-                Type[] superTypeArguments = getTypeArguments(genericSuperClass);\n-                List<Type> typeParameters =\n-                    Arrays.asList(((Class<?>) parameterizedType.getRawType()).getTypeParameters());\n-                int j = 0;\n-                for (int i = 0; i != superTypeArguments.length; i++) {\n-                    if (typeParameters.contains(superTypeArguments[i])) {\n-                        superTypeArguments[i] = parameterizedType.getActualTypeArguments()[j++];\n+    public static Type getSuperType(final Type type) {\n+        return SUPER_TYPE_MAP.computeIfAbsent(type, _type -> {\n+            if (type instanceof ParameterizedType) {\n+                ParameterizedType parameterizedType = (ParameterizedType) type;\n+                Type genericSuperClass = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();\n+                if (genericSuperClass instanceof ParameterizedType) {\n+                    /*\n+                     * Find erased generic types for the super class and replace\n+                     * with actual type arguments from the parameterized type\n+                     */\n+                    final Type[] superTypeArguments = getTypeArguments(genericSuperClass);\n+                    final Type[] typeParameters =\n+                        ((GenericDeclaration) parameterizedType.getRawType()).getTypeParameters();\n+                    int k = 0;\n+                    outer:\n+                    for (int i = 0; i != superTypeArguments.length; i++) {\n+                        for (int j = 0; i < typeParameters.length; j++) {\n+                            if (typeParameters[j].equals(superTypeArguments[i])) {\n+                                superTypeArguments[i] = parameterizedType.getActualTypeArguments()[k++];\n+                                break outer;\n+                            }\n+                        }\n                     }\n+                    return new ParameterizedType() {\n+                        @Override\n+                        public Type[] getActualTypeArguments() {\n+                            return superTypeArguments;\n+                        }\n+\n+                        @Override\n+                        public Type getRawType() {\n+                            return ((ParameterizedType) genericSuperClass).getRawType();\n+                        }\n+\n+                        @Override\n+                        public Type getOwnerType() {\n+                            return null;\n+                        }\n+                    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2ODc3OA==", "bodyText": "Yep, done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453368778", "createdAt": "2020-07-12T22:04:34Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "diffHunk": "@@ -75,46 +79,52 @@ public static Type getTypeArgument(Type type) {\n      * @param type the input type\n      * @return the direct super type\n      */\n-    public static Type getSuperType(Type type) {\n-        if (type instanceof ParameterizedType) {\n-            ParameterizedType parameterizedType = (ParameterizedType) type;\n-            Type genericSuperClass = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();\n-            if (genericSuperClass instanceof ParameterizedType) {\n-                /*\n-                 * Find erased generic types for the super class and replace\n-                 * with actual type arguments from the parameterized type\n-                 */\n-                Type[] superTypeArguments = getTypeArguments(genericSuperClass);\n-                List<Type> typeParameters =\n-                    Arrays.asList(((Class<?>) parameterizedType.getRawType()).getTypeParameters());\n-                int j = 0;\n-                for (int i = 0; i != superTypeArguments.length; i++) {\n-                    if (typeParameters.contains(superTypeArguments[i])) {\n-                        superTypeArguments[i] = parameterizedType.getActualTypeArguments()[j++];\n+    public static Type getSuperType(final Type type) {\n+        return SUPER_TYPE_MAP.computeIfAbsent(type, _type -> {\n+            if (type instanceof ParameterizedType) {\n+                ParameterizedType parameterizedType = (ParameterizedType) type;\n+                Type genericSuperClass = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();\n+                if (genericSuperClass instanceof ParameterizedType) {\n+                    /*\n+                     * Find erased generic types for the super class and replace\n+                     * with actual type arguments from the parameterized type\n+                     */\n+                    final Type[] superTypeArguments = getTypeArguments(genericSuperClass);\n+                    final Type[] typeParameters =\n+                        ((GenericDeclaration) parameterizedType.getRawType()).getTypeParameters();\n+                    int k = 0;\n+                    outer:\n+                    for (int i = 0; i != superTypeArguments.length; i++) {\n+                        for (int j = 0; i < typeParameters.length; j++) {\n+                            if (typeParameters[j].equals(superTypeArguments[i])) {\n+                                superTypeArguments[i] = parameterizedType.getActualTypeArguments()[k++];\n+                                break outer;\n+                            }\n+                        }\n                     }\n+                    return new ParameterizedType() {\n+                        @Override\n+                        public Type[] getActualTypeArguments() {\n+                            return superTypeArguments;\n+                        }\n+\n+                        @Override\n+                        public Type getRawType() {\n+                            return ((ParameterizedType) genericSuperClass).getRawType();\n+                        }\n+\n+                        @Override\n+                        public Type getOwnerType() {\n+                            return null;\n+                        }\n+                    };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyMzY1MA=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg0NTA4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1NDozNFrOGvdyMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1NDozNFrOGvdyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNDI0Mw==", "bodyText": "Mind adding more Javadocs to this, having break labels isn't very common.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452424243", "createdAt": "2020-07-09T18:54:34Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "diffHunk": "@@ -75,46 +79,52 @@ public static Type getTypeArgument(Type type) {\n      * @param type the input type\n      * @return the direct super type\n      */\n-    public static Type getSuperType(Type type) {\n-        if (type instanceof ParameterizedType) {\n-            ParameterizedType parameterizedType = (ParameterizedType) type;\n-            Type genericSuperClass = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();\n-            if (genericSuperClass instanceof ParameterizedType) {\n-                /*\n-                 * Find erased generic types for the super class and replace\n-                 * with actual type arguments from the parameterized type\n-                 */\n-                Type[] superTypeArguments = getTypeArguments(genericSuperClass);\n-                List<Type> typeParameters =\n-                    Arrays.asList(((Class<?>) parameterizedType.getRawType()).getTypeParameters());\n-                int j = 0;\n-                for (int i = 0; i != superTypeArguments.length; i++) {\n-                    if (typeParameters.contains(superTypeArguments[i])) {\n-                        superTypeArguments[i] = parameterizedType.getActualTypeArguments()[j++];\n+    public static Type getSuperType(final Type type) {\n+        return SUPER_TYPE_MAP.computeIfAbsent(type, _type -> {\n+            if (type instanceof ParameterizedType) {\n+                ParameterizedType parameterizedType = (ParameterizedType) type;\n+                Type genericSuperClass = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();\n+                if (genericSuperClass instanceof ParameterizedType) {\n+                    /*\n+                     * Find erased generic types for the super class and replace\n+                     * with actual type arguments from the parameterized type\n+                     */\n+                    final Type[] superTypeArguments = getTypeArguments(genericSuperClass);\n+                    final Type[] typeParameters =\n+                        ((GenericDeclaration) parameterizedType.getRawType()).getTypeParameters();\n+                    int k = 0;\n+                    outer:\n+                    for (int i = 0; i != superTypeArguments.length; i++) {\n+                        for (int j = 0; i < typeParameters.length; j++) {\n+                            if (typeParameters[j].equals(superTypeArguments[i])) {\n+                                superTypeArguments[i] = parameterizedType.getActualTypeArguments()[k++];\n+                                break outer;\n+                            }\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg0ODAzOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1NToxOVrOGvdz6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMjowODoyMFrOGwXdFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNDY4Mg==", "bodyText": "We want to use WeakHashMap to evict from the cache once the Type key becomes null/garbage collected right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452424682", "createdAt": "2020-07-09T18:55:19Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "diffHunk": "@@ -3,16 +3,20 @@\n \n package com.azure.core.implementation;\n \n+import java.lang.reflect.GenericDeclaration;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n \n /**\n  * Utility type exposing methods to deal with {@link Type}.\n  */\n public final class TypeUtil {\n+    private static final Map<Type, Type> SUPER_TYPE_MAP = new WeakHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2OTEwOA==", "bodyText": "I've changed it to be a HashMap.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453369108", "createdAt": "2020-07-12T22:08:20Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/TypeUtil.java", "diffHunk": "@@ -3,16 +3,20 @@\n \n package com.azure.core.implementation;\n \n+import java.lang.reflect.GenericDeclaration;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n \n /**\n  * Utility type exposing methods to deal with {@link Type}.\n  */\n public final class TypeUtil {\n+    private static final Map<Type, Type> SUPER_TYPE_MAP = new WeakHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNDY4Mg=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg1MDEzOnYy", "diffSide": "LEFT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/UrlBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1NTo1NlrOGvd1OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMjowODoyOFrOGwXdJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNTAxNw==", "bodyText": "Was this unused?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452425017", "createdAt": "2020-07-09T18:55:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/UrlBuilder.java", "diffHunk": "@@ -3,18 +3,17 @@\n \n package com.azure.core.util;\n \n-import com.azure.core.util.logging.ClientLogger;\n-\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n /**\n  * A builder class that is used to create URLs.\n  */\n public final class UrlBuilder {\n-    private final ClientLogger logger = new ClientLogger(UrlBuilder.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2OTEyNQ==", "bodyText": "Yep", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453369125", "createdAt": "2020-07-12T22:08:28Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/UrlBuilder.java", "diffHunk": "@@ -3,18 +3,17 @@\n \n package com.azure.core.util;\n \n-import com.azure.core.util.logging.ClientLogger;\n-\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n /**\n  * A builder class that is used to create URLs.\n  */\n public final class UrlBuilder {\n-    private final ClientLogger logger = new ClientLogger(UrlBuilder.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNTAxNw=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg1ODUxOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/JacksonAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODo1ODo0MVrOGvd6qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMjowOTowM1rOGwXdQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNjQwOA==", "bodyText": "This is an API breaking change.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r452426408", "createdAt": "2020-07-09T18:58:41Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/JacksonAdapter.java", "diffHunk": "@@ -153,8 +172,8 @@ public String serializeList(List<?> list, CollectionFormat format) {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public <T> T deserialize(String value, final Type type, SerializerEncoding encoding) throws IOException {\n-        if (CoreUtils.isNullOrEmpty(value)) {\n+    public <T> T deserialize(byte[] value, final Type type, SerializerEncoding encoding) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2OTE1Mw==", "bodyText": "It's now called deserializeFromBytes in more recent commits.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r453369153", "createdAt": "2020-07-12T22:09:03Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/JacksonAdapter.java", "diffHunk": "@@ -153,8 +172,8 @@ public String serializeList(List<?> list, CollectionFormat format) {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public <T> T deserialize(String value, final Type type, SerializerEncoding encoding) throws IOException {\n-        if (CoreUtils.isNullOrEmpty(value)) {\n+    public <T> T deserialize(byte[] value, final Type type, SerializerEncoding encoding) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNjQwOA=="}, "originalCommit": {"oid": "184522452033a8fab48ef90748ad90032e5ffee4"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDYwNzY5OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/RestProxy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOToxNDoxMFrOG9A2AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODozMDozNVrOG_EJKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMDE0NA==", "bodyText": "String.split(.) internally uses java regex which is CPU expensive.\nPlease ensure regex is not used:\nhttps://www.baeldung.com/java-string-performance#split", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r466630144", "createdAt": "2020-08-06T19:14:10Z", "author": {"login": "moderakh"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/RestProxy.java", "diffHunk": "@@ -195,86 +198,86 @@ private Context startTracingSpan(Method method, Context context) {\n      * @throws IOException thrown if the body contents cannot be serialized\n      */\n     private HttpRequest createHttpRequest(SwaggerMethodParser methodParser, Object[] args) throws IOException {\n-        UrlBuilder urlBuilder;\n-\n         // Sometimes people pass in a full URL for the value of their PathParam annotated argument.\n         // This definitely happens in paging scenarios. In that case, just use the full URL and\n         // ignore the Host annotation.\n         final String path = methodParser.setPath(args);\n         final UrlBuilder pathUrlBuilder = UrlBuilder.parse(path);\n+\n+        final UrlBuilder urlBuilder;\n         if (pathUrlBuilder.getScheme() != null) {\n             urlBuilder = pathUrlBuilder;\n         } else {\n             urlBuilder = new UrlBuilder();\n \n-            final String scheme = methodParser.setScheme(args);\n-            urlBuilder.setScheme(scheme);\n-\n-            final String host = methodParser.setHost(args);\n-            urlBuilder.setHost(host);\n+            methodParser.setSchemeAndHost(args, urlBuilder);\n \n             // Set the path after host, concatenating the path\n             // segment in the host.\n-            if (path != null && !path.isEmpty() && !path.equals(\"/\")) {\n+            if (path != null && !path.isEmpty() && !\"/\".equals(path)) {\n                 String hostPath = urlBuilder.getPath();\n-                if (hostPath == null || hostPath.isEmpty() || hostPath.equals(\"/\") || path.contains(\"://\")) {\n+                if (hostPath == null || hostPath.isEmpty() || \"/\".equals(hostPath) || path.contains(\"://\")) {\n                     urlBuilder.setPath(path);\n                 } else {\n                     urlBuilder.setPath(hostPath + \"/\" + path);\n                 }\n             }\n         }\n \n-        for (final EncodedParameter queryParameter : methodParser.setEncodedQueryParameters(args)) {\n-            urlBuilder.setQueryParameter(queryParameter.getName(), queryParameter.getEncodedValue());\n-        }\n+        methodParser.setEncodedQueryParameters(args, urlBuilder);\n \n         final URL url = urlBuilder.toUrl();\n         final HttpRequest request = configRequest(new HttpRequest(methodParser.getHttpMethod(), url),\n             methodParser, args);\n \n         // Headers from Swagger method arguments always take precedence over inferred headers from body types\n-        for (final HttpHeader header : methodParser.setHeaders(args)) {\n-            request.setHeader(header.getName(), header.getValue());\n-        }\n+        HttpHeaders httpHeaders = request.getHeaders();\n+        methodParser.setHeaders(args, httpHeaders);\n \n         return request;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private HttpRequest configRequest(HttpRequest request, SwaggerMethodParser methodParser, Object[] args)\n-        throws IOException {\n+    private HttpRequest configRequest(final HttpRequest request,\n+                                      final SwaggerMethodParser methodParser,\n+                                      final Object[] args) throws IOException {\n         final Object bodyContentObject = methodParser.setBody(args);\n         if (bodyContentObject == null) {\n             request.getHeaders().put(\"Content-Length\", \"0\");\n         } else {\n+            // We read the content type from the @BodyParam annotation\n             String contentType = methodParser.getBodyContentType();\n+\n+            // If this is null or empty, the service interface definition is incomplete and should\n+            // be fixed to ensure correct definitions are applied\n             if (contentType == null || contentType.isEmpty()) {\n                 if (bodyContentObject instanceof byte[] || bodyContentObject instanceof String) {\n                     contentType = ContentType.APPLICATION_OCTET_STREAM;\n                 } else {\n                     contentType = ContentType.APPLICATION_JSON;\n                 }\n+//                throw logger.logExceptionAsError(new IllegalStateException(\n+//                    \"The method \" + methodParser.getFullyQualifiedMethodName() + \" does does not have its content \"\n+//                        + \"type correctly specified in its service interface\"));\n             }\n \n             request.getHeaders().put(\"Content-Type\", contentType);\n \n+            // TODO(jogiles) this feels hacky\n             boolean isJson = false;\n             final String[] contentTypeParts = contentType.split(\";\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f17417bfb0f38989efd4d50dfb7d8af0d089ea63"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODAyNg==", "bodyText": "I looked into this when I was reviewing the code, String.split has a fast-path for single-char 'regexes' which this goes through. You can see the fast path in the JDK here: http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/String.java#l2317", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r467638026", "createdAt": "2020-08-09T22:48:59Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/RestProxy.java", "diffHunk": "@@ -195,86 +198,86 @@ private Context startTracingSpan(Method method, Context context) {\n      * @throws IOException thrown if the body contents cannot be serialized\n      */\n     private HttpRequest createHttpRequest(SwaggerMethodParser methodParser, Object[] args) throws IOException {\n-        UrlBuilder urlBuilder;\n-\n         // Sometimes people pass in a full URL for the value of their PathParam annotated argument.\n         // This definitely happens in paging scenarios. In that case, just use the full URL and\n         // ignore the Host annotation.\n         final String path = methodParser.setPath(args);\n         final UrlBuilder pathUrlBuilder = UrlBuilder.parse(path);\n+\n+        final UrlBuilder urlBuilder;\n         if (pathUrlBuilder.getScheme() != null) {\n             urlBuilder = pathUrlBuilder;\n         } else {\n             urlBuilder = new UrlBuilder();\n \n-            final String scheme = methodParser.setScheme(args);\n-            urlBuilder.setScheme(scheme);\n-\n-            final String host = methodParser.setHost(args);\n-            urlBuilder.setHost(host);\n+            methodParser.setSchemeAndHost(args, urlBuilder);\n \n             // Set the path after host, concatenating the path\n             // segment in the host.\n-            if (path != null && !path.isEmpty() && !path.equals(\"/\")) {\n+            if (path != null && !path.isEmpty() && !\"/\".equals(path)) {\n                 String hostPath = urlBuilder.getPath();\n-                if (hostPath == null || hostPath.isEmpty() || hostPath.equals(\"/\") || path.contains(\"://\")) {\n+                if (hostPath == null || hostPath.isEmpty() || \"/\".equals(hostPath) || path.contains(\"://\")) {\n                     urlBuilder.setPath(path);\n                 } else {\n                     urlBuilder.setPath(hostPath + \"/\" + path);\n                 }\n             }\n         }\n \n-        for (final EncodedParameter queryParameter : methodParser.setEncodedQueryParameters(args)) {\n-            urlBuilder.setQueryParameter(queryParameter.getName(), queryParameter.getEncodedValue());\n-        }\n+        methodParser.setEncodedQueryParameters(args, urlBuilder);\n \n         final URL url = urlBuilder.toUrl();\n         final HttpRequest request = configRequest(new HttpRequest(methodParser.getHttpMethod(), url),\n             methodParser, args);\n \n         // Headers from Swagger method arguments always take precedence over inferred headers from body types\n-        for (final HttpHeader header : methodParser.setHeaders(args)) {\n-            request.setHeader(header.getName(), header.getValue());\n-        }\n+        HttpHeaders httpHeaders = request.getHeaders();\n+        methodParser.setHeaders(args, httpHeaders);\n \n         return request;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private HttpRequest configRequest(HttpRequest request, SwaggerMethodParser methodParser, Object[] args)\n-        throws IOException {\n+    private HttpRequest configRequest(final HttpRequest request,\n+                                      final SwaggerMethodParser methodParser,\n+                                      final Object[] args) throws IOException {\n         final Object bodyContentObject = methodParser.setBody(args);\n         if (bodyContentObject == null) {\n             request.getHeaders().put(\"Content-Length\", \"0\");\n         } else {\n+            // We read the content type from the @BodyParam annotation\n             String contentType = methodParser.getBodyContentType();\n+\n+            // If this is null or empty, the service interface definition is incomplete and should\n+            // be fixed to ensure correct definitions are applied\n             if (contentType == null || contentType.isEmpty()) {\n                 if (bodyContentObject instanceof byte[] || bodyContentObject instanceof String) {\n                     contentType = ContentType.APPLICATION_OCTET_STREAM;\n                 } else {\n                     contentType = ContentType.APPLICATION_JSON;\n                 }\n+//                throw logger.logExceptionAsError(new IllegalStateException(\n+//                    \"The method \" + methodParser.getFullyQualifiedMethodName() + \" does does not have its content \"\n+//                        + \"type correctly specified in its service interface\"));\n             }\n \n             request.getHeaders().put(\"Content-Type\", contentType);\n \n+            // TODO(jogiles) this feels hacky\n             boolean isJson = false;\n             final String[] contentTypeParts = contentType.split(\";\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMDE0NA=="}, "originalCommit": {"oid": "f17417bfb0f38989efd4d50dfb7d8af0d089ea63"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MTM1NA==", "bodyText": "Thank you @JonathanGiles I learnt something today.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r468781354", "createdAt": "2020-08-11T18:30:35Z", "author": {"login": "moderakh"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/rest/RestProxy.java", "diffHunk": "@@ -195,86 +198,86 @@ private Context startTracingSpan(Method method, Context context) {\n      * @throws IOException thrown if the body contents cannot be serialized\n      */\n     private HttpRequest createHttpRequest(SwaggerMethodParser methodParser, Object[] args) throws IOException {\n-        UrlBuilder urlBuilder;\n-\n         // Sometimes people pass in a full URL for the value of their PathParam annotated argument.\n         // This definitely happens in paging scenarios. In that case, just use the full URL and\n         // ignore the Host annotation.\n         final String path = methodParser.setPath(args);\n         final UrlBuilder pathUrlBuilder = UrlBuilder.parse(path);\n+\n+        final UrlBuilder urlBuilder;\n         if (pathUrlBuilder.getScheme() != null) {\n             urlBuilder = pathUrlBuilder;\n         } else {\n             urlBuilder = new UrlBuilder();\n \n-            final String scheme = methodParser.setScheme(args);\n-            urlBuilder.setScheme(scheme);\n-\n-            final String host = methodParser.setHost(args);\n-            urlBuilder.setHost(host);\n+            methodParser.setSchemeAndHost(args, urlBuilder);\n \n             // Set the path after host, concatenating the path\n             // segment in the host.\n-            if (path != null && !path.isEmpty() && !path.equals(\"/\")) {\n+            if (path != null && !path.isEmpty() && !\"/\".equals(path)) {\n                 String hostPath = urlBuilder.getPath();\n-                if (hostPath == null || hostPath.isEmpty() || hostPath.equals(\"/\") || path.contains(\"://\")) {\n+                if (hostPath == null || hostPath.isEmpty() || \"/\".equals(hostPath) || path.contains(\"://\")) {\n                     urlBuilder.setPath(path);\n                 } else {\n                     urlBuilder.setPath(hostPath + \"/\" + path);\n                 }\n             }\n         }\n \n-        for (final EncodedParameter queryParameter : methodParser.setEncodedQueryParameters(args)) {\n-            urlBuilder.setQueryParameter(queryParameter.getName(), queryParameter.getEncodedValue());\n-        }\n+        methodParser.setEncodedQueryParameters(args, urlBuilder);\n \n         final URL url = urlBuilder.toUrl();\n         final HttpRequest request = configRequest(new HttpRequest(methodParser.getHttpMethod(), url),\n             methodParser, args);\n \n         // Headers from Swagger method arguments always take precedence over inferred headers from body types\n-        for (final HttpHeader header : methodParser.setHeaders(args)) {\n-            request.setHeader(header.getName(), header.getValue());\n-        }\n+        HttpHeaders httpHeaders = request.getHeaders();\n+        methodParser.setHeaders(args, httpHeaders);\n \n         return request;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private HttpRequest configRequest(HttpRequest request, SwaggerMethodParser methodParser, Object[] args)\n-        throws IOException {\n+    private HttpRequest configRequest(final HttpRequest request,\n+                                      final SwaggerMethodParser methodParser,\n+                                      final Object[] args) throws IOException {\n         final Object bodyContentObject = methodParser.setBody(args);\n         if (bodyContentObject == null) {\n             request.getHeaders().put(\"Content-Length\", \"0\");\n         } else {\n+            // We read the content type from the @BodyParam annotation\n             String contentType = methodParser.getBodyContentType();\n+\n+            // If this is null or empty, the service interface definition is incomplete and should\n+            // be fixed to ensure correct definitions are applied\n             if (contentType == null || contentType.isEmpty()) {\n                 if (bodyContentObject instanceof byte[] || bodyContentObject instanceof String) {\n                     contentType = ContentType.APPLICATION_OCTET_STREAM;\n                 } else {\n                     contentType = ContentType.APPLICATION_JSON;\n                 }\n+//                throw logger.logExceptionAsError(new IllegalStateException(\n+//                    \"The method \" + methodParser.getFullyQualifiedMethodName() + \" does does not have its content \"\n+//                        + \"type correctly specified in its service interface\"));\n             }\n \n             request.getHeaders().put(\"Content-Type\", contentType);\n \n+            // TODO(jogiles) this feels hacky\n             boolean isJson = false;\n             final String[] contentTypeParts = contentType.split(\";\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMDE0NA=="}, "originalCommit": {"oid": "f17417bfb0f38989efd4d50dfb7d8af0d089ea63"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc2MDI4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyOToyOVrOG_LaAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNDowNVrOG_LgsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMDM1NA==", "bodyText": "I thought we decided to not use afterburner for now because we didn't see any perf wins. We should remove this now, correct?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r468900354", "createdAt": "2020-08-11T22:29:29Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/pom.xml", "diffHunk": "@@ -65,6 +65,11 @@\n       <artifactId>jackson-dataformat-xml</artifactId>\n       <version>2.10.1</version> <!-- {x-version-update;com.fasterxml.jackson.dataformat:jackson-dataformat-xml;external_dependency} -->\n     </dependency>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.module</groupId>\n+      <artifactId>jackson-module-afterburner</artifactId>\n+      <version>2.10.1</version> <!-- {x-version-update;com.fasterxml.jackson.module:jackson-module-afterburner;external_dependency} -->\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2300f7e0a3cb48acd6851ceb21f050f45d7f693"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMjA2NA==", "bodyText": "@JonathanGiles , cosmos team is also using after-burner. and we have seen perf gain.\nI think you would see per gain for more complex Pojo where many reflection calls will be made in the absence of after-burner.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r468902064", "createdAt": "2020-08-11T22:34:05Z", "author": {"login": "moderakh"}, "path": "sdk/core/azure-core/pom.xml", "diffHunk": "@@ -65,6 +65,11 @@\n       <artifactId>jackson-dataformat-xml</artifactId>\n       <version>2.10.1</version> <!-- {x-version-update;com.fasterxml.jackson.dataformat:jackson-dataformat-xml;external_dependency} -->\n     </dependency>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.module</groupId>\n+      <artifactId>jackson-module-afterburner</artifactId>\n+      <version>2.10.1</version> <!-- {x-version-update;com.fasterxml.jackson.module:jackson-module-afterburner;external_dependency} -->\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMDM1NA=="}, "originalCommit": {"oid": "a2300f7e0a3cb48acd6851ceb21f050f45d7f693"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTM5MTM3OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/UrlBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMjowNDozNFrOHOz_WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMjowNDozNFrOHOz_WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI5MzkxMw==", "bodyText": "There might be a potential concurrency issue here on the static Map.\nWe had a possible one on this line in UrlBuilder.parse (under Java 8)\nPARSED_URLS.put(url, ub);\n\nhttps://user-images.githubusercontent.com/15213781/92462976-c574af80-f1fd-11ea-8f19-33e0919913a5.png", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12890#discussion_r485293913", "createdAt": "2020-09-09T02:04:34Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/UrlBuilder.java", "diffHunk": "@@ -3,18 +3,17 @@\n \n package com.azure.core.util;\n \n-import com.azure.core.util.logging.ClientLogger;\n-\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n /**\n  * A builder class that is used to create URLs.\n  */\n public final class UrlBuilder {\n-    private final ClientLogger logger = new ClientLogger(UrlBuilder.class);\n+    private static final Map<String, UrlBuilder> PARSED_URLS = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abefdd5b4aade41de35956686a733c860b6ab96f"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3653, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}