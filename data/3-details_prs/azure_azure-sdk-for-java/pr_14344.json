{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxODkxNzg4", "number": 14344, "title": "Cosmos encryption AKV integration initial version", "bodyText": "This PR follows the design of Azure/azure-cosmos-dotnet-v3#1660\nto provide an AzureKeyVaultCosmosEncryptor.\nThis PR doesn't change anything in the azure-cosmos. All new changes are in azure-cosmos-encryption.\nTODOs to be addressed: (after this PR)\n\nakv blocking calls should become non-blocking\nsample missing\ncode style fix, java convention to name static constant members, etc.", "createdAt": "2020-08-21T23:16:08Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344", "merged": true, "mergeCommit": {"oid": "e3bab2c785b8f106f3e44cfba2494c725fc9aea1"}, "closed": true, "closedAt": "2020-08-25T15:24:32Z", "author": {"login": "moderakh"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdBNKpIgH2gAyNDcxODkxNzg4OmVlNmYzMmZmYTZkZmE0NjdiNDdjZDA5NDcxNTY5MjVhZjc4MTE1MDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCRrJiAH2gAyNDcxODkxNzg4OjI2OGFmNWM4NzQyZWU5MTQ5YjNmOGYxOGFkOTZkMTJjYThjOTg0NmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ee6f32ffa6dfa467b47cd0947156925af7811503", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ee6f32ffa6dfa467b47cd0947156925af7811503", "committedDate": "2020-08-21T23:11:33Z", "message": "cosmos akv integration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a5d02472cb29485e7a9f88546a1994e8271fc61", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a5d02472cb29485e7a9f88546a1994e8271fc61", "committedDate": "2020-08-22T04:52:06Z", "message": "fixed a few CI code style issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b71122016dcbfeb32e6e8dfbff578c5299935a4a", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b71122016dcbfeb32e6e8dfbff578c5299935a4a", "committedDate": "2020-08-24T16:03:32Z", "message": "updated pom"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/003e7e859d0d5a0cca2d019350d6dae955eaf7af", "committedDate": "2020-08-24T16:57:08Z", "message": "remove transitive dependency on tcnative"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzA1NzI1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#pullrequestreview-473705725", "createdAt": "2020-08-24T17:21:07Z", "commit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyMTowN1rOHFvASg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNToyM1rOHFvJ8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NTA1MA==", "bodyText": "We should add some description to these class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475775050", "createdAt": "2020-08-24T17:21:07Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/AzureKeyVaultKeyWrapProvider.java", "diffHunk": "@@ -0,0 +1,94 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.encryption.EncryptionUtils;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+// TODO: moderakh remove blocking calls\n+public class AzureKeyVaultKeyWrapProvider implements EncryptionKeyWrapProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjE2MA==", "bodyText": "logger ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475776160", "createdAt": "2020-08-24T17:22:57Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.cosmos.implementation.caches.AsyncCache;\n+import com.azure.security.keyvault.keys.KeyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.models.UnwrapResult;\n+import com.azure.security.keyvault.keys.cryptography.models.WrapResult;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import reactor.core.publisher.Mono;\n+\n+import java.net.URI;\n+\n+/**\n+ * Implements Core KeyVault access methods that uses the TODO: moderakh this doesn't need to be public. it is public due\n+ * to tests. FIXME\n+ * TODO: methods should be async moderakh\n+ */\n+public class KeyVaultAccessClient {\n+    private final AsyncCache<URI, KeyAsyncClient> akvClientCache;\n+    private final AsyncCache<URI, CryptographyAsyncClient> akvCryptoClientCache;\n+    private final KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory;\n+    private final KeyClientFactory keyClientFactory;\n+    private final CryptographyClientFactory cryptographyClientFactory;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultAccessClient}\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredentials factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = new KeyClientFactory();\n+        this.cryptographyClientFactory = new CryptographyClientFactory();\n+    }\n+\n+    /**\n+     * TODO: this doesn't need to be public moderakh Initializes a new instance of the {@link KeyVaultAccessClient}\n+     * class Invokes internal factory Methods.\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredential\n+     * @param keyClientFactory KeyClient Factory\n+     * @param cryptographyClientFactory KeyClient Factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory,\n+                                KeyClientFactory keyClientFactory,\n+                                CryptographyClientFactory cryptographyClientFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = keyClientFactory;\n+        this.cryptographyClientFactory = cryptographyClientFactory;\n+    }\n+\n+    /**\n+     * Unwrap the encrypted Key. Only supports encrypted bytes in base64 format.\n+     *\n+     * Note: this may return an empty Mono if cryptoClient returns empty/null\n+     *\n+     * @param wrappedKey encrypted bytes.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and decrypted bytes in base64 string format, can be convert to\n+     * bytes using Convert.FromBase64String().\n+     */\n+    public Mono<byte[]> unwrapKeyAsync(\n+        byte[] wrappedKey,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        UnwrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        Mono<CryptographyAsyncClient> cryptoClientMono = this.getCryptoClientAsync(keyVaultUriProperties);\n+\n+        // TODO: moderakh change to async\n+        CryptographyAsyncClient cryptoClient = cryptoClientMono.block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.unwrapKey(KeyVaultConstants.RsaOaep256, wrappedKey).block();\n+        } catch (AzureException ex) {\n+\n+            throw new KeyVaultAccessException();\n+            // TODO: set proper exception moderakh\n+            //            throw new KeyVaultAccessException(\n+            //                ex.Status,\n+            //                ex.ErrorCode,\n+            //                \"UnwrapKeyAsync:Failed to Unwrap the encrypted key.\",\n+            //                ex);\n+        }\n+\n+        if (keyOpResult == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"keyOpResult cannot be null\"));\n+        }\n+\n+        // may return null\n+        return Mono.justOrEmpty(keyOpResult.getKey());\n+    }\n+\n+    /**\n+     * Wrap the Key with latest Key version. Only supports bytes in base64 format.\n+     *\n+     * @param key plain text key.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and encrypted bytes in base64 string format.\n+     */\n+    public Mono<byte[]> wrapKeyAsync(\n+        byte[] key,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        WrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        CryptographyAsyncClient cryptoClient = this.getCryptoClientAsync(keyVaultUriProperties).block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.wrapKey(KeyVaultConstants.RsaOaep256, key).block();\n+        }\n+        // TODO: set proper exception moderakh moderakh\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"WrapKeyAsync: Failed to Wrap the data encryption key.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjI4NQ==", "bodyText": "logger ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475776285", "createdAt": "2020-08-24T17:23:12Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessClient.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.cosmos.implementation.caches.AsyncCache;\n+import com.azure.security.keyvault.keys.KeyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\n+import com.azure.security.keyvault.keys.cryptography.models.UnwrapResult;\n+import com.azure.security.keyvault.keys.cryptography.models.WrapResult;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import reactor.core.publisher.Mono;\n+\n+import java.net.URI;\n+\n+/**\n+ * Implements Core KeyVault access methods that uses the TODO: moderakh this doesn't need to be public. it is public due\n+ * to tests. FIXME\n+ * TODO: methods should be async moderakh\n+ */\n+public class KeyVaultAccessClient {\n+    private final AsyncCache<URI, KeyAsyncClient> akvClientCache;\n+    private final AsyncCache<URI, CryptographyAsyncClient> akvCryptoClientCache;\n+    private final KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory;\n+    private final KeyClientFactory keyClientFactory;\n+    private final CryptographyClientFactory cryptographyClientFactory;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultAccessClient}\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredentials factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = new KeyClientFactory();\n+        this.cryptographyClientFactory = new CryptographyClientFactory();\n+    }\n+\n+    /**\n+     * TODO: this doesn't need to be public moderakh Initializes a new instance of the {@link KeyVaultAccessClient}\n+     * class Invokes internal factory Methods.\n+     *\n+     * @param keyVaultTokenCredentialFactory TokenCredential\n+     * @param keyClientFactory KeyClient Factory\n+     * @param cryptographyClientFactory KeyClient Factory\n+     */\n+    public KeyVaultAccessClient(KeyVaultTokenCredentialFactory keyVaultTokenCredentialFactory,\n+                                KeyClientFactory keyClientFactory,\n+                                CryptographyClientFactory cryptographyClientFactory) {\n+        this.keyVaultTokenCredentialFactory = keyVaultTokenCredentialFactory;\n+        this.akvClientCache = new AsyncCache<>();\n+        this.akvCryptoClientCache = new AsyncCache<>();\n+        this.keyClientFactory = keyClientFactory;\n+        this.cryptographyClientFactory = cryptographyClientFactory;\n+    }\n+\n+    /**\n+     * Unwrap the encrypted Key. Only supports encrypted bytes in base64 format.\n+     *\n+     * Note: this may return an empty Mono if cryptoClient returns empty/null\n+     *\n+     * @param wrappedKey encrypted bytes.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and decrypted bytes in base64 string format, can be convert to\n+     * bytes using Convert.FromBase64String().\n+     */\n+    public Mono<byte[]> unwrapKeyAsync(\n+        byte[] wrappedKey,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        UnwrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        Mono<CryptographyAsyncClient> cryptoClientMono = this.getCryptoClientAsync(keyVaultUriProperties);\n+\n+        // TODO: moderakh change to async\n+        CryptographyAsyncClient cryptoClient = cryptoClientMono.block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.unwrapKey(KeyVaultConstants.RsaOaep256, wrappedKey).block();\n+        } catch (AzureException ex) {\n+\n+            throw new KeyVaultAccessException();\n+            // TODO: set proper exception moderakh\n+            //            throw new KeyVaultAccessException(\n+            //                ex.Status,\n+            //                ex.ErrorCode,\n+            //                \"UnwrapKeyAsync:Failed to Unwrap the encrypted key.\",\n+            //                ex);\n+        }\n+\n+        if (keyOpResult == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"keyOpResult cannot be null\"));\n+        }\n+\n+        // may return null\n+        return Mono.justOrEmpty(keyOpResult.getKey());\n+    }\n+\n+    /**\n+     * Wrap the Key with latest Key version. Only supports bytes in base64 format.\n+     *\n+     * @param key plain text key.\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.Properties as in sample Format:\n+     * https://{keyvault-name}.vault.azure.net/keys/{key-name}/{key-version}\n+     * @return Mono of Result including KeyIdentifier and encrypted bytes in base64 string format.\n+     */\n+    public Mono<byte[]> wrapKeyAsync(\n+        byte[] key,\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        WrapResult keyOpResult;\n+\n+        // Get a Crypto Client for Wrap and UnWrap,this gets init per Key ID\n+        CryptographyAsyncClient cryptoClient = this.getCryptoClientAsync(keyVaultUriProperties).block();\n+        if (cryptoClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+\n+        try {\n+            keyOpResult = cryptoClient.wrapKey(KeyVaultConstants.RsaOaep256, key).block();\n+        }\n+        // TODO: set proper exception moderakh moderakh\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"WrapKeyAsync: Failed to Wrap the data encryption key.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new KeyVaultAccessException();\n+        }\n+\n+        // key vault may return null\n+        return Mono.justOrEmpty(keyOpResult.getEncryptedKey());\n+    }\n+\n+    /**\n+     * Validate the Purge Protection AndSoft Delete Settings.\n+     *\n+     * @param keyVaultUriProperties Parsed key Vault Uri Properties.\n+     * @return Whether The Customer has the correct Deletion Level.\n+     */\n+    public Mono<Boolean> validatePurgeProtectionAndSoftDeleteSettingsAsync(\n+        KeyVaultKeyUriProperties keyVaultUriProperties) {\n+        KeyAsyncClient akvClient = this.getAkvClientAsync(keyVaultUriProperties).block();\n+        if (akvClient == null) {\n+            // this never be empty Mono and hence never null\n+            // TODO: remove this once moved to async and removed blocking call\n+            return Mono.error(new IllegalStateException(\"avk cannot be null\"));\n+        }\n+        try {\n+            KeyVaultKey getKeyResponse = akvClient.getKey(keyVaultUriProperties.getKeyName()).block();\n+\n+            String keyDeletionRecoveryLevel = null;\n+            if (getKeyResponse != null && getKeyResponse.getProperties() != null) {\n+                keyDeletionRecoveryLevel = getKeyResponse.getProperties().getRecoveryLevel();\n+            }\n+\n+            return Mono.just(keyDeletionRecoveryLevel != null && (\n+                keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.Recoverable)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.RecoverableProtectedSubscription)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.CustomizedRecoverable)\n+                    || keyDeletionRecoveryLevel.contains(KeyVaultConstants.DeletionRecoveryLevel.CustomizedRecoverableProtectedSubscription)));\n+        }\n+        //        catch (RequestFailedException ex)\n+        //        {\n+        //            throw new KeyVaultAccessException(\n+        //                ex.Status,\n+        //                ex.ErrorCode,\n+        //                \"ValidatePurgeProtectionAndSoftDeleteSettingsAsync: Failed to fetch Key from Key Vault.\",\n+        //                ex);\n+        //        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NjQ0OA==", "bodyText": "new line at the end of file.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475776448", "createdAt": "2020-08-24T17:23:30Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultAccessException.java", "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.core.exception.AzureException;\n+\n+// TODO: moderakh we should extend CosmosException. dotnet has problem too\n+// TODO also we should set proper error message, status code\n+class KeyVaultAccessException extends AzureException {\n+    public KeyVaultAccessException() {\n+        // TODO: remove this\n+    }\n+\n+    public KeyVaultAccessException(int statusCode,\n+                                   String keyVaultErrorCode,\n+                                   String errorMessage,\n+                                   Exception innerException) {\n+        // TODO: CosmosException as super class?\n+        //super(statusCode, keyVaultErrorCode, errorMessage, innerException)\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzA5Mw==", "bodyText": "Do we need some sort of debug / warn error level logging here ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475777093", "createdAt": "2020-08-24T17:24:40Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/KeyVaultKeyUriProperties.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+//  TODO: this also doesn't need to be public, it is public because of test FIXME\n+public class KeyVaultKeyUriProperties {\n+    private final URI keyUri;\n+    private String keyName;\n+    private URI keyVaultUri;\n+    private String keyVersion;\n+\n+    /**\n+     * Initializes a new instance of the {@link KeyVaultKeyUriProperties} Helper Class to fetch frequently used Uri\n+     * parsed information for KeyVault.\n+     *\n+     * @param keyUri\n+     */\n+    private KeyVaultKeyUriProperties(URI keyUri) {\n+        this.keyUri = keyUri;\n+    }\n+\n+    public URI getKeyUri() {\n+        return keyUri;\n+    }\n+\n+    public String getKeyName() {\n+        return keyName;\n+    }\n+\n+    public String getKeyVersion() {\n+        return keyVersion;\n+    }\n+\n+    public URI getKeyVaultUri() {\n+        return keyVaultUri;\n+    }\n+\n+    private static String[] getSegments(URI uri) {\n+        return StringUtils.split(uri.getPath(), \"/\");\n+    }\n+\n+    public static boolean tryParse(URI keyUri,\n+                                   AtomicReference<KeyVaultKeyUriProperties> keyVaultUriPropertiesReference) {\n+        KeyVaultKeyUriProperties keyVaultUriProperties = null;\n+\n+        String[] segments = getSegments(keyUri);\n+        // https://testdemo1.vault.azure.net/keys/testkey1/47d306aeaae74baab294672354603ca3\n+\n+        // https://testdemo1.vault.azure.net/keys/testkey1/47d306aeaae74baab294672354603ca3\n+        if (!((segments.length == 3) && StringUtils.equalsIgnoreCase(segments[0], KeyVaultConstants.KeysSegment))) {\n+            return false;\n+        }\n+\n+        try {\n+            // TODO: shifted the index wrt dot net and keyName is \"testKey1 instead of testkey1/\n+            keyVaultUriProperties = new KeyVaultKeyUriProperties(keyUri);\n+            keyVaultUriProperties.keyName = segments[1]; // \"testKey1/\"\n+            keyVaultUriProperties.keyVersion = segments[2]; // \"47d306aeaae74baab294672354603ca3\"\n+            //keyVaultUriProperties.keyVaultUri = new URI(keyVaultUriProperties.KeyUri.GetLeftPart(UriPartial.Scheme\n+            // | UriPartial.Authority)); // https://testdemo1.vault.azure.net/\n+            keyVaultUriProperties.keyVaultUri = new URI(keyUri.getScheme(), keyUri.getAuthority(), null, null, null); // https://testdemo1.vault.azure.net/\n+\n+            keyVaultUriPropertiesReference.set(keyVaultUriProperties);\n+        } catch (URISyntaxException e) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzUyMQ==", "bodyText": "Please add public description of the class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14344#discussion_r475777521", "createdAt": "2020-08-24T17:25:23Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/encryption/KeyModelFactory.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.encryption;\n+\n+import com.azure.cosmos.implementation.guava25.base.Function;\n+import com.azure.security.keyvault.keys.models.JsonWebKey;\n+import com.azure.security.keyvault.keys.models.KeyOperation;\n+import com.azure.security.keyvault.keys.models.KeyProperties;\n+import com.azure.security.keyvault.keys.models.KeyType;\n+import com.azure.security.keyvault.keys.models.KeyVaultKey;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.List;\n+\n+public class KeyModelFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003e7e859d0d5a0cca2d019350d6dae955eaf7af"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "706fefc4dbcac5e16e85828e5f5ad6eabb228342", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/706fefc4dbcac5e16e85828e5f5ad6eabb228342", "committedDate": "2020-08-24T17:50:37Z", "message": "addressed code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4eddeeca10fbcdcafa290b42a252817683546fd", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b4eddeeca10fbcdcafa290b42a252817683546fd", "committedDate": "2020-08-25T06:51:15Z", "message": "added sample"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "268af5c8742ee9149b3f8f18ad96d12ca8c9846e", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/268af5c8742ee9149b3f8f18ad96d12ca8c9846e", "committedDate": "2020-08-25T07:00:36Z", "message": "update azure-identity dependency version"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 346, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}