{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMzU4NjU2", "number": 17044, "title": "[Tables] Add transactional batch support", "bodyText": "Fixes: #15901", "createdAt": "2020-10-31T02:32:41Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044", "merged": true, "mergeCommit": {"oid": "77c1f7a4989f52b49df8da8a7e3e7cdf12580751"}, "closed": true, "closedAt": "2020-11-06T21:31:10Z", "author": {"login": "bsiegel"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdYrzZ6gBqjM5NTAyMzIwODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZ82kbgFqTUyNTQ2NzcwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abe77a0889632e7653732f3aa73a93ad8b8c3305", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/abe77a0889632e7653732f3aa73a93ad8b8c3305", "committedDate": "2020-11-02T20:58:23Z", "message": "Add changelog"}, "afterCommit": {"oid": "12f7cd15c1a375b1698d95de3f1d169954097c5e", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/12f7cd15c1a375b1698d95de3f1d169954097c5e", "committedDate": "2020-11-02T21:53:17Z", "message": "Add changelog"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12f7cd15c1a375b1698d95de3f1d169954097c5e", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/12f7cd15c1a375b1698d95de3f1d169954097c5e", "committedDate": "2020-11-02T21:53:17Z", "message": "Add changelog"}, "afterCommit": {"oid": "8d8f62830a0ef8fd9833b089d6dcb6db7377eaac", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8d8f62830a0ef8fd9833b089d6dcb6db7377eaac", "committedDate": "2020-11-02T22:21:13Z", "message": "Add changelog"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d8f62830a0ef8fd9833b089d6dcb6db7377eaac", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8d8f62830a0ef8fd9833b089d6dcb6db7377eaac", "committedDate": "2020-11-02T22:21:13Z", "message": "Add changelog"}, "afterCommit": {"oid": "05afd40e73cde9d1b87c4cb497210b3df18bceab", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/05afd40e73cde9d1b87c4cb497210b3df18bceab", "committedDate": "2020-11-02T22:36:35Z", "message": "Add changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87401a34fdfc9dab30c7ab9eed6d9016d3c90472", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/87401a34fdfc9dab30c7ab9eed6d9016d3c90472", "committedDate": "2020-11-02T23:22:01Z", "message": "Initial public API for batching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e91eb4ab2f296ffb4b47dd4f7cc3c0698e5634d8", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e91eb4ab2f296ffb4b47dd4f7cc3c0698e5634d8", "committedDate": "2020-11-02T23:22:02Z", "message": "Record operations in a txn"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5831e7506689447b37291f87a1eaeb25b48702f", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5831e7506689447b37291f87a1eaeb25b48702f", "committedDate": "2020-11-02T23:22:02Z", "message": "Make the batch APIs fluent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90a7b27dbb67c8ace1fb4336276e4e1c56684264", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/90a7b27dbb67c8ace1fb4336276e4e1c56684264", "committedDate": "2020-11-02T23:22:02Z", "message": "Make batch interactions thread-safe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21ac1034eb381dc6ef8866c1f237c0d77ba106f0", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21ac1034eb381dc6ef8866c1f237c0d77ba106f0", "committedDate": "2020-11-02T23:22:03Z", "message": "Fix return types for batch operations\n\nThey return a multipart response body containing either all the\nindividual responses or one error response, but for now just make\nthese Response<Void>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed2fdcd04c6bc27f01ee92202afd6d65e3a4ae56", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed2fdcd04c6bc27f01ee92202afd6d65e3a4ae56", "committedDate": "2020-11-02T23:22:03Z", "message": "Model the body of a Multipart request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9150be5735247b56186574bdb6666930d2f2fc1a", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9150be5735247b56186574bdb6666930d2f2fc1a", "committedDate": "2020-11-02T23:22:03Z", "message": "Add service client for table batch operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ca313ced2308c1f4be6dda5c4ca1458d43d7260", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ca313ced2308c1f4be6dda5c4ca1458d43d7260", "committedDate": "2020-11-02T23:22:03Z", "message": "Refactor Batch into client-like objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cc4b43ab77568b97ac2f4f30b649c98e28a2fca", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2cc4b43ab77568b97ac2f4f30b649c98e28a2fca", "committedDate": "2020-11-02T23:22:04Z", "message": "Checkpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dbb9c0aff1c7b1927ae7f58da2eb1ea572591b9", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3dbb9c0aff1c7b1927ae7f58da2eb1ea572591b9", "committedDate": "2020-11-02T23:22:04Z", "message": "Batch now propagates errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10a65318612a0eb86311712c7a107a20cff395e3", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/10a65318612a0eb86311712c7a107a20cff395e3", "committedDate": "2020-11-02T23:22:04Z", "message": "Fix including failed operation in batch error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c443c99a62d4043ffd8e5fe12cd832ecc98f1049", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c443c99a62d4043ffd8e5fe12cd832ecc98f1049", "committedDate": "2020-11-02T23:22:04Z", "message": "Add recordings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6095a9005a7fa59c20a8372970ecade3190acb6", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a6095a9005a7fa59c20a8372970ecade3190acb6", "committedDate": "2020-11-02T23:22:05Z", "message": "Add changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cae7c89a09f9c8a5508941c400be2ba22f02b67b", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cae7c89a09f9c8a5508941c400be2ba22f02b67b", "committedDate": "2020-11-02T23:39:06Z", "message": "Fix checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76486a368b1b7bf4acdd490cbec81207dc5d979b", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/76486a368b1b7bf4acdd490cbec81207dc5d979b", "committedDate": "2020-11-03T00:45:17Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "108b27f67bbfc703fe0fe31722e052b240c5db87", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/108b27f67bbfc703fe0fe31722e052b240c5db87", "committedDate": "2020-11-03T01:01:58Z", "message": "Fix spotbugs issues"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05afd40e73cde9d1b87c4cb497210b3df18bceab", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/05afd40e73cde9d1b87c4cb497210b3df18bceab", "committedDate": "2020-11-02T22:36:35Z", "message": "Add changelog"}, "afterCommit": {"oid": "108b27f67bbfc703fe0fe31722e052b240c5db87", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/108b27f67bbfc703fe0fe31722e052b240c5db87", "committedDate": "2020-11-03T01:01:58Z", "message": "Fix spotbugs issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fcab1aa5e8fc7ee61951a9380dc5b944f4b42af", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3fcab1aa5e8fc7ee61951a9380dc5b944f4b42af", "committedDate": "2020-11-04T23:05:45Z", "message": "Move BatchOperationResponse to the public API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdd146ba058944494847278d7c07f7dc1346a1e6", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cdd146ba058944494847278d7c07f7dc1346a1e6", "committedDate": "2020-11-04T23:06:45Z", "message": "Disallow submitting the batch with no operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "656ddb1f6bf0005e8fc25f959f3c1f7567d013fe", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/656ddb1f6bf0005e8fc25f959f3c1f7567d013fe", "committedDate": "2020-11-04T23:07:23Z", "message": "Don't try to serialize a null sub-request body"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f09aa2ae34ca3bdb3a857fb66d3510dfbc9849dc", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f09aa2ae34ca3bdb3a857fb66d3510dfbc9849dc", "committedDate": "2020-11-04T23:07:41Z", "message": "Handle more error cases in sub-responses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9238dffa3b263ab2391cd61a563170c589c8102b", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9238dffa3b263ab2391cd61a563170c589c8102b", "committedDate": "2020-11-04T23:08:10Z", "message": "The HTTP verb for merge sub-requests must be MERGE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0c6571b68f395ba39b4919b6f121d08dd092638", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d0c6571b68f395ba39b4919b6f121d08dd092638", "committedDate": "2020-11-04T23:30:07Z", "message": "Fix upsert - it was actually doing an update!\n\nAlso simplify the implementation of update, the getEntity result is not\nused, nor does it appear to be needed in order to fail correctly when\nthe entity does not exist, as #13680 seems to imply."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f24814e6f4457098d5b291efc86f785f75ea3c8a", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f24814e6f4457098d5b291efc86f785f75ea3c8a", "committedDate": "2020-11-04T23:30:21Z", "message": "Send the whole URL in each sub-request."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a2c23890662eaeb77d345b835e8136af7e5a613", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a2c23890662eaeb77d345b835e8136af7e5a613", "committedDate": "2020-11-04T23:40:37Z", "message": "Add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bdd5eb88d111088a63febb9afd03734774ab3ad", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2bdd5eb88d111088a63febb9afd03734774ab3ad", "committedDate": "2020-11-05T00:59:14Z", "message": "Make BatchOperationResponse public read-only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95fb875ccf6a5a0a66222645afea6c5381d37c8a", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/95fb875ccf6a5a0a66222645afea6c5381d37c8a", "committedDate": "2020-11-05T00:59:15Z", "message": "Re-record tests and commit recordings"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ca8eaf0a2ea07606c4fd58ef3f78609ce3be82a", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ca8eaf0a2ea07606c4fd58ef3f78609ce3be82a", "committedDate": "2020-11-04T23:48:04Z", "message": "Re-record tests and commit recordings"}, "afterCommit": {"oid": "95fb875ccf6a5a0a66222645afea6c5381d37c8a", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/95fb875ccf6a5a0a66222645afea6c5381d37c8a", "committedDate": "2020-11-05T00:59:15Z", "message": "Re-record tests and commit recordings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9fb9131e7f167be7c63cefc4c1296aeb52003d76", "committedDate": "2020-11-05T01:09:39Z", "message": "Add changelog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzOTUyMzA2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#pullrequestreview-523952306", "createdAt": "2020-11-05T06:17:50Z", "commit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNjoxNzo1MVrOHt04-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNjozOTowMlrOHt1TbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNDUyMw==", "bodyText": "Since there is only one element, you probably don't have to allocate a list for it:\nHttpPipelinePolicy[] policies = {\n    new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", \"application/json;odata=minimalmetadata\"))\n};", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517814523", "createdAt": "2020-11-05T06:17:51Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/BuilderHelper.java", "diffHunk": "@@ -99,6 +100,16 @@ static HttpPipeline buildPipeline(TablesSharedKeyCredential tablesSharedKeyCrede\n             .build();\n     }\n \n+    static HttpPipeline buildNullClientPipeline() {\n+        List<HttpPipelinePolicy> policies = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNjAxNg==", "bodyText": "Do we need a new instance of this serializer for each batch? Can it be passed in as a dependency?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517816016", "createdAt": "2020-11-05T06:22:41Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNzM3OA==", "bodyText": "We don't align parameters or throws.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517817378", "createdAt": "2020-11-05T06:26:51Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNzUwMw==", "bodyText": "Same with the other javadocs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517817503", "createdAt": "2020-11-05T06:27:09Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNzM3OA=="}, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODgyMQ==", "bodyText": "doOnNext should be for side effects like logging. There are better operators to use if you want it to be part of your main scenario.\nIn this case, would you be better using operations.stream()....? There aren't any async operations going on.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517818821", "createdAt": "2020-11-05T06:31:14Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxOTcxNQ==", "bodyText": "The .handle operator is better for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517819715", "createdAt": "2020-11-05T06:34:05Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();\n+\n+        try {\n+            return batchImpl.submitBatchWithRestResponseAsync(body, null, context)\n+                .map(response -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMDkwMg==", "bodyText": "Is it possible to make this an AtomicBoolean and use that as a guard instead of having every method synchronized?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517820902", "createdAt": "2020-11-05T06:37:46Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMDk4NA==", "bodyText": "We have CoreUtils.isNullorEmpty", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517820984", "createdAt": "2020-11-05T06:38:03Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();\n+\n+        try {\n+            return batchImpl.submitBatchWithRestResponseAsync(body, null, context)\n+                .map(response -> {\n+                    TableServiceError error = null;\n+                    String errorMessage = null;\n+                    BatchChangeSet changes = null;\n+                    BatchOperation failedOperation = null;\n+\n+                    if (body.getContents().get(0) instanceof BatchChangeSet) {\n+                        changes = (BatchChangeSet) body.getContents().get(0);\n+                    }\n+\n+                    for (int i = 0; i < response.getValue().length; i++) {\n+                        BatchOperationResponse subResponse = response.getValue()[i];\n+\n+                        // Attempt to attach a sub-request to each batch sub-response\n+                        if (changes != null && changes.getContents().get(i) != null) {\n+                            ModelHelper.updateBatchOperationResponse(subResponse,\n+                                changes.getContents().get(i).getHttpRequest());\n+                        }\n+\n+                        // If one sub-response was an error, we need to throw even though the service responded with 202\n+                        if (subResponse.getStatusCode() >= 400 && error == null && errorMessage == null) {\n+                            if (subResponse.getValue() instanceof TableServiceError) {\n+                                error = (TableServiceError) subResponse.getValue();\n+\n+                                // Make a best effort to locate the failed operation and include it in the message\n+                                if (changes != null && error.getOdataError() != null\n+                                    && error.getOdataError().getMessage() != null\n+                                    && error.getOdataError().getMessage().getValue() != null) {\n+\n+                                    String message = error.getOdataError().getMessage().getValue();\n+                                    try {\n+                                        int failedIndex = Integer.parseInt(message.substring(0, message.indexOf(\":\")));\n+                                        failedOperation = changes.getContents().get(failedIndex).getOperation();\n+                                    } catch (NumberFormatException e) {\n+                                        // Unable to parse failed operation from batch error message - this just means\n+                                        // the service did not indicate which request was the one that failed. Since\n+                                        // this is optional, just swallow the exception.\n+                                    }\n+                                }\n+                            } else if (subResponse.getValue() instanceof String) {\n+                                errorMessage = \"The service returned the following data for the failed operation: \"\n+                                    + subResponse.getValue();\n+                            } else {\n+                                errorMessage =\n+                                    \"The service returned the following status code for the failed operation: \"\n+                                        + subResponse.getStatusCode();\n+                            }\n+                        }\n+                    }\n+\n+                    if (error != null || errorMessage != null) {\n+                        String message = \"An operation within the batch failed, the transaction has been rolled back.\";\n+                        if (failedOperation != null) {\n+                            message += \" The failed operation was: \" + failedOperation.toString();\n+                        } else if (errorMessage != null) {\n+                            message += \" \" + errorMessage;\n+                        }\n+                        throw logger.logExceptionAsError(new TableServiceErrorException(message, null, error));\n+                    } else {\n+                        return new SimpleResponse<>(response, Arrays.asList(response.getValue()));\n+                    }\n+                });\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    private synchronized void addOperation(BatchOperation operation) {\n+        operations.add(operation);\n+    }\n+\n+    private synchronized void validate(TableEntity entity) {\n+        validate(entity.getPartitionKey(), entity.getRowKey());\n+    }\n+\n+    private synchronized void validate(String partitionKey, String rowKey) {\n+        if (this.frozen) {\n+            throw logger.logExceptionAsError(\n+                new IllegalStateException(\"Operations can't be modified once a batch is submitted.\"));\n+        }\n+\n+        if (!this.partitionKey.equals(partitionKey)) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"All operations in a batch must share the same partition key.\"));\n+        }\n+\n+        if (rowKey == null || rowKey.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMTExNA==", "bodyText": "CoreUtils.isnullorEmpty", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517821114", "createdAt": "2020-11-05T06:38:27Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncClient.java", "diffHunk": "@@ -124,6 +127,31 @@ public TablesServiceVersion getApiVersion() {\n         return TablesServiceVersion.fromString(implementation.getVersion());\n     }\n \n+    /**\n+     * Creates a new {@link TableAsyncBatch} object. Batch objects allow you to enqueue multiple create, update, upsert,\n+     * and/or delete operations on entities that share the same partition key. When the batch is executed, all of the\n+     * operations will be performed as part of a single transaction. As a result, either all operations in the batch\n+     * will succeed, or if a failure occurs, all operations in the batch will be rolled back. Each operation in a batch\n+     * must operate on a distinct row key. Attempting to add multiple operations to a batch that share the same row key\n+     * will cause an exception to be thrown.\n+     *\n+     * @param partitionKey The partition key shared by all operations in the batch.\n+     *\n+     * @return An object representing the batch, to which operations can be added.\n+     * @throws IllegalArgumentException if the provided partition key is {@code null} or empty.\n+     */\n+    public TableAsyncBatch createBatch(String partitionKey) {\n+        if (partitionKey == null || partitionKey.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMTI5Mw==", "bodyText": "parameter alignments aren't necessary. it results in a lot of empty whitespace.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517821293", "createdAt": "2020-11-05T06:39:02Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableBatch.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import static com.azure.storage.common.implementation.StorageImplUtils.blockWithOptionalTimeout;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableClient#createBatch(String)} method on a {@link\n+ * TableClient} object.\n+ */\n+@Fluent\n+public final class TableBatch {\n+    private final TableAsyncBatch batch;\n+\n+    TableBatch(TableAsyncBatch batch) {\n+        this.batch = batch;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableBatch} object, if the entity's row key is {@code null}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjY1NDgz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#pullrequestreview-524665483", "createdAt": "2020-11-05T21:05:25Z", "commit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTowNToyNVrOHuWbJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTowNToyNVrOHuWbJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM2Mzk0MA==", "bodyText": "Shouldn't block here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518363940", "createdAt": "2020-11-05T21:05:25Z", "author": {"login": "alzimmermsft"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 283}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Njg2Njc0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#pullrequestreview-524686674", "createdAt": "2020-11-05T21:28:39Z", "commit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMToyODo0MFrOHuXXPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMToyODo0MFrOHuXXPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM3OTMyNA==", "bodyText": "Given this is in the scope of a reactive operation use Mono.error to return the exception.\nFluxUtil.monoError(logger, /* exception */)\nThis will prevent needing to wrap this statement in a try/catch.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518379324", "createdAt": "2020-11-05T21:28:40Z", "author": {"login": "alzimmermsft"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();\n+\n+        try {\n+            return batchImpl.submitBatchWithRestResponseAsync(body, null, context)\n+                .map(response -> {\n+                    TableServiceError error = null;\n+                    String errorMessage = null;\n+                    BatchChangeSet changes = null;\n+                    BatchOperation failedOperation = null;\n+\n+                    if (body.getContents().get(0) instanceof BatchChangeSet) {\n+                        changes = (BatchChangeSet) body.getContents().get(0);\n+                    }\n+\n+                    for (int i = 0; i < response.getValue().length; i++) {\n+                        BatchOperationResponse subResponse = response.getValue()[i];\n+\n+                        // Attempt to attach a sub-request to each batch sub-response\n+                        if (changes != null && changes.getContents().get(i) != null) {\n+                            ModelHelper.updateBatchOperationResponse(subResponse,\n+                                changes.getContents().get(i).getHttpRequest());\n+                        }\n+\n+                        // If one sub-response was an error, we need to throw even though the service responded with 202\n+                        if (subResponse.getStatusCode() >= 400 && error == null && errorMessage == null) {\n+                            if (subResponse.getValue() instanceof TableServiceError) {\n+                                error = (TableServiceError) subResponse.getValue();\n+\n+                                // Make a best effort to locate the failed operation and include it in the message\n+                                if (changes != null && error.getOdataError() != null\n+                                    && error.getOdataError().getMessage() != null\n+                                    && error.getOdataError().getMessage().getValue() != null) {\n+\n+                                    String message = error.getOdataError().getMessage().getValue();\n+                                    try {\n+                                        int failedIndex = Integer.parseInt(message.substring(0, message.indexOf(\":\")));\n+                                        failedOperation = changes.getContents().get(failedIndex).getOperation();\n+                                    } catch (NumberFormatException e) {\n+                                        // Unable to parse failed operation from batch error message - this just means\n+                                        // the service did not indicate which request was the one that failed. Since\n+                                        // this is optional, just swallow the exception.\n+                                    }\n+                                }\n+                            } else if (subResponse.getValue() instanceof String) {\n+                                errorMessage = \"The service returned the following data for the failed operation: \"\n+                                    + subResponse.getValue();\n+                            } else {\n+                                errorMessage =\n+                                    \"The service returned the following status code for the failed operation: \"\n+                                        + subResponse.getStatusCode();\n+                            }\n+                        }\n+                    }\n+\n+                    if (error != null || errorMessage != null) {\n+                        String message = \"An operation within the batch failed, the transaction has been rolled back.\";\n+                        if (failedOperation != null) {\n+                            message += \" The failed operation was: \" + failedOperation.toString();\n+                        } else if (errorMessage != null) {\n+                            message += \" \" + errorMessage;\n+                        }\n+                        throw logger.logExceptionAsError(new TableServiceErrorException(message, null, error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76"}, "originalPosition": 344}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "committedDate": "2020-11-05T23:07:18Z", "message": "Code review changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92bfa115227d9828937d88ad236042e279a7603c", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/92bfa115227d9828937d88ad236042e279a7603c", "committedDate": "2020-11-05T22:50:06Z", "message": "Code review changes"}, "afterCommit": {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "author": {"user": {"login": "bsiegel", "name": "Brandon Siegel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "committedDate": "2020-11-05T23:07:18Z", "message": "Code review changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NDY3MjIz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#pullrequestreview-525467223", "createdAt": "2020-11-06T20:18:23Z", "commit": {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NDY3NzAz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#pullrequestreview-525467703", "createdAt": "2020-11-06T20:19:15Z", "commit": {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMDoxOToxNVrOHu8VOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMDoxOToxNVrOHu8VOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NTAxNw==", "bodyText": "Is this the only data service version this is supported in? I thought there was some expandable enum for these.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518985017", "createdAt": "2020-11-06T20:19:15Z", "author": {"login": "conniey"}, "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/BatchImpl.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.data.tables.implementation;\n+\n+import com.azure.core.annotation.BodyParam;\n+import com.azure.core.annotation.ExpectedResponses;\n+import com.azure.core.annotation.HeaderParam;\n+import com.azure.core.annotation.Host;\n+import com.azure.core.annotation.HostParam;\n+import com.azure.core.annotation.Post;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceInterface;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.annotation.UnexpectedResponseExceptionType;\n+import com.azure.core.http.rest.RestProxy;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubmitBatchResponse;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import reactor.core.publisher.Mono;\n+\n+/** An instance of this class provides access to all the operations defined in Batch. */\n+public final class BatchImpl {\n+    /** The proxy service used to perform REST calls. */\n+    private final BatchService service;\n+\n+    /** The service client containing this operation class. */\n+    private final AzureTableImpl client;\n+\n+    /**\n+     * Initializes an instance of BatchImpl.\n+     *\n+     * @param client the instance of the service client containing this operation class.\n+     */\n+    public BatchImpl(AzureTableImpl client, SerializerAdapter serializerAdapter) {\n+        this.service = RestProxy.create(BatchService.class, client.getHttpPipeline(), serializerAdapter);\n+        this.client = client;\n+    }\n+\n+    /**\n+     * The interface defining all the services for AzureTableBatch to be used by the proxy service to perform REST\n+     * calls.\n+     */\n+    @Host(\"{url}\")\n+    @ServiceInterface(name = \"AzureTableServices\")\n+    private interface BatchService {\n+        @Post(\"/$batch\")\n+        @ExpectedResponses({202})\n+        @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n+        Mono<BatchSubmitBatchResponse> submitBatch(\n+            @HostParam(\"url\") String url,\n+            @HeaderParam(\"Content-Type\") String multipartContentType,\n+            @HeaderParam(\"x-ms-version\") String version,\n+            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+            @BodyParam(\"multipart/mixed\") BatchRequestBody body,\n+            Context context);\n+    }\n+\n+    /**\n+     * The Batch operation allows multiple API calls to be embedded into a single HTTP request.\n+     *\n+     * @param body Initial data.\n+     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the\n+     *                  analytics logs when storage analytics logging is enabled.\n+     * @param context The context to associate with this operation.\n+     * @throws IllegalArgumentException thrown if parameters fail the validation.\n+     * @return a Mono which performs the network request upon subscription.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<BatchSubmitBatchResponse> submitBatchWithRestResponseAsync(\n+        BatchRequestBody body,\n+        String requestId,\n+        Context context\n+    ) {\n+        final String dataServiceVersion = \"3.0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1639, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}