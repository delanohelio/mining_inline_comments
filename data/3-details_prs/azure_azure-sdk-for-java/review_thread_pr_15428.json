{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNDg0OTcy", "number": 15428, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo0NTozNFrOEly07g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzoyNlrOEmJsUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY1NTE4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo0NTozNFrOHVd6ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo0NTozNFrOHVd6ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MjI2Ng==", "bodyText": "remove extra new lines", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492272266", "createdAt": "2020-09-21T18:45:34Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -849,14 +847,13 @@ private void throwOnAnonymousAccess() {\n      * @return A {@link Mono} containing a {@link BlobContainerAsyncClient} used\n      * to interact with the restored container.\n      */\n-    /*\n     public Mono<BlobContainerAsyncClient> undeleteBlobContainer(\n         String deletedContainerName, String deletedContainerVersion) {\n-        return this.undeleteBlobContainerWithResponse(\n-            new UndeleteBlobContainerOptions(deletedContainerName, deletedContainerVersion)\n+        return this.undeleteBlobContainerWithResponse(new UndeleteBlobContainerOptions(deletedContainerName,\n+            deletedContainerVersion)\n         ).flatMap(FluxUtil::toMono);\n     }\n-    */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d600512ecf1e0c821b4c1d84deb19eb7cd6759d2"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDkzNzkxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-file-datalake/src/test/java/com/azure/storage/file/datalake/DirectoryAPITest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDowNzozM1rOHVgmXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDowNzozM1rOHVgmXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjI1NQ==", "bodyText": "@rickle-msft Is this still a TODO or can we delete this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492316255", "createdAt": "2020-09-21T20:07:33Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-file-datalake/src/test/java/com/azure/storage/file/datalake/DirectoryAPITest.groovy", "diffHunk": "@@ -434,6 +444,786 @@ class DirectoryAPITest extends APISpec {\n         thrown(DataLakeStorageException)\n     }\n \n+    def \"Set ACL recursive min\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        when:\n+        def result = dc.setAccessControlRecursive(pathAccessControlEntries)\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive batches\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2)\n+\n+        when:\n+        def result = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive batches resume\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(1)\n+\n+        when:\n+        def result = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        and:\n+        options.setMaxBatches(null).setContinuationToken(result.getContinuationToken())\n+        def result2 = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        (result.getCounters().getChangedDirectoriesCount() + result2.getCounters().getChangedDirectoriesCount()) == 3 // Including the top level\n+        (result.getCounters().getChangedFilesCount() + result2.getCounters().getChangedFilesCount()) == 4\n+        (result.getCounters().getFailedChangesCount() + result2.getCounters().getFailedChangesCount()) == 0\n+        result2.getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive batches progress\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setProgressHandler(progress)\n+\n+        when:\n+        def result = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+        progress.batchCounters.size() == 4\n+        (progress.batchCounters[0].getChangedFilesCount() + progress.batchCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[1].getChangedFilesCount() + progress.batchCounters[1].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[2].getChangedFilesCount() + progress.batchCounters[2].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[3].getChangedFilesCount() + progress.batchCounters[3].getChangedDirectoriesCount()) == 1\n+        progress.cumulativeCounters.size() == 4\n+        (progress.cumulativeCounters[0].getChangedFilesCount() + progress.cumulativeCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.cumulativeCounters[1].getChangedFilesCount() + progress.cumulativeCounters[1].getChangedDirectoriesCount()) == 4\n+        (progress.cumulativeCounters[2].getChangedFilesCount() + progress.cumulativeCounters[2].getChangedDirectoriesCount()) == 6\n+        (progress.cumulativeCounters[3].getChangedFilesCount() + progress.cumulativeCounters[3].getChangedDirectoriesCount()) == 7\n+    }\n+\n+    def \"Set ACL recursive batches follow token\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(2)\n+\n+        when:\n+        String continuation = \"null\"\n+        def failedChanges = 0\n+        def directoriesChanged = 0\n+        def filesChanged = 0\n+        def iterations = 0\n+        while(continuation != null && continuation != \"\" && iterations < 10) {\n+            if (iterations == 0) {\n+                continuation = null // do while not supported in Groovy\n+            }\n+            options.setContinuationToken(continuation)\n+            def result = dc.setAccessControlRecursiveWithResponse(options, null, null)\n+            failedChanges += result.getValue().getCounters().getFailedChangesCount()\n+            directoriesChanged += result.getValue().getCounters().getChangedDirectoriesCount()\n+            filesChanged += result.getValue().getCounters().getChangedFilesCount()\n+            iterations++\n+            continuation = result.getValue().getContinuationToken()\n+        }\n+\n+        then:\n+        failedChanges == 0\n+        directoriesChanged == 3\n+        filesChanged == 4\n+        iterations == 2\n+    }\n+\n+    def \"Set ACL recursive progress with failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create file4 as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        when:\n+        def result = topDirOauthClient.setAccessControlRecursiveWithResponse(\n+            new PathSetAccessControlRecursiveOptions(pathAccessControlEntries).setProgressHandler(progress), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getFailedChangesCount() == 1\n+        progress.failures.size() == 1\n+        progress.batchCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.cumulativeCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.failures[0].getName().contains(file4.getObjectName())\n+        !progress.failures[0].isDirectory()\n+        progress.failures[0].getErrorMessage()\n+    }\n+\n+    def \"Set ACL recursive continue on failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        when:\n+        def result = topDirOauthClient.setAccessControlRecursiveWithResponse(\n+            new PathSetAccessControlRecursiveOptions(pathAccessControlEntries).setContinueOnFailure(true), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getChangedDirectoriesCount() == 3\n+        result.getValue().getCounters().getChangedFilesCount() == 3\n+        result.getValue().getCounters().getFailedChangesCount() == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive continue on failure batches resume\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        // Create more files as app\n+        def file7 = subdir1.createFile(generatePathName())\n+        def file8 = subdir1.createFile(generatePathName())\n+        def subdir4 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file9 = subdir4.createFile(generatePathName())\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setContinueOnFailure(true).setMaxBatches(1)\n+\n+        when:\n+        def intermediateResult = topDirOauthClient.setAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        intermediateResult.getValue().getContinuationToken() != null\n+\n+        when:\n+        options.setMaxBatches(null).setContinuationToken(intermediateResult.getValue().getContinuationToken())\n+        def result = topDirOauthClient.setAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        (result.getValue().getCounters().getChangedDirectoriesCount() + intermediateResult.getValue().getCounters().getChangedDirectoriesCount()) == 4\n+        (result.getValue().getCounters().getChangedFilesCount() + intermediateResult.getValue().getCounters().getChangedFilesCount()) == 6\n+        (result.getValue().getCounters().getFailedChangesCount() + intermediateResult.getValue().getCounters().getFailedChangesCount()) == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive error\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+\n+        String topDirName = generatePathName()\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+\n+        when:\n+        topDirOauthClient.setAccessControlRecursiveWithResponse(\n+            new PathSetAccessControlRecursiveOptions(pathAccessControlEntries), null, null)\n+\n+        then:\n+        thrown(DataLakeStorageException)\n+    }\n+\n+    def \"Update ACL recursive\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        when:\n+        def result = dc.updateAccessControlRecursive(pathAccessControlEntries)\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+    }\n+\n+    def \"Update ACL recursive batches\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2)\n+\n+        when:\n+        def result = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive batches resume\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(1)\n+\n+        when:\n+        def result = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        and:\n+        options.setMaxBatches(null).setContinuationToken(result.getContinuationToken())\n+        def result2 = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        (result.getCounters().getChangedDirectoriesCount() + result2.getCounters().getChangedDirectoriesCount()) == 3 // Including the top level\n+        (result.getCounters().getChangedFilesCount() + result2.getCounters().getChangedFilesCount()) == 4\n+        (result.getCounters().getFailedChangesCount() + result2.getCounters().getFailedChangesCount()) == 0\n+        result2.getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive batches progress\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setProgressHandler(progress)\n+\n+        when:\n+        def result = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+        progress.batchCounters.size() == 4\n+        (progress.batchCounters[0].getChangedFilesCount() + progress.batchCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[1].getChangedFilesCount() + progress.batchCounters[1].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[2].getChangedFilesCount() + progress.batchCounters[2].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[3].getChangedFilesCount() + progress.batchCounters[3].getChangedDirectoriesCount()) == 1\n+        progress.cumulativeCounters.size() == 4\n+        (progress.cumulativeCounters[0].getChangedFilesCount() + progress.cumulativeCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.cumulativeCounters[1].getChangedFilesCount() + progress.cumulativeCounters[1].getChangedDirectoriesCount()) == 4\n+        (progress.cumulativeCounters[2].getChangedFilesCount() + progress.cumulativeCounters[2].getChangedDirectoriesCount()) == 6\n+        (progress.cumulativeCounters[3].getChangedFilesCount() + progress.cumulativeCounters[3].getChangedDirectoriesCount()) == 7\n+    }\n+\n+    def \"Update ACL recursive batches follow token\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(2)\n+\n+        when:\n+        String continuation = \"null\"\n+        def failedChanges = 0\n+        def directoriesChanged = 0\n+        def filesChanged = 0\n+        def iterations = 0\n+        while(continuation != null && continuation != \"\" && iterations < 10) {\n+            if (iterations == 0) {\n+                continuation = null // do while not supported in Groovy\n+            }\n+            options.setContinuationToken(continuation)\n+            def result = dc.updateAccessControlRecursiveWithResponse(options, null, null)\n+            failedChanges += result.getValue().getCounters().getFailedChangesCount()\n+            directoriesChanged += result.getValue().getCounters().getChangedDirectoriesCount()\n+            filesChanged += result.getValue().getCounters().getChangedFilesCount()\n+            iterations++\n+            continuation = result.getValue().getContinuationToken()\n+        }\n+\n+        then:\n+        failedChanges == 0\n+        directoriesChanged == 3\n+        filesChanged == 4\n+        iterations == 2\n+    }\n+\n+    def \"Update ACL recursive progress with failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create file4 as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        when:\n+        def result = topDirOauthClient.updateAccessControlRecursiveWithResponse(\n+            new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries).setProgressHandler(progress), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getFailedChangesCount() == 1\n+        progress.failures.size() == 1\n+        progress.batchCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.cumulativeCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.failures[0].getName().contains(file4.getObjectName())\n+        !progress.failures[0].isDirectory()\n+        progress.failures[0].getErrorMessage()\n+    }\n+\n+    def \"Update ACL recursive continue on failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        when:\n+        def result = topDirOauthClient.updateAccessControlRecursiveWithResponse(\n+            new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries).setContinueOnFailure(true), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getChangedDirectoriesCount() == 3\n+        result.getValue().getCounters().getChangedFilesCount() == 3\n+        result.getValue().getCounters().getFailedChangesCount() == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive continue on failure batches resume\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        // Create more files as app\n+        def file7 = subdir1.createFile(generatePathName())\n+        def file8 = subdir1.createFile(generatePathName())\n+        def subdir4 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file9 = subdir4.createFile(generatePathName())\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setContinueOnFailure(true).setMaxBatches(1)\n+\n+        when:\n+        def intermediateResult = topDirOauthClient.updateAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        intermediateResult.getValue().getContinuationToken() != null\n+\n+        when:\n+        options.setMaxBatches(null).setContinuationToken(intermediateResult.getValue().getContinuationToken())\n+        def result = topDirOauthClient.updateAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        (result.getValue().getCounters().getChangedDirectoriesCount() + intermediateResult.getValue().getCounters().getChangedDirectoriesCount()) == 4\n+        (result.getValue().getCounters().getChangedFilesCount() + intermediateResult.getValue().getCounters().getChangedFilesCount()) == 6\n+        (result.getValue().getCounters().getFailedChangesCount() + intermediateResult.getValue().getCounters().getFailedChangesCount()) == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive error\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+\n+        String topDirName = generatePathName()\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+\n+        when:\n+        topDirOauthClient.updateAccessControlRecursiveWithResponse(\n+            new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries), null, null)\n+\n+        then:\n+        thrown(DataLakeStorageException)\n+    }\n+\n+    def \"Remove ACL recursive\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        when:\n+        def result = dc.removeAccessControlRecursive(removeAccessControlEntries)\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+    }\n+\n+    def \"Remove ACL recursive batches\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2)\n+\n+        when:\n+        def result = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive batches resume\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(1)\n+\n+        when:\n+        def result = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        and:\n+        options.setMaxBatches(null).setContinuationToken(result.getContinuationToken())\n+        def result2 = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        (result.getCounters().getChangedDirectoriesCount() + result2.getCounters().getChangedDirectoriesCount()) == 3 // Including the top level\n+        (result.getCounters().getChangedFilesCount() + result2.getCounters().getChangedFilesCount()) == 4\n+        (result.getCounters().getFailedChangesCount() + result2.getCounters().getFailedChangesCount()) == 0\n+        result2.getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive batches progress\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setProgressHandler(progress)\n+\n+        when:\n+        def result = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+        progress.batchCounters.size() == 4\n+        (progress.batchCounters[0].getChangedFilesCount() + progress.batchCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[1].getChangedFilesCount() + progress.batchCounters[1].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[2].getChangedFilesCount() + progress.batchCounters[2].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[3].getChangedFilesCount() + progress.batchCounters[3].getChangedDirectoriesCount()) == 1\n+        progress.cumulativeCounters.size() == 4\n+        (progress.cumulativeCounters[0].getChangedFilesCount() + progress.cumulativeCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.cumulativeCounters[1].getChangedFilesCount() + progress.cumulativeCounters[1].getChangedDirectoriesCount()) == 4\n+        (progress.cumulativeCounters[2].getChangedFilesCount() + progress.cumulativeCounters[2].getChangedDirectoriesCount()) == 6\n+        (progress.cumulativeCounters[3].getChangedFilesCount() + progress.cumulativeCounters[3].getChangedDirectoriesCount()) == 7\n+    }\n+\n+    def \"Remove ACL recursive batches follow token\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(2)\n+\n+        when:\n+        String continuation = \"null\"\n+        def failedChanges = 0\n+        def directoriesChanged = 0\n+        def filesChanged = 0\n+        def iterations = 0\n+        while(continuation != null && continuation != \"\" && iterations < 10) {\n+            if (iterations == 0) {\n+                continuation = null // do while not supported in Groovy\n+            }\n+            options.setContinuationToken(continuation)\n+            def result = dc.removeAccessControlRecursiveWithResponse(options, null, null)\n+            failedChanges += result.getValue().getCounters().getFailedChangesCount()\n+            directoriesChanged += result.getValue().getCounters().getChangedDirectoriesCount()\n+            filesChanged += result.getValue().getCounters().getChangedFilesCount()\n+            iterations++\n+            continuation = result.getValue().getContinuationToken()\n+        }\n+\n+        then:\n+        failedChanges == 0\n+        directoriesChanged == 3\n+        filesChanged == 4\n+        iterations == 2\n+    }\n+\n+    def \"Remove ACL recursive progress with failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create file4 as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        when:\n+        def result = topDirOauthClient.removeAccessControlRecursiveWithResponse(\n+            new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries).setProgressHandler(progress), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getFailedChangesCount() == 1\n+        progress.failures.size() == 1\n+        progress.batchCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.cumulativeCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.failures[0].getName().contains(file4.getObjectName())\n+        !progress.failures[0].isDirectory()\n+        progress.failures[0].getErrorMessage()\n+    }\n+\n+    def \"Remove ACL recursive continue on failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        when:\n+        def result = topDirOauthClient.removeAccessControlRecursiveWithResponse(\n+            new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries).setContinueOnFailure(true), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getChangedDirectoriesCount() == 3\n+        result.getValue().getCounters().getChangedFilesCount() == 3\n+        result.getValue().getCounters().getFailedChangesCount() == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive continue on failure batches resume\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        // Create more files as app\n+        def file7 = subdir1.createFile(generatePathName())\n+        def file8 = subdir1.createFile(generatePathName())\n+        def subdir4 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file9 = subdir4.createFile(generatePathName())\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setContinueOnFailure(true).setMaxBatches(1)\n+\n+        when:\n+        def intermediateResult = topDirOauthClient.removeAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        intermediateResult.getValue().getContinuationToken() != null\n+\n+        when:\n+        options.setMaxBatches(null).setContinuationToken(intermediateResult.getValue().getContinuationToken())\n+        def result = topDirOauthClient.removeAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        (result.getValue().getCounters().getChangedDirectoriesCount() + intermediateResult.getValue().getCounters().getChangedDirectoriesCount()) == 4\n+        (result.getValue().getCounters().getChangedFilesCount() + intermediateResult.getValue().getCounters().getChangedFilesCount()) == 6\n+        (result.getValue().getCounters().getFailedChangesCount() + intermediateResult.getValue().getCounters().getFailedChangesCount()) == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive error\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+\n+        String topDirName = generatePathName()\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+\n+        when:\n+        topDirOauthClient.removeAccessControlRecursiveWithResponse(\n+            new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries), null, null)\n+\n+        then:\n+        thrown(DataLakeStorageException)\n+    }\n+\n+    def setupStandardRecursiveAclTest() {\n+        def subdir1 = dc.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = dc.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+        def file4 = dc.createFile(generatePathName())\n+    }\n+\n+    static class InMemoryAccessControlRecursiveChangeProgress implements Consumer<Response<AccessControlChanges>> {\n+\n+        List<AccessControlChangeFailure> failures = new ArrayList<>()\n+        List<AccessControlChangeCounters> batchCounters = new ArrayList<>()\n+        List<AccessControlChangeCounters> cumulativeCounters = new ArrayList<>()\n+\n+        @Override\n+        void accept(Response<AccessControlChanges> response) {\n+            failures.addAll(response.getValue().getBatchFailures())\n+            batchCounters.addAll(response.getValue().getBatchCounters())\n+            cumulativeCounters.addAll(response.getValue().getAggregateCounters())\n+        }\n+    }\n+\n+    // set recursive acl error, with response", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "originalPosition": 807}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM5OTk2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzowNFrOHWA3VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzowNFrOHWA3VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NDg4NQ==", "bodyText": "Add REST Docs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492844885", "createdAt": "2020-09-22T15:47:04Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -849,14 +847,12 @@ private void throwOnAnonymousAccess() {\n      * @return A {@link Mono} containing a {@link BlobContainerAsyncClient} used\n      * to interact with the restored container.\n      */\n-    /*\n     public Mono<BlobContainerAsyncClient> undeleteBlobContainer(\n         String deletedContainerName, String deletedContainerVersion) {\n-        return this.undeleteBlobContainerWithResponse(\n-            new UndeleteBlobContainerOptions(deletedContainerName, deletedContainerVersion)\n+        return this.undeleteBlobContainerWithResponse(new UndeleteBlobContainerOptions(deletedContainerName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQwMTQ3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzoyNlrOHWA4YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzoyNlrOHWA4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NTE1Mg==", "bodyText": "Add Rest docs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492845152", "createdAt": "2020-09-22T15:47:26Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileClient.java", "diffHunk": "@@ -716,4 +717,41 @@ public FileQueryResponse queryWithResponse(FileQueryOptions queryOptions, Durati\n             return Transforms.toFileQueryResponse(response);\n         }, logger);\n     }\n+\n+    // TODO (kasobol-msft) add REST DOCS\n+    /**\n+     * Schedules the file for deletion.\n+     * For more information, see the\n+     * <a href=\"TBD\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileClient.scheduleDeletion#FileScheduleDeletionOptions}\n+     *\n+     * @param options Schedule deletion parameters.\n+     */\n+    public void scheduleDeletion(FileScheduleDeletionOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 990, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}