{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NDc3ODE2", "number": 12867, "title": "Merging back Tracer PR without conditional check on withContext()", "bodyText": "Merging back reverted PR #10265\nNote : Scope of this PR is limited to merging Tracer PR back without conditional check on withContext()", "createdAt": "2020-07-07T15:10:37Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867", "merged": true, "mergeCommit": {"oid": "5150e06dcc6d08d72bdb58f69d56c06bcd74153d"}, "closed": true, "closedAt": "2020-07-21T13:47:23Z", "author": {"login": "simplynaveen20"}, "timelineItems": {"totalCount": 78, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVo42BgH2gAyNDQ1NDc3ODE2OjA4OTMwN2EzYTgxNjdmOTZkZDM4ZWNiZjNjM2ExY2E2YTFjYTMyYjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc17FWvgFqTQ1MDk3NTg3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "committedDate": "2020-04-08T14:36:47Z", "message": "initial commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "175222e616cf0ff1026ff70735fcc36377d05054", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/175222e616cf0ff1026ff70735fcc36377d05054", "committedDate": "2020-04-08T14:46:01Z", "message": "changing sample"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe03e665cc2fdbef20b5aab7961a690854d8f48c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe03e665cc2fdbef20b5aab7961a690854d8f48c", "committedDate": "2020-04-13T16:29:48Z", "message": "adding query api tracer support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "committedDate": "2020-04-14T18:46:05Z", "message": "merging with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "committedDate": "2020-04-14T19:25:12Z", "message": "reverting change for jaeger ui local testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c2fc40f3a35df2381104f88817209804491ae329", "committedDate": "2020-04-15T19:11:27Z", "message": "adding tracers in trigger udf and sproc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "committedDate": "2020-04-21T13:41:47Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e614db5d38ff2f4947900fa0174774f8c13f37fe", "committedDate": "2020-04-21T21:13:25Z", "message": "adding test case and refactoring code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "committedDate": "2020-04-24T18:49:27Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "committedDate": "2020-04-24T20:05:35Z", "message": "refactoring code with PR ready version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/36dde959516c9db168cca34023a105bbb19aa5da", "committedDate": "2020-04-24T21:06:40Z", "message": "ending span on doOnComplete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36743ca506ec2fca6e25fe1c80062abcaba04688", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/36743ca506ec2fca6e25fe1c80062abcaba04688", "committedDate": "2020-05-04T15:02:31Z", "message": "resolving error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "committedDate": "2020-05-04T15:33:04Z", "message": "merging with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "committedDate": "2020-05-05T20:06:26Z", "message": "perf improvement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21034b55d17e22f587a0a9004359423c21959d4b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21034b55d17e22f587a0a9004359423c21959d4b", "committedDate": "2020-05-06T16:07:20Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "committedDate": "2020-05-06T16:37:16Z", "message": "fixing build error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aab85a6184c6ceda774df0b0ae055ee78af29289", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aab85a6184c6ceda774df0b0ae055ee78af29289", "committedDate": "2020-05-11T14:27:12Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "committedDate": "2020-05-11T14:29:15Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "committedDate": "2020-05-11T14:36:28Z", "message": "check non opentelementry jar non existence in starting of all api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b09e5c2504b94e80788d30048c96836bd20c1cb", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b09e5c2504b94e80788d30048c96836bd20c1cb", "committedDate": "2020-05-11T15:18:52Z", "message": "fixing checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81040b270c3a369ae5289428143c144b9e57d54c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/81040b270c3a369ae5289428143c144b9e57d54c", "committedDate": "2020-05-11T18:09:41Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbc74c8f7ea56fdcf88c1bc35032d81139302805", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbc74c8f7ea56fdcf88c1bc35032d81139302805", "committedDate": "2020-05-11T18:20:59Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "806cdf154862a36147c6bc3cfebe582e6fa323b3", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/806cdf154862a36147c6bc3cfebe582e6fa323b3", "committedDate": "2020-05-11T18:56:09Z", "message": "check style fix as per java 8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d061db5abcbf948ae4159576f7ee94a75eca574f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d061db5abcbf948ae4159576f7ee94a75eca574f", "committedDate": "2020-05-11T21:11:36Z", "message": "adding azure-core-tracing-opentelemetry in test scope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "committedDate": "2020-05-11T23:17:04Z", "message": "resolving conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fc0cc923557735ac777c7037e5a5491e6675467", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0fc0cc923557735ac777c7037e5a5491e6675467", "committedDate": "2020-05-11T23:38:49Z", "message": "build error fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "committedDate": "2020-05-12T01:19:20Z", "message": "test failure fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d2a815459cf553a0f24126b0765e5b3a375ccd4b", "committedDate": "2020-05-12T02:00:54Z", "message": "test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30c2f8962f070e59790585b7abee6aa5e5a136a1", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/30c2f8962f070e59790585b7abee6aa5e5a136a1", "committedDate": "2020-05-13T15:56:57Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7fa831bfcdc284440ff14a26ec84bd02732c79c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fa831bfcdc284440ff14a26ec84bd02732c79c", "committedDate": "2020-05-13T17:38:31Z", "message": "complie error fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "committedDate": "2020-05-15T14:51:03Z", "message": "removing query text from tracer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0debac080b3ff04085ed11f0fdaa2a482a8eb096", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0debac080b3ff04085ed11f0fdaa2a482a8eb096", "committedDate": "2020-05-15T16:14:16Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8efa4514350b03035400964d817e4136b4e03486", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8efa4514350b03035400964d817e4136b4e03486", "committedDate": "2020-05-26T23:17:29Z", "message": "merge with master and removing subscriber context for perf gain"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fe8bb66384a0999cb137e3d0476540cf419c84", "committedDate": "2020-05-26T23:20:33Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3461604e14d02caffdb2e6df5e9755702bf658c6", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3461604e14d02caffdb2e6df5e9755702bf658c6", "committedDate": "2020-06-11T18:04:42Z", "message": "resolving merge conflict after GA"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0984a9ceadd61b2c0862a4a6ae3b968693952d57", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0984a9ceadd61b2c0862a4a6ae3b968693952d57", "committedDate": "2020-06-11T22:11:06Z", "message": "code formating change and some comment resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9c60a2431add13e597f3c7874f590cc8695945f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9c60a2431add13e597f3c7874f590cc8695945f", "committedDate": "2020-06-11T23:30:10Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "committedDate": "2020-06-15T16:33:48Z", "message": "moving AZ_TRACING_NAMESPACE_KEY to context from span attribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8024999b269086cdc804cf1b2212abde9f21ca6a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8024999b269086cdc804cf1b2212abde9f21ca6a", "committedDate": "2020-06-15T18:40:41Z", "message": "updating core opentelementry jar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "210185126bcf0d44a8b74cf21d0780e7bed06c5f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/210185126bcf0d44a8b74cf21d0780e7bed06c5f", "committedDate": "2020-07-06T13:18:25Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f4c6ac37696c0ce0b7e15677955ede58afcf04b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f4c6ac37696c0ce0b7e15677955ede58afcf04b", "committedDate": "2020-07-07T14:41:19Z", "message": "Tracer code without conditional check for withContext"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b0becb11e94eed93ac2ec15ae893ef94c5d2385", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b0becb11e94eed93ac2ec15ae893ef94c5d2385", "committedDate": "2020-07-07T15:01:00Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3548215370fea7ff0fb9b4e6a79c0130f629cb37", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3548215370fea7ff0fb9b4e6a79c0130f629cb37", "committedDate": "2020-07-07T15:03:37Z", "message": "formating chage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb398d9091cf47354129e61a5d90040fadd6f0d0", "committedDate": "2020-07-07T15:07:27Z", "message": "formating chage"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDA1MTkx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-444005191", "createdAt": "2020-07-07T15:28:08Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDY4NjAw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-444068600", "createdAt": "2020-07-07T16:41:15Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjo0MToxNVrOGuG4Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjo0MToxNVrOGuG4Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMDMzNQ==", "bodyText": "What is the timeline for GA of this package - Seems weird if a part of the SDK officially GAed (azure-cosmos) takes a dependency on a component still in Beta.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451000335", "createdAt": "2020-07-07T16:41:15Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -128,7 +128,18 @@ Licensed under the MIT License.\n         </exclusion>\n       </exclusions>\n     </dependency>\n-\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-tracing-opentelemetry</artifactId>\n+      <scope>test</scope>\n+      <version>1.0.0-beta.5</version> <!-- {x-version-update;com.azure:azure-core-tracing-opentelemetry;dependency} -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDgwMTE1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-444080115", "createdAt": "2020-07-07T16:55:40Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTI5NDgw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-445129480", "createdAt": "2020-07-08T21:07:16Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTc3NTM2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-444177536", "createdAt": "2020-07-07T19:14:19Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToxNDoxOVrOGuMGjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTo1MjoyNVrOGuNUBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTk2Nw==", "bodyText": "Not sure if I understand why would we need this to be a context object. Could this be a Map or an optional object?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451085967", "createdAt": "2020-07-07T19:14:19Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +450,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw==", "bodyText": "Could store database.getId() in a variable.\nAlso, some places below.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451086407", "createdAt": "2020-07-07T19:15:08Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +450,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {\n+                        Database wrappedDatabase = new Database();\n+                        wrappedDatabase.setId(database.getId());\n+                        return createDatabaseInternal(wrappedDatabase,\n+                            requestOptions, context);\n+                    }\n+\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        requestOptions);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseInternal(Database database, CosmosDatabaseRequestOptions options,\n+                                                             Context context) {\n+        String spanName = \"createDatabase.\" + database.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NzI4NA==", "bodyText": "Is the getId() on L111 the same database Id as on this line?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451087284", "createdAt": "2020-07-07T19:16:45Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncConflict.java", "diffHunk": "@@ -106,4 +106,33 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosConflictResponse> readInternal(RequestOptions options, Context context) {\n+        String spanName = \"readConflict.\" + getId();\n+        Mono<CosmosConflictResponse> responseMono = this.readInternal(options);\n+        return this.container.getDatabase().getClient().getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            this.container.getDatabase().getId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNDE5NA==", "bodyText": "nit: space before .", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451104194", "createdAt": "2020-07-07T19:49:30Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -628,35 +673,13 @@ public CosmosAsyncConflict getConflict(String id) {\n     }\n \n     /**\n-     * Replace the throughput provisioned for the current container.\n+     * Replace the throughput .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw==", "bodyText": "Do we need to define these here if they are only used once?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451105797", "createdAt": "2020-07-07T19:52:25Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -43,12 +46,40 @@\n     private final CosmosAsyncDatabase database;\n     private final String id;\n     private final String link;\n+    private final String replaceContainerSpanName;\n+    private final String deleteContainerSpanName;\n+    private final String replaceThroughputSpanName;\n+    private final String readThroughputSpanName;\n+    private final String readContainerSpanName;\n+    private final String readItemSpanName;\n+    private final String upsertItemSpanName;\n+    private final String deleteItemSpanName;\n+    private final String replaceItemSpanName;\n+    private final String createItemSpanName;\n+    private final String readAllItemsSpanName;\n+    private final String queryItemsSpanName;\n+    private final String readAllConflictsSpanName;\n+    private final String queryConflictsSpanName;\n     private CosmosAsyncScripts scripts;\n \n     CosmosAsyncContainer(String id, CosmosAsyncDatabase database) {\n         this.id = id;\n         this.database = database;\n         this.link = getParentLink() + \"/\" + getURIPathSegment() + \"/\" + getId();\n+        this.replaceContainerSpanName = \"replaceContainer.\" + this.id;\n+        this.deleteContainerSpanName = \"deleteContainer.\" + this.id;\n+        this.replaceThroughputSpanName = \"replaceThroughput.\" + this.id;\n+        this.readThroughputSpanName = \"readThroughput.\" + this.id;\n+        this.readContainerSpanName = \"readContainer.\" + this.id;\n+        this.readItemSpanName = \"readItem.\" + this.id;\n+        this.upsertItemSpanName = \"upsertItem.\" + this.id;\n+        this.deleteItemSpanName = \"deleteItem.\" + this.id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTYwNjI5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-445160629", "createdAt": "2020-07-08T22:04:43Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMjowNDo0M1rOGu6ycg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMjowNzozMlrOGu629w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDg2Ng==", "bodyText": "Not completely sure if we need this dependency. I don't see it being used in the Tests either.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451850866", "createdAt": "2020-07-08T22:04:43Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -128,7 +128,18 @@ Licensed under the MIT License.\n         </exclusion>\n       </exclusions>\n     </dependency>\n-\n+    <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MTU0MQ==", "bodyText": "Could we update these tests to check for the attributes that are needed to be set for the particular request, rather than just checking for anyString()?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451851541", "createdAt": "2020-07-08T22:06:24Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ServiceLoader;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+                \"/pk\", 5000).block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        cosmosAsyncContainer.read().block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracer, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracer, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.deleteItem(ITEM_ID, PartitionKey.NONE).block();\n+        Mockito.verify(tracer, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        cosmosAsyncContainer.readAllItems(new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        String query = \"select * from c where c.id = '\" + ITEM_ID + \"'\";\n+        cosmosAsyncContainer.queryItems(query, new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncScripts() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        CosmosUserDefinedFunctionProperties cosmosUserDefinedFunctionProperties =\n+            getCosmosUserDefinedFunctionProperties();\n+        CosmosUserDefinedFunctionProperties resultUdf =\n+            cosmosAsyncContainer.getScripts().createUserDefinedFunction(cosmosUserDefinedFunctionProperties).block().getProperties();\n+        Mockito.verify(tracer, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).read().block();\n+        Mockito.verify(tracer, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosUserDefinedFunctionProperties.setBody(\"function() {var x = 15;}\");\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(resultUdf.getId()).replace(resultUdf).block();\n+        Mockito.verify(tracer, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).delete().block();\n+        Mockito.verify(tracer, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        CosmosTriggerProperties cosmosTriggerProperties = getCosmosTriggerProperties();\n+        CosmosTriggerProperties resultTrigger =\n+            cosmosAsyncContainer.getScripts().createTrigger(cosmosTriggerProperties).block().getProperties();\n+        Mockito.verify(tracer, Mockito.times(9)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).read().block();\n+        Mockito.verify(tracer, Mockito.times(10)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).replace(resultTrigger).block();\n+        Mockito.verify(tracer, Mockito.times(11)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(12)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).delete().block();\n+        Mockito.verify(tracer, Mockito.times(13)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        CosmosStoredProcedureProperties procedureProperties = getCosmosStoredProcedureProperties();\n+        CosmosStoredProcedureProperties resultSproc =\n+            cosmosAsyncContainer.getScripts().createStoredProcedure(procedureProperties).block().getProperties();\n+        Mockito.verify(tracer, Mockito.times(14)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).read().block();\n+        Mockito.verify(tracer, Mockito.times(15)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MjAyMw==", "bodyText": "what update is this related to?\nWe don't validate anything related to tracing here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451852023", "createdAt": "2020-07-08T22:07:32Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ReadFeedExceptionHandlingTest.java", "diffHunk": "@@ -46,7 +49,10 @@ public void readFeedException() throws Exception {\n                                                                     .mergeWith(Flux.fromIterable(frps));\n \n         final CosmosAsyncClientWrapper mockedClientWrapper = Mockito.spy(new CosmosAsyncClientWrapper(client));\n-        Mockito.when(mockedClientWrapper.readAllDatabases()).thenReturn(UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> response));\n+        Mockito.when(mockedClientWrapper.readAllDatabases()).thenReturn(UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(new TracerProvider(ServiceLoader.load(Tracer.class)), \"testSpan\", \"testEndpoint,\", \"testDb\");\n+            return response;\n+        }));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MjM4NTc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-445238576", "createdAt": "2020-07-09T01:53:53Z", "commit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMTo1Mzo1M1rOGu-9Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMjoyNzoxN1rOGu_fqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTIwNg==", "bodyText": "From a code style perspective, it would be better to do lines 255-257 and 260 on a single line:\nfinal CosmosDatabaseRequestOptions requestOptions = options == null ? new CosmosDatabaseRequestOptions() : options;", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451919206", "createdAt": "2020-07-09T01:53:53Z", "author": {"login": "JonathanGiles"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -274,9 +257,8 @@ boolean isContentResponseOnWriteEnabled() {\n         }\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseProperties.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosDatabaseResponse(databaseResourceResponse))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTQ2MA==", "bodyText": "Could you save a variable declaration and set by just directly passing the string into the method call?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451919460", "createdAt": "2020-07-09T01:54:47Z", "author": {"login": "JonathanGiles"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -397,12 +378,14 @@ boolean isContentResponseOnWriteEnabled() {\n      */\n     CosmosPagedFlux<CosmosDatabaseProperties> readAllDatabases(CosmosQueryRequestOptions options) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"readAllDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyMDQ4Mg==", "bodyText": "Why are you removing full stops? We should keep them", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451920482", "createdAt": "2020-07-09T01:58:37Z", "author": {"login": "JonathanGiles"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -628,35 +673,13 @@ public CosmosAsyncConflict getConflict(String id) {\n     }\n \n     /**\n-     * Replace the throughput provisioned for the current container.\n+     * Replace the throughput .\n      *\n-     * @param throughputProperties the throughput properties.\n-     * @return the mono containing throughput response.\n+     * @param throughputProperties the throughput properties\n+     * @return the mono containing throughput response", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyNzk3Nw==", "bodyText": "This feels out of place, but because it is implementation API it is fine.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451927977", "createdAt": "2020-07-09T02:27:17Z", "author": {"login": "JonathanGiles"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/CosmosPagedFluxOptions.java", "diffHunk": "@@ -57,4 +64,43 @@ public CosmosPagedFluxOptions setMaxItemCount(Integer maxItemCount) {\n         this.maxItemCount = maxItemCount;\n         return this;\n     }\n+\n+    /**\n+     * Gets the tracer provider\n+     * @return tracerProvider\n+     */\n+    public TracerProvider getTracerProvider() {\n+        return this.tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the tracer span name\n+     * @return tracerSpanName\n+     */\n+    public String getTracerSpanName() {\n+        return tracerSpanName;\n+    }\n+\n+    /**\n+     * Gets the databaseId\n+     * @return databaseId\n+     */\n+    public String getDatabaseId() {\n+        return databaseId;\n+    }\n+\n+    /**\n+     * Gets the service end point\n+     * @return serviceEndpoint\n+     */\n+    public String getServiceEndpoint() {\n+        return serviceEndpoint;\n+    }\n+\n+    public void setTracerInformation(TracerProvider tracerProvider, String tracerSpanName, String serviceEndpoint, String databaseId) {\n+        this.databaseId = databaseId;\n+        this.serviceEndpoint = serviceEndpoint;\n+        this.tracerSpanName = tracerSpanName;\n+        this.tracerProvider = tracerProvider;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b168fd28c8799ec139edfef9dfd55bfff4f67e69", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b168fd28c8799ec139edfef9dfd55bfff4f67e69", "committedDate": "2020-07-09T18:54:13Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c1d31f8b46f43c312fbb3dfcecc3837369d5e08", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9c1d31f8b46f43c312fbb3dfcecc3837369d5e08", "committedDate": "2020-07-09T19:55:35Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0703a2810d684c09b7738f1c5695df0f823a362a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0703a2810d684c09b7738f1c5695df0f823a362a", "committedDate": "2020-07-09T20:31:59Z", "message": "build error fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5283fe5ba3c3d18bb4d55f64aa4c59590c2f0cd", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c5283fe5ba3c3d18bb4d55f64aa4c59590c2f0cd", "committedDate": "2020-07-09T23:24:19Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/deb6978f7642675623ae06dcb34d2a186d66cadf", "committedDate": "2020-07-10T00:15:21Z", "message": "resolving comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDU0OTky", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446054992", "createdAt": "2020-07-10T00:41:54Z", "commit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMDo0MTo1NVrOGvmR-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMjowNjo1MFrOGvnhxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzQ1MQ==", "bodyText": "Can this method call the method on L204", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452563451", "createdAt": "2020-07-10T00:41:55Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -209,21 +217,7 @@ boolean isContentResponseOnWriteEnabled() {\n      * an error.\n      */\n     public Mono<CosmosDatabaseResponse> createDatabaseIfNotExists(String id) {\n-        return createDatabaseIfNotExistsInternal(getDatabase(id));\n-    }\n-\n-    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database) {\n-        return database.read().onErrorResume(exception -> {\n-            final Throwable unwrappedException = Exceptions.unwrap(exception);\n-            if (unwrappedException instanceof CosmosException) {\n-                final CosmosException cosmosException = (CosmosException) unwrappedException;\n-                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n-                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n-                        new CosmosDatabaseRequestOptions());\n-                }\n-            }\n-            return Mono.error(unwrappedException);\n-        });\n+        return withContext(context -> createDatabaseIfNotExistsInternal(getDatabase(id), null, context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDQ1Nw==", "bodyText": "same here.\nSome methods could be reused instead of having the code repetition of withContext", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452564457", "createdAt": "2020-07-10T00:46:07Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -240,19 +234,8 @@ boolean isContentResponseOnWriteEnabled() {\n      * @return the mono.\n      */\n     public Mono<CosmosDatabaseResponse> createDatabaseIfNotExists(String id, ThroughputProperties throughputProperties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDY3Mg==", "bodyText": "same here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452564672", "createdAt": "2020-07-10T00:47:04Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -328,12 +307,12 @@ boolean isContentResponseOnWriteEnabled() {\n         if (options == null) {\n             options = new CosmosDatabaseRequestOptions();\n         }\n+\n         ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseProperties.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosDatabaseResponse(databaseResourceResponse))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabaseInternal(wrappedDatabase, requestOptions, context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTE5Mw==", "bodyText": "Cannot comment but the package-private method on L348 doesn't seem to be used anywhere?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452565193", "createdAt": "2020-07-10T00:49:10Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -397,12 +376,13 @@ boolean isContentResponseOnWriteEnabled() {\n      */\n     CosmosPagedFlux<CosmosDatabaseProperties> readAllDatabases(CosmosQueryRequestOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTc0Ng==", "bodyText": "This public API seems to be missing tracing instrumentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452565746", "createdAt": "2020-07-10T00:51:18Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -432,7 +412,7 @@ boolean isContentResponseOnWriteEnabled() {\n      * @return a {@link CosmosPagedFlux} containing one or several feed response pages of read databases or an error.\n      */\n     public CosmosPagedFlux<CosmosDatabaseProperties> queryDatabases(String query, CosmosQueryRequestOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NjQ0MQ==", "bodyText": "I was saying it is better if we have computation on per api call as it would just create one span name, rthaer than all of them that the user wouldn't end up using anyway.\nAlso, this seems to be deviating from the approach we have followed in other places.\nAlso, it is a per API property vs class level?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452566441", "createdAt": "2020-07-10T00:54:32Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -43,12 +46,40 @@\n     private final CosmosAsyncDatabase database;\n     private final String id;\n     private final String link;\n+    private final String replaceContainerSpanName;\n+    private final String deleteContainerSpanName;\n+    private final String replaceThroughputSpanName;\n+    private final String readThroughputSpanName;\n+    private final String readContainerSpanName;\n+    private final String readItemSpanName;\n+    private final String upsertItemSpanName;\n+    private final String deleteItemSpanName;\n+    private final String replaceItemSpanName;\n+    private final String createItemSpanName;\n+    private final String readAllItemsSpanName;\n+    private final String queryItemsSpanName;\n+    private final String readAllConflictsSpanName;\n+    private final String queryConflictsSpanName;\n     private CosmosAsyncScripts scripts;\n \n     CosmosAsyncContainer(String id, CosmosAsyncDatabase database) {\n         this.id = id;\n         this.database = database;\n         this.link = getParentLink() + \"/\" + getURIPathSegment() + \"/\" + getId();\n+        this.replaceContainerSpanName = \"replaceContainer.\" + this.id;\n+        this.deleteContainerSpanName = \"deleteContainer.\" + this.id;\n+        this.replaceThroughputSpanName = \"replaceThroughput.\" + this.id;\n+        this.readThroughputSpanName = \"readThroughput.\" + this.id;\n+        this.readContainerSpanName = \"readContainer.\" + this.id;\n+        this.readItemSpanName = \"readItem.\" + this.id;\n+        this.upsertItemSpanName = \"upsertItem.\" + this.id;\n+        this.deleteItemSpanName = \"deleteItem.\" + this.id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NzEzMA==", "bodyText": "It doesn't have to be computed twice.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452567130", "createdAt": "2020-07-10T00:57:12Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +450,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {\n+                        Database wrappedDatabase = new Database();\n+                        wrappedDatabase.setId(database.getId());\n+                        return createDatabaseInternal(wrappedDatabase,\n+                            requestOptions, context);\n+                    }\n+\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        requestOptions);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseInternal(Database database, CosmosDatabaseRequestOptions options,\n+                                                             Context context) {\n+        String spanName = \"createDatabase.\" + database.getId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw=="}, "originalCommit": {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2Nzg3Mg==", "bodyText": "I see we don't set the context object with nested data info for this method.\nI was wondering if it would be a better approach to always set the key but the value should determine if the call is nested or not. That should give us a more robust way to future developer don't miss this out.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452567872", "createdAt": "2020-07-10T01:00:09Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +447,76 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2ODU4Ng==", "bodyText": "nit: doesn;t need the extra variable assignment.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452568586", "createdAt": "2020-07-10T01:03:26Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +447,76 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {\n+                        Database wrappedDatabase = new Database();\n+                        wrappedDatabase.setId(database.getId());\n+                        return createDatabaseInternal(wrappedDatabase,\n+                            requestOptions, context);\n+                    }\n+\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        requestOptions);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseInternal(Database database, CosmosDatabaseRequestOptions options,\n+                                                             Context context) {\n+        String spanName = \"createDatabase.\" + database.getId();\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseInternal(database, options);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2OTczNg==", "bodyText": "When do we expect this context to be null?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452569736", "createdAt": "2020-07-10T01:08:05Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +447,76 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3MzI4Nw==", "bodyText": "nit:  withContext(this::readThroughputInternal)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452573287", "createdAt": "2020-07-10T01:22:27Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -665,30 +672,9 @@ public CosmosAsyncConflict getConflict(String id) {\n      * @return the mono containing throughput response.\n      */\n     public Mono<ThroughputResponse> readThroughput() {\n-        return this.read()\n-                   .flatMap(response -> this.database.getDocClientWrapper()\n-                                            .queryOffers(database.getOfferQuerySpecFromResourceId(response.getProperties()\n-                                                                                                      .getResourceId())\n-                                                , new CosmosQueryRequestOptions())\n-                                            .single()\n-                                            .flatMap(offerFeedResponse -> {\n-                                                if (offerFeedResponse.getResults().isEmpty()) {\n-                                                    return Mono.error(BridgeInternal\n-                                                                          .createCosmosException(\n-                                                                              HttpConstants.StatusCodes.BADREQUEST,\n-                                                                              \"No offers found for the resource \"\n-                                                                                  + this.getId()));\n-                                                }\n-                                                return this.database.getDocClientWrapper()\n-                                                           .readOffer(offerFeedResponse.getResults()\n-                                                                          .get(0)\n-                                                                          .getSelfLink())\n-                                                           .single();\n-                                            })\n-                                            .map(ModelBridgeInternal::createThroughputRespose));\n+        return withContext(context -> readThroughputInternal(context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDA0OQ==", "bodyText": "Don't need to create an extra variable for options.\nreturn withContext(context -> readInternal(options == null ? new CosmosDatabaseRequestOptions() : options,\n            context));\nMore instances in the PR for this update.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452574049", "createdAt": "2020-07-10T01:25:29Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -79,11 +82,8 @@ public String getId() {\n      * the read database or an error.\n      */\n     public Mono<CosmosDatabaseResponse> read(CosmosDatabaseRequestOptions options) {\n-        if (options == null) {\n-            options = new CosmosDatabaseRequestOptions();\n-        }\n-        return getDocClientWrapper().readDatabase(getLink(), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosDatabaseResponse(response)).single();\n+        final CosmosDatabaseRequestOptions requestOptions = options == null ? new CosmosDatabaseRequestOptions() : options;\n+        return withContext(context -> readInternal(requestOptions, context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDk0Mw==", "bodyText": "Rather than calling the withContext you can call the method on L342.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452574943", "createdAt": "2020-07-10T01:29:04Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -328,7 +323,8 @@ public String getId() {\n         CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n         ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         CosmosAsyncContainer container = getContainer(containerProperties.getId());\n-        return createContainerIfNotExistsInternal(containerProperties, container, options);\n+        return withContext(context -> createContainerIfNotExistsInternal(containerProperties, container, options,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTE5MQ==", "bodyText": "therefor --> therefore/hence", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452575191", "createdAt": "2020-07-10T01:29:59Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTM0Ng==", "bodyText": "This API was made public, intentional?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452575346", "createdAt": "2020-07-10T01:30:29Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.\n      *\n      * After subscription the operation will be performed. The {@link Mono} upon\n      * successful completion will contain a cosmos container response with the\n      * created container. In case of failure the {@link Mono} will error.\n      *\n      * @param id the cosmos container id.\n      * @param partitionKeyPath the partition key path.\n-     * @param throughput the throughput for the container.\n+     * @param throughputProperties the throughput properties for the container.\n      * @return a {@link Mono} containing the cosmos container response with the\n      * created container or an error.\n      */\n-    Mono<CosmosContainerResponse> createContainerIfNotExists(\n+    public Mono<CosmosContainerResponse> createContainerIfNotExists(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTY4MQ==", "bodyText": "same with the withContext call can it be deferred to the last/final internal call.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452575681", "createdAt": "2020-07-10T01:31:49Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.\n      *\n      * After subscription the operation will be performed. The {@link Mono} upon\n      * successful completion will contain a cosmos container response with the\n      * created container. In case of failure the {@link Mono} will error.\n      *\n      * @param id the cosmos container id.\n      * @param partitionKeyPath the partition key path.\n-     * @param throughput the throughput for the container.\n+     * @param throughputProperties the throughput properties for the container.\n      * @return a {@link Mono} containing the cosmos container response with the\n      * created container or an error.\n      */\n-    Mono<CosmosContainerResponse> createContainerIfNotExists(\n+    public Mono<CosmosContainerResponse> createContainerIfNotExists(\n         String id, String partitionKeyPath,\n-        int throughput) {\n+        ThroughputProperties throughputProperties) {\n         CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n-        ModelBridgeInternal.setThroughputProperties(options, ThroughputProperties.createManualThroughput(throughput));\n+        ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath), container,\n-                                                  options);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjExMw==", "bodyText": "readAllContainers missing tracing/withContext intrumentation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452576113", "createdAt": "2020-07-10T01:33:50Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -464,7 +448,7 @@ public String getId() {\n      * obtained containers or an error.\n      */\n     public CosmosPagedFlux<CosmosContainerProperties> queryContainers(String query) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA==", "bodyText": "CosmosQueryRequestOptions options could be null resulting in NPE?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452576620", "createdAt": "2020-07-10T01:36:02Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -627,7 +604,7 @@ public CosmosAsyncContainer getContainer(String id) {\n      * obtained users or an error.\n      */\n     public CosmosPagedFlux<CosmosUserProperties> queryUsers(String query, CosmosQueryRequestOptions options) {\n-        return queryUsers(new SqlQuerySpec(query), options);\n+        return queryUsersInternal(new SqlQuerySpec(query), options);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NzIxMw==", "bodyText": "Don't need to an extra variable here, can directly be replaced by \"createUser.\" + this.getId().", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452577213", "createdAt": "2020-07-10T01:38:38Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        Mono<CosmosContainerResponse> responseMono,\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    if(context != null) {\n+                        return createContainerInternal(containerProperties, options, context);\n+                    }\n+\n+                    return createContainer(containerProperties, options);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainer.\" + containerProperties.getId();\n+        Mono<CosmosContainerResponse> responseMono = createContainerInternal(containerProperties, options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options) {\n+        return getDocClientWrapper()\n+            .createCollection(this.getLink(), ModelBridgeInternal.getV2Collection(containerProperties),\n+                ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosContainerResponse(response)).single();\n+    }\n+\n+    Mono<CosmosDatabaseResponse> readInternal(CosmosDatabaseRequestOptions options, Context context) {\n+        String spanName = \"readDatabase.\" + this.getId();\n+        Mono<CosmosDatabaseResponse> responseMono = readInternal(options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> readInternal(CosmosDatabaseRequestOptions options) {\n+        return getDocClientWrapper().readDatabase(getLink(),\n+            ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosDatabaseResponse(response)).single();\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> deleteInternal(CosmosDatabaseRequestOptions options, Context context) {\n+        String spanName = \"deleteDatabase.\" + this.getId();\n+        Mono<CosmosDatabaseResponse> responseMono = deleteInternal(options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> deleteInternal(CosmosDatabaseRequestOptions options) {\n+        return getDocClientWrapper().deleteDatabase(getLink(),\n+            ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosDatabaseResponse(response)).single();\n+    }\n+\n+    private Mono<CosmosUserResponse> createUserInternal(CosmosUserProperties userProperties, Context context) {\n+        String spanName = \"createUser.\" + this.getId();\n+        Mono<CosmosUserResponse> responseMono = createUserInternal(userProperties);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 541}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODUwNw==", "bodyText": "Same with queryContainers, don't seem to be having withContext update.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452578507", "createdAt": "2020-07-10T01:44:39Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -464,7 +448,7 @@ public String getId() {\n      * obtained containers or an error.\n      */\n     public CosmosPagedFlux<CosmosContainerProperties> queryContainers(String query) {\n-        return queryContainers(new SqlQuerySpec(query));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODgwOA==", "bodyText": "and below", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452578808", "createdAt": "2020-07-10T01:45:56Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.\n      *\n      * After subscription the operation will be performed. The {@link Mono} upon\n      * successful completion will contain a cosmos container response with the\n      * created container. In case of failure the {@link Mono} will error.\n      *\n      * @param id the cosmos container id.\n      * @param partitionKeyPath the partition key path.\n-     * @param throughput the throughput for the container.\n+     * @param throughputProperties the throughput properties for the container.\n      * @return a {@link Mono} containing the cosmos container response with the\n      * created container or an error.\n      */\n-    Mono<CosmosContainerResponse> createContainerIfNotExists(\n+    public Mono<CosmosContainerResponse> createContainerIfNotExists(\n         String id, String partitionKeyPath,\n-        int throughput) {\n+        ThroughputProperties throughputProperties) {\n         CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n-        ModelBridgeInternal.setThroughputProperties(options, ThroughputProperties.createManualThroughput(throughput));\n+        ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath), container,\n-                                                  options);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTY4MQ=="}, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTE0OA==", "bodyText": "Same here, does not have context propagation of withContext", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452579148", "createdAt": "2020-07-10T01:47:27Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -642,7 +619,7 @@ public CosmosAsyncContainer getContainer(String id) {\n      * obtained users or an error.\n      */\n     public CosmosPagedFlux<CosmosUserProperties> queryUsers(SqlQuerySpec querySpec) {\n-        return queryUsers(querySpec, new CosmosQueryRequestOptions());\n+        return queryUsersInternal(querySpec, new CosmosQueryRequestOptions());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTUyNw==", "bodyText": "Why two methods for createContainerIfNotExistsInternal?\nCould we combine them?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452579527", "createdAt": "2020-07-10T01:49:06Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 465}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTg5NA==", "bodyText": "This wouldn't be a good idea to be checking for context, since it can be anything and expected to be a property bag.\nRather check for a specific property/property value for which you would like to call a different method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452579894", "createdAt": "2020-07-10T01:50:39Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        Mono<CosmosContainerResponse> responseMono,\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    if(context != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 475}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MDEwNw==", "bodyText": "general comment, spanNames don't need to be created outside of the method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452580107", "createdAt": "2020-07-10T01:51:27Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        Mono<CosmosContainerResponse> responseMono,\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    if(context != null) {\n+                        return createContainerInternal(containerProperties, options, context);\n+                    }\n+\n+                    return createContainer(containerProperties, options);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainer.\" + containerProperties.getId();\n+        Mono<CosmosContainerResponse> responseMono = createContainerInternal(containerProperties, options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 493}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTA3Nw==", "bodyText": "Same comment about the span name.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452581077", "createdAt": "2020-07-10T01:55:24Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncPermission.java", "diffHunk": "@@ -126,4 +121,67 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosPermissionResponse> readInternal(CosmosPermissionRequestOptions options, Context context) {\n+\n+        String spanName = \"readPermission.\" + cosmosUser.getId();\n+        Mono<CosmosPermissionResponse> responseMono = readInternal(options);\n+        return cosmosUser.getDatabase().getClient().getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTM3NA==", "bodyText": "No too inclined on these two internal functions. If only called once could they be combined to a single method?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452581374", "createdAt": "2020-07-10T01:56:33Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncPermission.java", "diffHunk": "@@ -126,4 +121,67 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosPermissionResponse> readInternal(CosmosPermissionRequestOptions options, Context context) {\n+\n+        String spanName = \"readPermission.\" + cosmosUser.getId();\n+        Mono<CosmosPermissionResponse> responseMono = readInternal(options);\n+        return cosmosUser.getDatabase().getClient().getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            cosmosUser.getDatabase().getId(),\n+            cosmosUser.getDatabase().getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosPermissionResponse> readInternal(CosmosPermissionRequestOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTcxNw==", "bodyText": "readAllStoredProcedures doesn't have withContext instrumentation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452581717", "createdAt": "2020-07-10T01:58:03Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncScripts.java", "diffHunk": "@@ -108,6 +108,11 @@\n      */\n     CosmosPagedFlux<CosmosStoredProcedureProperties> readAllStoredProcedures(CosmosQueryRequestOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MjYwNQ==", "bodyText": "Don't see this used in the class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452582605", "createdAt": "2020-07-10T02:01:18Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private Tracer tracer;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MzY1OQ==", "bodyText": "Rather than this defaulting to 0 we should get the error status code from the Throwable itself.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452583659", "createdAt": "2020-07-10T02:05:56Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private Tracer tracer;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final int ERROR_CODE = 0;\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        if (tracers.iterator().hasNext()) {\n+            tracer = tracers.iterator().next();\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracer != null;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        local = local.addData(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME);\n+        local = tracer.start(methodName, local); // start the span and return the started span\n+        if (databaseId != null) {\n+            tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+        }\n+\n+        tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+        tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+        tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n+                                                                                   Context context,\n+                                                                                   String spanName,\n+                                                                                   String databaseId,\n+                                                                                   String endpoint) {\n+        return traceEnabledPublisher(resultPublisher, context, spanName,databaseId, endpoint,\n+            CosmosItemResponse::getStatusCode);\n+    }\n+\n+    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n+                                             Context context,\n+                                             String spanName,\n+                                             String databaseId,\n+                                             String endpoint,\n+                                             Function<T, Integer> statusCodeFunc) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        Optional<Object> callDepth = context.getData(COSMOS_CALL_DEPTH);\n+        final boolean isNestedCall = callDepth.isPresent();\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isEnabled() && !isNestedCall) {\n+                    parentContext.set(this.startSpan(spanName, databaseId, endpoint,\n+                        context));\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isEnabled() && !isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), statusCodeFunc.apply(response));\n+                }\n+            }).doOnError(throwable -> {\n+                if (isEnabled() && !isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), ERROR_CODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4Mzg3OA==", "bodyText": "Need unit tests for this class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452583878", "createdAt": "2020-07-10T02:06:50Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8af1cc9d56a405a9ec2bb72bac142b9d8c02890e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8af1cc9d56a405a9ec2bb72bac142b9d8c02890e", "committedDate": "2020-07-10T15:24:50Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "798839c218d086be39a3463b17a681d39c179084", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/798839c218d086be39a3463b17a681d39c179084", "committedDate": "2020-07-10T15:33:32Z", "message": "resolving comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c5743709725058254427079d898d2ad810da90", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21c5743709725058254427079d898d2ad810da90", "committedDate": "2020-07-10T15:34:00Z", "message": "resolving comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42e97890b47c2cfb06745bc4593003bd8f944b47", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/42e97890b47c2cfb06745bc4593003bd8f944b47", "committedDate": "2020-07-10T17:06:25Z", "message": "removing extra method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/be8d7ebbdd6ca856946093d058fa3045b56316fd", "committedDate": "2020-07-10T20:16:12Z", "message": "removing tets dependency"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzAzMTE2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446703116", "createdAt": "2020-07-10T21:11:13Z", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxMToxM1rOGwFwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxMToxM1rOGwFwEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTA1Ng==", "bodyText": "missing space before context", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453079056", "createdAt": "2020-07-10T21:11:13Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -500,11 +530,8 @@ public String getId() {\n         ModelBridgeInternal.setPartitionKey(options, partitionKey);\n         @SuppressWarnings(\"unchecked\")\n         Class<T> itemType = (Class<T>) item.getClass();\n-        return this.getDatabase()\n-                   .getDocClientWrapper()\n-                   .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n-                   .single();\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> replaceItemInternal(itemType, itemId, doc, requestOptions,context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "originalPosition": 268}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA2NDAx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446706401", "createdAt": "2020-07-10T21:18:37Z", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA2MDEy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446706012", "createdAt": "2020-07-10T21:17:46Z", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxNzo0NlrOGwF5IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyNToxOFrOGwGDzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTM3Nw==", "bodyText": "@simplynaveen20 Was thinking about this a little bit. Would it be acceptable for Cosmos behavior to throw an NPE if the tracer failed to load?\nAs tracing being an added functionality would it rather be acceptable to log that the tracer could not be loaded rather than to throw and make it completely impossible for the users to use this functionality just because we want to mandate a code pattern for the developers?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453081377", "createdAt": "2020-07-10T21:17:46Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -580,11 +603,14 @@ public CosmosAsyncScripts getScripts() {\n      */\n     public CosmosPagedFlux<CosmosConflictProperties> readAllConflicts(CosmosQueryRequestOptions options) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.getDatabase().getClient().getTracerProvider(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NDExMQ==", "bodyText": "[Not Blocking for this PR]\nInteresting..So by \"user fault\" you mean its acceptable for Cosmos API's to throw an NPE?\nJust curious why don't we do a null check upfront and let it flow through the code.  If it is an expected param, you could use a  Objects.requireNonNull(..)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453084111", "createdAt": "2020-07-10T21:25:18Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -627,7 +604,7 @@ public CosmosAsyncContainer getContainer(String id) {\n      * obtained users or an error.\n      */\n     public CosmosPagedFlux<CosmosUserProperties> queryUsers(String query, CosmosQueryRequestOptions options) {\n-        return queryUsers(new SqlQuerySpec(query), options);\n+        return queryUsersInternal(new SqlQuerySpec(query), options);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 327}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzM4MjU0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446738254", "createdAt": "2020-07-10T22:47:34Z", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjo0NzozNVrOGwHoRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjo0NzozNVrOGwHoRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwOTgzMQ==", "bodyText": "Can the internal methods be combined here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453109831", "createdAt": "2020-07-10T22:47:35Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncConflict.java", "diffHunk": "@@ -106,4 +106,33 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosConflictResponse> readInternal(RequestOptions options, Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzQ5MjQz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446749243", "createdAt": "2020-07-10T23:29:43Z", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzUwOTYz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-446750963", "createdAt": "2020-07-10T23:37:43Z", "commit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMzozNzo0NFrOGwIXsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMzozNzo0NFrOGwIXsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTk3MA==", "bodyText": "@simplynaveen20 Non-blocking, what are your thoughts about combing these?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453121970", "createdAt": "2020-07-10T23:37:44Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -709,4 +695,214 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.deleteItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        Mono<CosmosItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.replaceItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.upsertItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> readItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        Mono<CosmosItemResponse<T>> responseMono = readItemInternal(itemId, requestOptions, itemType);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.readItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> readItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions, Class<T> itemType) {\n+        return this.getDatabase().getDocClientWrapper()\n+            .readDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    Mono<CosmosContainerResponse> read(CosmosContainerRequestOptions options, Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd"}, "originalPosition": 482}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9725c8608fb80cbb446f5f4f0c94b5754b97db", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9725c8608fb80cbb446f5f4f0c94b5754b97db", "committedDate": "2020-07-13T17:02:12Z", "message": "adding span attribute unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc1296f69012aaf51b1b229ed1e36625cec14bc6", "committedDate": "2020-07-13T17:09:16Z", "message": "resolving comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDU1MzYw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-447455360", "createdAt": "2020-07-13T17:29:14Z", "commit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzoyOToxNFrOGwyhOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzozMDoyNVrOGwykDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgxMjUzOA==", "bodyText": "same here, can combine these.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453812538", "createdAt": "2020-07-13T17:29:14Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -221,16 +241,31 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItemInternal(item, requestOptions, context));\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> createItemInternal(T item, CosmosItemRequestOptions options, Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgxMzI2Mw==", "bodyText": "same here combine these internal methods.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453813263", "createdAt": "2020-07-13T17:30:25Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -709,4 +695,210 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.deleteItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 408}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NjIxMTk2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-447621196", "createdAt": "2020-07-13T21:35:43Z", "commit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTozNTo0M1rOGw6wKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMTo0MjowNFrOGw67bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0NzQzNA==", "bodyText": "What is happening here, why are we setting attributes in a method that's verifying tracer attributes?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453947434", "createdAt": "2020-07-13T21:35:43Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createContainerIfNotExists.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUsers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllContainers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.read().block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readContainer.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"upsertItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 5);\n+\n+        cosmosAsyncContainer.deleteItem(ITEM_ID, PartitionKey.NONE).block();\n+        Mockito.verify(tracerProvider, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 6);\n+\n+        cosmosAsyncContainer.readAllItems(new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 7);\n+\n+        String query = \"select * from c where c.id = '\" + ITEM_ID + \"'\";\n+        cosmosAsyncContainer.queryItems(query, new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 8);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncScripts() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Context context = tracerProviderCapture.getResult();\n+\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllStoredProcedures.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllTriggers.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUserDefinedFunctions.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        CosmosUserDefinedFunctionProperties cosmosUserDefinedFunctionProperties =\n+            getCosmosUserDefinedFunctionProperties();\n+        CosmosUserDefinedFunctionProperties resultUdf =\n+            cosmosAsyncContainer.getScripts().createUserDefinedFunction(cosmosUserDefinedFunctionProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createUserDefinedFunction.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readUDF.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 5);\n+\n+        cosmosUserDefinedFunctionProperties.setBody(\"function() {var x = 15;}\");\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(resultUdf.getId()).replace(resultUdf).block();\n+        Mockito.verify(tracerProvider, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"replaceUDF.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 6);\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).delete().block();\n+        Mockito.verify(tracerProvider, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteUDF.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 8);\n+\n+        CosmosTriggerProperties cosmosTriggerProperties = getCosmosTriggerProperties();\n+        CosmosTriggerProperties resultTrigger =\n+            cosmosAsyncContainer.getScripts().createTrigger(cosmosTriggerProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(9)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 9);\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(10)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 10);\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).replace(resultTrigger).block();\n+        Mockito.verify(tracerProvider, Mockito.times(11)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"replaceTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 11);\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(12)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).delete().block();\n+        Mockito.verify(tracerProvider, Mockito.times(13)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 13);\n+\n+        CosmosStoredProcedureProperties procedureProperties = getCosmosStoredProcedureProperties();\n+        CosmosStoredProcedureProperties resultSproc =\n+            cosmosAsyncContainer.getScripts().createStoredProcedure(procedureProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(14)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 14);\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(15)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 15);\n+\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).replace(resultSproc).block();\n+        Mockito.verify(tracerProvider, Mockito.times(16)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"replaceStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 16);\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).delete().block();\n+        Mockito.verify(tracerProvider, Mockito.times(18)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 18);\n+    }\n+\n+    @AfterClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void afterClass() {\n+        LifeCycleUtils.closeQuietly(client);\n+    }\n+\n+    private static CosmosUserDefinedFunctionProperties getCosmosUserDefinedFunctionProperties() {\n+        CosmosUserDefinedFunctionProperties udf =\n+            new CosmosUserDefinedFunctionProperties(UUID.randomUUID().toString(), \"function() {var x = 10;}\");\n+        return udf;\n+    }\n+\n+    private static CosmosTriggerProperties getCosmosTriggerProperties() {\n+        CosmosTriggerProperties trigger = new CosmosTriggerProperties(UUID.randomUUID().toString(), \"function() {var \" +\n+            \"x = 10;}\");\n+        trigger.setTriggerOperation(TriggerOperation.CREATE);\n+        trigger.setTriggerType(TriggerType.PRE);\n+        return trigger;\n+    }\n+\n+    private static CosmosStoredProcedureProperties getCosmosStoredProcedureProperties() {\n+        CosmosStoredProcedureProperties storedProcedureDef =\n+            new CosmosStoredProcedureProperties(UUID.randomUUID().toString(), \"function() {var x = 10;}\");\n+        return storedProcedureDef;\n+    }\n+\n+    private List<Tracer> getMockTracer(Tracer tracer) {\n+        List<Tracer> tracerList = new ArrayList<>();\n+        tracerList.add(tracer);\n+        Mockito.when(tracer.start(Matchers.anyString(), Matchers.any(Context.class))).thenReturn(Context.NONE);\n+        return tracerList;\n+    }\n+\n+    private void verifyTracerAttributes(Tracer mockTracer, String methodName, Context context, String databaseName,\n+                                        int numberOfTimesCalledWithinTest) {\n+        if (databaseName != null) {\n+            Mockito.verify(mockTracer, Mockito.times(numberOfTimesCalledWithinTest)).setAttribute(TracerProvider.DB_INSTANCE,\n+                databaseName, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODQyNQ==", "bodyText": "We shouldn't be grouping more than one use case in a testing scenario. Please consider breaking this up, to be unit testing cases.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453948425", "createdAt": "2020-07-13T21:37:54Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODk1Nw==", "bodyText": "Does this mean we are expecting, there would be 5 spans for a single readItem?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453948957", "createdAt": "2020-07-13T21:39:09Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createContainerIfNotExists.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUsers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllContainers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.read().block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readContainer.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"upsertItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0OTUyOA==", "bodyText": "I thought we got rid of the span name readUDF and should be using the same public API name for user -API visibility concerns.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453949528", "createdAt": "2020-07-13T21:40:23Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createContainerIfNotExists.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUsers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllContainers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.read().block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readContainer.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"upsertItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 5);\n+\n+        cosmosAsyncContainer.deleteItem(ITEM_ID, PartitionKey.NONE).block();\n+        Mockito.verify(tracerProvider, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 6);\n+\n+        cosmosAsyncContainer.readAllItems(new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 7);\n+\n+        String query = \"select * from c where c.id = '\" + ITEM_ID + \"'\";\n+        cosmosAsyncContainer.queryItems(query, new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 8);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncScripts() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Context context = tracerProviderCapture.getResult();\n+\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllStoredProcedures.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllTriggers.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUserDefinedFunctions.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        CosmosUserDefinedFunctionProperties cosmosUserDefinedFunctionProperties =\n+            getCosmosUserDefinedFunctionProperties();\n+        CosmosUserDefinedFunctionProperties resultUdf =\n+            cosmosAsyncContainer.getScripts().createUserDefinedFunction(cosmosUserDefinedFunctionProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createUserDefinedFunction.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readUDF.\" + cosmosAsyncContainer.getId(), context,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1MDMxNg==", "bodyText": "Suggestion can be updated to check for the span name here\nMockito.verify(tracerProvider, Mockito.times(1)).startSpan(eq(\"createContainerIfNotExists\"), Matchers.anyString()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453950316", "createdAt": "2020-07-13T21:42:04Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NjQyMzY2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-447642366", "createdAt": "2020-07-13T22:04:02Z", "commit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNDowMlrOGw7y9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNDowMlrOGw7y9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NDUzNA==", "bodyText": "Do we need the spy if we have a mock of tracer list for a valid tracerProvider object?\nnit: Consider adding static import for Mockito methods.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453964534", "createdAt": "2020-07-13T22:04:02Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NjY1MTE1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-447665115", "createdAt": "2020-07-13T22:52:50Z", "commit": {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a7aab07efdce2088ef79cd27ad62576d6064a25", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a7aab07efdce2088ef79cd27ad62576d6064a25", "committedDate": "2020-07-14T18:33:13Z", "message": "resolving comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDUxNzkw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-450451790", "createdAt": "2020-07-17T08:00:38Z", "commit": {"oid": "0a7aab07efdce2088ef79cd27ad62576d6064a25"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODowMDozOVrOGzJVcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOToyODowNFrOGzMJCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4MzUwNg==", "bodyText": "Calling ServiceLoader.load() for each instance of the client is not required. This can be done once as the result of the loader doesn't change during the lifespan of the application.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456283506", "createdAt": "2020-07-17T08:00:39Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -65,6 +71,7 @@\n         this.sessionCapturingOverride = builder.isSessionCapturingOverrideEnabled();\n         this.enableTransportClientSharing = builder.isConnectionSharingAcrossClientsEnabled();\n         this.contentResponseOnWriteEnabled = builder.isContentResponseOnWriteEnabled();\n+        this.tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a7aab07efdce2088ef79cd27ad62576d6064a25"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4Nzg5NA==", "bodyText": "Should this be using the nestedContext instead since a new key, value pair is added to the original context?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456287894", "createdAt": "2020-07-17T08:09:23Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +429,63 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = database.readInternal(new CosmosDatabaseRequestOptions(),\n+            nestedContext).onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if (throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    Database wrappedDatabase = new Database();\n+                    wrappedDatabase.setId(database.getId());\n+                    return createDatabaseInternal(wrappedDatabase,\n+                        requestOptions, nestedContext);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a7aab07efdce2088ef79cd27ad62576d6064a25"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyNDI1Mg==", "bodyText": "A method that returns a reactor publisher (CosmosPagedFlux here) should not throw an exception directly. The error has to flow through the error channel and the user should be able to use onError handler to gracefully handle exceptions. Also, since options are optional, the user should still be able to pass a null value and this method should not throw.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456324252", "createdAt": "2020-07-17T09:18:16Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -627,7 +604,7 @@ public CosmosAsyncContainer getContainer(String id) {\n      * obtained users or an error.\n      */\n     public CosmosPagedFlux<CosmosUserProperties> queryUsers(String query, CosmosQueryRequestOptions options) {\n-        return queryUsers(new SqlQuerySpec(query), options);\n+        return queryUsersInternal(new SqlQuerySpec(query), options);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}, "originalCommit": {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyOTQ4MQ==", "bodyText": "nit: fix formatting.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456329481", "createdAt": "2020-07-17T09:28:04Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private Tracer tracer;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final int ERROR_CODE = 0;\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        if (tracers.iterator().hasNext()) {\n+            tracer = tracers.iterator().next();\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracer != null;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        local = local.addData(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME);\n+        local = tracer.start(methodName, local); // start the span and return the started span\n+        if (databaseId != null) {\n+            tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+        }\n+\n+        tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+        tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+        tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a7aab07efdce2088ef79cd27ad62576d6064a25"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8292a8342d170644c4fcc3fe91087008183b9ac1", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8292a8342d170644c4fcc3fe91087008183b9ac1", "committedDate": "2020-07-17T21:47:49Z", "message": "resolving merge conflic and comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwOTc1ODcz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#pullrequestreview-450975873", "createdAt": "2020-07-17T21:54:19Z", "commit": {"oid": "8292a8342d170644c4fcc3fe91087008183b9ac1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTo1NDoxOVrOGziJ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTo1NDoxOVrOGziJ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MDE2OA==", "bodyText": "what happens if there are multiple implementation for Tracer on the classpath? is that possible?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456690168", "createdAt": "2020-07-17T21:54:19Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -52,8 +58,20 @@\n     private final AzureKeyCredential credential;\n     private final boolean sessionCapturingOverride;\n     private final boolean enableTransportClientSharing;\n+    private final TracerProvider tracerProvider;\n     private final DataEncryptionKeyProvider dataEncryptionKeyProvider;\n     private final boolean contentResponseOnWriteEnabled;\n+    private static final Tracer TRACER;\n+\n+    static {\n+        ServiceLoader<Tracer> serviceLoader = ServiceLoader.load(Tracer.class);\n+        Iterator<?> iterator = serviceLoader.iterator();\n+        if (iterator.hasNext()) {\n+            TRACER = serviceLoader.iterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8292a8342d170644c4fcc3fe91087008183b9ac1"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2714, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}