{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0NTg3NDc2", "number": 15076, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjowNjo0OFrOEiZOow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowNzo1MVrOEin4dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTAwMzg3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjowNjo0OFrOHQPgaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjowNjo0OFrOHQPgaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5MzMyMQ==", "bodyText": "\"renews the specified message\" is confusing", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486793321", "createdAt": "2020-09-11T06:06:48Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTAwODM4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjowOTowMFrOHQPjKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjo1NTozMlrOHQQoiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NDAyNA==", "bodyText": "The above uses monoError. Why is this line different?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486794024", "createdAt": "2020-09-11T06:09:00Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgxMTc4NA==", "bodyText": "Good catch. I've replaced all instances", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486811784", "createdAt": "2020-09-11T06:55:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NDAyNA=="}, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTAxNTg2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjoxMjoyMVrOHQPnkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjoxMjoyMVrOHQPnkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NTE1Mg==", "bodyText": "Same question. The above uses monoError. This overload uses logger.logExceptionAsError().", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486795152", "createdAt": "2020-09-11T06:12:21Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTAxNzk3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjoxMzoxNFrOHQPo3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjoxMzoxNFrOHQPo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NTQ4NA==", "bodyText": "same question", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486795484", "createdAt": "2020-09-11T06:13:14Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -885,6 +848,42 @@ public String getEntityPath() {\n                 .map(instant -> instant.atOffset(ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code sessionId} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.\n+     */\n+    public Mono<Void> renewSessionLock(String sessionId, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewSessionLock\")));\n+        } else if (!receiverOptions.isSessionReceiver()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTQyNjI4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODoyOTo1OFrOHQTfOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTowNjo0NlrOHQt39Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg==", "bodyText": "Why are we using ServiceBusReceivedMessage for renewing and other settlement methods? Should we use the locktoken instead as per this API view?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486858552", "createdAt": "2020-09-11T08:29:58Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTIyMQ==", "bodyText": "@srnagar  I should update this APIview with this change.  There was a review with Clemens (Messaging Architect ) and Service team on this . The requirement of  using lockToken was dropped. Here is discussion thread Azure/azure-sdk-for-net#10852 (comment)   Here is an issue for this https://app.zenhub.com/workspaces/azure-sdk-team-5bdca72c4b5806bc2bf0aab2/issues/azure/azure-sdk-for-java/14664", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487161221", "createdAt": "2020-09-11T16:38:10Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg=="}, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5MDg2OQ==", "bodyText": "The API view has been updated already: https://apiview.dev/Assemblies/Review/64f40be9988242c9a8facc8a20c5e9e7", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487290869", "createdAt": "2020-09-11T21:06:46Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg=="}, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTQzNDQxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozMjoyNlrOHQTkdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozMjoyNlrOHQTkdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1OTg5Mw==", "bodyText": "There's no lockToken in the input args? I guess this is referring to message. However, as per the API view, the actual argument should be lockToken.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486859893", "createdAt": "2020-09-11T08:32:26Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTQzOTc5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozNDoxNFrOHQToAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozNDoxNFrOHQToAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MDgwMA==", "bodyText": "Might be worth adding a log when onComplete() is called too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486860800", "createdAt": "2020-09-11T08:34:14Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";\n+        final Consumer<Throwable> throwableConsumer = onError != null\n+            ? onError\n+            : error -> logger.warning(\"Exception occurred while renewing lock token '{}'.\", lockToken, error);\n+\n+        asyncClient.renewMessageLock(message, maxLockRenewalDuration).subscribe(\n+            v -> logger.verbose(\"Completed renewing lock token: '{}'\", lockToken),\n+            throwableConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTQ0NjMyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozNjoxMFrOHQTsFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzoyNzowNFrOHQng9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTg0Nw==", "bodyText": "Does the auto-lock renewal stop if the user settles the message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486861847", "createdAt": "2020-09-11T08:36:10Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n+        } else if (receiverOptions.isSessionReceiver()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n+        } else if (maxLockRenewalDuration == null) {\n+            return monoError(logger, new NullPointerException(\"'maxLockRenewalDuration' cannot be null.\"));\n+        } else if (maxLockRenewalDuration.isNegative()) {\n+            return monoError(logger, new IllegalArgumentException(\"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        final LockRenewalOperation operation = new LockRenewalOperation(message.getLockToken(),\n+            maxLockRenewalDuration, false, ignored -> renewMessageLock(message));\n+        renewalContainer.addOrUpdate(message.getLockToken(), Instant.now().plus(maxLockRenewalDuration), operation);\n+\n+        return operation.getCompletionOperation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NjY3Ng==", "bodyText": "Yes it does.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487186676", "createdAt": "2020-09-11T17:27:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n+        } else if (receiverOptions.isSessionReceiver()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n+        } else if (maxLockRenewalDuration == null) {\n+            return monoError(logger, new NullPointerException(\"'maxLockRenewalDuration' cannot be null.\"));\n+        } else if (maxLockRenewalDuration.isNegative()) {\n+            return monoError(logger, new IllegalArgumentException(\"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        final LockRenewalOperation operation = new LockRenewalOperation(message.getLockToken(),\n+            maxLockRenewalDuration, false, ignored -> renewMessageLock(message));\n+        renewalContainer.addOrUpdate(message.getLockToken(), Instant.now().plus(maxLockRenewalDuration), operation);\n+\n+        return operation.getCompletionOperation();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTg0Nw=="}, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzMyMjYyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0MzozMlrOHQmIsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0MzozMlrOHQmIsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDA4MA==", "bodyText": "Although logically lockToken will always be there but we should check for null value also.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487164080", "createdAt": "2020-09-11T16:43:32Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzMyNzg4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0NTowNlrOHQmL7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0NTowNlrOHQmL7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDkxMA==", "bodyText": "given lock -> given {@link ServiceBusReceivedMessage}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487164910", "createdAt": "2020-09-11T16:45:06Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzMzMjEyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0NjoxOFrOHQmOhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0NjoxOFrOHQmOhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NTU3NQ==", "bodyText": "null check for message.getLockToken()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487165575", "createdAt": "2020-09-11T16:46:18Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzMzODY1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0ODoxM1rOHQmSag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0ODoxM1rOHQmSag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjU3MA==", "bodyText": "lock token -> session ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487166570", "createdAt": "2020-09-11T16:48:13Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -885,6 +847,42 @@ public String getEntityPath() {\n                 .map(instant -> instant.atOffset(ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzM1NzU3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1Mzo1NVrOHQmefg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1Mzo1NVrOHQmefg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2OTY2Mg==", "bodyText": "the lock on the specified message   This is repeated two times.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487169662", "createdAt": "2020-09-11T16:53:55Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -570,13 +524,13 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n     }\n \n     /**\n-     * Renews the lock on the specified message. The lock will be renewed based on the setting specified on the entity.\n-     * When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the server for this\n-     * receiver instance for a duration as specified during the Queue creation (LockDuration). If processing of the\n-     * message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to\n-     * the entity's LockDuration value.\n+     * Renews the lock on the specified message.the lock on the specified message. The lock will be renewed based on the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzM4MTAxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowMDoyNlrOHQmsnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMDo0Njo0NVrOHQtY-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MzI3OQ==", "bodyText": "What is the reason of assigning \"null\" string to lockToken . Shouldn't  we throw NPE if it is null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487173279", "createdAt": "2020-09-11T17:00:26Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4MjkzNw==", "bodyText": "It'll get thrown later when we call into asyncClient. This is so the function invocation resolves correctly.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487282937", "createdAt": "2020-09-11T20:46:45Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MzI3OQ=="}, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzM4NjYzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowMjoxMlrOHQmwKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowMjoxMlrOHQmwKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDE4NA==", "bodyText": "with the given lock : It is a bit confusing since user never gave us any lock in this API.\nSuggestion Starts the auto lock renewal for a session id.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487174184", "createdAt": "2020-09-11T17:02:12Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -601,6 +578,27 @@ public OffsetDateTime renewSessionLock(String sessionId) {\n         return asyncClient.renewSessionLock(sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzM4ODM4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowMjo0NVrOHQmxNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowMjo0NVrOHQmxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDQ1NQ==", "bodyText": "lock token -> session", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487174455", "createdAt": "2020-09-11T17:02:45Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -601,6 +578,27 @@ public OffsetDateTime renewSessionLock(String sessionId) {\n         return asyncClient.renewSessionLock(sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzQwNDY4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowNzo1MVrOHQm7Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowNzo1MVrOHQm7Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NzAzMA==", "bodyText": "May be adding test is message.getLockToken() returns null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487177030", "createdAt": "2020-09-11T17:07:51Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientTest.java", "diffHunk": "@@ -164,15 +166,17 @@ void autoRenewMessageLockFails() {\n         final TestPublisher<Void> publisher = TestPublisher.create();\n         final Throwable testError = new IllegalAccessException(\"Some exception\");\n \n-        when(asyncClient.getAutoRenewMessageLock(LOCK_TOKEN, maxDuration)).thenReturn(publisher.mono());\n+        when(message.getLockToken()).thenReturn(LOCK_TOKEN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1196, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}