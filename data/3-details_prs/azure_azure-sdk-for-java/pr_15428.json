{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNDg0OTcy", "number": 15428, "title": "Implemented features for STG 74", "bodyText": "Note: Waiting to merge until after live tests are running and passing.\nazure-storage-blob\n\nAdded support for the 2020-02-10 service version.\nAdded support to specify Arrow Output Serialization when querying a blob.\nAdded support to undelete a container.\nAdded BlobImmutableDueToPolicy to the BlobErrorCode enum.\n\nazure-storage-file-datalake\n\nAdded support for the 2020-02-10 service version.\nAdded support for setting, modifying, and removing ACLs recursively.\nAdded support to schedule file expiration.\nAdded support to specify Arrow Output Serialization when querying a file.\nAdded support to generate directory SAS and added support to specify additional user ids and correlation ids for user delegation SAS.\n\nazure-storage-file-share\n\nAdded support for the 2020-02-10 service version.\nAdded support to getFileRanges on a previous snapshot by adding the getFileRangesDiff API.\nAdded support to set whether or not smb multichannel is enabled.\nAdded support to lease shares and snapshot shares.\nAdded support to specify a lease id for share operations.\nFixed a bug where getProperties on a file client would throw a HttpResponseException instead of ShareStorageException.\nFixed a bug where snapshot would be appended to a share snapshot instead of sharesnapshot.\n\nazure-storage-queue\n\nAdded support for the 2020-02-10 service version.", "createdAt": "2020-09-21T18:36:14Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428", "merged": true, "mergeCommit": {"oid": "a27047b0e2061149d940ccfefd9b569d91bafbd9"}, "closed": true, "closedAt": "2020-10-01T19:18:36Z", "author": {"login": "gapra-msft"}, "timelineItems": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-q2F8gH2gAyNDkwNDg0OTcyOjNiMTQzOWU2MmNhMjZhZjE5NjRiZTAxYzM3ZDk1ZmZjYzZiYTcwMmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOWZvSAFqTUwMDY0Njg1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3b1439e62ca26af1964be01c37d95ffcc6ba702b", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3b1439e62ca26af1964be01c37d95ffcc6ba702b", "committedDate": "2020-08-14T02:04:29Z", "message": "Updated all service versions to STG74 (#14079)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39e8f81da0142c426c663458a3c46569dabd65b5", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/39e8f81da0142c426c663458a3c46569dabd65b5", "committedDate": "2020-08-14T15:59:05Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09364928b56e728f99a19736c0f599e530581af2", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/09364928b56e728f99a19736c0f599e530581af2", "committedDate": "2020-08-17T15:55:28Z", "message": "Added code for get file range diff (#14140)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b22fe458a596cf590076407708febd1e8a7d80f", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2b22fe458a596cf590076407708febd1e8a7d80f", "committedDate": "2020-08-18T15:56:56Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6df5d14093c1b4301b16df353c52765cd243067d", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6df5d14093c1b4301b16df353c52765cd243067d", "committedDate": "2020-08-18T17:48:43Z", "message": "Added code for smb multi channel (#14180)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9707fc9aee5aea133db27939c1da4edba3b10b3", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9707fc9aee5aea133db27939c1da4edba3b10b3", "committedDate": "2020-08-25T00:42:47Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c96fefbc002d4de3405f88c9fa93d12e2bbe9f5b", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c96fefbc002d4de3405f88c9fa93d12e2bbe9f5b", "committedDate": "2020-08-25T16:12:54Z", "message": "Added code to allow scheduling file expiry (#14319)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3193068ec6615a89bec8e152c0a90e7835f4c03c", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3193068ec6615a89bec8e152c0a90e7835f4c03c", "committedDate": "2020-08-25T23:23:42Z", "message": "Added support for arrow output serialization (#14431)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3a97bdf640334fa92489a57aa4bc357c0e3eed3", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3a97bdf640334fa92489a57aa4bc357c0e3eed3", "committedDate": "2020-08-28T01:24:50Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c44229968538724184487871478d3b75165e50a2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c44229968538724184487871478d3b75165e50a2", "committedDate": "2020-08-28T17:04:27Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "022b7ca4a48411a12cc28e6496f85fb68d2fc260", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/022b7ca4a48411a12cc28e6496f85fb68d2fc260", "committedDate": "2020-08-31T15:50:22Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75d62aeb3b5c3e1fba4152cacd168f0721cae1cc", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/75d62aeb3b5c3e1fba4152cacd168f0721cae1cc", "committedDate": "2020-09-02T00:09:51Z", "message": "Added support to read last access time  (#14342)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5039773de618d923e66ec157af75994bb9eb974", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f5039773de618d923e66ec157af75994bb9eb974", "committedDate": "2020-09-02T15:41:26Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e065ebc26978696f8ca71892883d1f7abe376e73", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e065ebc26978696f8ca71892883d1f7abe376e73", "committedDate": "2020-09-02T19:53:57Z", "message": "Added support to lease shares (#14287)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac212deba0d4ac571995c6ad1436707b2dfcd8e7", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ac212deba0d4ac571995c6ad1436707b2dfcd8e7", "committedDate": "2020-09-08T16:54:51Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01bc3188a300047b314bfafd0ff701020f78a13d", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/01bc3188a300047b314bfafd0ff701020f78a13d", "committedDate": "2020-09-08T17:18:04Z", "message": "Updated file ranges to getFileRangesDiff (#14839)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b91c9302bd57cb5dbdfa7b4718bcb87bbcc5fdb0", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b91c9302bd57cb5dbdfa7b4718bcb87bbcc5fdb0", "committedDate": "2020-09-09T18:35:50Z", "message": "Added support for directory and delegation SAS (#14531)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41af3e86346582525b644860d59b3a029e79bf5a", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/41af3e86346582525b644860d59b3a029e79bf5a", "committedDate": "2020-09-09T18:39:36Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "988e69b5a811272c9aea141bb0c80b2eb5a1d5aa", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/988e69b5a811272c9aea141bb0c80b2eb5a1d5aa", "committedDate": "2020-09-09T19:59:27Z", "message": "Recursive acl (#14669)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8703aeda95890bf03d02079b34d1cc1da618b8f1", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8703aeda95890bf03d02079b34d1cc1da618b8f1", "committedDate": "2020-09-09T20:03:52Z", "message": "Added missing error code (#14986)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14c4696b6ec441fa11494226c240bf1545d7ea0f", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/14c4696b6ec441fa11494226c240bf1545d7ea0f", "committedDate": "2020-09-11T17:49:37Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6964085e3fd1b798f2d65e6660341749003de0fc", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6964085e3fd1b798f2d65e6660341749003de0fc", "committedDate": "2020-09-14T19:24:43Z", "message": "Added tests to ensure support for 4TB file (#15179)\n\nCo-authored-by: Gauri Prasad <gapra@microsoft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e700c2b427f1b09be0109de30831317a25159c02", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e700c2b427f1b09be0109de30831317a25159c02", "committedDate": "2020-09-15T18:31:41Z", "message": "Storage/file share error code (#15007)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70bd4093bc24d79aef0b0a67ecbf4bb13521893c", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/70bd4093bc24d79aef0b0a67ecbf4bb13521893c", "committedDate": "2020-09-16T17:24:42Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "652424c90ca692885f85b7b64102a6e5d2439db9", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/652424c90ca692885f85b7b64102a6e5d2439db9", "committedDate": "2020-09-16T23:22:25Z", "message": "Fixed simple renames and doc issues from 74 (#15297)\n\nCo-authored-by: Gauri Prasad <gapra@microsoft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "118f69e40de643c5df75b2a845f3f6f5752ebdc4", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/118f69e40de643c5df75b2a845f3f6f5752ebdc4", "committedDate": "2020-09-21T15:23:13Z", "message": "Added back support for container undelete. (#15344)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60d2675afed1fe518f72482b81b6d519218d1082", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/60d2675afed1fe518f72482b81b6d519218d1082", "committedDate": "2020-09-21T18:26:36Z", "message": "Regenerated code to address APIView comments (#15341)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe4b5e8d6a71e801a47256adfe92feff4c23495b", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe4b5e8d6a71e801a47256adfe92feff4c23495b", "committedDate": "2020-09-21T18:35:24Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d600512ecf1e0c821b4c1d84deb19eb7cd6759d2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d600512ecf1e0c821b4c1d84deb19eb7cd6759d2", "committedDate": "2020-09-21T18:41:20Z", "message": "Minor changelog formatting issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODg2ODg2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#pullrequestreview-492886886", "createdAt": "2020-09-21T18:45:33Z", "commit": {"oid": "d600512ecf1e0c821b4c1d84deb19eb7cd6759d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo0NTozNFrOHVd6ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo0NTozNFrOHVd6ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MjI2Ng==", "bodyText": "remove extra new lines", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492272266", "createdAt": "2020-09-21T18:45:34Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -849,14 +847,13 @@ private void throwOnAnonymousAccess() {\n      * @return A {@link Mono} containing a {@link BlobContainerAsyncClient} used\n      * to interact with the restored container.\n      */\n-    /*\n     public Mono<BlobContainerAsyncClient> undeleteBlobContainer(\n         String deletedContainerName, String deletedContainerVersion) {\n-        return this.undeleteBlobContainerWithResponse(\n-            new UndeleteBlobContainerOptions(deletedContainerName, deletedContainerVersion)\n+        return this.undeleteBlobContainerWithResponse(new UndeleteBlobContainerOptions(deletedContainerName,\n+            deletedContainerVersion)\n         ).flatMap(FluxUtil::toMono);\n     }\n-    */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d600512ecf1e0c821b4c1d84deb19eb7cd6759d2"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c6d93e28ba4bfca9f168f9812fe982d5a13e45b2", "committedDate": "2020-09-21T19:38:51Z", "message": "Formatting - new lines and unused imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTQxOTQ4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#pullrequestreview-492941948", "createdAt": "2020-09-21T20:07:33Z", "commit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDowNzozM1rOHVgmXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDowNzozM1rOHVgmXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjI1NQ==", "bodyText": "@rickle-msft Is this still a TODO or can we delete this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492316255", "createdAt": "2020-09-21T20:07:33Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-file-datalake/src/test/java/com/azure/storage/file/datalake/DirectoryAPITest.groovy", "diffHunk": "@@ -434,6 +444,786 @@ class DirectoryAPITest extends APISpec {\n         thrown(DataLakeStorageException)\n     }\n \n+    def \"Set ACL recursive min\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        when:\n+        def result = dc.setAccessControlRecursive(pathAccessControlEntries)\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive batches\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2)\n+\n+        when:\n+        def result = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive batches resume\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(1)\n+\n+        when:\n+        def result = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        and:\n+        options.setMaxBatches(null).setContinuationToken(result.getContinuationToken())\n+        def result2 = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        (result.getCounters().getChangedDirectoriesCount() + result2.getCounters().getChangedDirectoriesCount()) == 3 // Including the top level\n+        (result.getCounters().getChangedFilesCount() + result2.getCounters().getChangedFilesCount()) == 4\n+        (result.getCounters().getFailedChangesCount() + result2.getCounters().getFailedChangesCount()) == 0\n+        result2.getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive batches progress\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setProgressHandler(progress)\n+\n+        when:\n+        def result = dc.setAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+        progress.batchCounters.size() == 4\n+        (progress.batchCounters[0].getChangedFilesCount() + progress.batchCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[1].getChangedFilesCount() + progress.batchCounters[1].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[2].getChangedFilesCount() + progress.batchCounters[2].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[3].getChangedFilesCount() + progress.batchCounters[3].getChangedDirectoriesCount()) == 1\n+        progress.cumulativeCounters.size() == 4\n+        (progress.cumulativeCounters[0].getChangedFilesCount() + progress.cumulativeCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.cumulativeCounters[1].getChangedFilesCount() + progress.cumulativeCounters[1].getChangedDirectoriesCount()) == 4\n+        (progress.cumulativeCounters[2].getChangedFilesCount() + progress.cumulativeCounters[2].getChangedDirectoriesCount()) == 6\n+        (progress.cumulativeCounters[3].getChangedFilesCount() + progress.cumulativeCounters[3].getChangedDirectoriesCount()) == 7\n+    }\n+\n+    def \"Set ACL recursive batches follow token\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(2)\n+\n+        when:\n+        String continuation = \"null\"\n+        def failedChanges = 0\n+        def directoriesChanged = 0\n+        def filesChanged = 0\n+        def iterations = 0\n+        while(continuation != null && continuation != \"\" && iterations < 10) {\n+            if (iterations == 0) {\n+                continuation = null // do while not supported in Groovy\n+            }\n+            options.setContinuationToken(continuation)\n+            def result = dc.setAccessControlRecursiveWithResponse(options, null, null)\n+            failedChanges += result.getValue().getCounters().getFailedChangesCount()\n+            directoriesChanged += result.getValue().getCounters().getChangedDirectoriesCount()\n+            filesChanged += result.getValue().getCounters().getChangedFilesCount()\n+            iterations++\n+            continuation = result.getValue().getContinuationToken()\n+        }\n+\n+        then:\n+        failedChanges == 0\n+        directoriesChanged == 3\n+        filesChanged == 4\n+        iterations == 2\n+    }\n+\n+    def \"Set ACL recursive progress with failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create file4 as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        when:\n+        def result = topDirOauthClient.setAccessControlRecursiveWithResponse(\n+            new PathSetAccessControlRecursiveOptions(pathAccessControlEntries).setProgressHandler(progress), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getFailedChangesCount() == 1\n+        progress.failures.size() == 1\n+        progress.batchCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.cumulativeCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.failures[0].getName().contains(file4.getObjectName())\n+        !progress.failures[0].isDirectory()\n+        progress.failures[0].getErrorMessage()\n+    }\n+\n+    def \"Set ACL recursive continue on failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        when:\n+        def result = topDirOauthClient.setAccessControlRecursiveWithResponse(\n+            new PathSetAccessControlRecursiveOptions(pathAccessControlEntries).setContinueOnFailure(true), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getChangedDirectoriesCount() == 3\n+        result.getValue().getCounters().getChangedFilesCount() == 3\n+        result.getValue().getCounters().getFailedChangesCount() == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive continue on failure batches resume\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        // Create more files as app\n+        def file7 = subdir1.createFile(generatePathName())\n+        def file8 = subdir1.createFile(generatePathName())\n+        def subdir4 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file9 = subdir4.createFile(generatePathName())\n+\n+        def options = new PathSetAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setContinueOnFailure(true).setMaxBatches(1)\n+\n+        when:\n+        def intermediateResult = topDirOauthClient.setAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        intermediateResult.getValue().getContinuationToken() != null\n+\n+        when:\n+        options.setMaxBatches(null).setContinuationToken(intermediateResult.getValue().getContinuationToken())\n+        def result = topDirOauthClient.setAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        (result.getValue().getCounters().getChangedDirectoriesCount() + intermediateResult.getValue().getCounters().getChangedDirectoriesCount()) == 4\n+        (result.getValue().getCounters().getChangedFilesCount() + intermediateResult.getValue().getCounters().getChangedFilesCount()) == 6\n+        (result.getValue().getCounters().getFailedChangesCount() + intermediateResult.getValue().getCounters().getFailedChangesCount()) == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Set ACL recursive error\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+\n+        String topDirName = generatePathName()\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+\n+        when:\n+        topDirOauthClient.setAccessControlRecursiveWithResponse(\n+            new PathSetAccessControlRecursiveOptions(pathAccessControlEntries), null, null)\n+\n+        then:\n+        thrown(DataLakeStorageException)\n+    }\n+\n+    def \"Update ACL recursive\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        when:\n+        def result = dc.updateAccessControlRecursive(pathAccessControlEntries)\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+    }\n+\n+    def \"Update ACL recursive batches\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2)\n+\n+        when:\n+        def result = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive batches resume\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(1)\n+\n+        when:\n+        def result = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        and:\n+        options.setMaxBatches(null).setContinuationToken(result.getContinuationToken())\n+        def result2 = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        (result.getCounters().getChangedDirectoriesCount() + result2.getCounters().getChangedDirectoriesCount()) == 3 // Including the top level\n+        (result.getCounters().getChangedFilesCount() + result2.getCounters().getChangedFilesCount()) == 4\n+        (result.getCounters().getFailedChangesCount() + result2.getCounters().getFailedChangesCount()) == 0\n+        result2.getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive batches progress\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setProgressHandler(progress)\n+\n+        when:\n+        def result = dc.updateAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+        progress.batchCounters.size() == 4\n+        (progress.batchCounters[0].getChangedFilesCount() + progress.batchCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[1].getChangedFilesCount() + progress.batchCounters[1].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[2].getChangedFilesCount() + progress.batchCounters[2].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[3].getChangedFilesCount() + progress.batchCounters[3].getChangedDirectoriesCount()) == 1\n+        progress.cumulativeCounters.size() == 4\n+        (progress.cumulativeCounters[0].getChangedFilesCount() + progress.cumulativeCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.cumulativeCounters[1].getChangedFilesCount() + progress.cumulativeCounters[1].getChangedDirectoriesCount()) == 4\n+        (progress.cumulativeCounters[2].getChangedFilesCount() + progress.cumulativeCounters[2].getChangedDirectoriesCount()) == 6\n+        (progress.cumulativeCounters[3].getChangedFilesCount() + progress.cumulativeCounters[3].getChangedDirectoriesCount()) == 7\n+    }\n+\n+    def \"Update ACL recursive batches follow token\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(2)\n+\n+        when:\n+        String continuation = \"null\"\n+        def failedChanges = 0\n+        def directoriesChanged = 0\n+        def filesChanged = 0\n+        def iterations = 0\n+        while(continuation != null && continuation != \"\" && iterations < 10) {\n+            if (iterations == 0) {\n+                continuation = null // do while not supported in Groovy\n+            }\n+            options.setContinuationToken(continuation)\n+            def result = dc.updateAccessControlRecursiveWithResponse(options, null, null)\n+            failedChanges += result.getValue().getCounters().getFailedChangesCount()\n+            directoriesChanged += result.getValue().getCounters().getChangedDirectoriesCount()\n+            filesChanged += result.getValue().getCounters().getChangedFilesCount()\n+            iterations++\n+            continuation = result.getValue().getContinuationToken()\n+        }\n+\n+        then:\n+        failedChanges == 0\n+        directoriesChanged == 3\n+        filesChanged == 4\n+        iterations == 2\n+    }\n+\n+    def \"Update ACL recursive progress with failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create file4 as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        when:\n+        def result = topDirOauthClient.updateAccessControlRecursiveWithResponse(\n+            new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries).setProgressHandler(progress), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getFailedChangesCount() == 1\n+        progress.failures.size() == 1\n+        progress.batchCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.cumulativeCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.failures[0].getName().contains(file4.getObjectName())\n+        !progress.failures[0].isDirectory()\n+        progress.failures[0].getErrorMessage()\n+    }\n+\n+    def \"Update ACL recursive continue on failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        when:\n+        def result = topDirOauthClient.updateAccessControlRecursiveWithResponse(\n+            new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries).setContinueOnFailure(true), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getChangedDirectoriesCount() == 3\n+        result.getValue().getCounters().getChangedFilesCount() == 3\n+        result.getValue().getCounters().getFailedChangesCount() == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive continue on failure batches resume\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        // Create more files as app\n+        def file7 = subdir1.createFile(generatePathName())\n+        def file8 = subdir1.createFile(generatePathName())\n+        def subdir4 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file9 = subdir4.createFile(generatePathName())\n+\n+        def options = new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries)\n+            .setBatchSize(2).setContinueOnFailure(true).setMaxBatches(1)\n+\n+        when:\n+        def intermediateResult = topDirOauthClient.updateAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        intermediateResult.getValue().getContinuationToken() != null\n+\n+        when:\n+        options.setMaxBatches(null).setContinuationToken(intermediateResult.getValue().getContinuationToken())\n+        def result = topDirOauthClient.updateAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        (result.getValue().getCounters().getChangedDirectoriesCount() + intermediateResult.getValue().getCounters().getChangedDirectoriesCount()) == 4\n+        (result.getValue().getCounters().getChangedFilesCount() + intermediateResult.getValue().getCounters().getChangedFilesCount()) == 6\n+        (result.getValue().getCounters().getFailedChangesCount() + intermediateResult.getValue().getCounters().getFailedChangesCount()) == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Update ACL recursive error\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+\n+        String topDirName = generatePathName()\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+\n+        when:\n+        topDirOauthClient.updateAccessControlRecursiveWithResponse(\n+            new PathUpdateAccessControlRecursiveOptions(pathAccessControlEntries), null, null)\n+\n+        then:\n+        thrown(DataLakeStorageException)\n+    }\n+\n+    def \"Remove ACL recursive\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        when:\n+        def result = dc.removeAccessControlRecursive(removeAccessControlEntries)\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+    }\n+\n+    def \"Remove ACL recursive batches\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2)\n+\n+        when:\n+        def result = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3 // Including the top level\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive batches resume\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(1)\n+\n+        when:\n+        def result = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        and:\n+        options.setMaxBatches(null).setContinuationToken(result.getContinuationToken())\n+        def result2 = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        (result.getCounters().getChangedDirectoriesCount() + result2.getCounters().getChangedDirectoriesCount()) == 3 // Including the top level\n+        (result.getCounters().getChangedFilesCount() + result2.getCounters().getChangedFilesCount()) == 4\n+        (result.getCounters().getFailedChangesCount() + result2.getCounters().getFailedChangesCount()) == 0\n+        result2.getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive batches progress\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setProgressHandler(progress)\n+\n+        when:\n+        def result = dc.removeAccessControlRecursiveWithResponse(options, null, null).getValue()\n+\n+        then:\n+        result.getCounters().getChangedDirectoriesCount() == 3\n+        result.getCounters().getChangedFilesCount() == 4\n+        result.getCounters().getFailedChangesCount() == 0\n+        result.getContinuationToken() == null\n+        progress.batchCounters.size() == 4\n+        (progress.batchCounters[0].getChangedFilesCount() + progress.batchCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[1].getChangedFilesCount() + progress.batchCounters[1].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[2].getChangedFilesCount() + progress.batchCounters[2].getChangedDirectoriesCount()) == 2\n+        (progress.batchCounters[3].getChangedFilesCount() + progress.batchCounters[3].getChangedDirectoriesCount()) == 1\n+        progress.cumulativeCounters.size() == 4\n+        (progress.cumulativeCounters[0].getChangedFilesCount() + progress.cumulativeCounters[0].getChangedDirectoriesCount()) == 2\n+        (progress.cumulativeCounters[1].getChangedFilesCount() + progress.cumulativeCounters[1].getChangedDirectoriesCount()) == 4\n+        (progress.cumulativeCounters[2].getChangedFilesCount() + progress.cumulativeCounters[2].getChangedDirectoriesCount()) == 6\n+        (progress.cumulativeCounters[3].getChangedFilesCount() + progress.cumulativeCounters[3].getChangedDirectoriesCount()) == 7\n+    }\n+\n+    def \"Remove ACL recursive batches follow token\"() {\n+        setup:\n+        setupStandardRecursiveAclTest()\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setMaxBatches(2)\n+\n+        when:\n+        String continuation = \"null\"\n+        def failedChanges = 0\n+        def directoriesChanged = 0\n+        def filesChanged = 0\n+        def iterations = 0\n+        while(continuation != null && continuation != \"\" && iterations < 10) {\n+            if (iterations == 0) {\n+                continuation = null // do while not supported in Groovy\n+            }\n+            options.setContinuationToken(continuation)\n+            def result = dc.removeAccessControlRecursiveWithResponse(options, null, null)\n+            failedChanges += result.getValue().getCounters().getFailedChangesCount()\n+            directoriesChanged += result.getValue().getCounters().getChangedDirectoriesCount()\n+            filesChanged += result.getValue().getCounters().getChangedFilesCount()\n+            iterations++\n+            continuation = result.getValue().getContinuationToken()\n+        }\n+\n+        then:\n+        failedChanges == 0\n+        directoriesChanged == 3\n+        filesChanged == 4\n+        iterations == 2\n+    }\n+\n+    def \"Remove ACL recursive progress with failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create file4 as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+\n+        def progress = new InMemoryAccessControlRecursiveChangeProgress()\n+\n+        when:\n+        def result = topDirOauthClient.removeAccessControlRecursiveWithResponse(\n+            new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries).setProgressHandler(progress), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getFailedChangesCount() == 1\n+        progress.failures.size() == 1\n+        progress.batchCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.cumulativeCounters.findIndexOf {counter -> counter.getFailedChangesCount() > 0} >= 0\n+        progress.failures[0].getName().contains(file4.getObjectName())\n+        !progress.failures[0].isDirectory()\n+        progress.failures[0].getErrorMessage()\n+    }\n+\n+    def \"Remove ACL recursive continue on failure\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        when:\n+        def result = topDirOauthClient.removeAccessControlRecursiveWithResponse(\n+            new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries).setContinueOnFailure(true), null, null)\n+\n+        then:\n+        result.getValue().getCounters().getChangedDirectoriesCount() == 3\n+        result.getValue().getCounters().getChangedFilesCount() == 3\n+        result.getValue().getCounters().getFailedChangesCount() == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive continue on failure batches resume\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+        String topDirName = generatePathName()\n+\n+        // Create tree using AAD creds\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+        topDirOauthClient.create()\n+        def subdir1 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+\n+        // Create resources as super user (using shared key)\n+        def file4 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file5 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def file6 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createFile(generatePathName())\n+        def subdir3 = fsc.getDirectoryClient(topDirName).getSubdirectoryClient(subdir2.getObjectName())\n+            .createSubdirectory(generatePathName())\n+\n+        // Create more files as app\n+        def file7 = subdir1.createFile(generatePathName())\n+        def file8 = subdir1.createFile(generatePathName())\n+        def subdir4 = topDirOauthClient.createSubdirectory(generatePathName())\n+        def file9 = subdir4.createFile(generatePathName())\n+\n+        def options = new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries)\n+            .setBatchSize(2).setContinueOnFailure(true).setMaxBatches(1)\n+\n+        when:\n+        def intermediateResult = topDirOauthClient.removeAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        intermediateResult.getValue().getContinuationToken() != null\n+\n+        when:\n+        options.setMaxBatches(null).setContinuationToken(intermediateResult.getValue().getContinuationToken())\n+        def result = topDirOauthClient.removeAccessControlRecursiveWithResponse(options, null, null)\n+\n+        then:\n+        (result.getValue().getCounters().getChangedDirectoriesCount() + intermediateResult.getValue().getCounters().getChangedDirectoriesCount()) == 4\n+        (result.getValue().getCounters().getChangedFilesCount() + intermediateResult.getValue().getCounters().getChangedFilesCount()) == 6\n+        (result.getValue().getCounters().getFailedChangesCount() + intermediateResult.getValue().getCounters().getFailedChangesCount()) == 4\n+        result.getValue().getContinuationToken() == null\n+    }\n+\n+    def \"Remove ACL recursive error\"() {\n+        setup:\n+        fsc.getRootDirectoryClient().setAccessControlList(executeOnlyAccessControlEntries, null, null)\n+\n+        String topDirName = generatePathName()\n+        def topDirOauthClient = getOAuthServiceClient().getFileSystemClient(fsc.getFileSystemName())\n+            .getDirectoryClient(topDirName)\n+\n+        when:\n+        topDirOauthClient.removeAccessControlRecursiveWithResponse(\n+            new PathRemoveAccessControlRecursiveOptions(removeAccessControlEntries), null, null)\n+\n+        then:\n+        thrown(DataLakeStorageException)\n+    }\n+\n+    def setupStandardRecursiveAclTest() {\n+        def subdir1 = dc.createSubdirectory(generatePathName())\n+        def file1 = subdir1.createFile(generatePathName())\n+        def file2 = subdir1.createFile(generatePathName())\n+        def subdir2 = dc.createSubdirectory(generatePathName())\n+        def file3 = subdir2.createFile(generatePathName())\n+        def file4 = dc.createFile(generatePathName())\n+    }\n+\n+    static class InMemoryAccessControlRecursiveChangeProgress implements Consumer<Response<AccessControlChanges>> {\n+\n+        List<AccessControlChangeFailure> failures = new ArrayList<>()\n+        List<AccessControlChangeCounters> batchCounters = new ArrayList<>()\n+        List<AccessControlChangeCounters> cumulativeCounters = new ArrayList<>()\n+\n+        @Override\n+        void accept(Response<AccessControlChanges> response) {\n+            failures.addAll(response.getValue().getBatchFailures())\n+            batchCounters.addAll(response.getValue().getBatchCounters())\n+            cumulativeCounters.addAll(response.getValue().getAggregateCounters())\n+        }\n+    }\n+\n+    // set recursive acl error, with response", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "originalPosition": 807}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjA1OTUy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#pullrequestreview-493605952", "createdAt": "2020-09-22T15:47:04Z", "commit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzowNFrOHWA3VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzowNFrOHWA3VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NDg4NQ==", "bodyText": "Add REST Docs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492844885", "createdAt": "2020-09-22T15:47:04Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -849,14 +847,12 @@ private void throwOnAnonymousAccess() {\n      * @return A {@link Mono} containing a {@link BlobContainerAsyncClient} used\n      * to interact with the restored container.\n      */\n-    /*\n     public Mono<BlobContainerAsyncClient> undeleteBlobContainer(\n         String deletedContainerName, String deletedContainerVersion) {\n-        return this.undeleteBlobContainerWithResponse(\n-            new UndeleteBlobContainerOptions(deletedContainerName, deletedContainerVersion)\n+        return this.undeleteBlobContainerWithResponse(new UndeleteBlobContainerOptions(deletedContainerName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjA2Mjkz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#pullrequestreview-493606293", "createdAt": "2020-09-22T15:47:26Z", "commit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzoyNlrOHWA4YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NzoyNlrOHWA4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NTE1Mg==", "bodyText": "Add Rest docs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#discussion_r492845152", "createdAt": "2020-09-22T15:47:26Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileClient.java", "diffHunk": "@@ -716,4 +717,41 @@ public FileQueryResponse queryWithResponse(FileQueryOptions queryOptions, Durati\n             return Transforms.toFileQueryResponse(response);\n         }, logger);\n     }\n+\n+    // TODO (kasobol-msft) add REST DOCS\n+    /**\n+     * Schedules the file for deletion.\n+     * For more information, see the\n+     * <a href=\"TBD\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileClient.scheduleDeletion#FileScheduleDeletionOptions}\n+     *\n+     * @param options Schedule deletion parameters.\n+     */\n+    public void scheduleDeletion(FileScheduleDeletionOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d93e28ba4bfca9f168f9812fe982d5a13e45b2"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95ab50aa944fefefa807cf3504d1d9e033ab977d", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/95ab50aa944fefefa807cf3504d1d9e033ab977d", "committedDate": "2020-09-24T17:36:02Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c3b2544df7798bd9fbd2f079a386af33681e400", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2c3b2544df7798bd9fbd2f079a386af33681e400", "committedDate": "2020-09-25T18:47:19Z", "message": "Fixed public API for file get range diff (#15562)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43b73472b269e7a138cba4af201cce44109d7792", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/43b73472b269e7a138cba4af201cce44109d7792", "committedDate": "2020-09-28T18:35:21Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22b315b8f89789942bbc281de57207ec00727d13", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/22b315b8f89789942bbc281de57207ec00727d13", "committedDate": "2020-09-30T16:49:48Z", "message": "Modified recursive acl tests to be able to play in live mode (#15815)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7abc8faa0ffab9ad89586dcfa9f654d534000ab5", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7abc8faa0ffab9ad89586dcfa9f654d534000ab5", "committedDate": "2020-09-30T18:34:08Z", "message": "Added support for live tests in the STG 74 branch (#15724)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d576deee7642c6ce0fbde5eb36de58433ffe793", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7d576deee7642c6ce0fbde5eb36de58433ffe793", "committedDate": "2020-09-30T18:35:20Z", "message": "Merge branch 'master' into feature/storage/stg74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44743b1fd228b8163a5d2c747b962e5d0e7585c1", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/44743b1fd228b8163a5d2c747b962e5d0e7585c1", "committedDate": "2020-10-01T04:59:10Z", "message": "Added code to return batch failures in results for recursive ACL (#15842)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e266b8c429867d882123cbeb9e41b8fea43255e2", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e266b8c429867d882123cbeb9e41b8fea43255e2", "committedDate": "2020-10-01T04:59:48Z", "message": "Wrapped continuation token with Exception when recursive acl call is \u2026 (#15839)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTg2NTgy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#pullrequestreview-500586582", "createdAt": "2020-10-01T17:53:19Z", "commit": {"oid": "e266b8c429867d882123cbeb9e41b8fea43255e2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjQ2ODU4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15428#pullrequestreview-500646858", "createdAt": "2020-10-01T19:18:12Z", "commit": {"oid": "e266b8c429867d882123cbeb9e41b8fea43255e2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3289, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}