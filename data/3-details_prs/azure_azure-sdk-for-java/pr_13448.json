{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzY2NDM3", "number": 13448, "title": "Adding write and query workload for ctl run", "bodyText": "This PR will create separate workload in benchmark project for ctl testing which includes read/write/query.\nIt will measure throughput, success/unsuccessful count, latency across operations\nPercentage of each operation is configurable.\n-readWriteQueryPct = \"70,25,5\"  (default is 90% 9% 1%)\nThis workload will be distributed across multiple collections, also configurable.\n-numberOfCollectionForCtl = 2  (default is 4)\nBelow are the screen shots from monitoring tools, how this workload will look like.", "createdAt": "2020-07-23T14:49:32Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448", "merged": true, "mergeCommit": {"oid": "5e38a4b3d63e10713cc62f3438b63a5982002ba5"}, "closed": true, "closedAt": "2020-07-24T18:00:15Z", "author": {"login": "simplynaveen20"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3iCLUAH2gAyNDU1NzY2NDM3OjUzMjM5MjBhNzY3M2IxMDRmMzQ4MTQ1ZWJhODdmOGYwMzUzZTQ2NDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc4H691gFqTQ1NTA4Mjc5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5323920a7673b104f348145eba87f8f0353e4641", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5323920a7673b104f348145eba87f8f0353e4641", "committedDate": "2020-07-22T21:51:04Z", "message": "adding ctl workload"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf5d3b041f884957c8efe4a6ddc8f67a14ac3076", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf5d3b041f884957c8efe4a6ddc8f67a14ac3076", "committedDate": "2020-07-23T14:58:29Z", "message": "formatting and refoctoring changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/313aa63d6ccc3a256314ff5e32c77d50963e3cff", "committedDate": "2020-07-23T15:00:34Z", "message": "build error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDI2MTI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454426127", "createdAt": "2020-07-23T19:18:24Z", "commit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToxODoyNFrOG2YOWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToyMjoyOFrOG2YXLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MzE3Nw==", "bodyText": "shouldn't this be CTLWorkload?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459673177", "createdAt": "2020-07-23T19:18:24Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -155,7 +162,8 @@ public Duration convert(String value) {\n         QueryTopOrderby,\n         Mixed,\n         ReadMyWrites,\n-        ReadThroughputWithMultipleClients;\n+        ReadThroughputWithMultipleClients,\n+        CtlWorkload;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NDI0Nw==", "bodyText": "does this need to be public? can we change it to private or package level?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459674247", "createdAt": "2020-07-23T19:20:20Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -47,7 +46,7 @@\n \n abstract class AsyncBenchmark<T> {\n     private final MetricRegistry metricsRegistry = new MetricRegistry();\n-    private final ScheduledReporter reporter;\n+    public ScheduledReporter reporter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTIwMw==", "bodyText": "this class is getting instantiated in a for loop in your benchmark, meaning the logger initialization will be called per for loop iteration.\nlogger should be static to avoid initialization cost per loop iteration.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459675203", "createdAt": "2020-07-23T19:22:01Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n+    final Logger logger;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Semaphore concurrencyControlSemaphore;\n+    private  AtomicLong count;\n+    Timer.Context context;\n+\n+    public BenchmarkRequestSubscriber(Meter successMeter, Meter failureMeter, Semaphore concurrencyControlSemaphore,  AtomicLong count) {\n+        this.successMeter = successMeter;\n+        this.failureMeter = failureMeter;\n+        this.concurrencyControlSemaphore = concurrencyControlSemaphore;\n+        this.count = count;\n+        logger = LoggerFactory.getLogger(this.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTQzOQ==", "bodyText": "nit: additional space.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459675439", "createdAt": "2020-07-23T19:22:28Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n+    final Logger logger;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Semaphore concurrencyControlSemaphore;\n+    private  AtomicLong count;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDQxMzM2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454441336", "createdAt": "2020-07-23T19:41:44Z", "commit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo0MTo0NFrOG2Y92w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo0MTo0NFrOG2Y92w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NTMzOQ==", "bodyText": "This is used only in CTL so BenchmarkRequestSubscriber -> CTLBenchmarkRequestSubscriber\nor perhaps create a sub package for CTL and put CTL related code in that package?\ncom.azure.cosmos.benchmark.ctl ? thought Naveen?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459685339", "createdAt": "2020-07-23T19:41:44Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/19bb729f2076c370d9c2bce92387532e6c2c16dc", "committedDate": "2020-07-24T15:20:04Z", "message": "refactoring code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTkyMDM3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454992037", "createdAt": "2020-07-24T15:42:26Z", "commit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0MjoyNlrOG20VrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0MjoyNlrOG20VrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMzgwNA==", "bodyText": "public?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460133804", "createdAt": "2020-07-24T15:42:26Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n+    final static Logger logger = LoggerFactory.getLogger(BenchmarkRequestSubscriber.class);\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Semaphore concurrencyControlSemaphore;\n+    private AtomicLong count;\n+    public Timer.Context context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTk0MTQx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454994141", "createdAt": "2020-07-24T15:45:17Z", "commit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0NToxN1rOG20cYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0NToxN1rOG20cYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNTUyMQ==", "bodyText": "as a code style, we should try to either\n\nhave all args on the same line\nor if there are many, have one arg per line.\n\nPlease try to follow that here and in other new code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460135521", "createdAt": "2020-07-24T15:45:17Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark.ctl;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.DirectConnectionConfig;\n+import com.azure.cosmos.GatewayConnectionConfig;\n+import com.azure.cosmos.benchmark.BenchmarkHelper;\n+import com.azure.cosmos.benchmark.BenchmarkRequestSubscriber;\n+import com.azure.cosmos.benchmark.Configuration;\n+import com.azure.cosmos.benchmark.PojoizedJson;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsyncCtlWorkload {\n+    private final String PERCENT_PARSING_ERROR = \"Unable to parse user provided readWriteQueryPct, using default {} {} {}\";\n+    private final String prefixUuidForCreate;\n+    private final String dataFieldValue;\n+    private final String partitionKey;\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final Logger logger;\n+    private final CosmosAsyncClient cosmosClient;\n+    private final Configuration configuration;\n+    private final Map<String, List<PojoizedJson>> docsToRead = new HashMap<>();\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Random random;\n+\n+    private Timer readLatency;\n+    private Timer writeLatency;\n+    private Timer queryLatency;\n+    private ScheduledReporter reporter;\n+\n+    private Meter readSuccessMeter;\n+    private Meter readFailureMeter;\n+    private Meter writeSuccessMeter;\n+    private Meter writeFailureMeter;\n+    private Meter querySuccessMeter;\n+    private Meter queryFailureMeter;\n+\n+    private CosmosAsyncDatabase cosmosAsyncDatabase;\n+    private List<CosmosAsyncContainer> containers = new ArrayList<>();\n+    private List<String> containerToClearAfterTest = new ArrayList<>();\n+    private boolean databaseCreated;\n+    private int readPct = 90;\n+    private int writePct = 9;\n+    private int queryPct = 1;\n+\n+    public AsyncCtlWorkload(Configuration cfg) {\n+        CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder()\n+            .endpoint(cfg.getServiceEndpoint())\n+            .key(cfg.getMasterKey())\n+            .consistencyLevel(cfg.getConsistencyLevel())\n+            .contentResponseOnWriteEnabled(Boolean.parseBoolean(cfg.isContentResponseOnWriteEnabled()));\n+        if (cfg.getConnectionMode().equals(ConnectionMode.DIRECT)) {\n+            cosmosClientBuilder = cosmosClientBuilder.directMode(DirectConnectionConfig.getDefaultConfig());\n+        } else {\n+            GatewayConnectionConfig gatewayConnectionConfig = new GatewayConnectionConfig();\n+            gatewayConnectionConfig.setMaxConnectionPoolSize(cfg.getMaxConnectionPoolSize());\n+            cosmosClientBuilder = cosmosClientBuilder.gatewayMode(gatewayConnectionConfig);\n+        }\n+        cosmosClient = cosmosClientBuilder.buildAsyncClient();\n+        configuration = cfg;\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        createDatabaseAndContainers(configuration);\n+\n+        partitionKey = containers.get(0).read().block().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+\n+        logger.info(\"PRE-populating {} documents ....\", cfg.getNumberOfPreCreatedDocuments());\n+        dataFieldValue = RandomStringUtils.randomAlphabetic(configuration.getDocumentDataFieldSize());\n+        createPrePopulatedDocs(configuration.getNumberOfPreCreatedDocuments());\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        initializeReporter(cfg);\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+        prefixUuidForCreate = UUID.randomUUID().toString();\n+        random = new Random();\n+        parsedReadWriteQueryPct(configuration.getReadWriteQueryPct());\n+    }\n+\n+    public void shutdown() {\n+        if (this.databaseCreated) {\n+            cosmosAsyncDatabase.delete().block();\n+            logger.info(\"Deleted temporary database {} created for this test\", this.configuration.getDatabaseId());\n+        } else if (containerToClearAfterTest.size() > 0) {\n+            for (String id : containerToClearAfterTest) {\n+                cosmosAsyncDatabase.getContainer(id).delete().block();\n+                logger.info(\"Deleted temporary collection {} created for this test\", id);\n+            }\n+        }\n+        cosmosClient.close();\n+    }\n+\n+    private void performWorkload(BaseSubscriber<Object> documentSubscriber, OperationType type, long i) throws Exception {\n+        Flux<? extends Object> obs;\n+        CosmosAsyncContainer container = containers.get((int) i % containers.size());\n+        if (type.equals(OperationType.Create)) {\n+            PojoizedJson data = BenchmarkHelper.generateDocument(prefixUuidForCreate + i, dataFieldValue, partitionKey,\n+                configuration.getDocumentDataFieldCount());\n+            obs = container.createItem(data).flux();\n+        } else if (type.equals(OperationType.Query)) {\n+            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+            String sqlQuery = \"Select top 100 * from c order by c._ts\";\n+            obs = container.queryItems(sqlQuery, options, PojoizedJson.class).byPage(10);\n+        } else {\n+            int index = random.nextInt(1000);\n+            RequestOptions options = new RequestOptions();\n+            String partitionKeyValue = docsToRead.get(container.getId()).get(index).getId();\n+            options.setPartitionKey(new PartitionKey(partitionKeyValue));\n+            obs = container.readItem(docsToRead.get(container.getId()).get(index).getId(),\n+                new PartitionKey(partitionKeyValue),\n+                PojoizedJson.class)\n+                .flux();\n+        }\n+\n+        concurrencyControlSemaphore.acquire();\n+\n+        obs.subscribeOn(Schedulers.parallel()).subscribe(documentSubscriber);\n+    }\n+\n+    public void run() throws Exception {\n+        readSuccessMeter = metricsRegistry.meter(\"#Read Successful Operations\");\n+        readFailureMeter = metricsRegistry.meter(\"#Read Unsuccessful Operations\");\n+        writeSuccessMeter = metricsRegistry.meter(\"#Write Successful Operations\");\n+        writeFailureMeter = metricsRegistry.meter(\"#Write Unsuccessful Operations\");\n+        querySuccessMeter = metricsRegistry.meter(\"#Query Successful Operations\");\n+        queryFailureMeter = metricsRegistry.meter(\"#Query Unsuccessful Operations\");\n+        readLatency = metricsRegistry.timer(\"Read Latency\");\n+        writeLatency = metricsRegistry.timer(\"Write Latency\");\n+        queryLatency = metricsRegistry.timer(\"Query Latency\");\n+\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        long startTime = System.currentTimeMillis();\n+\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        int writeRange = readPct + writePct;\n+        for (i = 0; BenchmarkHelper.shouldContinue(startTime, i, configuration); i++) {\n+            int index = (int) i % 100;\n+            if (index < readPct) {\n+                BenchmarkRequestSubscriber<Object> readSubscriber = new BenchmarkRequestSubscriber<>(readSuccessMeter,\n+                    readFailureMeter, concurrencyControlSemaphore, count);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTk1MzE2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454995316", "createdAt": "2020-07-24T15:46:59Z", "commit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0Njo1OVrOG20gFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0Njo1OVrOG20gFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNjQ2OA==", "bodyText": "if the input config is not valid, shouldn't we log error and terminate?\notherwise invalid config may go unnoticed.\nI don't see you throwing any exception on invalid config.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460136468", "createdAt": "2020-07-24T15:46:59Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark.ctl;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.DirectConnectionConfig;\n+import com.azure.cosmos.GatewayConnectionConfig;\n+import com.azure.cosmos.benchmark.BenchmarkHelper;\n+import com.azure.cosmos.benchmark.BenchmarkRequestSubscriber;\n+import com.azure.cosmos.benchmark.Configuration;\n+import com.azure.cosmos.benchmark.PojoizedJson;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsyncCtlWorkload {\n+    private final String PERCENT_PARSING_ERROR = \"Unable to parse user provided readWriteQueryPct, using default {} {} {}\";\n+    private final String prefixUuidForCreate;\n+    private final String dataFieldValue;\n+    private final String partitionKey;\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final Logger logger;\n+    private final CosmosAsyncClient cosmosClient;\n+    private final Configuration configuration;\n+    private final Map<String, List<PojoizedJson>> docsToRead = new HashMap<>();\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Random random;\n+\n+    private Timer readLatency;\n+    private Timer writeLatency;\n+    private Timer queryLatency;\n+    private ScheduledReporter reporter;\n+\n+    private Meter readSuccessMeter;\n+    private Meter readFailureMeter;\n+    private Meter writeSuccessMeter;\n+    private Meter writeFailureMeter;\n+    private Meter querySuccessMeter;\n+    private Meter queryFailureMeter;\n+\n+    private CosmosAsyncDatabase cosmosAsyncDatabase;\n+    private List<CosmosAsyncContainer> containers = new ArrayList<>();\n+    private List<String> containerToClearAfterTest = new ArrayList<>();\n+    private boolean databaseCreated;\n+    private int readPct = 90;\n+    private int writePct = 9;\n+    private int queryPct = 1;\n+\n+    public AsyncCtlWorkload(Configuration cfg) {\n+        CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder()\n+            .endpoint(cfg.getServiceEndpoint())\n+            .key(cfg.getMasterKey())\n+            .consistencyLevel(cfg.getConsistencyLevel())\n+            .contentResponseOnWriteEnabled(Boolean.parseBoolean(cfg.isContentResponseOnWriteEnabled()));\n+        if (cfg.getConnectionMode().equals(ConnectionMode.DIRECT)) {\n+            cosmosClientBuilder = cosmosClientBuilder.directMode(DirectConnectionConfig.getDefaultConfig());\n+        } else {\n+            GatewayConnectionConfig gatewayConnectionConfig = new GatewayConnectionConfig();\n+            gatewayConnectionConfig.setMaxConnectionPoolSize(cfg.getMaxConnectionPoolSize());\n+            cosmosClientBuilder = cosmosClientBuilder.gatewayMode(gatewayConnectionConfig);\n+        }\n+        cosmosClient = cosmosClientBuilder.buildAsyncClient();\n+        configuration = cfg;\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        createDatabaseAndContainers(configuration);\n+\n+        partitionKey = containers.get(0).read().block().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+\n+        logger.info(\"PRE-populating {} documents ....\", cfg.getNumberOfPreCreatedDocuments());\n+        dataFieldValue = RandomStringUtils.randomAlphabetic(configuration.getDocumentDataFieldSize());\n+        createPrePopulatedDocs(configuration.getNumberOfPreCreatedDocuments());\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        initializeReporter(cfg);\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+        prefixUuidForCreate = UUID.randomUUID().toString();\n+        random = new Random();\n+        parsedReadWriteQueryPct(configuration.getReadWriteQueryPct());\n+    }\n+\n+    public void shutdown() {\n+        if (this.databaseCreated) {\n+            cosmosAsyncDatabase.delete().block();\n+            logger.info(\"Deleted temporary database {} created for this test\", this.configuration.getDatabaseId());\n+        } else if (containerToClearAfterTest.size() > 0) {\n+            for (String id : containerToClearAfterTest) {\n+                cosmosAsyncDatabase.getContainer(id).delete().block();\n+                logger.info(\"Deleted temporary collection {} created for this test\", id);\n+            }\n+        }\n+        cosmosClient.close();\n+    }\n+\n+    private void performWorkload(BaseSubscriber<Object> documentSubscriber, OperationType type, long i) throws Exception {\n+        Flux<? extends Object> obs;\n+        CosmosAsyncContainer container = containers.get((int) i % containers.size());\n+        if (type.equals(OperationType.Create)) {\n+            PojoizedJson data = BenchmarkHelper.generateDocument(prefixUuidForCreate + i, dataFieldValue, partitionKey,\n+                configuration.getDocumentDataFieldCount());\n+            obs = container.createItem(data).flux();\n+        } else if (type.equals(OperationType.Query)) {\n+            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+            String sqlQuery = \"Select top 100 * from c order by c._ts\";\n+            obs = container.queryItems(sqlQuery, options, PojoizedJson.class).byPage(10);\n+        } else {\n+            int index = random.nextInt(1000);\n+            RequestOptions options = new RequestOptions();\n+            String partitionKeyValue = docsToRead.get(container.getId()).get(index).getId();\n+            options.setPartitionKey(new PartitionKey(partitionKeyValue));\n+            obs = container.readItem(docsToRead.get(container.getId()).get(index).getId(),\n+                new PartitionKey(partitionKeyValue),\n+                PojoizedJson.class)\n+                .flux();\n+        }\n+\n+        concurrencyControlSemaphore.acquire();\n+\n+        obs.subscribeOn(Schedulers.parallel()).subscribe(documentSubscriber);\n+    }\n+\n+    public void run() throws Exception {\n+        readSuccessMeter = metricsRegistry.meter(\"#Read Successful Operations\");\n+        readFailureMeter = metricsRegistry.meter(\"#Read Unsuccessful Operations\");\n+        writeSuccessMeter = metricsRegistry.meter(\"#Write Successful Operations\");\n+        writeFailureMeter = metricsRegistry.meter(\"#Write Unsuccessful Operations\");\n+        querySuccessMeter = metricsRegistry.meter(\"#Query Successful Operations\");\n+        queryFailureMeter = metricsRegistry.meter(\"#Query Unsuccessful Operations\");\n+        readLatency = metricsRegistry.timer(\"Read Latency\");\n+        writeLatency = metricsRegistry.timer(\"Write Latency\");\n+        queryLatency = metricsRegistry.timer(\"Query Latency\");\n+\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        long startTime = System.currentTimeMillis();\n+\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        int writeRange = readPct + writePct;\n+        for (i = 0; BenchmarkHelper.shouldContinue(startTime, i, configuration); i++) {\n+            int index = (int) i % 100;\n+            if (index < readPct) {\n+                BenchmarkRequestSubscriber<Object> readSubscriber = new BenchmarkRequestSubscriber<>(readSuccessMeter,\n+                    readFailureMeter, concurrencyControlSemaphore, count);\n+                readSubscriber.context = readLatency.time();\n+                performWorkload(readSubscriber, OperationType.Read, i);\n+            } else if (index < writeRange) {\n+                BenchmarkRequestSubscriber<Object> writeSubscriber = new BenchmarkRequestSubscriber<>(writeSuccessMeter,\n+                    writeFailureMeter, concurrencyControlSemaphore, count);\n+                writeSubscriber.context = writeLatency.time();\n+                performWorkload(writeSubscriber, OperationType.Create, i);\n+\n+            } else {\n+                BenchmarkRequestSubscriber<Object> querySubscriber = new BenchmarkRequestSubscriber<>(querySuccessMeter,\n+                    queryFailureMeter, concurrencyControlSemaphore, count);\n+                querySubscriber.context = queryLatency.time();\n+                performWorkload(querySubscriber, OperationType.Query, i);\n+            }\n+        }\n+\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    private void parsedReadWriteQueryPct(String readWriteQueryPct) {\n+        String[] readWriteQueryPctList = readWriteQueryPct.split(\",\");\n+        if (readWriteQueryPctList.length == 3) {\n+            try {\n+                if (Integer.valueOf(readWriteQueryPctList[0]) + Integer.valueOf(readWriteQueryPctList[1]) + Integer.valueOf(readWriteQueryPctList[2]) == 100) {\n+                    readPct = Integer.valueOf(readWriteQueryPctList[0]);\n+                    writePct = Integer.valueOf(readWriteQueryPctList[1]);\n+                    queryPct = Integer.valueOf(readWriteQueryPctList[2]);\n+                } else {\n+                    logger.warn(PERCENT_PARSING_ERROR, readPct,\n+                        writePct, queryPct);\n+                }\n+            } catch (NumberFormatException ex) {\n+                logger.warn(PERCENT_PARSING_ERROR, readPct,\n+                    writePct, queryPct);\n+            }\n+        } else {\n+            logger.warn(PERCENT_PARSING_ERROR, readPct, writePct,\n+                queryPct);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "originalPosition": 253}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTk3NjU3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454997657", "createdAt": "2020-07-24T15:50:17Z", "commit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo1MDoxN1rOG20nrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo1MDoxN1rOG20nrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzODQxMw==", "bodyText": "so on query, we just run an orderby by query and we expect it to not fail, but we don't validate the result.\nam I right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460138413", "createdAt": "2020-07-24T15:50:17Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark.ctl;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.DirectConnectionConfig;\n+import com.azure.cosmos.GatewayConnectionConfig;\n+import com.azure.cosmos.benchmark.BenchmarkHelper;\n+import com.azure.cosmos.benchmark.BenchmarkRequestSubscriber;\n+import com.azure.cosmos.benchmark.Configuration;\n+import com.azure.cosmos.benchmark.PojoizedJson;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsyncCtlWorkload {\n+    private final String PERCENT_PARSING_ERROR = \"Unable to parse user provided readWriteQueryPct, using default {} {} {}\";\n+    private final String prefixUuidForCreate;\n+    private final String dataFieldValue;\n+    private final String partitionKey;\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final Logger logger;\n+    private final CosmosAsyncClient cosmosClient;\n+    private final Configuration configuration;\n+    private final Map<String, List<PojoizedJson>> docsToRead = new HashMap<>();\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Random random;\n+\n+    private Timer readLatency;\n+    private Timer writeLatency;\n+    private Timer queryLatency;\n+    private ScheduledReporter reporter;\n+\n+    private Meter readSuccessMeter;\n+    private Meter readFailureMeter;\n+    private Meter writeSuccessMeter;\n+    private Meter writeFailureMeter;\n+    private Meter querySuccessMeter;\n+    private Meter queryFailureMeter;\n+\n+    private CosmosAsyncDatabase cosmosAsyncDatabase;\n+    private List<CosmosAsyncContainer> containers = new ArrayList<>();\n+    private List<String> containerToClearAfterTest = new ArrayList<>();\n+    private boolean databaseCreated;\n+    private int readPct = 90;\n+    private int writePct = 9;\n+    private int queryPct = 1;\n+\n+    public AsyncCtlWorkload(Configuration cfg) {\n+        CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder()\n+            .endpoint(cfg.getServiceEndpoint())\n+            .key(cfg.getMasterKey())\n+            .consistencyLevel(cfg.getConsistencyLevel())\n+            .contentResponseOnWriteEnabled(Boolean.parseBoolean(cfg.isContentResponseOnWriteEnabled()));\n+        if (cfg.getConnectionMode().equals(ConnectionMode.DIRECT)) {\n+            cosmosClientBuilder = cosmosClientBuilder.directMode(DirectConnectionConfig.getDefaultConfig());\n+        } else {\n+            GatewayConnectionConfig gatewayConnectionConfig = new GatewayConnectionConfig();\n+            gatewayConnectionConfig.setMaxConnectionPoolSize(cfg.getMaxConnectionPoolSize());\n+            cosmosClientBuilder = cosmosClientBuilder.gatewayMode(gatewayConnectionConfig);\n+        }\n+        cosmosClient = cosmosClientBuilder.buildAsyncClient();\n+        configuration = cfg;\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        createDatabaseAndContainers(configuration);\n+\n+        partitionKey = containers.get(0).read().block().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+\n+        logger.info(\"PRE-populating {} documents ....\", cfg.getNumberOfPreCreatedDocuments());\n+        dataFieldValue = RandomStringUtils.randomAlphabetic(configuration.getDocumentDataFieldSize());\n+        createPrePopulatedDocs(configuration.getNumberOfPreCreatedDocuments());\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        initializeReporter(cfg);\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+        prefixUuidForCreate = UUID.randomUUID().toString();\n+        random = new Random();\n+        parsedReadWriteQueryPct(configuration.getReadWriteQueryPct());\n+    }\n+\n+    public void shutdown() {\n+        if (this.databaseCreated) {\n+            cosmosAsyncDatabase.delete().block();\n+            logger.info(\"Deleted temporary database {} created for this test\", this.configuration.getDatabaseId());\n+        } else if (containerToClearAfterTest.size() > 0) {\n+            for (String id : containerToClearAfterTest) {\n+                cosmosAsyncDatabase.getContainer(id).delete().block();\n+                logger.info(\"Deleted temporary collection {} created for this test\", id);\n+            }\n+        }\n+        cosmosClient.close();\n+    }\n+\n+    private void performWorkload(BaseSubscriber<Object> documentSubscriber, OperationType type, long i) throws Exception {\n+        Flux<? extends Object> obs;\n+        CosmosAsyncContainer container = containers.get((int) i % containers.size());\n+        if (type.equals(OperationType.Create)) {\n+            PojoizedJson data = BenchmarkHelper.generateDocument(prefixUuidForCreate + i, dataFieldValue, partitionKey,\n+                configuration.getDocumentDataFieldCount());\n+            obs = container.createItem(data).flux();\n+        } else if (type.equals(OperationType.Query)) {\n+            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+            String sqlQuery = \"Select top 100 * from c order by c._ts\";\n+            obs = container.queryItems(sqlQuery, options, PojoizedJson.class).byPage(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTk5MDE3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-454999017", "createdAt": "2020-07-24T15:52:10Z", "commit": {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6d406884e8a50e8e8946546db08d514252fd223", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b6d406884e8a50e8e8946546db08d514252fd223", "committedDate": "2020-07-24T16:46:36Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c684816ad17c4021992bb7d815c102b0b802605", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8c684816ad17c4021992bb7d815c102b0b802605", "committedDate": "2020-07-24T16:50:17Z", "message": "resolving comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MDgyNzkx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#pullrequestreview-455082791", "createdAt": "2020-07-24T17:59:35Z", "commit": {"oid": "8c684816ad17c4021992bb7d815c102b0b802605"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1090, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}