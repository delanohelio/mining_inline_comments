{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2OTQ0Mjk3", "number": 12350, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoxODoyOVrOELHjoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxMzo1NlrOELIpAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDkzNjAwOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoxODoyOVrOGsjN8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowNzo0OVrOGsj1dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2NzUzOQ==", "bodyText": "Why Mono? Normally you should create ShareFileAsyncClient, which is not async, and pass it to other methods. Async call of create(maxSize) appear not about the createShareFileAsyncClient method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449367539", "createdAt": "2020-07-03T04:18:29Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MDgzNw==", "bodyText": "Since all callers need the create function, so I add it to the common function. Unless we do create repeatedly in every caller, we'll always need a function to return a Mono<ShareFileAsyncClient> as common function. I could remove this due to it is little repeated code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449370837", "createdAt": "2020-07-03T04:34:53Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2NzUzOQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NzY1Mw==", "bodyText": "You need 2 things from this method, the ShareFileAsyncClient which is just an object, and a Mono<Void> as completion of the create. You should not mix the 2 to a Mono<ShareFileAsyncClient>, it just abuses the reactor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449377653", "createdAt": "2020-07-03T05:07:49Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2NzUzOQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk0NTI0OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoyNTozNFrOGsjTdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoyNTozNFrOGsjTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2ODk0OQ==", "bodyText": "Same as above, it should be a Mono<Void> to signal completion.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449368949", "createdAt": "2020-07-03T04:25:34Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk0OTEwOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/pom.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoyODoxM1rOGsjVow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDozNjoyMlrOGsjb-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2OTUwNw==", "bodyText": "Should we move the dependency to parent pom so the version control only happen there?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449369507", "createdAt": "2020-07-03T04:28:13Z", "author": {"login": "xseeseesee"}, "path": "sdk/appplatform/mgmt/pom.xml", "diffHunk": "@@ -0,0 +1,139 @@\n+<!--\n+ Copyright (c) Microsoft Corporation. All rights reserved.\n+ Licensed under the MIT License. See License.txt in the project root for\n+ license information.\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+      <groupId>com.azure.resourcemanager</groupId>\n+      <artifactId>azure-resourcemanager-parent</artifactId>\n+      <version>2.0.0-SNAPSHOT</version>\n+      <relativePath>../../management/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>azure-resourcemanager-appplatform</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Microsoft Azure SDK for App Platform Management</name>\n+    <description>This package contains Microsoft Azure App Platform Management SDK.</description>\n+    <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+    <licenses>\n+      <license>\n+        <name>The MIT License (MIT)</name>\n+        <url>http://opensource.org/licenses/MIT</url>\n+        <distribution>repo</distribution>\n+      </license>\n+    </licenses>\n+\n+    <scm>\n+      <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+      <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+      <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+      <legal><![CDATA[[INFO] Any downloads listed may be third party software.  Microsoft grants you no rights for third party software.]]></legal>\n+    </properties>\n+\n+    <developers>\n+      <developer>\n+        <id>microsoft</id>\n+        <name>Microsoft</name>\n+      </developer>\n+    </developers>\n+\n+    <dependencies>\n+      <dependency>\n+        <groupId>com.azure.resourcemanager</groupId>\n+        <artifactId>azure-resourcemanager-resources</artifactId>\n+        <version>2.0.0-SNAPSHOT</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-storage-file-share</artifactId>\n+        <version>12.5.0</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MDk3NA==", "bodyText": "No, we'll separate all dependency into package pom later. So I don't add it to parent pom anymore", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449370974", "createdAt": "2020-07-03T04:35:36Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/pom.xml", "diffHunk": "@@ -0,0 +1,139 @@\n+<!--\n+ Copyright (c) Microsoft Corporation. All rights reserved.\n+ Licensed under the MIT License. See License.txt in the project root for\n+ license information.\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+      <groupId>com.azure.resourcemanager</groupId>\n+      <artifactId>azure-resourcemanager-parent</artifactId>\n+      <version>2.0.0-SNAPSHOT</version>\n+      <relativePath>../../management/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>azure-resourcemanager-appplatform</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Microsoft Azure SDK for App Platform Management</name>\n+    <description>This package contains Microsoft Azure App Platform Management SDK.</description>\n+    <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+    <licenses>\n+      <license>\n+        <name>The MIT License (MIT)</name>\n+        <url>http://opensource.org/licenses/MIT</url>\n+        <distribution>repo</distribution>\n+      </license>\n+    </licenses>\n+\n+    <scm>\n+      <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+      <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+      <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+      <legal><![CDATA[[INFO] Any downloads listed may be third party software.  Microsoft grants you no rights for third party software.]]></legal>\n+    </properties>\n+\n+    <developers>\n+      <developer>\n+        <id>microsoft</id>\n+        <name>Microsoft</name>\n+      </developer>\n+    </developers>\n+\n+    <dependencies>\n+      <dependency>\n+        <groupId>com.azure.resourcemanager</groupId>\n+        <artifactId>azure-resourcemanager-resources</artifactId>\n+        <version>2.0.0-SNAPSHOT</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-storage-file-share</artifactId>\n+        <version>12.5.0</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2OTUwNw=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MTEyOQ==", "bodyText": "Although, it is not the final shape for the pom.xml", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449371129", "createdAt": "2020-07-03T04:36:22Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/pom.xml", "diffHunk": "@@ -0,0 +1,139 @@\n+<!--\n+ Copyright (c) Microsoft Corporation. All rights reserved.\n+ Licensed under the MIT License. See License.txt in the project root for\n+ license information.\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+      <groupId>com.azure.resourcemanager</groupId>\n+      <artifactId>azure-resourcemanager-parent</artifactId>\n+      <version>2.0.0-SNAPSHOT</version>\n+      <relativePath>../../management/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>azure-resourcemanager-appplatform</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Microsoft Azure SDK for App Platform Management</name>\n+    <description>This package contains Microsoft Azure App Platform Management SDK.</description>\n+    <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+    <licenses>\n+      <license>\n+        <name>The MIT License (MIT)</name>\n+        <url>http://opensource.org/licenses/MIT</url>\n+        <distribution>repo</distribution>\n+      </license>\n+    </licenses>\n+\n+    <scm>\n+      <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+      <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+      <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+      <legal><![CDATA[[INFO] Any downloads listed may be third party software.  Microsoft grants you no rights for third party software.]]></legal>\n+    </properties>\n+\n+    <developers>\n+      <developer>\n+        <id>microsoft</id>\n+        <name>Microsoft</name>\n+      </developer>\n+    </developers>\n+\n+    <dependencies>\n+      <dependency>\n+        <groupId>com.azure.resourcemanager</groupId>\n+        <artifactId>azure-resourcemanager-resources</artifactId>\n+        <version>2.0.0-SNAPSHOT</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-storage-file-share</artifactId>\n+        <version>12.5.0</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2OTUwNw=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk0OTk3OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoyODo1M1rOGsjWIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDoyODo1M1rOGsjWIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2OTYzMw==", "bodyText": "Same as above azure-storage-file-share", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449369633", "createdAt": "2020-07-03T04:28:53Z", "author": {"login": "xseeseesee"}, "path": "sdk/appplatform/mgmt/pom.xml", "diffHunk": "@@ -0,0 +1,139 @@\n+<!--\n+ Copyright (c) Microsoft Corporation. All rights reserved.\n+ Licensed under the MIT License. See License.txt in the project root for\n+ license information.\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+      <groupId>com.azure.resourcemanager</groupId>\n+      <artifactId>azure-resourcemanager-parent</artifactId>\n+      <version>2.0.0-SNAPSHOT</version>\n+      <relativePath>../../management/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>azure-resourcemanager-appplatform</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Microsoft Azure SDK for App Platform Management</name>\n+    <description>This package contains Microsoft Azure App Platform Management SDK.</description>\n+    <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+    <licenses>\n+      <license>\n+        <name>The MIT License (MIT)</name>\n+        <url>http://opensource.org/licenses/MIT</url>\n+        <distribution>repo</distribution>\n+      </license>\n+    </licenses>\n+\n+    <scm>\n+      <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+      <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+      <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+      <legal><![CDATA[[INFO] Any downloads listed may be third party software.  Microsoft grants you no rights for third party software.]]></legal>\n+    </properties>\n+\n+    <developers>\n+      <developer>\n+        <id>microsoft</id>\n+        <name>Microsoft</name>\n+      </developer>\n+    </developers>\n+\n+    <dependencies>\n+      <dependency>\n+        <groupId>com.azure.resourcemanager</groupId>\n+        <artifactId>azure-resourcemanager-resources</artifactId>\n+        <version>2.0.0-SNAPSHOT</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-storage-file-share</artifactId>\n+        <version>12.5.0</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.commons</groupId>\n+        <artifactId>commons-compress</artifactId>\n+        <version>1.20</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk2MTczOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDozNzoyMVrOGsjc6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDozNzoyMVrOGsjc6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MTM2OA==", "bodyText": "deployments would be a better name? Current you will have deploy().deleteByNameAsync which seems not clear.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449371368", "createdAt": "2020-07-03T04:37:21Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppImpl.java", "diffHunk": "@@ -0,0 +1,282 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.AppResourceInner;\n+import com.azure.resourcemanager.appplatform.models.AppResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.ManagedIdentityProperties;\n+import com.azure.resourcemanager.appplatform.models.PersistentDisk;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployments;\n+import com.azure.resourcemanager.appplatform.models.SpringService;\n+import com.azure.resourcemanager.appplatform.models.TemporaryDisk;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.time.OffsetDateTime;\n+\n+public class SpringAppImpl\n+    extends ExternalChildResourceImpl<SpringApp, AppResourceInner, SpringServiceImpl, SpringService>\n+    implements SpringApp, SpringApp.Definition, SpringApp.Update {\n+    private Creatable<SpringAppDeployment> springAppDeploymentToCreate = null;\n+\n+    SpringAppImpl(String name, SpringServiceImpl parent, AppResourceInner innerObject) {\n+        super(name, parent, innerObject);\n+    }\n+\n+    @Override\n+    public boolean isPublic() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().publicProperty();\n+    }\n+\n+    @Override\n+    public boolean isHttpsOnly() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().httpsOnly();\n+    }\n+\n+    @Override\n+    public String url() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().url();\n+    }\n+\n+    @Override\n+    public TemporaryDisk temporaryDisk() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().temporaryDisk();\n+    }\n+\n+    @Override\n+    public PersistentDisk persistentDisk() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().persistentDisk();\n+    }\n+\n+    @Override\n+    public ManagedIdentityProperties identity() {\n+        return inner().identity();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public String activeDeployment() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().activeDeploymentName();\n+    }\n+\n+    @Override\n+    public SpringAppDeployments deploy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk2NTYzOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDo0MDoxMVrOGsjfIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDo0MDoxMVrOGsjfIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MTkzNg==", "bodyText": "withActiveDeploymentSetting or withSettingFromActiveDeployment seems better?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449371936", "createdAt": "2020-07-03T04:40:11Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withSourceCodeFolder(File sourceCode) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.SOURCE);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> {\n+                    try {\n+                        return uploadToStorage(compressSource(sourceCode), option);\n+                    } catch (Exception e) {\n+                        return Mono.error(e);\n+                    }\n+                })\n+                .then(context.voidMono())\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withExistingSource(UserSourceType type, String relativePath) {\n+        ensureSource();\n+        inner().properties().source().withType(type);\n+        inner().properties().source().withRelativePath(relativePath);\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withSourceCodeTarGzFile(File sourceCodeTarGz) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.SOURCE);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(sourceCodeTarGz, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withTargetModule(String moduleName) {\n+        ensureSource();\n+        inner().properties().source().withArtifactSelector(moduleName);\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withSingleModule() {\n+        ensureSource();\n+        inner().properties().source().withArtifactSelector(null);\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withCurrentActiveSetting() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk2ODQzOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDo0MjowNlrOGsjgww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTo0Mzo0N1rOGskW7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MjM1NQ==", "bodyText": "Should (or not?) we provide byte[] as input?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449372355", "createdAt": "2020-07-03T04:42:06Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3Mjg1NA==", "bodyText": "Just remove this function? only provider file as input?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449372854", "createdAt": "2020-07-03T04:44:37Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MjM1NQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MzAwMA==", "bodyText": "I found these functions name should be changed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449373000", "createdAt": "2020-07-03T04:45:06Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MjM1NQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3ODE4MQ==", "bodyText": "I found these functions name should be changed.\n\nReason?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449378181", "createdAt": "2020-07-03T05:10:22Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MjM1NQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM4MzEwNg==", "bodyText": "I firstly use Path and byte[] for the jarPath and jarFile, but later I change parameter to File, which I think the function should also be changed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449383106", "createdAt": "2020-07-03T05:30:55Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MjM1NQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM4NjIyMw==", "bodyText": "removed the byte[] function", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449386223", "createdAt": "2020-07-03T05:43:47Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3MjM1NQ=="}, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk4MTI2OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDo1MTowNFrOGsjoOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDo1MTowNFrOGsjoOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NDI2Ng==", "bodyText": "Be clear on param, maybe better as sourceCodeFolder.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449374266", "createdAt": "2020-07-03T04:51:04Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");\n+        try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(\n+                 new GZIPOutputStream(new FileOutputStream(compressFile)))) {\n+            tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+\n+            for (Path sourceFile : Files.walk(sourceFolder.toPath()).collect(Collectors.toList())) {\n+                String relativePath = sourceFolder.toPath().relativize(sourceFile).toString();\n+                TarArchiveEntry entry = new TarArchiveEntry(sourceFile.toFile(), relativePath);\n+                if (sourceFile.toFile().isFile()) {\n+                    try (InputStream inputStream = new FileInputStream(sourceFile.toFile())) {\n+                        tarArchiveOutputStream.putArchiveEntry(entry);\n+                        IOUtils.copy(inputStream, tarArchiveOutputStream);\n+                        tarArchiveOutputStream.closeArchiveEntry();\n+                    }\n+                } else {\n+                    tarArchiveOutputStream.putArchiveEntry(entry);\n+                    tarArchiveOutputStream.closeArchiveEntry();\n+                }\n+            }\n+        }\n+        return compressFile;\n+    }\n+\n+    private Mono<ShareFileAsyncClient> createShareFileAsyncClient(ResourceUploadDefinition option, long maxSize) {\n+        ShareFileAsyncClient shareFileAsyncClient = new ShareFileClientBuilder()\n+            .endpoint(option.uploadUrl())\n+            .httpClient(manager().httpPipeline().getHttpClient())\n+            .buildFileAsyncClient();\n+\n+        return shareFileAsyncClient.create(maxSize)\n+            .then(Mono.just(shareFileAsyncClient));\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(byte[] bytes, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        return createShareFileAsyncClient(option, bytes.length)\n+                .flatMap(shareFileAsyncClient -> {\n+                    List<Integer> blockList = new ArrayList<>();\n+                    for (int start = 0; start < bytes.length; start += BLOCK_SIZE) {\n+                        blockList.add(start);\n+                    }\n+                    return Flux.fromIterable(blockList)\n+                        .flatMap(start -> {\n+                            int length = Math.min(bytes.length - start, BLOCK_SIZE);\n+                            return shareFileAsyncClient.uploadWithResponse(\n+                                Flux.just(ByteBuffer.wrap(bytes, start, length)), length, (long) start);\n+                        })\n+                        .then(Mono.just(shareFileAsyncClient));\n+                });\n+    }\n+\n+    private Mono<ShareFileAsyncClient> uploadToStorage(File source, ResourceUploadDefinition option) {\n+        inner().properties().source().withRelativePath(option.relativePath());\n+        try {\n+            return createShareFileAsyncClient(option, source.length())\n+                .flatMap(shareFileAsyncClient -> shareFileAsyncClient.uploadFromFile(source.getAbsolutePath())\n+                    .then(Mono.just(shareFileAsyncClient)));\n+        } catch (Exception e) {\n+            return Mono.error(e);\n+        }\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarPath(File jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withJarFile(byte[] jar) {\n+        ensureSource();\n+        inner().properties().source().withType(UserSourceType.JAR);\n+        this.addDependency(\n+            context -> parent().getResourceUploadUrlAsync()\n+                .flatMap(option -> uploadToStorage(jar, option)\n+                    .then(context.voidMono()))\n+        );\n+        return this;\n+    }\n+\n+    @Override\n+    public SpringAppDeploymentImpl withSourceCodeFolder(File sourceCode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk5NTA2OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowMTowOVrOGsjwPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowMTowOVrOGsjwPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NjMxOQ==", "bodyText": "Check whether to use File.deleteOnExit ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449376319", "createdAt": "2020-07-03T05:01:09Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;\n+\n+    SpringAppDeploymentImpl(String name, SpringAppImpl parent,\n+                            DeploymentResourceInner innerObject, SpringAppDeploymentsImpl client) {\n+        super(name, parent, innerObject);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public String appName() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().appName();\n+    }\n+\n+    @Override\n+    public DeploymentSettings settings() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().deploymentSettings();\n+    }\n+\n+    @Override\n+    public DeploymentResourceStatus status() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().status();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        if (inner().properties() == null) {\n+            return false;\n+        }\n+        return inner().properties().active();\n+    }\n+\n+    @Override\n+    public OffsetDateTime createdTime() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().createdTime();\n+    }\n+\n+    @Override\n+    public List<DeploymentInstance> instances() {\n+        if (inner().properties() == null) {\n+            return null;\n+        }\n+        return inner().properties().instances();\n+    }\n+\n+    @Override\n+    public String getLogFileUrl() {\n+        return getLogFileUrlAsync().block();\n+    }\n+\n+    @Override\n+    public Mono<String> getLogFileUrlAsync() {\n+        return manager().inner().getDeployments().getLogFileUrlAsync(\n+            parent().parent().resourceGroupName(), parent().parent().name(), parent().name(), name()\n+        )\n+            .map(LogFileUrlResponseInner::url);\n+    }\n+\n+    private void ensureDeploySettings() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().deploymentSettings() == null) {\n+            inner().properties().withDeploymentSettings(new DeploymentSettings());\n+        }\n+    }\n+\n+    private void ensureSource() {\n+        if (inner().properties() == null) {\n+            inner().withProperties(new DeploymentResourceProperties());\n+        }\n+        if (inner().properties().source() == null) {\n+            inner().properties().withSource(new UserSourceInfo());\n+        }\n+    }\n+\n+    private File compressSource(File sourceFolder) throws IOException {\n+        File compressFile = File.createTempFile(\"java_package\", \"tar.gz\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDk5OTI4OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowNDoyMFrOGsjyuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowNDoyMFrOGsjyuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3Njk1Mw==", "bodyText": "If you only need the setting, it might be better to only cache the setting.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449376953", "createdAt": "2020-07-03T05:04:20Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/implementation/SpringAppDeploymentImpl.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.implementation;\n+\n+import com.azure.resourcemanager.appplatform.AppPlatformManager;\n+import com.azure.resourcemanager.appplatform.fluent.inner.DeploymentResourceInner;\n+import com.azure.resourcemanager.appplatform.fluent.inner.LogFileUrlResponseInner;\n+import com.azure.resourcemanager.appplatform.models.DeploymentInstance;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceProperties;\n+import com.azure.resourcemanager.appplatform.models.DeploymentResourceStatus;\n+import com.azure.resourcemanager.appplatform.models.DeploymentSettings;\n+import com.azure.resourcemanager.appplatform.models.ResourceUploadDefinition;\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.UserSourceInfo;\n+import com.azure.resourcemanager.appplatform.models.UserSourceType;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.ExternalChildResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.storage.file.share.ShareFileAsyncClient;\n+import com.azure.storage.file.share.ShareFileClientBuilder;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class SpringAppDeploymentImpl\n+    extends ExternalChildResourceImpl<SpringAppDeployment, DeploymentResourceInner, SpringAppImpl, SpringApp>\n+    implements SpringAppDeployment, SpringAppDeployment.Definition, SpringAppDeployment.Update {\n+    private static final int BLOCK_SIZE = 4 * 1024 * 1024; // 4MB\n+    private final SpringAppDeploymentsImpl client;\n+    private SpringAppDeployment originalDeployment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02ec9c9966ebbb06d92c46925a3a15011948baa"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTA4NjAxOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/models/SpringApp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTo1ODozNFrOGskl0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMDozOVrOGslK3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MDAzMw==", "bodyText": "Ideally this seems should be in another interface (seems not related to PublicEndpoint). Or maybe rename the interface name to something more generic?\nSimilar for update.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449390033", "createdAt": "2020-07-03T05:58:34Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/models/SpringApp.java", "diffHunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.models;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.implementation.annotation.Beta;\n+import com.azure.resourcemanager.appplatform.fluent.inner.AppResourceInner;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.ExternalChildResource;\n+import com.azure.resourcemanager.resources.fluentcore.model.Appliable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.HasInner;\n+import com.azure.resourcemanager.resources.fluentcore.model.Updatable;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.time.OffsetDateTime;\n+\n+/** An immutable client-side representation of an Azure Spring App. */\n+@Fluent\n+@Beta\n+public interface SpringApp\n+    extends ExternalChildResource<SpringApp, SpringService>,\n+        HasInner<AppResourceInner>,\n+        Updatable<SpringApp.Update> {\n+    /** @return whether the app exposes public endpoint */\n+    boolean isPublic();\n+\n+    /** @return whether only https is allowed for the app */\n+    boolean isHttpsOnly();\n+\n+    /** @return the url of the app */\n+    String url();\n+\n+    /** @return the temporary disk of the app */\n+    TemporaryDisk temporaryDisk();\n+\n+    /** @return the persistent disk of the app */\n+    PersistentDisk persistentDisk();\n+\n+    /** @return the identity property of the app */\n+    ManagedIdentityProperties identity();\n+\n+    /** @return the creation time of the app */\n+    OffsetDateTime createdTime();\n+\n+    /** @return the active deployment name */\n+    String activeDeployment();\n+\n+    /** @return the entry point of the spring app deployment */\n+    SpringAppDeployments deployments();\n+\n+    /** @return the blob url to upload deployment */\n+    Mono<ResourceUploadDefinition> getResourceUploadUrlAsync();\n+\n+    /** @return the blob url to upload deployment */\n+    ResourceUploadDefinition getResourceUploadUrl();\n+\n+    /** Container interface for all the definitions that need to be implemented. */\n+    interface Definition\n+        extends DefinitionStages.Blank { }\n+\n+    /** Grouping of all the spring app definition stages. */\n+    interface DefinitionStages {\n+        /** The first stage of the spring app definition. */\n+        interface Blank extends WithCreate { }\n+\n+        /** The stage of a spring app definition allowing to specify the public endpoint. */\n+        interface WithPublicEndpoint {\n+            /**\n+             * Enables the public endpoint for the spring app.\n+             * @return the next stage of spring app definition\n+             */\n+            WithCreate withPublicEndpoint();\n+\n+            /**\n+             * Specifies the custom domain for the spring app.\n+             * @param domain the domain name\n+             * @return the next stage of spring app definition\n+             */\n+            WithCreate withCustomDomain(String domain);\n+\n+            /**\n+             * Enables https only for the spring app.\n+             * @return the next stage of spring app definition\n+             */\n+            WithCreate withHttpsOnly();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc04b316e9e7de58c96e052a1ecd41558ea12d3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5OTUxOA==", "bodyText": "Is it OK named to WithEndpoint?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449399518", "createdAt": "2020-07-03T06:30:39Z", "author": {"login": "ChenTanyi"}, "path": "sdk/appplatform/mgmt/src/main/java/com/azure/resourcemanager/appplatform/models/SpringApp.java", "diffHunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform.models;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.implementation.annotation.Beta;\n+import com.azure.resourcemanager.appplatform.fluent.inner.AppResourceInner;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.ExternalChildResource;\n+import com.azure.resourcemanager.resources.fluentcore.model.Appliable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.HasInner;\n+import com.azure.resourcemanager.resources.fluentcore.model.Updatable;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.File;\n+import java.time.OffsetDateTime;\n+\n+/** An immutable client-side representation of an Azure Spring App. */\n+@Fluent\n+@Beta\n+public interface SpringApp\n+    extends ExternalChildResource<SpringApp, SpringService>,\n+        HasInner<AppResourceInner>,\n+        Updatable<SpringApp.Update> {\n+    /** @return whether the app exposes public endpoint */\n+    boolean isPublic();\n+\n+    /** @return whether only https is allowed for the app */\n+    boolean isHttpsOnly();\n+\n+    /** @return the url of the app */\n+    String url();\n+\n+    /** @return the temporary disk of the app */\n+    TemporaryDisk temporaryDisk();\n+\n+    /** @return the persistent disk of the app */\n+    PersistentDisk persistentDisk();\n+\n+    /** @return the identity property of the app */\n+    ManagedIdentityProperties identity();\n+\n+    /** @return the creation time of the app */\n+    OffsetDateTime createdTime();\n+\n+    /** @return the active deployment name */\n+    String activeDeployment();\n+\n+    /** @return the entry point of the spring app deployment */\n+    SpringAppDeployments deployments();\n+\n+    /** @return the blob url to upload deployment */\n+    Mono<ResourceUploadDefinition> getResourceUploadUrlAsync();\n+\n+    /** @return the blob url to upload deployment */\n+    ResourceUploadDefinition getResourceUploadUrl();\n+\n+    /** Container interface for all the definitions that need to be implemented. */\n+    interface Definition\n+        extends DefinitionStages.Blank { }\n+\n+    /** Grouping of all the spring app definition stages. */\n+    interface DefinitionStages {\n+        /** The first stage of the spring app definition. */\n+        interface Blank extends WithCreate { }\n+\n+        /** The stage of a spring app definition allowing to specify the public endpoint. */\n+        interface WithPublicEndpoint {\n+            /**\n+             * Enables the public endpoint for the spring app.\n+             * @return the next stage of spring app definition\n+             */\n+            WithCreate withPublicEndpoint();\n+\n+            /**\n+             * Specifies the custom domain for the spring app.\n+             * @param domain the domain name\n+             * @return the next stage of spring app definition\n+             */\n+            WithCreate withCustomDomain(String domain);\n+\n+            /**\n+             * Enables https only for the spring app.\n+             * @return the next stage of spring app definition\n+             */\n+            WithCreate withHttpsOnly();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MDAzMw=="}, "originalCommit": {"oid": "5cc04b316e9e7de58c96e052a1ecd41558ea12d3"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTEwMTA4OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/test/java/com/azure/resourcemanager/appplatform/SpringCloudTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjowNzoyMVrOGsku_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjowNzoyMVrOGsku_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MjM4MA==", "bodyText": "I think you need to close connection.getInputStream()\nMaybe close FileOutputStream as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449392380", "createdAt": "2020-07-03T06:07:21Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/test/java/com/azure/resourcemanager/appplatform/SpringCloudTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform;\n+\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.SpringService;\n+import com.azure.resourcemanager.resources.fluentcore.arm.Region;\n+import com.azure.resourcemanager.resources.fluentcore.utils.SdkContext;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+\n+public class SpringCloudTest extends AppPlatformTest {\n+\n+    SpringCloudTest() {\n+        super(RunCondition.LIVE_ONLY); // need storage data-plane and url check\n+    }\n+\n+    @Test\n+    public void canCRUDSpringAppWithDeployment() throws IOException {\n+        String serviceName = generateRandomResourceName(\"springsvc\", 15);\n+        String appName = \"gateway\";\n+        String deploymentName = generateRandomResourceName(\"deploy\", 15);\n+        String deploymentName1 = generateRandomResourceName(\"deploy\", 15);\n+\n+        SpringService service = appPlatformManager.springServices().define(serviceName)\n+            .withRegion(Region.US_EAST)\n+            .withNewResourceGroup(rgName)\n+            .withSku(\"B0\")\n+            .create();\n+\n+        Assertions.assertEquals(\"B0\", service.sku().name());\n+\n+        service.update()\n+            .withSku(\"S0\")\n+            .apply();\n+\n+        Assertions.assertEquals(\"S0\", service.sku().name());\n+\n+        service.update()\n+            .withGitUri(\"https://github.com/Azure-Samples/piggymetrics-config\")\n+            .apply();\n+        Assertions.assertEquals(\"https://github.com/Azure-Samples/piggymetrics-config\", service.serverProperties().configServer().gitProperty().uri());\n+\n+        File jarFile = new File(\"gateway.jar\");\n+        if (!jarFile.exists()) {\n+            URLConnection connection = new URL(\"https://github.com/weidongxu-microsoft/azure-sdk-for-java-management-tests/raw/master/spring-cloud/gateway.jar\").openConnection();\n+            connection.connect();\n+            IOUtils.copy(connection.getInputStream(), new FileOutputStream(jarFile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc04b316e9e7de58c96e052a1ecd41558ea12d3"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTEwODA4OnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/test/java/com/azure/resourcemanager/appplatform/SpringCloudTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxMTowNlrOGskzAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxMTowNlrOGskzAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MzQxMA==", "bodyText": "Need to close it somewhere.\nhttps://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html#disconnect()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449393410", "createdAt": "2020-07-03T06:11:06Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/test/java/com/azure/resourcemanager/appplatform/SpringCloudTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform;\n+\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.SpringService;\n+import com.azure.resourcemanager.resources.fluentcore.arm.Region;\n+import com.azure.resourcemanager.resources.fluentcore.utils.SdkContext;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+\n+public class SpringCloudTest extends AppPlatformTest {\n+\n+    SpringCloudTest() {\n+        super(RunCondition.LIVE_ONLY); // need storage data-plane and url check\n+    }\n+\n+    @Test\n+    public void canCRUDSpringAppWithDeployment() throws IOException {\n+        String serviceName = generateRandomResourceName(\"springsvc\", 15);\n+        String appName = \"gateway\";\n+        String deploymentName = generateRandomResourceName(\"deploy\", 15);\n+        String deploymentName1 = generateRandomResourceName(\"deploy\", 15);\n+\n+        SpringService service = appPlatformManager.springServices().define(serviceName)\n+            .withRegion(Region.US_EAST)\n+            .withNewResourceGroup(rgName)\n+            .withSku(\"B0\")\n+            .create();\n+\n+        Assertions.assertEquals(\"B0\", service.sku().name());\n+\n+        service.update()\n+            .withSku(\"S0\")\n+            .apply();\n+\n+        Assertions.assertEquals(\"S0\", service.sku().name());\n+\n+        service.update()\n+            .withGitUri(\"https://github.com/Azure-Samples/piggymetrics-config\")\n+            .apply();\n+        Assertions.assertEquals(\"https://github.com/Azure-Samples/piggymetrics-config\", service.serverProperties().configServer().gitProperty().uri());\n+\n+        File jarFile = new File(\"gateway.jar\");\n+        if (!jarFile.exists()) {\n+            URLConnection connection = new URL(\"https://github.com/weidongxu-microsoft/azure-sdk-for-java-management-tests/raw/master/spring-cloud/gateway.jar\").openConnection();\n+            connection.connect();\n+            IOUtils.copy(connection.getInputStream(), new FileOutputStream(jarFile));\n+        }\n+\n+        SpringApp app = service.apps().define(appName)\n+            .withPublicEndpoint()\n+            .create();\n+\n+        Assertions.assertNotNull(app.url());\n+        Assertions.assertNotNull(app.activeDeployment());\n+\n+        Assertions.assertTrue(requestSuccess(app.url()));\n+\n+        app.update()\n+            .withoutDeployment(app.activeDeployment())\n+            .deployJar(deploymentName, jarFile)\n+            .apply();\n+\n+        Assertions.assertNotNull(app.url());\n+        Assertions.assertEquals(deploymentName, app.activeDeployment());\n+\n+        Assertions.assertTrue(requestSuccess(app.url()));\n+\n+        SpringAppDeployment deployment = app.deployments().getByName(app.activeDeployment());\n+        deployment.update()\n+            .withCpu(2)\n+            .withMemory(4)\n+            .withRuntime(RuntimeVersion.JAVA_11)\n+            .withInstance(2)\n+            .apply();\n+\n+        Assertions.assertEquals(2, deployment.settings().cpu());\n+        Assertions.assertEquals(4, deployment.settings().memoryInGB());\n+        Assertions.assertEquals(RuntimeVersion.JAVA_11, deployment.settings().runtimeVersion());\n+        Assertions.assertEquals(2, deployment.instances().size());\n+\n+        deployment = app.deployments().define(deploymentName1)\n+            .withSourceCodeFolder(new File(this.getClass().getResource(\"/piggymetrics\").getFile()))\n+            .withTargetModule(\"gateway\")\n+            .withSettingsFromActiveDeployment()\n+            .activate()\n+            .create();\n+        app.refresh();\n+\n+        Assertions.assertEquals(deploymentName1, app.activeDeployment());\n+        Assertions.assertEquals(2, deployment.settings().cpu());\n+        Assertions.assertNotNull(deployment.getLogFileUrl());\n+\n+        Assertions.assertTrue(requestSuccess(app.url()));\n+\n+        app.update()\n+            .withoutPublicEndpoint()\n+            .apply();\n+        Assertions.assertFalse(app.isPublic());\n+    }\n+\n+    private boolean requestSuccess(String url) throws IOException {\n+        for (int i = 0; i < 60; ++i) {\n+            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n+            connection.connect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc04b316e9e7de58c96e052a1ecd41558ea12d3"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTExMzYwOnYy", "diffSide": "RIGHT", "path": "sdk/appplatform/mgmt/src/test/java/com/azure/resourcemanager/appplatform/SpringCloudTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxMzo1NlrOGsk2Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxMzo1NlrOGsk2Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5NDI0Ng==", "bodyText": "Is there a way to verify that this deployment is deleted?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12350#discussion_r449394246", "createdAt": "2020-07-03T06:13:56Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/appplatform/mgmt/src/test/java/com/azure/resourcemanager/appplatform/SpringCloudTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.appplatform;\n+\n+import com.azure.resourcemanager.appplatform.models.RuntimeVersion;\n+import com.azure.resourcemanager.appplatform.models.SpringApp;\n+import com.azure.resourcemanager.appplatform.models.SpringAppDeployment;\n+import com.azure.resourcemanager.appplatform.models.SpringService;\n+import com.azure.resourcemanager.resources.fluentcore.arm.Region;\n+import com.azure.resourcemanager.resources.fluentcore.utils.SdkContext;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+\n+public class SpringCloudTest extends AppPlatformTest {\n+\n+    SpringCloudTest() {\n+        super(RunCondition.LIVE_ONLY); // need storage data-plane and url check\n+    }\n+\n+    @Test\n+    public void canCRUDSpringAppWithDeployment() throws IOException {\n+        String serviceName = generateRandomResourceName(\"springsvc\", 15);\n+        String appName = \"gateway\";\n+        String deploymentName = generateRandomResourceName(\"deploy\", 15);\n+        String deploymentName1 = generateRandomResourceName(\"deploy\", 15);\n+\n+        SpringService service = appPlatformManager.springServices().define(serviceName)\n+            .withRegion(Region.US_EAST)\n+            .withNewResourceGroup(rgName)\n+            .withSku(\"B0\")\n+            .create();\n+\n+        Assertions.assertEquals(\"B0\", service.sku().name());\n+\n+        service.update()\n+            .withSku(\"S0\")\n+            .apply();\n+\n+        Assertions.assertEquals(\"S0\", service.sku().name());\n+\n+        service.update()\n+            .withGitUri(\"https://github.com/Azure-Samples/piggymetrics-config\")\n+            .apply();\n+        Assertions.assertEquals(\"https://github.com/Azure-Samples/piggymetrics-config\", service.serverProperties().configServer().gitProperty().uri());\n+\n+        File jarFile = new File(\"gateway.jar\");\n+        if (!jarFile.exists()) {\n+            URLConnection connection = new URL(\"https://github.com/weidongxu-microsoft/azure-sdk-for-java-management-tests/raw/master/spring-cloud/gateway.jar\").openConnection();\n+            connection.connect();\n+            IOUtils.copy(connection.getInputStream(), new FileOutputStream(jarFile));\n+        }\n+\n+        SpringApp app = service.apps().define(appName)\n+            .withPublicEndpoint()\n+            .create();\n+\n+        Assertions.assertNotNull(app.url());\n+        Assertions.assertNotNull(app.activeDeployment());\n+\n+        Assertions.assertTrue(requestSuccess(app.url()));\n+\n+        app.update()\n+            .withoutDeployment(app.activeDeployment())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc04b316e9e7de58c96e052a1ecd41558ea12d3"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3801, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}