{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMzEyNTU5", "number": 16183, "title": "Enable Autolock renewal  - Service bus Sync/Async client", "bodyText": "Enable auto lock renew for\n\nSync client\nasync client\nDefault to auto lock renew time to 5 minutes ( .Net doing same)", "createdAt": "2020-10-12T05:35:08Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183", "merged": true, "mergeCommit": {"oid": "a768be6a99a52cce4163ce02120d2402da7b8981"}, "closed": true, "closedAt": "2020-10-22T06:03:56Z", "author": {"login": "hemanttanwar"}, "timelineItems": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRtIlRgH2gAyNTAxMzEyNTU5OjI5MTc0MzZlMWNjYzEzYzdlMWQyYjgwYmQ3ZGMwMjEzZDc4YzJhNmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdU6J3-AFqTUxNDM0NzgyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2917436e1ccc13c7e1d2b80bd7dc0213d78c2a6f", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2917436e1ccc13c7e1d2b80bd7dc0213d78c2a6f", "committedDate": "2020-10-12T05:29:03Z", "message": "Draft implementation of Auto lock renewal."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0686cc558e1a5f806af744722ee477c744625819", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0686cc558e1a5f806af744722ee477c744625819", "committedDate": "2020-10-12T05:32:41Z", "message": "Draft implementation of Auto lock renewal."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae323dc7022a7aa7178b56cbbc95da00e4aafb9d", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae323dc7022a7aa7178b56cbbc95da00e4aafb9d", "committedDate": "2020-10-13T07:55:03Z", "message": "Fixing test case and changing processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2e22dbbc170f60540ee284d66e1ad67f9424c85", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2e22dbbc170f60540ee284d66e1ad67f9424c85", "committedDate": "2020-10-13T08:07:43Z", "message": "unit test fixing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "502c4df17b3d1f94fa847c1fed5f2652314d3235", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/502c4df17b3d1f94fa847c1fed5f2652314d3235", "committedDate": "2020-10-13T08:15:15Z", "message": "Remove unwanted args from contructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7bfd5a1776d419adf3ae2fdd8583af4055a09c2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d7bfd5a1776d419adf3ae2fdd8583af4055a09c2", "committedDate": "2020-10-13T16:10:07Z", "message": "Spot bugs fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f67be389108eb449dc8930f249cd876ddfce963", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f67be389108eb449dc8930f249cd876ddfce963", "committedDate": "2020-10-13T23:05:29Z", "message": "Adding custom operstor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6af26108806ccdbb45ef9876d3ad98988fd17ca8", "committedDate": "2020-10-13T23:27:22Z", "message": "Adding custom operstor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3OTc4MjAy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-507978202", "createdAt": "2020-10-14T04:00:46Z", "commit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowMDo0NlrOHhBWcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyNzowNVrOHhBwRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4NzE4Ng==", "bodyText": "Is this operator required even if the autoLockRenewal is set to false? Also, this member variable should now be renamed to renewOperator.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504387186", "createdAt": "2020-10-14T04:00:46Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -29,14 +33,19 @@\n     private final Flux<ServiceBusReceivedMessage> processor;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        this.processor = new ServiceBusRenewOperator(linkProcessor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODMyMA==", "bodyText": "Setter methods on builder should not have set prefix.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388320", "createdAt": "2020-10-14T04:05:38Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder setMaxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODQxMQ==", "bodyText": "Same here. Remove set prefix.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388411", "createdAt": "2020-10-14T04:05:59Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +851,25 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO} or\n+         * {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder setMaxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODc4MQ==", "bodyText": "Not sure why we are passing connectionProcessor and connectionProcessor.getRetryOptions().getTryTimeout(). If the session manager has the connection processor, it should be able to get the retry options from it anyway. Also, it's weird to see retry options in connection processor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388781", "createdAt": "2020-10-14T04:07:36Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -763,19 +781,22 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final ReceiverOptions receiverOptions = new ReceiverOptions(receiveMode, prefetchCount,\n                 sessionId, isRollingSessionReceiver(), maxConcurrentSessions);\n \n+            final UnnamedSessionManager sessionManager;\n+\n             if (CoreUtils.isNullOrEmpty(sessionId)) {\n-                final UnnamedSessionManager sessionManager = new UnnamedSessionManager(entityPath, entityType,\n+                sessionManager = new UnnamedSessionManager(entityPath, entityType,\n                     connectionProcessor, connectionProcessor.getRetryOptions().getTryTimeout(), tracerProvider,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4OTE4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n          \n          \n            \n                     * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504389180", "createdAt": "2020-10-14T04:09:18Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4OTUwNA==", "bodyText": "I don't see this class being used anywhere outside this file. Do we need this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504389504", "createdAt": "2020-10-14T04:10:34Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageProcessor.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Processor that listens to upstream messages, pushes them downstream then completes it if necessary.\n+ */\n+class ServiceBusMessageProcessor extends FluxProcessor<ServiceBusReceivedMessage, ServiceBusReceivedMessage>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5MjQ4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {\n          \n          \n            \n                public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504392486", "createdAt": "2020-10-14T04:21:36Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+/**\n+ * Operate on messages from to upstream, pushes them downstream  and start lock renewal.\n+ */\n+final class ServiceBusRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage>  {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link org.reactivestreams.Publisher}\n+     * @param source the {@link org.reactivestreams.Publisher} to decorate\n+     */\n+    ServiceBusRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5MzM4Nw==", "bodyText": "What is the purpose of hasError? Also, we are swallowing the exception here. If actual.onNext() throws an exception, should we stop the source flux?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504393387", "createdAt": "2020-10-14T04:25:30Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+/**\n+ * Operate on messages from to upstream, pushes them downstream  and start lock renewal.\n+ */\n+final class ServiceBusRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage>  {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link org.reactivestreams.Publisher}\n+     * @param source the {@link org.reactivestreams.Publisher} to decorate\n+     */\n+    ServiceBusRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription s) {\n+                actual.onSubscribe(s);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+\n+                final long sequenceNumber = message.getSequenceNumber();\n+                final String lockToken = message.getLockToken();\n+                LockRenewalOperation renewLockOperation = null;\n+\n+                if (isAutoRenewLock) {\n+                    if (CoreUtils.isNullOrEmpty(lockToken)) {\n+                        throw logger.logExceptionAsError(new IllegalStateException(\n+                            \"Cannot auto-renew message without a lock token on message. Sequence number: \" + sequenceNumber));\n+                    } else if (message.getLockedUntil() ==  null) {\n+                        throw logger.logExceptionAsError(new IllegalStateException(\n+                            \"Cannot auto-renew message without a lock token until on message. Sequence number: \" + sequenceNumber));\n+                    }\n+\n+                    renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal, false,\n+                        onRenewLock, message.getLockedUntil());\n+                    messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                        renewLockOperation);\n+                }\n+\n+                final AtomicBoolean hasError = new AtomicBoolean();\n+                try {\n+                    actual.onNext(message);\n+                } catch (Exception e) {\n+                    hasError.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng==", "bodyText": "This should be available transitively through com.azure.core.amqp already.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504393796", "createdAt": "2020-10-14T04:27:05Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,7 @@\n \n module com.azure.messaging.servicebus {\n     requires transitive com.azure.core.amqp;\n+    requires transitive org.reactivestreams;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6892dd806377c2518833f851915fe77d7d816305", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6892dd806377c2518833f851915fe77d7d816305", "committedDate": "2020-10-14T19:30:21Z", "message": "Added unit test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae0c6eab878397eefa44faa94afaa15ea6388eb9", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae0c6eab878397eefa44faa94afaa15ea6388eb9", "committedDate": "2020-10-14T19:42:24Z", "message": "cleanup of constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a5444892387a0184eba361884203bb75b0aa2977", "committedDate": "2020-10-14T23:44:57Z", "message": "Rename unnamessession manager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NDc1NDY0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-509475464", "createdAt": "2020-10-15T14:58:22Z", "commit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1ODoyMlrOHiMKNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxNDowN1rOHiM9bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMjg1NQ==", "bodyText": "I notice this file keeps changing, but there are no functional changes here. You can revert them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505612855", "createdAt": "2020-10-15T14:58:22Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -5,6 +5,7 @@\n import com.azure.core.util.logging.ClientLogger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMzkxMQ==", "bodyText": "This comment isn't needed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505613911", "createdAt": "2020-10-15T14:59:40Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNTA3NA==", "bodyText": "I think we should move the validation of this argument to here, so we don't need to bloat buildAsyncClient. Same with prefetch as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505615074", "createdAt": "2020-10-15T15:01:06Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {\n+            this.maxAutoRenewDuration = maxAutoRenewDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNzY1Mg==", "bodyText": "What about validation of these other parameters?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505617652", "createdAt": "2020-10-15T15:04:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODE4NQ==", "bodyText": "Can you split this into another class instead of an anonymous one. This is hard to understand.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505618185", "createdAt": "2020-10-15T15:04:41Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODUxMQ==", "bodyText": "Why do you need a lock?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505618511", "createdAt": "2020-10-15T15:05:03Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxOTc2NQ==", "bodyText": "Can we have a static \"Is complete\" lock renewal so we can make this variable final.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505619765", "createdAt": "2020-10-15T15:06:28Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMDYxOQ==", "bodyText": "nit: change formatting of these if conditionals statements. I notice times you use Objects.isNull rather than comparing. Is there a reason for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505620619", "createdAt": "2020-10-15T15:07:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMTM4Mg==", "bodyText": "final LockRenewalOperation operation;\nif (renewLock) {\n    operation = ...\n} else {\n    operation = COMPLETED_ONE;\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505621382", "createdAt": "2020-10-15T15:08:25Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxOTc2NQ=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMTczMg==", "bodyText": "This can be dumped in the \"ReceiverOptions\"... so we wouldn't have to keep changing the ctor signature.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505621732", "createdAt": "2020-10-15T15:08:49Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -121,10 +123,12 @@\n      * @param tracerProvider Tracer for telemetry.\n      * @param messageSerializer Serializes and deserializes Service Bus messages.\n      * @param onClientClose Operation to run when the client completes.\n+     * @param maxAutoRenewLockDuration for which lock should be renewed.\n      */\n     ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType,\n         ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, Duration cleanupInterval,\n-        TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose) {\n+        TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose,\n+        Duration maxAutoRenewLockDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNDEzMA==", "bodyText": "Log the error, e?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505624130", "createdAt": "2020-10-15T15:11:48Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null\n+                       && message.getLockToken() != null) {\n+                       renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal,\n+                           false, onRenewLock, message.getLockedUntil());\n+\n+                       messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                           renewLockOperation);\n+                   }\n+\n+                   try {\n+                       actual.onNext(message);\n+                   } catch (Exception e) {\n+                       logger.error(\"Exception occurred while handling downstream onNext operation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNDU3NA==", "bodyText": "If you use the final suggestion above, this null check is not needed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505624574", "createdAt": "2020-10-15T15:12:20Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null\n+                       && message.getLockToken() != null) {\n+                       renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal,\n+                           false, onRenewLock, message.getLockedUntil());\n+\n+                       messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                           renewLockOperation);\n+                   }\n+\n+                   try {\n+                       actual.onNext(message);\n+                   } catch (Exception e) {\n+                       logger.error(\"Exception occurred while handling downstream onNext operation.\");\n+                       onError(e);\n+                   } finally {\n+                       if (renewLockOperation != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTA1Nw==", "bodyText": "Does this anonymous class need to inherit from CoreSubscriber? BaseSubscriber does most of this for you already.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505625057", "createdAt": "2020-10-15T15:12:58Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODE4NQ=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTk2Ng==", "bodyText": "Why the rename?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505625966", "createdAt": "2020-10-15T15:14:07Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,58 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bedc59a3a1a70e0b5c424b75ba7e28859d2769e", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9bedc59a3a1a70e0b5c424b75ba7e28859d2769e", "committedDate": "2020-10-15T16:43:48Z", "message": "Merge branch 'master' into sb-enable-autolock-renewal-16071"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03b2e9747f902e463e0c3e181820aa75da720aab", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/03b2e9747f902e463e0c3e181820aa75da720aab", "committedDate": "2020-10-15T20:22:21Z", "message": "Incorporated review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "761c4f0d19a62fad5d5041f93808f2774a42dc57", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/761c4f0d19a62fad5d5041f93808f2774a42dc57", "committedDate": "2020-10-15T20:47:16Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6314871ae514b3ae9d10ff02193c66895415e788", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6314871ae514b3ae9d10ff02193c66895415e788", "committedDate": "2020-10-16T00:16:57Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8849d768abf0a3ee356094a4f8730199bc07ebc", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e8849d768abf0a3ee356094a4f8730199bc07ebc", "committedDate": "2020-10-16T00:24:12Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3ba139a570ba13ea7f38f769ef2b880f4c32636", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e3ba139a570ba13ea7f38f769ef2b880f4c32636", "committedDate": "2020-10-16T05:34:22Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "committedDate": "2020-10-16T06:18:08Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMjUyMDI0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-510252024", "createdAt": "2020-10-16T08:19:54Z", "commit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODoxOTo1NFrOHithWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyNToxNVrOHiw4dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE1OTQ0OA==", "bodyText": "When will this happen?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506159448", "createdAt": "2020-10-16T08:19:54Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3MjY0MQ==", "bodyText": "Why do we need to use this subscriber if the autoRenewLock is false?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506172641", "createdAt": "2020-10-16T08:34:00Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mzk0MQ==", "bodyText": "Log the exception as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506173941", "createdAt": "2020-10-16T08:35:28Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTMxOA==", "bodyText": "This else block is not required.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506181318", "createdAt": "2020-10-16T08:45:33Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTczMw==", "bodyText": "Remove this printStackTrace.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506181733", "createdAt": "2020-10-16T08:46:09Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MjM3OQ==", "bodyText": "Will this also call hookOnError()?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506182379", "createdAt": "2020-10-16T08:46:58Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4NDA1Ng==", "bodyText": "Will this propagate the subscriber context?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506184056", "createdAt": "2020-10-16T08:49:36Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ==", "bodyText": "It's odd that creating an instance of LockRenewalOperation also starts renewing the locks immediately. Also, if the lock renewal fails, how is the user notified of it?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506200711", "createdAt": "2020-10-16T09:08:40Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTA0NA==", "bodyText": "If the message has null lockedUntil and lockToken values, should that be considered an invalid message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506205044", "createdAt": "2020-10-16T09:12:14Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTcwMg==", "bodyText": "When the lock is renewed, will message.getLockedUntil() return the renewed time? If yes, where is the update to lockedUntil property happening for this message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506205702", "createdAt": "2020-10-16T09:12:50Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNzA4MQ==", "bodyText": "What happens if this operation throws an exception? This can throw if the lockContainer is disposed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506207081", "createdAt": "2020-10-16T09:15:03Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwODQ3OA==", "bodyText": "Typo in method name max. Also, include Lock after Auto in the name and update the javadocs too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506208478", "createdAt": "2020-10-16T09:16:47Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,25 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxMTAxMg==", "bodyText": "maxAutoLockRenewDuration.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506211012", "createdAt": "2020-10-16T09:20:28Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +844,25 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO} or\n+         * {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxMzEyNw==", "bodyText": "Since this operator is created only when autoLockRenewal is true, do we need the 2nd param?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506213127", "createdAt": "2020-10-16T09:23:25Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor\n             .map(message -> this.messageSerializer.deserialize(message, ServiceBusReceivedMessage.class))\n             .publish(prefetch)\n             .autoConnect(1);\n+\n+        if (autoLockRenewal) {\n+            this.messageSource = new ServiceBusMessageRenewOperator(source,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxNDUxOQ==", "bodyText": "If only one subscription is allowed, this should return from here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506214519", "createdAt": "2020-10-16T09:25:15Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, isAutoRenewLock,\n+            maxAutoLockRenewal, messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {\n+            newLockRenewSubscriber.dispose();\n+            logger.error(\"Already subscribed once.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc90d6763d1bf8279e2a46403f1baa6499f53b62", "committedDate": "2020-10-16T18:52:28Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzI4OTYy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-510728962", "createdAt": "2020-10-16T19:00:04Z", "commit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTowMDowNFrOHjMiog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyODowNFrOHjNSxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY2NzY4Mg==", "bodyText": "Why are you keeping a reference to this? BaseSubscriber holds most of this logic. I don't see a call to the base class either.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506667682", "createdAt": "2020-10-16T19:00:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MDYxOQ==", "bodyText": "nit: unneeded new line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506670619", "createdAt": "2020-10-16T19:06:25Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiver.java", "diffHunk": "@@ -182,6 +183,7 @@ void setSessionLockedUntil(OffsetDateTime lockedUntil) {\n     }\n \n     Mono<Void> updateDisposition(String lockToken, DeliveryState deliveryState) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjY3Mw==", "bodyText": "When is this used?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506672673", "createdAt": "2020-10-16T19:11:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReceiveLinkProcessor.java", "diffHunk": "@@ -129,6 +135,15 @@ public String getLinkName() {\n             }));\n     }\n \n+    /**\n+     * Gets the error context associated with this link.\n+     *\n+     * @return the error context associated with this link.\n+     */\n+    public AmqpErrorContext getErrorContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MzIxMw==", "bodyText": "consistent use of final.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506673213", "createdAt": "2020-10-16T19:12:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});\n+\n+        ServiceBusMessageRenewOperator renewOperator = new ServiceBusMessageRenewOperator(messageSource,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw==", "bodyText": "Use TestPublisher because we should test multiple renewals.\nWe should also test that cancellation from downstream.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506674377", "createdAt": "2020-10-16T19:15:09Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTQ4MQ==", "bodyText": "same comment about moving validation not to build method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506675481", "createdAt": "2020-10-16T19:17:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -927,20 +956,23 @@ public ServiceBusReceiverClientBuilder topicName(String topicName) {\n          *     #topicName(String) topicName} is set, but {@link #subscriptionName(String) subscriptionName} is not.\n          * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n+         * @throws IllegalArgumentException {#code maxAutoLockRenewDuration} is negative.\n          */\n         public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final MessagingEntityType entityType = validateEntityPaths(logger, connectionStringEntityName, topicName,\n                 queueName);\n             final String entityPath = getEntityPath(logger, entityType, queueName, topicName, subscriptionName,\n                 subQueue);\n             validateAndThrow(prefetchCount);\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTkwNQ==", "bodyText": "Should move validation to the maxAutoLockRenewDuration setter.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506675905", "createdAt": "2020-10-16T19:18:29Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -758,24 +777,19 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n                 SubQueue.NONE);\n \n             validateAndThrow(prefetchCount);\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw==", "bodyText": "Can we keep this to ReceiveOptions? it seems like we're bloating this constructor", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506678567", "createdAt": "2020-10-16T19:24:39Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTA3NA==", "bodyText": "I'm also adding another parameter from ReceiveOptions.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506679074", "createdAt": "2020-10-16T19:25:48Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw=="}, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTQxOQ==", "bodyText": "Same with this one. I'm not sure if Yijun fixed this too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506679419", "createdAt": "2020-10-16T19:26:41Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -758,24 +777,19 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n                 SubQueue.NONE);\n \n             validateAndThrow(prefetchCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MDAwNQ==", "bodyText": "Can we dump this in receive options.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506680005", "createdAt": "2020-10-16T19:28:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -142,13 +147,13 @@\n             renewal.close();\n         });\n \n-        this.unnamedSessionManager = null;\n+        this.sessionManager = null;\n     }\n \n     ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType,\n         ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, Duration cleanupInterval,\n         TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose,\n-        UnnamedSessionManager unnamedSessionManager) {\n+        Duration maxAutoRenewLockDuration, ServiceBusSessionManager sessionManager) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f085df3d56abea3b6c60c3dd7fd89cf5c15e4b7", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7f085df3d56abea3b6c60c3dd7fd89cf5c15e4b7", "committedDate": "2020-10-17T19:20:45Z", "message": "Incorporated  Review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b409dd3f5dbfafef1c5b109de1cf6766d13a5d1", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7b409dd3f5dbfafef1c5b109de1cf6766d13a5d1", "committedDate": "2020-10-19T09:24:18Z", "message": " Added more nuit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9172a5a13a1cac6c850bad20360549b788e7aba2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9172a5a13a1cac6c850bad20360549b788e7aba2", "committedDate": "2020-10-19T16:23:37Z", "message": "Fix unit test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a", "committedDate": "2020-10-19T17:57:39Z", "message": "Fixed unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68427390a6f0344b73766e9693c45e8fb2649be2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/68427390a6f0344b73766e9693c45e8fb2649be2", "committedDate": "2020-10-19T20:33:19Z", "message": "add unit test cae"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA4NjY2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-512208666", "createdAt": "2020-10-19T22:37:23Z", "commit": {"oid": "a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNzoyM1rOHkkHtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNzoyM1rOHkkHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMjU4MQ==", "bodyText": "receiverOptions also has an sessionId. Can we just use that one?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508102581", "createdAt": "2020-10-19T22:37:23Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,47 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {\n     // Time to delay before trying to accept another session.\n     private static final Duration SLEEP_DURATION_ON_ACCEPT_SESSION_EXCEPTION = Duration.ofMinutes(1);\n \n-    private final ClientLogger logger = new ClientLogger(UnnamedSessionManager.class);\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionManager.class);\n     private final String entityPath;\n     private final MessagingEntityType entityType;\n     private final ReceiverOptions receiverOptions;\n     private final ServiceBusConnectionProcessor connectionProcessor;\n     private final Duration operationTimeout;\n     private final TracerProvider tracerProvider;\n     private final MessageSerializer messageSerializer;\n+    private final String userProvidedSessionId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58c909ac64783a747605edaafb4cdee7b7efb8e0", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/58c909ac64783a747605edaafb4cdee7b7efb8e0", "committedDate": "2020-10-20T06:23:45Z", "message": "Add more unit test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "committedDate": "2020-10-20T06:37:20Z", "message": "Fix spot bugs error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzkyMjg2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-512392286", "createdAt": "2020-10-20T07:10:48Z", "commit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoxMDo0OFrOHktr-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzo1ODozM1rOHkvcjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTMyMQ==", "bodyText": "Wouldn't this call user's onError handler? I thought we were not going to notify the user of any error if auto lock renewal fails.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508259321", "createdAt": "2020-10-20T07:10:48Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTgxNQ==", "bodyText": "When will the message have null lock token and lockedUntil?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508259815", "createdAt": "2020-10-20T07:11:43Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NTgwNg==", "bodyText": "com.azure.core module requires this transitively. So, anything depending on core should have it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508265806", "createdAt": "2020-10-20T07:22:12Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,7 @@\n \n module com.azure.messaging.servicebus {\n     requires transitive com.azure.core.amqp;\n+    requires transitive org.reactivestreams;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng=="}, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NzAzOA==", "bodyText": "Maybe we should just mark this as info as we don't surface any errors to users. Logging an error could alarm the user.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508267038", "createdAt": "2020-10-20T07:24:21Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2ODE2Ng==", "bodyText": "When the renewOperation is closed, should we also remove this from messageLockContainer?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508268166", "createdAt": "2020-10-20T07:26:12Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);\n+            }\n+        } else {\n+            logger.warning(\"Unexpected, LockToken [{}] or lockedUntil [{}] is not present for message [{}].\",\n+                lockToken, lockedUntil, message.getSequenceNumber());\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);\n+        } finally {\n+            renewOperation.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4ODE0MA==", "bodyText": "Why do we restrict this to a single subscriber? Are multiple calls to receive() not allowed?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508288140", "createdAt": "2020-10-20T07:58:33Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyOTEzNDY0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-512913464", "createdAt": "2020-10-20T16:20:16Z", "commit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyMDoxN1rOHlGiPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozNTowMlrOHlHIqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjQzMQ==", "bodyText": "Why OffsetDateTime.now()? This variable is only used once.\nI'm not sure why we don't just have a LockRenewalOperation.DONE it just returns empty.\nclass LockRenewalOperation {\n    static final LockRenewalOperation COMPLETED = new LockRenewalOperation(null, null, null, null);\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508666431", "createdAt": "2020-10-20T16:20:17Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODM0MA==", "bodyText": "That's true. We should probably log it and return early.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508668340", "createdAt": "2020-10-20T16:22:57Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTgxNQ=="}, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjY5NQ==", "bodyText": "Do we need all these overloads? I'm not entirely sure why we need this consumer... Can't we map the renewalOperation.map(update -> {});?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508672695", "createdAt": "2020-10-20T16:29:31Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -49,6 +53,34 @@\n         this(lockToken, maxLockRenewalDuration, isSession, renewalOperation, OffsetDateTime.now());\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NDcyNg==", "bodyText": "Can we move that LockRenewSubscriber class into this one? It only exists to be used in this class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508674726", "createdAt": "2020-10-20T16:32:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {\n+            newLockRenewSubscriber.dispose();\n+            logger.error(\"Already subscribed once.\");\n+            return;\n+        }\n+        source.subscribe(lockRenewSubscriber.get());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NTEzNQ==", "bodyText": "nit: FluxAutoRenew to follow the same vein as the existing ones.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508675135", "createdAt": "2020-10-20T16:33:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NjI2Nw==", "bodyText": "Can we move this duration logic into a receiver option?\nboolean isAutoRenewEnabled() { return maxAutoLockRenewDuration != null ...; }", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508676267", "createdAt": "2020-10-20T16:35:02Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,32 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor\n             .map(message -> this.messageSerializer.deserialize(message, ServiceBusReceivedMessage.class))\n-            .publish(prefetch)\n+            .publish(receiverOptions.getPrefetchCount())\n             .autoConnect(1);\n+\n+        final Duration maxAutoLockRenewDuration = receiverOptions.getMaxLockRenewDuration();\n+\n+        final boolean isAutoLockRenewal = maxAutoLockRenewDuration != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddf801f590d44aa4f8e42b0eaba8561258633485", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ddf801f590d44aa4f8e42b0eaba8561258633485", "committedDate": "2020-10-20T20:00:02Z", "message": "Incorporated review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fc64e7324197d104ce8bbf92dee64be83670a30", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fc64e7324197d104ce8bbf92dee64be83670a30", "committedDate": "2020-10-20T20:45:05Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "committedDate": "2020-10-20T21:29:58Z", "message": "Fix unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTUzMDUy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-513153052", "createdAt": "2020-10-20T21:36:20Z", "commit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozNjoyMVrOHlSCjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0OTo1OFrOHlScKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDkyNw==", "bodyText": "FluxAutoLockRenew", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508854927", "createdAt": "2020-10-20T21:36:21Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjU0MA==", "bodyText": "Don't use error level here as we are not reporting these errors to the user. It will show up in their log and can alert them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508856540", "createdAt": "2020-10-20T21:39:40Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            } else if (Objects.isNull(lockedUntil)) {\n+                logger.info(\"Unexpected, lockedUntil is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            }\n+\n+            final Function<String, Mono<OffsetDateTime>> onRenewLockUpdateMessage = onRenewLock.andThen(updated ->\n+                updated.map(newLockedUntil -> {\n+                    message.setLockedUntil(newLockedUntil);\n+                    return newLockedUntil;\n+                }));\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false,\n+                onRenewLockUpdateMessage, lockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Njc5Ng==", "bodyText": "onError() shouldn't be called here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508856796", "createdAt": "2020-10-20T21:40:10Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            } else if (Objects.isNull(lockedUntil)) {\n+                logger.info(\"Unexpected, lockedUntil is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            }\n+\n+            final Function<String, Mono<OffsetDateTime>> onRenewLockUpdateMessage = onRenewLock.andThen(updated ->\n+                updated.map(newLockedUntil -> {\n+                    message.setLockedUntil(newLockedUntil);\n+                    return newLockedUntil;\n+                }));\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false,\n+                onRenewLockUpdateMessage, lockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+            }\n+\n+            try {\n+                actual.onNext(message);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODM2MQ==", "bodyText": "We should use AutoLockRenew terminology consistently.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858361", "createdAt": "2020-10-20T21:43:30Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ReceiverOptions.java", "diffHunk": "@@ -62,6 +75,15 @@ int getPrefetchCount() {\n         return prefetchCount;\n     }\n \n+    /**\n+     * Determine if client have enabled auto renew of message or session lock.\n+     *\n+     * @return true if  autoRenew is enabled; false otherwise.\n+     */\n+    boolean isAutoRenewEnabled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDgwOA==", "bodyText": "Don't think we need to log this as it's not very informative.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860808", "createdAt": "2020-10-20T21:48:38Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTQ4MQ==", "bodyText": "As discussed, we should categorize these errors into different error sources.\nhttps://github.com/Azure/azure-sdk-for-net/blob/master/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ServiceBusErrorSource.cs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508861481", "createdAt": "2020-10-20T21:49:58Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTU3NjYx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-513157661", "createdAt": "2020-10-20T21:43:42Z", "commit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Mzo0MlrOHlSQTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1NDozMFrOHlSkiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODQ0NQ==", "bodyText": "can this be static", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858445", "createdAt": "2020-10-20T21:43:42Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODU0Mw==", "bodyText": "consistent null checks?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858543", "createdAt": "2020-10-20T21:43:55Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODY3MA==", "bodyText": "you can do the assignment on the same line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858670", "createdAt": "2020-10-20T21:44:12Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODc3Mg==", "bodyText": "This can be verbose.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858772", "createdAt": "2020-10-20T21:44:25Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTAwNA==", "bodyText": "Informational?\nAlso, the underlying CoreSubscriber should do the dispose already. Do you need to explicitly do it?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508859004", "createdAt": "2020-10-20T21:44:57Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTM5Mw==", "bodyText": "This should be a warning other than an info?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508859393", "createdAt": "2020-10-20T21:45:46Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDE3OA==", "bodyText": "javadocs is incorrect. Same with the one on 654.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860178", "createdAt": "2020-10-20T21:47:20Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -669,8 +688,10 @@ public ServiceBusSessionReceiverClientBuilder maxConcurrentSessions(int maxConcu\n          * @param prefetchCount The prefetch count.\n          *\n          * @return The modified {@link ServiceBusSessionReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code prefetchCount} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDMzMg==", "bodyText": "Incorrect javadocs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860332", "createdAt": "2020-10-20T21:47:37Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDM5Mg==", "bodyText": "Incorrect javadocs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860392", "createdAt": "2020-10-20T21:47:44Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -845,8 +874,10 @@ private ServiceBusReceiverClientBuilder() {\n          * @param prefetchCount The prefetch count.\n          *\n          * @return The modified {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code prefetchCount} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDYzMA==", "bodyText": "This method is only used once. It can be pulled in here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860630", "createdAt": "2020-10-20T21:48:15Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoLockRenewDuration(Duration maxAutoLockRenewDuration) {\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDk1MQ==", "bodyText": "final?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860951", "createdAt": "2020-10-20T21:48:55Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -1068,8 +1084,9 @@ private ServiceBusAsyncConsumer getOrCreateConsumer() {\n         final ServiceBusReceiveLinkProcessor linkMessageProcessor = receiveLink.subscribeWith(\n             new ServiceBusReceiveLinkProcessor(receiverOptions.getPrefetchCount(), retryPolicy,\n                 receiverOptions.getReceiveMode()));\n-        final ServiceBusAsyncConsumer newConsumer = new ServiceBusAsyncConsumer(linkName, linkMessageProcessor,\n-            messageSerializer, receiverOptions.getPrefetchCount());\n+\n+        ServiceBusAsyncConsumer newConsumer = new ServiceBusAsyncConsumer(linkName, linkMessageProcessor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjEwNw==", "bodyText": "Should be consistent about adding ( around your lambdas. there are several down there that don't have it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862107", "createdAt": "2020-10-20T21:51:22Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjE3Ng==", "bodyText": "Same with other instances.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862176", "createdAt": "2020-10-20T21:51:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjEwNw=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjcwOQ==", "bodyText": "Is there any way to check that your renewal operations are cancelled on these messages?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862709", "createdAt": "2020-10-20T21:52:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzAyMw==", "bodyText": "The test above tests the same scenario. I'm not sure how Map makes a difference here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863023", "createdAt": "2020-10-20T21:53:12Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA==", "bodyText": "If you  mock this function, you can verify invocations it rather than keeping track.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863420", "createdAt": "2020-10-20T21:54:11Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator.map(serviceBusReceivedMessage -> expectedMappedValue))\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(expectedMappedValue, actual))\n+            .thenCancel()\n+            .verify();\n+    }\n+\n+    /**\n+     * Check that illegal values are not allowed in constructor.\n+     */\n+    @Test\n+    void illegalValueConstructor() {\n+        // Arrange, Act & Assert\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(null,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, null, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, null));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FluxAutoRenew(messageSource,\n+            DISABLE_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked. It will verify\n+     * 1. The renew lock function is invoked multiple times.\n+     * 2. The updated new lockedUntil is reflected on ServiceBusReceivedMessage object.\n+     */\n+    @Test\n+    void lockRenewedMultipleTimes() {\n+        // Arrange\n+        final int renewedForAtLeast = 3;\n+        final int totalProcessingTimeSeconds = 5;\n+        final AtomicInteger actualTokenRenewCalledTimes = new AtomicInteger();\n+        final Function<String, Mono<OffsetDateTime>> lockTokenRenewFunction = (lockToken) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzYyNQ==", "bodyText": "Also, you could have mocked the function in general instead of providing a concrete implementation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863625", "createdAt": "2020-10-20T21:54:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator.map(serviceBusReceivedMessage -> expectedMappedValue))\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(expectedMappedValue, actual))\n+            .thenCancel()\n+            .verify();\n+    }\n+\n+    /**\n+     * Check that illegal values are not allowed in constructor.\n+     */\n+    @Test\n+    void illegalValueConstructor() {\n+        // Arrange, Act & Assert\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(null,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, null, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, null));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FluxAutoRenew(messageSource,\n+            DISABLE_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked. It will verify\n+     * 1. The renew lock function is invoked multiple times.\n+     * 2. The updated new lockedUntil is reflected on ServiceBusReceivedMessage object.\n+     */\n+    @Test\n+    void lockRenewedMultipleTimes() {\n+        // Arrange\n+        final int renewedForAtLeast = 3;\n+        final int totalProcessingTimeSeconds = 5;\n+        final AtomicInteger actualTokenRenewCalledTimes = new AtomicInteger();\n+        final Function<String, Mono<OffsetDateTime>> lockTokenRenewFunction = (lockToken) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f536447cea355dfb7d2f13fd6f6f9c9903192061", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f536447cea355dfb7d2f13fd6f6f9c9903192061", "committedDate": "2020-10-21T08:13:57Z", "message": "More review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb1de592e10971a375acf93a3c60c9608b1f6917", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb1de592e10971a375acf93a3c60c9608b1f6917", "committedDate": "2020-10-21T08:37:17Z", "message": "Added check for receive and delete mode."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/450de935ac61d93fc19bd4c2403a6a462d70fbf9", "committedDate": "2020-10-21T19:50:40Z", "message": "Added test for multiple links creation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjA4NDc4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-514208478", "createdAt": "2020-10-21T21:43:16Z", "commit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTo0MzoxN1rOHmHJrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NjoyNFrOHmKnSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyNTEwMQ==", "bodyText": "Do you need this reference?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509725101", "createdAt": "2020-10-21T21:43:17Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTIxOQ==", "bodyText": "the parameter name is 'actual'", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779219", "createdAt": "2020-10-21T22:52:26Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTM1OA==", "bodyText": "nit: add new line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779358", "createdAt": "2020-10-21T22:52:36Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");\n+\n+        final LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    static final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = Objects.requireNonNull(actual, \"'downstream' cannot be null.\");\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+                \"'maxAutoLockRenewDuration' cannot be null.\");\n+        }\n+        /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTQ3Nw==", "bodyText": "nit: remove empty line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779477", "createdAt": "2020-10-21T22:52:45Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");\n+\n+        final LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTgzMw==", "bodyText": "My PR has this one level higher in ReceiverClient. Is there a constraining reason why? If we map this to one level higher, the onRenewLock doesn't have to be passed into the constructor for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509781833", "createdAt": "2020-10-21T22:56:24Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +29,27 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faf071a94e5bb976cd8bb2b3e338b8954e226bc3", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/faf071a94e5bb976cd8bb2b3e338b8954e226bc3", "committedDate": "2020-10-21T23:16:03Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c39689042daf7ebaaa177004bc700cdc583313dd", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c39689042daf7ebaaa177004bc700cdc583313dd", "committedDate": "2020-10-21T23:27:54Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3fbfa17393195019a2d46c769a3f159d4b6ab13", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3fbfa17393195019a2d46c769a3f159d4b6ab13", "committedDate": "2020-10-22T02:55:22Z", "message": "Moved FluxAutoLockRenew in receiver Client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e925b762be3e862e818decca7622bc4559a5c5c7", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e925b762be3e862e818decca7622bc4559a5c5c7", "committedDate": "2020-10-22T03:06:03Z", "message": "Moved FluxAutoLockRenew in receiver Client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "939166a7d9c40130ce96596cb3b8f79dbd8e87d9", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/939166a7d9c40130ce96596cb3b8f79dbd8e87d9", "committedDate": "2020-10-22T03:55:57Z", "message": "check style error fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzQ3ODI0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#pullrequestreview-514347824", "createdAt": "2020-10-22T04:17:33Z", "commit": {"oid": "c39689042daf7ebaaa177004bc700cdc583313dd"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDoxNzozM1rOHmP_zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDoxNzozM1rOHmP_zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg3MDAyOA==", "bodyText": "We should still append a random string to the name of the session to get a unique link name.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509870028", "createdAt": "2020-10-22T04:17:33Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -224,16 +224,21 @@ private AmqpErrorContext getErrorContext() {\n     }\n \n     /**\n-     * Creates an unnamed session receive link.\n+     * Creates an session receive link.\n      *\n-     * @return A Mono that completes with an unnamed session receive link.\n+     * @return A Mono that completes with an session receive link.\n      */\n     private Mono<ServiceBusReceiveLink> createSessionReceiveLink() {\n-        final String linkName = StringUtil.getRandomString(\"session-\");\n+        final String sessionId = receiverOptions.getSessionId();\n \n+        final String linkName = (sessionId != null)\n+            ? sessionId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39689042daf7ebaaa177004bc700cdc583313dd"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2110, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}