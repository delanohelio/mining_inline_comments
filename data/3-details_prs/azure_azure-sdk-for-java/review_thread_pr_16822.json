{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMjkwNjYw", "number": 16822, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1NDoxNFrOEyFV3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1NTozMVrOE3cggw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTUxNzcyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1NDoxNFrOHoh92w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMzozNFrOHwo6XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ==", "bodyText": "why aren't we capturing the exception stacktace?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261595", "createdAt": "2020-10-26T20:54:14Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzk5Nw==", "bodyText": "done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763997", "createdAt": "2020-11-10T18:03:34Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ=="}, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTUxODMzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1NDoyMVrOHoh-MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMzoyM1rOHwo56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA==", "bodyText": "ditto", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261680", "createdAt": "2020-10-26T20:54:21Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzg4MQ==", "bodyText": "done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763881", "createdAt": "2020-11-10T18:03:23Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA=="}, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTUzMDk3OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1Nzo1NFrOHoiF4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMzoxMFrOHwo5Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA==", "bodyText": "you are capturing the exception message twice.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512263648", "createdAt": "2020-10-26T20:57:54Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();\n+            }).onErrorResume(ex -> {\n+                logger.error(\"sendClientTelemetry() - Unable to send client telemetry\" +\n+                    \". Exception: {}\", ex.toString(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzc0Mg==", "bodyText": "removed extra message", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763742", "createdAt": "2020-11-10T18:03:10Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();\n+            }).onErrorResume(ex -> {\n+                logger.error(\"sendClientTelemetry() - Unable to send client telemetry\" +\n+                    \". Exception: {}\", ex.toString(), ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA=="}, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzMzNjQ2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoxNzozMVrOHqmbTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo0ODozNFrOHwoUpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw==", "bodyText": "I got this hashing from our existing partition key class, I could have done without (hash * 397) , thoughts ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514431823", "createdAt": "2020-10-29T17:17:31Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwMDM5NQ==", "bodyText": "The notion of 397 is - usually in hashCode() we take a prime number and then use that to generate hashCode.\nI will suggest to keep it.\nCan you also please check what IntelliJ generates when you generate the hashCode with it ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518300395", "createdAt": "2020-11-05T19:17:20Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}, "originalCommit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NDM0Mw==", "bodyText": "Oh I see, intellij with hash 397 generated 1474114674 and without it 1390251919. As you rightly mentioned it will help in better distribution of hash. So we are good with this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520754343", "createdAt": "2020-11-10T17:48:34Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}, "originalCommit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY4MTIyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozMDowNFrOHqzPyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTowMDowMVrOHtAQiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MTg2Nw==", "bodyText": "We need to tag it properly through external_dependencies.txt file - see the above external dependencies for examples on how to tag it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514641867", "createdAt": "2020-10-30T00:30:04Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjIwMw==", "bodyText": "done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952203", "createdAt": "2020-11-03T21:00:01Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MTg2Nw=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY4NDc0OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozMjoxMVrOHqzR8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTowMDoyMVrOHtARMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ==", "bodyText": "Please add java documentation to this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642419", "createdAt": "2020-10-30T00:32:11Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "diffHunk": "@@ -579,6 +580,11 @@ public CosmosClientBuilder multipleWriteRegionsEnabled(boolean multipleWriteRegi\n         return this;\n     }\n \n+    public CosmosClientBuilder clientTelemetryEnabled(boolean clientTelemetryEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjM2OQ==", "bodyText": "Thanks for this, done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952369", "createdAt": "2020-11-03T21:00:21Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "diffHunk": "@@ -579,6 +580,11 @@ public CosmosClientBuilder multipleWriteRegionsEnabled(boolean multipleWriteRegi\n         return this;\n     }\n \n+    public CosmosClientBuilder clientTelemetryEnabled(boolean clientTelemetryEnabled) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY4NjYwOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozMzoyOFrOHqzTEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTowMDoxMVrOHtAQ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA==", "bodyText": "This is great, thank you!\nPlease mention this issue in the PR as this API solves the github issue ask: #13488", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642704", "createdAt": "2020-10-30T00:33:28Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java", "diffHunk": "@@ -281,6 +281,22 @@ CosmosException setDiagnostics(CosmosDiagnostics cosmosDiagnostics) {\n         return this;\n     }\n \n+    /**\n+     * Gets the request charge as request units (RU) consumed by the operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjI5Mw==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952293", "createdAt": "2020-11-03T21:00:11Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java", "diffHunk": "@@ -281,6 +281,22 @@ CosmosException setDiagnostics(CosmosDiagnostics cosmosDiagnostics) {\n         return this;\n     }\n \n+    /**\n+     * Gets the request charge as request units (RU) consumed by the operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY4NzQyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozNDowNFrOHqzTmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo1MTowNVrOHuRldQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw==", "bodyText": "It is every 600 seconds / 10 minutes ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642843", "createdAt": "2020-10-30T00:34:04Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1Mjc5MQ==", "bodyText": "yes it is 10 min , representation 10*60 is more readable and i followed the existing model", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952791", "createdAt": "2020-11-03T21:01:15Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDY2MQ==", "bodyText": "Makes sense, thanks!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284661", "createdAt": "2020-11-05T18:51:05Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY5MTc3OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozNjoxMlrOHqzV-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo1MToyN1rOHuRmWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA==", "bodyText": "nit: What if the val is not a boolean value - this will throw an exception and might stop the application. Instead we should try catch it and just log the error and move forward with default value.\nAlso, this is an issue with other API as well - getIntValue()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643450", "createdAt": "2020-10-30T00:36:12Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1Mzk0OQ==", "bodyText": "If we pass any thing apart from true and false , it will return false. Below code from from Boolean class\n    public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; }\n public static boolean parseBoolean(String s) { return \"true\".equalsIgnoreCase(s); }", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516953949", "createdAt": "2020-11-03T21:03:42Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDg5MA==", "bodyText": "I see, cool, thanks!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284890", "createdAt": "2020-11-05T18:51:27Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY5MjU4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ConnectionPolicy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozNjo0N1rOHqzWdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTowNDozNlrOHtAZEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg==", "bodyText": "Please include clientTelemetryEnabled in toString() API", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643572", "createdAt": "2020-10-30T00:36:47Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ConnectionPolicy.java", "diffHunk": "@@ -497,6 +500,14 @@ public ConnectionPolicy setMaxRequestsPerConnection(int maxRequestsPerConnection\n         return this;\n     }\n \n+    public boolean isClientTelemetryEnabled() {\n+        return clientTelemetryEnabled;\n+    }\n+\n+    public void setClientTelemetryEnabled(boolean clientTelemetryEnabled) {\n+        this.clientTelemetryEnabled = clientTelemetryEnabled;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ConnectionPolicy{\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1NDM4Ng==", "bodyText": "Good catch , thanks", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516954386", "createdAt": "2020-11-03T21:04:36Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ConnectionPolicy.java", "diffHunk": "@@ -497,6 +500,14 @@ public ConnectionPolicy setMaxRequestsPerConnection(int maxRequestsPerConnection\n         return this;\n     }\n \n+    public boolean isClientTelemetryEnabled() {\n+        return clientTelemetryEnabled;\n+    }\n+\n+    public void setClientTelemetryEnabled(boolean clientTelemetryEnabled) {\n+        this.clientTelemetryEnabled = clientTelemetryEnabled;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ConnectionPolicy{\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY5NDAwOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozNzozOVrOHqzXSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTowNToxNlrOHtAatA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ==", "bodyText": "Why are we changing the scope of this API ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643785", "createdAt": "2020-10-30T00:37:39Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -121,18 +129,28 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n     public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n                                                                                    Context context,\n                                                                                    String spanName,\n+                                                                                   String containerId,\n                                                                                    String databaseId,\n-                                                                                   String endpoint) {\n-        return traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint,\n+                                                                                   CosmosAsyncClient client,\n+                                                                                   ConsistencyLevel consistencyLevel,\n+                                                                                   OperationType operationType,\n+                                                                                   ResourceType resourceType) {\n+\n+        return publisherWithClientTelemetry(resultPublisher, context, spanName, containerId, databaseId,\n+            BridgeInternal.getServiceEndpoint(client),\n+            client,\n+            consistencyLevel,\n+            operationType,\n+            resourceType,\n             CosmosItemResponse::getStatusCode);\n     }\n \n-    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n-                                             Context context,\n-                                             String spanName,\n-                                             String databaseId,\n-                                             String endpoint,\n-                                             Function<T, Integer> statusCodeFunc) {\n+    private <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1NDgwNA==", "bodyText": "This must be left public my mistake , not getting called from outside", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516954804", "createdAt": "2020-11-03T21:05:16Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -121,18 +129,28 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n     public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n                                                                                    Context context,\n                                                                                    String spanName,\n+                                                                                   String containerId,\n                                                                                    String databaseId,\n-                                                                                   String endpoint) {\n-        return traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint,\n+                                                                                   CosmosAsyncClient client,\n+                                                                                   ConsistencyLevel consistencyLevel,\n+                                                                                   OperationType operationType,\n+                                                                                   ResourceType resourceType) {\n+\n+        return publisherWithClientTelemetry(resultPublisher, context, spanName, containerId, databaseId,\n+            BridgeInternal.getServiceEndpoint(client),\n+            client,\n+            consistencyLevel,\n+            operationType,\n+            resourceType,\n             CosmosItemResponse::getStatusCode);\n     }\n \n-    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n-                                             Context context,\n-                                             String spanName,\n-                                             String databaseId,\n-                                             String endpoint,\n-                                             Function<T, Integer> statusCodeFunc) {\n+    private <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MDA5MTA5OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/pom.xml", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMjoxMTowMlrOHtCRYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo0ODo1NFrOH2zPJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA==", "bodyText": "Is this dependency meant for performance tests only? Right now this is being added as a compile time dependency.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516985184", "createdAt": "2020-11-03T22:11:02Z", "author": {"login": "alzimmermsft"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4ODE5Ng==", "bodyText": "This is not for test, we are using it to collect telemetry. We have analyzed other options like apache percentile , and this is the more optimize for our use case.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516988196", "createdAt": "2020-11-03T22:17:58Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1MzUyNw==", "bodyText": "@simplynaveen20  - you need to add the tag to this new library added, like this.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  <version>2.1.4</version>\n          \n          \n            \n                  <version>2.1.4</version> <!-- {x-version-update;cosmos_org.hdrhistogram:HdrHistogram;external_dependency} -->", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520853527", "createdAt": "2020-11-10T20:27:52Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1Mzg1OA==", "bodyText": "@alzimmermsft - do we have any issues with the use of this library ?\nCan we go ahead with the use of this ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520853858", "createdAt": "2020-11-10T20:28:34Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1NTE2NQ==", "bodyText": "Adding some more context Histogram isnot bringing any other library.\nAnd license they are using is \"bsd 2-clause license\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520855165", "createdAt": "2020-11-10T20:30:52Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTcxMA==", "bodyText": "There isn't a huge issue with on-boarding new compile/runtime dependencies. Generally, taking on new dependencies goes through a review to approve it, https://azure.github.io/azure-sdk/java_implementation.html#dependencies, with a reason on why it is required.\nSmall question on the dependency itself, why aren't we using the latest version of it? https://search.maven.org/artifact/org.hdrhistogram/HdrHistogram/2.1.12/bundle\ncc: @JonathanGiles", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520945710", "createdAt": "2020-11-10T23:45:03Z", "author": {"login": "alzimmermsft"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NTg5OQ==", "bodyText": "Thanks @alzimmermsft  for pointing out the lagging version , changed it to latest 2.1.12. I will sync offline for review and approval", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523045899", "createdAt": "2020-11-13T16:03:20Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNDYxNA==", "bodyText": "Got Jonathan's approval over email thread", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r527224614", "createdAt": "2020-11-19T21:48:54Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODQ2MDE1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo1Mzo0MlrOHuRreA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxNDoyMFrOHwr2Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA==", "bodyText": "when checking for throwable instanceof CosmosException, shouldn't we try to unwrap the exception in case the exception is of type ReactiveException ?\nSame for other places where we are checking throwable in doOnError blocks.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518286200", "createdAt": "2020-11-05T18:53:42Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NTYyNA==", "bodyText": "Idea here is to log the telemetry on every cosmos exception, irrespective of inner cause.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520755624", "createdAt": "2020-11-10T17:50:33Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjEwMg==", "bodyText": "I see, sounds good.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520812102", "createdAt": "2020-11-10T19:14:20Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODQ2ODg2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo1NjoxMFrOHuRxAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1MjozNVrOHwoe9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ==", "bodyText": "We also treat HttpConstants.StatusCodes.NOT_MODIFIED as success code in other places in the code. Shouldn't we include that here ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518287619", "createdAt": "2020-11-05T18:56:10Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1Njk4Mg==", "bodyText": "TracerProvider file will log only point operation, and 304 is for feed operation. So it will be redundant check. In cosmos page flux we create our own status code base on success and failure , it is not needed there also.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520756982", "createdAt": "2020-11-10T17:52:35Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODQ4MTM4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo1OTo0M1rOHuR5Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1MzoyMFrOHwogyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ==", "bodyText": "nit : This could be a private class if not used outside, if used outside, may be Compute can be its own class outside.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518289671", "createdAt": "2020-11-05T18:59:43Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {\n+    private Compute compute;\n+    public String getLocation() {\n+        return compute != null ? compute.getLocation() : null;\n+    }\n+\n+    public Compute getCompute() {\n+        return compute;\n+    }\n+\n+    public void setCompute(Compute compute) {\n+        this.compute = compute;\n+    }\n+\n+    static class Compute{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzQ0OA==", "bodyText": "Done, if in future we will use Compute exclusively , we will change it back to package private", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757448", "createdAt": "2020-11-10T17:53:20Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {\n+    private Compute compute;\n+    public String getLocation() {\n+        return compute != null ? compute.getLocation() : null;\n+    }\n+\n+    public Compute getCompute() {\n+        return compute;\n+    }\n+\n+    public void setCompute(Compute compute) {\n+        this.compute = compute;\n+    }\n+\n+    static class Compute{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODQ4NTc1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTowMDo1MVrOHuR7vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1MzozMlrOHwohUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA==", "bodyText": "Can you please add units to the name of this constant ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290364", "createdAt": "2020-11-05T19:00:51Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzU4Ng==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757586", "createdAt": "2020-11-10T17:53:32Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODQ4NzMyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTowMToxNVrOHuR8rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1MzozOVrOHwohmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw==", "bodyText": "Please add unit to the name of the constant.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290607", "createdAt": "2020-11-05T19:01:15Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzY1OA==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757658", "createdAt": "2020-11-10T17:53:39Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODUwNTU5OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTowNjozMFrOHuSICw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1OTo0NlrOHwoxOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ==", "bodyText": "I see, this is trace logging, while others are warning and info, is there a reason for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518293515", "createdAt": "2020-11-05T19:06:30Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTY1OQ==", "bodyText": "This is done intentionally, till the time we enable telemetry by default i don't want cx to get this log. Otherwise every customer will be getting this every 10 min , and might create a cri with question.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761659", "createdAt": "2020-11-10T17:59:46Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODUxODM2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTowOTo1OVrOHuSP_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxNDo0MVrOHwr3Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA==", "bodyText": "Are we doing recursion inside flatMap ?\nThere could be a better way to do this instead of doing it though flatMap- please take a look at expand operation from project reactor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518295548", "createdAt": "2020-11-05T19:09:59Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODc0NQ==", "bodyText": "This is in line with what we do in GlobalEndpointManager. Also expand is more applicable where we have values in stream and we want to do breath first or depth first recursion. In our case it is mono void.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520758745", "createdAt": "2020-11-10T17:55:17Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjMxOQ==", "bodyText": "Makes sense, thanks.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520812319", "createdAt": "2020-11-10T19:14:41Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODUzODk4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOToxNTo0NFrOHuSdHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1Njo0MVrOHwopXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ==", "bodyText": "where is that validation happening ?\nMay be worth mentioning here ?\nAlso, how do we plan to validate the keys specially in the set API for percentiles ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518298911", "createdAt": "2020-11-05T19:15:44Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1OTY0Ng==", "bodyText": "Removed the comment, it was the leftover from the initial contract discussion, it was more for BE service to validate the contract. Already passed this information to Vignesh", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520759646", "createdAt": "2020-11-10T17:56:41Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTA3MzU4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/cpu/CpuMemoryReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTozNjoxOVrOHuXmNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1Nzo0MFrOHworzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw==", "bodyText": "why can't we keep it double?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518383157", "createdAt": "2020-11-05T21:36:19Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/cpu/CpuMemoryReader.java", "diffHunk": "@@ -9,44 +9,56 @@\n \n import java.lang.management.ManagementFactory;\n \n-public class CpuReader {\n-    private final static Logger logger = LoggerFactory.getLogger(CpuReader.class);\n+public class CpuMemoryReader {\n+    private final static Logger logger = LoggerFactory.getLogger(CpuMemoryReader.class);\n     private final com.sun.management.OperatingSystemMXBean operatingSystemMXBean;\n \n-    public CpuReader() {\n+    public CpuMemoryReader() {\n         java.lang.management.OperatingSystemMXBean mxBean = null;\n         try {\n             mxBean =\n                 ManagementFactory.getOperatingSystemMXBean();\n         } catch (Throwable t) {\n-            logger.error(\"failed to initialized CpuReader\", t);\n+            logger.error(\"failed to initialized CpuMemoryReader\", t);\n         }\n \n         this.operatingSystemMXBean = tryGetAs(mxBean,\n             com.sun.management.OperatingSystemMXBean.class);\n     }\n \n-    public double getSystemWideCpuUsage() {\n+    public float getSystemWideCpuUsage() {\n         try {\n             if (operatingSystemMXBean != null) {\n-                double val = operatingSystemMXBean.getSystemCpuLoad();\n+                float val = (float) operatingSystemMXBean.getSystemCpuLoad();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MDI3MQ==", "bodyText": "We want to keep the size as low as possible, float give 6 to 7 place of decimal value , more than enough for us to measure cpu percentage.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520760271", "createdAt": "2020-11-10T17:57:40Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/cpu/CpuMemoryReader.java", "diffHunk": "@@ -9,44 +9,56 @@\n \n import java.lang.management.ManagementFactory;\n \n-public class CpuReader {\n-    private final static Logger logger = LoggerFactory.getLogger(CpuReader.class);\n+public class CpuMemoryReader {\n+    private final static Logger logger = LoggerFactory.getLogger(CpuMemoryReader.class);\n     private final com.sun.management.OperatingSystemMXBean operatingSystemMXBean;\n \n-    public CpuReader() {\n+    public CpuMemoryReader() {\n         java.lang.management.OperatingSystemMXBean mxBean = null;\n         try {\n             mxBean =\n                 ManagementFactory.getOperatingSystemMXBean();\n         } catch (Throwable t) {\n-            logger.error(\"failed to initialized CpuReader\", t);\n+            logger.error(\"failed to initialized CpuMemoryReader\", t);\n         }\n \n         this.operatingSystemMXBean = tryGetAs(mxBean,\n             com.sun.management.OperatingSystemMXBean.class);\n     }\n \n-    public double getSystemWideCpuUsage() {\n+    public float getSystemWideCpuUsage() {\n         try {\n             if (operatingSystemMXBean != null) {\n-                double val = operatingSystemMXBean.getSystemCpuLoad();\n+                float val = (float) operatingSystemMXBean.getSystemCpuLoad();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTA4MjcyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTozODo1OVrOHuXroA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1ODowNVrOHwos5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA==", "bodyText": "I wonder why we can't keep it double in the client telemetry as well ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518384544", "createdAt": "2020-11-05T21:38:59Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -125,11 +139,103 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n                 pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable),\n                     TracerProvider.ERROR_CODE);\n             }\n+\n+            if (pagedFluxOptions.getCosmosAsyncClient() != null &&\n+                Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(pagedFluxOptions.getCosmosAsyncClient())) &&\n+                throwable instanceof CosmosException) {\n+                CosmosException cosmosException = (CosmosException) throwable;\n+                fillClientTelemetry(pagedFluxOptions.getCosmosAsyncClient(), 0, pagedFluxOptions.getContainerId(),\n+                    pagedFluxOptions.getDatabaseId(),\n+                    pagedFluxOptions.getOperationType(), pagedFluxOptions.getResourceType(),\n+                    BridgeInternal.getContextClient(pagedFluxOptions.getCosmosAsyncClient()).getConsistencyLevel(),\n+                    (float) cosmosException.getRequestCharge(), Duration.between(startTime.get(), Instant.now()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MDU0OQ==", "bodyText": "We want to keep the size as low as possible, float give 6 to 7 place of decimal value , more than enough for us to measure request charge.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520760549", "createdAt": "2020-11-10T17:58:05Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -125,11 +139,103 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n                 pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable),\n                     TracerProvider.ERROR_CODE);\n             }\n+\n+            if (pagedFluxOptions.getCosmosAsyncClient() != null &&\n+                Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(pagedFluxOptions.getCosmosAsyncClient())) &&\n+                throwable instanceof CosmosException) {\n+                CosmosException cosmosException = (CosmosException) throwable;\n+                fillClientTelemetry(pagedFluxOptions.getCosmosAsyncClient(), 0, pagedFluxOptions.getContainerId(),\n+                    pagedFluxOptions.getDatabaseId(),\n+                    pagedFluxOptions.getOperationType(), pagedFluxOptions.getResourceType(),\n+                    BridgeInternal.getContextClient(pagedFluxOptions.getCosmosAsyncClient()).getConsistencyLevel(),\n+                    (float) cosmosException.getRequestCharge(), Duration.between(startTime.get(), Instant.now()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTU2NzI2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMDo0NjowMlrOHucIsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMjo1MVrOHwo4vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ==", "bodyText": "is this accessed from multiple threads?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518457521", "createdAt": "2020-11-06T00:46:02Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MzU4Mg==", "bodyText": "removed the object creation from here. This is getting created in a single thread every 10 min in client telemetry, so we don't need concurrency.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763582", "createdAt": "2020-11-10T18:02:51Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTU3MTE2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMDo0Nzo1MFrOHucK9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMDoyOFrOHwoy-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw==", "bodyText": "please use log instead of e.printSTackTrace", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458103", "createdAt": "2020-11-06T00:47:50Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MjEwNA==", "bodyText": "done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520762104", "createdAt": "2020-11-10T18:00:28Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTU3NDYyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMDo0OTo0MlrOHucNFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMDoxOFrOHwoyhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA==", "bodyText": "ideally we should use daemon threads otherwise if executor is not shutdown correctly JVM will not terminate.\nTake a look at how rntbd sets up its daemon IO threads.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458644", "createdAt": "2020-11-06T00:49:42Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTk4OA==", "bodyText": "done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761988", "createdAt": "2020-11-10T18:00:18Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0OTU3NzE1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMDo1MDo1NVrOHucOhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowMDoxMlrOHwoyQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ==", "bodyText": "constant?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518459015", "createdAt": "2020-11-06T00:50:55Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_CHARGE_NAME, ClientTelemetry.REQUEST_CHARGE_UNIT);\n+        ConcurrentDoubleHistogram requestChargeHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadRequestCharge);\n+        if (requestChargeHistogram != null) {\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+        } else {\n+            requestChargeHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_CHARGE_MAX, ClientTelemetry.REQUEST_CHARGE_PRECISION);\n+            requestChargeHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadRequestCharge,\n+                requestChargeHistogram);\n+        }\n+    }\n+\n+    private ReportPayload createReportPayload(CosmosAsyncClient cosmosAsyncClient,\n+                                              CosmosDiagnostics cosmosDiagnostics,\n+                                              int statusCode,\n+                                              Integer objectSize,\n+                                              String containerId,\n+                                              String databaseId,\n+                                              OperationType operationType,\n+                                              ResourceType resourceType,\n+                                              ConsistencyLevel consistencyLevel,\n+                                              String metricsName,\n+                                              String unitName) {\n+        ReportPayload reportPayload = new ReportPayload(metricsName, unitName);\n+        reportPayload.setRegionsContacted(BridgeInternal.getRegionContacted(cosmosDiagnostics).toString());\n+        reportPayload.setConsistency(consistencyLevel == null ?\n+            BridgeInternal.getContextClient(cosmosAsyncClient).getConsistencyLevel() :\n+            consistencyLevel);\n+        if (objectSize != null) {\n+            reportPayload.setGreaterThan1Kb(objectSize > 1024);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTkyMA==", "bodyText": "done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761920", "createdAt": "2020-11-10T18:00:12Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_CHARGE_NAME, ClientTelemetry.REQUEST_CHARGE_UNIT);\n+        ConcurrentDoubleHistogram requestChargeHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadRequestCharge);\n+        if (requestChargeHistogram != null) {\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+        } else {\n+            requestChargeHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_CHARGE_MAX, ClientTelemetry.REQUEST_CHARGE_PRECISION);\n+            requestChargeHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadRequestCharge,\n+                requestChargeHistogram);\n+        }\n+    }\n+\n+    private ReportPayload createReportPayload(CosmosAsyncClient cosmosAsyncClient,\n+                                              CosmosDiagnostics cosmosDiagnostics,\n+                                              int statusCode,\n+                                              Integer objectSize,\n+                                              String containerId,\n+                                              String databaseId,\n+                                              OperationType operationType,\n+                                              ResourceType resourceType,\n+                                              ConsistencyLevel consistencyLevel,\n+                                              String metricsName,\n+                                              String unitName) {\n+        ReportPayload reportPayload = new ReportPayload(metricsName, unitName);\n+        reportPayload.setRegionsContacted(BridgeInternal.getRegionContacted(cosmosDiagnostics).toString());\n+        reportPayload.setConsistency(consistencyLevel == null ?\n+            BridgeInternal.getContextClient(cosmosAsyncClient).getConsistencyLevel() :\n+            consistencyLevel);\n+        if (objectSize != null) {\n+            reportPayload.setGreaterThan1Kb(objectSize > 1024);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ=="}, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTY1NTc4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNTozOFrOHwyCAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNjowMDo1NVrOHy0GXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzQwOA==", "bodyText": "I believe the cosmos_ prefix is necessary in this tag as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520913408", "createdAt": "2020-11-10T22:25:38Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -232,6 +236,7 @@ Licensed under the MIT License.\n                 <include>io.dropwizard.metrics:metrics-core:[4.1.0]</include> <!-- {x-include-update;cosmos_io.dropwizard.metrics:metrics-core;external_dependency} -->\n                 <include>io.micrometer:micrometer-core:[1.5.6]</include> <!-- {x-include-update;io.micrometer:micrometer-core;external_dependency} -->\n                 <include>org.slf4j:slf4j-api:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-api;external_dependency} -->\n+                <include>org.hdrhistogram:HdrHistogram</include> <!-- {x-include-update;org.hdrhistogram:HdrHistogram;external_dependency} -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNjYzMA==", "bodyText": "Good catch, yes it is required.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520916630", "createdAt": "2020-11-10T22:32:49Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -232,6 +236,7 @@ Licensed under the MIT License.\n                 <include>io.dropwizard.metrics:metrics-core:[4.1.0]</include> <!-- {x-include-update;cosmos_io.dropwizard.metrics:metrics-core;external_dependency} -->\n                 <include>io.micrometer:micrometer-core:[1.5.6]</include> <!-- {x-include-update;io.micrometer:micrometer-core;external_dependency} -->\n                 <include>org.slf4j:slf4j-api:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-api;external_dependency} -->\n+                <include>org.hdrhistogram:HdrHistogram</include> <!-- {x-include-update;org.hdrhistogram:HdrHistogram;external_dependency} -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzQwOA=="}, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDQ0NQ==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044445", "createdAt": "2020-11-13T16:00:55Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -232,6 +236,7 @@ Licensed under the MIT License.\n                 <include>io.dropwizard.metrics:metrics-core:[4.1.0]</include> <!-- {x-include-update;cosmos_io.dropwizard.metrics:metrics-core;external_dependency} -->\n                 <include>io.micrometer:micrometer-core:[1.5.6]</include> <!-- {x-include-update;io.micrometer:micrometer-core;external_dependency} -->\n                 <include>org.slf4j:slf4j-api:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-api;external_dependency} -->\n+                <include>org.hdrhistogram:HdrHistogram</include> <!-- {x-include-update;org.hdrhistogram:HdrHistogram;external_dependency} -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzQwOA=="}, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTY3MDM2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjozMDozN1rOHwyKxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNjowMDo0OVrOHy0GDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw==", "bodyText": "Should be getRegionsContacted?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520915653", "createdAt": "2020-11-10T22:30:37Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -70,6 +73,26 @@ public static CosmosDiagnostics createCosmosDiagnostics(DiagnosticsClientContext\n         return new CosmosDiagnostics(diagnosticsClientContext);\n     }\n \n+    @Warning(value = INTERNAL_USE_ONLY_WARNING)\n+    public static Set<URI> getRegionContacted(CosmosDiagnostics cosmosDiagnostics) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDM2NQ==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044365", "createdAt": "2020-11-13T16:00:49Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -70,6 +73,26 @@ public static CosmosDiagnostics createCosmosDiagnostics(DiagnosticsClientContext\n         return new CosmosDiagnostics(diagnosticsClientContext);\n     }\n \n+    @Warning(value = INTERNAL_USE_ONLY_WARNING)\n+    public static Set<URI> getRegionContacted(CosmosDiagnostics cosmosDiagnostics) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw=="}, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTcyMDU0OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo0Nzo1MlrOHwyo0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNjowMDozN1rOHy0FlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA==", "bodyText": "300 instead - to stick with 5 minutes which we used everywhere else? We can adjust if needed - but why not start with the default that works reasonably well in other places?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520923344", "createdAt": "2020-11-10T22:47:52Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDI0NA==", "bodyText": "Discussed offline, will go with 10 minutes , and eventually will move to 5 min when we have answer where will be the endpoint", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044244", "createdAt": "2020-11-13T16:00:37Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA=="}, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTczNjA1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1MzoyMlrOHwyyDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNTo1OTo1NFrOHy0DtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA==", "bodyText": "I think the right groups here are\n200 - 299 --> success\n400 - 499 --> client_failure\n\n= 500 --> service failure", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925708", "createdAt": "2020-11-10T22:53:22Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0Mzc2NA==", "bodyText": "Discussed offline, changed success scenario to cover status code between 200-299", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523043764", "createdAt": "2020-11-13T15:59:54Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA=="}, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTczNzMzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1Mzo1MVrOHwyy2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1Mzo1MVrOHwyy2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTkxMw==", "bodyText": "NIT ',' at teh end of the line", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925913", "createdAt": "2020-11-10T22:53:51Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTc0MjExOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1NTozMVrOHwy1qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNTo1OToxNlrOHy0CFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ==", "bodyText": "VM SKU woudl be very helpful as well?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520926635", "createdAt": "2020-11-10T22:55:31Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0MzM0OQ==", "bodyText": "Discussed offline , added hostEnvInfo in format \"Linux|18.04-LTS|Standard_F4s|AzurePublicCloud\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523043349", "createdAt": "2020-11-13T15:59:16Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ=="}, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3856, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}