{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExOTk2OTgz", "number": 10660, "title": "Add Schema Registry Client SDK", "bodyText": "Hey Azure SDK folks - here's the initial add of the Schema Registry SDK.  Currently does not contain authorization component.\nThis PR contains no changes to EH Track 2 SDK, and has no references or changes to any Azure core code.\nWill be working with Srikanta to get required infrastructure set up.", "createdAt": "2020-05-01T05:58:32Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660", "merged": true, "mergeCommit": {"oid": "6763415975a0c4c5f6e501f761c9c01615cdd803"}, "closed": true, "closedAt": "2020-05-30T19:07:12Z", "author": {"login": "arerlend"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc7KWeAH2gAyNDExOTk2OTgzOjI5ZjdmNmMwMTMwNDYzZTE2YmI2NDNhNmIzZjBlMjczNzVlYmVkNTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmLVeagFqTQyMTM1MTY0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/29f7f6c0130463e16bb643a6b3f0e27375ebed50", "committedDate": "2020-05-01T05:51:40Z", "message": "init"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MTI5MTA1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-404129105", "createdAt": "2020-05-01T12:02:41Z", "commit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMjowMjo0MVrOGPIICQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMzowNToyN1rOGPJMdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxNDk1Mw==", "bodyText": "Use .gitignore file located at the root of the repository. This file can be removed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418514953", "createdAt": "2020-05-01T12:02:41Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/.gitignore", "diffHunk": "@@ -0,0 +1,49 @@\n+# Compiled class file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxODI0MQ==", "bodyText": "All track 2 modules should use the same parent located at sdk/parents/azure-client-sdk-parent/\n<parent>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-client-sdk-parent</artifactId>\n    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n  </parent>", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418518241", "createdAt": "2020-05-01T12:16:38Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxODc4Ng==", "bodyText": "Use beta instead of preview since Maven repository doesn't sort correctly if preview is used. Versions for new modules should start from 1.0.0-beta.1.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418518786", "createdAt": "2020-05-01T12:18:48Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxOTM3MQ==", "bodyText": "This can be removed. Source and target version will be defined in the parent.\nSidenote: the baseline is JDK 8, but we also build with JDK 11 to support some new features added since Java 8.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418519371", "createdAt": "2020-05-01T12:21:02Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>\n+  <name>schemaregistry-client</name>\n+\n+  <properties>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+  </properties>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMDA4OA==", "bodyText": "All dependency versions should have a version tag to help automate version upgrades. See storage blob pom or any other track 2 poms to see how to add a tag.\nFor internal dependencies, versions are declared in version_client.txt\nFor external dependencies, versions are declared in external_dependencies.txt", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418520088", "createdAt": "2020-05-01T12:23:44Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>\n+  <name>schemaregistry-client</name>\n+\n+  <properties>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+  </properties>\n+  \n+  <dependencies>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>3.8.1</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMTI0Nw==", "bodyText": "Use Mockito instead of easymock for mocking library as that's the one used across most of the track 2 libraries.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418521247", "createdAt": "2020-05-01T12:28:15Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>\n+  <name>schemaregistry-client</name>\n+\n+  <properties>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+  </properties>\n+  \n+  <dependencies>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>3.8.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.easymock</groupId>\n+      <artifactId>easymock</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjE2Mw==", "bodyText": "Adding azure-core will bring jackson and slf4j dependencies transitively.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522163", "createdAt": "2020-05-01T12:31:35Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>\n+  <name>schemaregistry-client</name>\n+\n+  <properties>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+  </properties>\n+  \n+  <dependencies>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>3.8.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.easymock</groupId>\n+      <artifactId>easymock</artifactId>\n+      <version>4.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.core</groupId>\n+      <artifactId>jackson-databind</artifactId>\n+      <version>2.10.2</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjI5Nw==", "bodyText": "ClientLogger defined in azure-core should be used for logging.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522297", "createdAt": "2020-05-01T12:32:09Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.schemaregistry.client.rest.RestService;\n+import com.azure.schemaregistry.client.rest.entities.responses.SchemaObjectResponse;\n+import com.azure.schemaregistry.client.rest.exceptions.RestClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ *\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ *\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SRObject cache by GUID - accessed when consuming, store GUIDs previously seen in payloads\n+ * - SRObject cache by schema string - accessed when sending, minimizes HTTP calls when payloads of same schema\n+ *\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClient.Builder Follows static builder pattern for object instantiation\n+ */\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private static final Logger log = LoggerFactory.getLogger(CachedSchemaRegistryClient.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjUzMA==", "bodyText": "License text should be:\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522530", "createdAt": "2020-05-01T12:32:54Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjk1NQ==", "bodyText": "Each package should also include a package-info.java. See an example here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522955", "createdAt": "2020-05-01T12:34:11Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMzMyNw==", "bodyText": "Mocks should be in src/test/java", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418523327", "createdAt": "2020-05-01T12:35:23Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class MockSchemaRegistryClient implements SchemaRegistryClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNDMyNw==", "bodyText": "Consider naming this as SchemaRegistryObject instead. See naming patterns", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418524327", "createdAt": "2020-05-01T12:38:51Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/SRObject.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.schemaregistry.client.rest.RestService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ *\n+ * @param <T> is derived from the parser function that is passed in the constructor.\n+ */\n+public class SRObject<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNTk0Mw==", "bodyText": "This won't be required when all modules inherit from track2 parent pom.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418525943", "createdAt": "2020-05-01T12:44:19Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/pom.xml", "diffHunk": "@@ -0,0 +1,45 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <groupId>com.azure</groupId>\n+  <version>0.5-preview</version>\n+  <artifactId>schemaregistry-parent</artifactId>\n+  <packaging>pom</packaging>\n+  <name>schemaregistry-parent</name>\n+\n+  <modules>\n+    <module>client</module>\n+    <module>serde</module>\n+    <module>codec</module>\n+  </modules>\n+\n+  <properties>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <jackson.version>2.10.2</jackson.version>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>org.slf4j</groupId>\n+        <artifactId>slf4j-api</artifactId>\n+        <version>1.7.30</version>\n+        <scope>compile</scope>\n+      </dependency>\n+      <dependency>\n+        <groupId>junit</groupId>\n+        <artifactId>junit</artifactId>\n+        <version>3.8.1</version>\n+        <scope>test</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNjYyMg==", "bodyText": "Artifact names should follow the naming pattern of azure-<group>-<service> - see naming guidelines", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418526622", "createdAt": "2020-05-01T12:46:34Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNzA5Ng==", "bodyText": "Each pom should have distributionManagement and scm sections.\n  <distributionManagement>\n    <site>\n      <id>azure-java-build-docs</id>\n      <url>${site.url}/site/${project.artifactId}</url>\n    </site>\n  </distributionManagement>\n\n  <scm>\n    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n    <tag>HEAD</tag>\n  </scm>", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418527096", "createdAt": "2020-05-01T12:48:16Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>\n+  <name>schemaregistry-client</name>\n+\n+  <properties>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+  </properties>\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNzY2Mw==", "bodyText": "Include name, description and url:\n<name>Microsoft Azure client library for [client library name]</name>\n<description>This package contains the Microsoft Azure [name] client library.</description>\n<url>https://github.com/Azure/azure-sdk-for-java</url>", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418527663", "createdAt": "2020-05-01T12:50:14Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/pom.xml", "diffHunk": "@@ -0,0 +1,49 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>schemaregistry-parent</artifactId>\n+    <version>0.5-preview</version>\n+  </parent>\n+\n+  <artifactId>schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>0.5-preview</version>\n+  <name>schemaregistry-client</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyODIwMw==", "bodyText": "Add module-info.java for all new modules.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418528203", "createdAt": "2020-05-01T12:51:54Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyOTk1Nw==", "bodyText": "azure-core has an HTTP client interface that should be used for making REST calls. We have 3 pluggable HTTP client implementations - Netty, OkHttp and JDK 11 HTTP client.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418529957", "createdAt": "2020-05-01T12:57:44Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/rest/RestService.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client.rest;\n+\n+import com.azure.schemaregistry.client.rest.entities.ErrorMessage;\n+import com.azure.schemaregistry.client.rest.entities.responses.RegisterSchemaResponse;\n+import com.azure.schemaregistry.client.rest.entities.responses.SchemaObjectResponse;\n+import com.azure.schemaregistry.client.rest.exceptions.RestClientException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSocketFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMTA1Mw==", "bodyText": "Clients have to be concrete classes instantiated from ClientBuilders. See guidelines on creating service clients. Also, add the necessary annotations.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418531053", "createdAt": "2020-05-01T13:01:01Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ *  Interface that defines operation for registering and fetching schemas and schema information to and from a\n+ *  schema registry store.\n+ */\n+public interface SchemaRegistryClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMjQ2OQ==", "bodyText": "Do you have a service swagger that can be used to generate clients using autorest?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418532469", "createdAt": "2020-05-01T13:05:27Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/rest/entities/responses/RegisterSchemaResponse.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client.rest.entities.responses;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.io.IOException;\n+\n+public class RegisterSchemaResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MzYwMzQ5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-415360349", "createdAt": "2020-05-20T13:54:59Z", "commit": {"oid": "3af70ffdce19ed272073d4102a717bc673d89210"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba86f027a0a2e124aae3fcdc417bedc75393db98", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ba86f027a0a2e124aae3fcdc417bedc75393db98", "committedDate": "2020-05-22T00:23:03Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e94edfd3863ce656887c0af5b5bb37eb8e14d19", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4e94edfd3863ce656887c0af5b5bb37eb8e14d19", "committedDate": "2020-05-22T00:24:06Z", "message": "remove kafka"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54d5ad837bedb3b753f770a300ad1c1a218c9848", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/54d5ad837bedb3b753f770a300ad1c1a218c9848", "committedDate": "2020-05-22T00:24:07Z", "message": "azure- artifact ids"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98ce87d6e289725830d190e2b71c71e0ec7bc4f1", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/98ce87d6e289725830d190e2b71c71e0ec7bc4f1", "committedDate": "2020-05-22T00:24:07Z", "message": "azure-core + version change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21b663dd43d0355c9411d56a0bc62e4e3609b52a", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21b663dd43d0355c9411d56a0bc62e4e3609b52a", "committedDate": "2020-05-22T00:24:07Z", "message": "progress snapshot before swapping autorest client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be646ab8560d73d83dc7eaff8944c4217d7b58bb", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/be646ab8560d73d83dc7eaff8944c4217d7b58bb", "committedDate": "2020-05-22T00:24:07Z", "message": "swagger generated http client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa8f89c9752d6c47f747a78e7daac35fa372fd2", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fa8f89c9752d6c47f747a78e7daac35fa372fd2", "committedDate": "2020-05-22T00:24:07Z", "message": "update common package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "305ffa56f78e370864f606629efbc6d56c34b127", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/305ffa56f78e370864f606629efbc6d56c34b127", "committedDate": "2020-05-22T00:24:08Z", "message": "junit engine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eb5a2f353cf28486485ed3119b86e69c96a2fa8", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7eb5a2f353cf28486485ed3119b86e69c96a2fa8", "committedDate": "2020-05-22T00:26:11Z", "message": "fix versioning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e13f670dd838a875fe52555fc5609c01bd896ae5", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e13f670dd838a875fe52555fc5609c01bd896ae5", "committedDate": "2020-05-22T00:26:12Z", "message": "javadoc checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59c1c07d195d29336b245b125d1525f244457685", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/59c1c07d195d29336b245b125d1525f244457685", "committedDate": "2020-05-22T00:26:12Z", "message": "javadoc checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "492a77ed646237e05b9872a9477a3e521e80c4d6", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/492a77ed646237e05b9872a9477a3e521e80c4d6", "committedDate": "2020-05-22T00:26:12Z", "message": "checkstyle javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07fcff11aa494af2aaad61c7d67e4d701eb69acc", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/07fcff11aa494af2aaad61c7d67e4d701eb69acc", "committedDate": "2020-05-22T00:26:13Z", "message": "spotbugs override for serializing null value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16ec23e54235c372cba9295cb98394f30da15d2a", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/16ec23e54235c372cba9295cb98394f30da15d2a", "committedDate": "2020-05-22T00:33:48Z", "message": "add service client annotation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6b56a8ea6815d7797f6e4f7719aa8308a6b0f9b", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a6b56a8ea6815d7797f6e4f7719aa8308a6b0f9b", "committedDate": "2020-05-22T00:41:53Z", "message": "service client style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "309b0bb4ef849caa33c85527eb138e4a9487517e", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/309b0bb4ef849caa33c85527eb138e4a9487517e", "committedDate": "2020-05-22T02:06:29Z", "message": "fix dep management tags"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51db740b3fdc1a7be446361a547ed187b2fcdc0e", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/51db740b3fdc1a7be446361a547ed187b2fcdc0e", "committedDate": "2020-05-22T05:00:19Z", "message": "add module-info and initial readme"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7492f737a61d0151097267692e9e7aeee62b4ab9", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7492f737a61d0151097267692e9e7aeee62b4ab9", "committedDate": "2020-05-22T05:36:45Z", "message": "add readme sections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1ac6c6a8cebe93b9ceca251c19d925b3c1fdd5d", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1ac6c6a8cebe93b9ceca251c19d925b3c1fdd5d", "committedDate": "2020-05-22T05:44:34Z", "message": "fix readme section case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47dba954784ff3b90784ed5e7aee231ca36c26c9", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/47dba954784ff3b90784ed5e7aee231ca36c26c9", "committedDate": "2020-05-22T19:15:27Z", "message": "add src clients to jacoco"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "198a0304094ecdabffc951af5763ee30c6539d11", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/198a0304094ecdabffc951af5763ee30c6539d11", "committedDate": "2020-05-22T19:33:01Z", "message": "add latest swagger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24381c0ddcfa41338502bf12181deb5c33688d42", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/24381c0ddcfa41338502bf12181deb5c33688d42", "committedDate": "2020-05-22T22:59:15Z", "message": "add basic readme intros"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "committedDate": "2020-05-26T16:01:48Z", "message": "Merge branch 'master' into arerlend.src"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDk1MTM2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-418495136", "createdAt": "2020-05-26T16:54:50Z", "commit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjo1NDo1MVrOGank5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTo1NDowNFrOGauDow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NDU4MQ==", "bodyText": "Don't need to add implementation details about which Map type we are using since this may change over time. Added in some explanation on how to set the maximum map size along with the default value that will be used.\nChanges some HTML formatting for the maps that are maintained explanation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Utilizes in-memory HashMap caching to minimize network I/O.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Max HashMap size can be configured when instantiating.\n          \n          \n            \n             * Two maps are maintained -\n          \n          \n            \n             * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n          \n          \n            \n             * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n          \n          \n            \n             * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Two maps are maintained.\n          \n          \n            \n             * <ul>\n          \n          \n            \n             * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n          \n          \n            \n             * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n          \n          \n            \n             * </ul>", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430564581", "createdAt": "2020-05-26T16:54:51Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NzIxMA==", "bodyText": "Should place TODO comments outside of Javadocs, I would move this above the Javadoc as the following:\n// TODO (<your alias>): implement max age for schema mapls? or will schemas always be immutable?\nThe reason to move this outside of the Javadocs is two-fold, we won't accidentally ship Javadocs with TODO comments generated into them and some IDEs will add in highlighting for TODO comments that will make them more noticeable.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430567210", "createdAt": "2020-05-26T16:58:52Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTE4MQ==", "bodyText": "Generally, client builders use empty parameter constructors. Another benefit of setting scheamRegistryUrl with a method would allow for more general configurations like HttpPipeline, log options, etc, to be set once and different registries could be passed to build multiple clients.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430571181", "createdAt": "2020-05-26T17:05:40Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTU4MA==", "bodyText": "Should these checks be moved into the building instead of the client constructor?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430571580", "createdAt": "2020-05-26T17:06:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjMxNw==", "bodyText": "Given that this is a default value does this need to be public? Should this be used in place when no value is passed for max map size?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430572317", "createdAt": "2020-05-26T17:07:37Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MzEzNg==", "bodyText": "Does this need to be public? Would a user of the library leverage this constant or is it for internal usage in the SDK?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430573136", "createdAt": "2020-05-26T17:09:02Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDA2NQ==", "bodyText": "Azure Core has a CoreUtils.isNullOrEmpty which covers these checks. Doesn't need to be used but centralizes the logic.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430574065", "createdAt": "2020-05-26T17:10:46Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDcyOQ==", "bodyText": "Is Locale.ENGLISH safe to use when this library goes public.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430574729", "createdAt": "2020-05-26T17:11:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NzI0MA==", "bodyText": "Should typeParserDictionary use a ConcurrentHashMap? I'm seeing that it gets used in a synchronized manner and ConcurrentHashMap could handle that internally. In one place I see checking if the map contains the key already and throwing if it does, this could be replaced with putIfAbsent and checking if the return is not null.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#putIfAbsent-K-V-", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430577240", "createdAt": "2020-05-26T17:16:14Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzNDY4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n          \n          \n            \n                                String.format(\"Max schema map size must be greater than %d.\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430634688", "createdAt": "2020-05-26T18:53:14Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzNTY1MQ==", "bodyText": "The logger APIs will use SLF4J's string formatting which is lazy compared to String.format, it uses a general {} instead of type specific formatting like %s or %d. Where possible look to update to using this instead as it will reduce CPU time on formatting strings that may not get used due to log level configuration.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.verbose(\n          \n          \n            \n                        String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));\n          \n          \n            \n                    logger.verbose(\n          \n          \n            \n                        \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430635651", "createdAt": "2020-05-26T18:54:51Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTI2NQ==", "bodyText": "Has a least recently used cache been thought about? Instead of clearing everything when we hit the limit just begin prune stale entries. Current logic will work but for hot path schemas they'll need to go make a network call when this case happens.\nOverall, this doesn't need to be prioritized now as 1000 entries, by default, seems to be a lot of head space.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430639265", "createdAt": "2020-05-26T19:01:00Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(\n+            schemaString,\n+            new SchemaRegistryObject(\n+                schemaId.getId(),\n+                schemaType,\n+                schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+                getParseFunc(schemaType)));\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return schemaId.getId();\n+    }\n+\n+    @Override\n+    public String deleteSchemaVersion(String schemaGroup, String schemaName, int version)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, version);\n+        // remove from cache\n+        return null;\n+    }\n+\n+    @Override\n+    public String deleteLatestSchemaVersion(String schemaGroup, String schemaName)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, null);\n+        // remove from cache\n+        return null;\n+    }\n+\n+    @Override\n+    public List<String> deleteSchema(String schemaGroup, String schemaName)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchema();\n+        // remove from cache\n+        return null;\n+    }\n+\n+    /**\n+     * Explicit call to clear all caches.\n+     */\n+    public synchronized void reset() {\n+        guidCache.clear();\n+        schemaStringCache.clear();\n+        typeParserDictionary.clear();\n+    }\n+\n+    /**\n+     * Checks if caches should be reinitialized to satisfy initial configuration\n+     */\n+    private synchronized void resetIfNeeded() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MzY2MA==", "bodyText": "I see that typeParserDictionary generally has it's key lower cased to allow for case insensitive matching, I believe using a TreeMap should cover that case without needing to manually manage key casing on accesses. Using new TreeMap(String::equalsIgnoreCase) should produce the same effect.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#TreeMap-java.util.Comparator-", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430643660", "createdAt": "2020-05-26T19:09:06Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0Njg4Nw==", "bodyText": "Need to null check the retryPolicy here and use the default. Another option is null checking when setting the retry policy.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430646887", "createdAt": "2020-05-26T19:15:01Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+\n+        this.headers = new HttpHeaders();\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a {@link CachedSchemaRegistryClient} based on options set in the builder.\n+     * Every time {@code buildClient()} is called a new instance of {@link CachedSchemaRegistryClient} is created.\n+     *\n+     * If {@link #pipeline(HttpPipeline) pipeline} is set, then all HTTP pipeline related settings are ignored\n+     * endpoint} are when creating the {@link CachedSchemaRegistryClient client}.\n+     *\n+     * @return A {@link CachedSchemaRegistryClient} with the options set from the builder.\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public CachedSchemaRegistryClient buildClient() {\n+        HttpPipeline pipeline = this.httpPipeline;\n+        // Create a default Pipeline if it is not given\n+        if (pipeline == null) {\n+            // Closest to API goes first, closest to wire goes last.\n+            final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+            policies.add(new UserAgentPolicy(httpLogOptions.getApplicationId(), clientName, clientVersion,\n+                Configuration.getGlobalConfiguration().clone()));\n+            policies.add(new RequestIdPolicy());\n+            policies.add(new AddHeadersPolicy(this.headers));\n+\n+            HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+\n+            policies.add(retryPolicy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0Nzc1MA==", "bodyText": "Is this ever mutated? If there are plans to add static headers let's leave it, but otherwise we can just remove it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430647750", "createdAt": "2020-05-26T19:16:36Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+\n+        this.headers = new HttpHeaders();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0ODQ3OA==", "bodyText": "Let's check for this when starting the construction of the HttpPipeline, no need to waste time to just throw.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430648478", "createdAt": "2020-05-26T19:17:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+\n+        this.headers = new HttpHeaders();\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a {@link CachedSchemaRegistryClient} based on options set in the builder.\n+     * Every time {@code buildClient()} is called a new instance of {@link CachedSchemaRegistryClient} is created.\n+     *\n+     * If {@link #pipeline(HttpPipeline) pipeline} is set, then all HTTP pipeline related settings are ignored\n+     * endpoint} are when creating the {@link CachedSchemaRegistryClient client}.\n+     *\n+     * @return A {@link CachedSchemaRegistryClient} with the options set from the builder.\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public CachedSchemaRegistryClient buildClient() {\n+        HttpPipeline pipeline = this.httpPipeline;\n+        // Create a default Pipeline if it is not given\n+        if (pipeline == null) {\n+            // Closest to API goes first, closest to wire goes last.\n+            final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+            policies.add(new UserAgentPolicy(httpLogOptions.getApplicationId(), clientName, clientVersion,\n+                Configuration.getGlobalConfiguration().clone()));\n+            policies.add(new RequestIdPolicy());\n+            policies.add(new AddHeadersPolicy(this.headers));\n+\n+            HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+\n+            policies.add(retryPolicy);\n+\n+            policies.add(new AddDatePolicy());\n+            // Authentications\n+            if (credential != null) {\n+                // User token based policy\n+                policies.add(new BearerTokenAuthenticationPolicy(credential, DEFAULT_SCOPE));\n+            } else {\n+                // Throw exception that credential and tokenCredential cannot be null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY3MDc1NQ==", "bodyText": "Let's initialize this String once before any potential logging.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430670755", "createdAt": "2020-05-26T19:54:04Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryObject.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ */\n+public class SchemaRegistryObject {\n+    private final ClientLogger logger = new ClientLogger(SchemaRegistryObject.class);\n+\n+    private final String schemaId;\n+    private final String schemaType;\n+    private final Function<String, Object> parseMethod;\n+    private final byte[] schemaByteArray;\n+\n+    private Object deserialized;\n+\n+    /**\n+     * Initializes SchemaRegistryObject instance.\n+     *\n+     * @param schemaId schema ID\n+     * @param schemaType type of schema, e.g. avro, json\n+     * @param schemaByteArray byte payload representing schema, returned from Azure Schema Registry\n+     * @param parseMethod method to deserialize schema payload into Object\n+     */\n+    public SchemaRegistryObject(\n+        String schemaId,\n+        String schemaType,\n+        byte[] schemaByteArray,\n+        Function<String, Object> parseMethod) {\n+        this.schemaId = schemaId;\n+        this.schemaType = schemaType;\n+        this.schemaByteArray = schemaByteArray.clone();\n+        this.deserialized = null;\n+        this.parseMethod = parseMethod;\n+    }\n+\n+    /**\n+     * @return schema ID\n+     */\n+    public String getSchemaId() {\n+        return schemaId;\n+    }\n+\n+    /**\n+     * @return schema type associated with the schema payload\n+     */\n+    public String getSchemaType() {\n+        return schemaType;\n+    }\n+\n+    /**\n+     *  Deserialize schema bytes returned from Schema Registry.  If deserialization has happened once, the deserialized\n+     *  object is stored and returned.\n+     *\n+     *  @return schema object, deserialized using stored schema parser method.\n+     */\n+    public Object deserialize() {\n+        if (parseMethod == null) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"No loaded parser for %s format. Schema guid: %s\",\n+                    this.schemaType, this.schemaId)));\n+        }\n+\n+        if (this.deserialized == null) {\n+            logger.verbose(\n+                String.format(\"Deserializing schema, id: %s, schema string %s\",\n+                    this.schemaId,\n+                    new String(this.schemaByteArray, CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING)));\n+            this.deserialized = parseMethod.apply(\n+                new String(this.schemaByteArray, CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09d2745466c27375d3d238f4b19fad94a14b2257", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/09d2745466c27375d3d238f4b19fad94a14b2257", "committedDate": "2020-05-26T23:34:29Z", "message": "Update sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "866fe7f70ef19f0ab65169cbdcb411c44f1068c9", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/866fe7f70ef19f0ab65169cbdcb411c44f1068c9", "committedDate": "2020-05-26T23:36:24Z", "message": "fix comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abc131d4cf4a6aaf83337eb3e1c4c620b1475f3c", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/abc131d4cf4a6aaf83337eb3e1c4c620b1475f3c", "committedDate": "2020-05-26T23:36:26Z", "message": "Merge branch 'arerlend.src' of https://github.com/arerlend/azure-sdk-for-java into arerlend.src"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4e534007a19fe5f9198e31acc5c152b8b05b4f1", "committedDate": "2020-05-26T23:40:23Z", "message": "Update sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0a35a9e1e27970d02c194bfb243fcddf312fd15", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0a35a9e1e27970d02c194bfb243fcddf312fd15", "committedDate": "2020-05-26T23:57:41Z", "message": "default retry policy on null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6199719b77530eaeb38b267733b693ad2afee002", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6199719b77530eaeb38b267733b693ad2afee002", "committedDate": "2020-05-27T00:03:42Z", "message": "Merge branch 'arerlend.src' of https://github.com/arerlend/azure-sdk-for-java into arerlend.src"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "committedDate": "2020-05-27T00:04:28Z", "message": "remove unused headers policy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzU4MzIw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-418758320", "createdAt": "2020-05-27T00:05:44Z", "commit": {"oid": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1"}, "state": "COMMENTED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMDowNTo0NFrOGa0SVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToxODozNVrOGa1qQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MjgyMg==", "bodyText": "Use the interface instead Map<String, Function<String, Object>>.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430772822", "createdAt": "2020-05-27T00:05:44Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MzE3Mg==", "bodyText": "Use Map instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430773172", "createdAt": "2020-05-27T00:06:58Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MzkwNQ==", "bodyText": "This should be configured in the builder itself and the restService instance should be passed in to this constructor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430773905", "createdAt": "2020-05-27T00:09:27Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDEyOQ==", "bodyText": "both these should use ConcurrentHashMap.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430774129", "createdAt": "2020-05-27T00:10:08Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDQ0MA==", "bodyText": "Is this ctor required just to enable testing? Can mocks be used instead?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430774440", "createdAt": "2020-05-27T00:11:07Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDk5NA==", "bodyText": "Use Locale.ROOT instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430774994", "createdAt": "2020-05-27T00:12:59Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDcyOQ=="}, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NTI3Ng==", "bodyText": "You can instead use putIfAbsent() to add to map only when it doesn't exist. You can then also remove synchronized keyword if you make the typeParserDicitionary a ConcurrentHashMap.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430775276", "createdAt": "2020-05-27T00:14:03Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NTgwMg==", "bodyText": "nit: Consider naming it as typeParserMap to be java-like and agree with Alan on using a ConcurrentHashMap.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430775802", "createdAt": "2020-05-27T00:15:55Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NjM4NQ==", "bodyText": "Don't need to have throws SchemaRegistryClientException in the method signature as it's a RuntimeException.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430776385", "createdAt": "2020-05-27T00:18:02Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NjkxMg==", "bodyText": "Making this method synchronized will have a performance impact especially when register is called every single time an event is serialized. Consider using ConcurrentHashMap and remove synchronized.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430776912", "createdAt": "2020-05-27T00:19:59Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzQzNg==", "bodyText": "Consider using HttpResponseException instead of creating a custom exception.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430777436", "createdAt": "2020-05-27T00:21:45Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClientException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+/**\n+ * Runtime exception to be returned from SchemaRegistryClient implementations.\n+ */\n+public class SchemaRegistryClientException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3ODIwNQ==", "bodyText": "Same here - avoid using synchronized if ConcurrentHashMap for guidCache can serve the purpose and especially since the cache hit is expected to be the majority scenario here and we don't want to penalize every request by synchronizing the method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430778205", "createdAt": "2020-05-27T00:24:41Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3ODM5OQ==", "bodyText": "You might want to have a null check for schemaId.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430778399", "createdAt": "2020-05-27T00:25:17Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3OTM2Ng==", "bodyText": "putIfAbsent()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430779366", "createdAt": "2020-05-27T00:28:57Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3OTcxOA==", "bodyText": "Are these yet to be implemented?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430779718", "createdAt": "2020-05-27T00:30:09Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(\n+            schemaString,\n+            new SchemaRegistryObject(\n+                schemaId.getId(),\n+                schemaType,\n+                schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+                getParseFunc(schemaType)));\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return schemaId.getId();\n+    }\n+\n+    @Override\n+    public String deleteSchemaVersion(String schemaGroup, String schemaName, int version)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, version);\n+        // remove from cache\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MDE4Ng==", "bodyText": "Yeah, don't need to clear all - we can use the LRU approach later.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430780186", "createdAt": "2020-05-27T00:31:59Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(\n+            schemaString,\n+            new SchemaRegistryObject(\n+                schemaId.getId(),\n+                schemaType,\n+                schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+                getParseFunc(schemaType)));\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return schemaId.getId();\n+    }\n+\n+    @Override\n+    public String deleteSchemaVersion(String schemaGroup, String schemaName, int version)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, version);\n+        // remove from cache\n+        return null;\n+    }\n+\n+    @Override\n+    public String deleteLatestSchemaVersion(String schemaGroup, String schemaName)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, null);\n+        // remove from cache\n+        return null;\n+    }\n+\n+    @Override\n+    public List<String> deleteSchema(String schemaGroup, String schemaName)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchema();\n+        // remove from cache\n+        return null;\n+    }\n+\n+    /**\n+     * Explicit call to clear all caches.\n+     */\n+    public synchronized void reset() {\n+        guidCache.clear();\n+        schemaStringCache.clear();\n+        typeParserDictionary.clear();\n+    }\n+\n+    /**\n+     * Checks if caches should be reinitialized to satisfy initial configuration\n+     */\n+    private synchronized void resetIfNeeded() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTI2NQ=="}, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MTYyNQ==", "bodyText": "Make this client final.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430781625", "createdAt": "2020-05-27T00:37:23Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzQ1Nw==", "bodyText": "+1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430783457", "createdAt": "2020-05-27T00:43:10Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTE4MQ=="}, "originalCommit": {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NDA1Nw==", "bodyText": "Shouldn't this be allowed if the user wants to overwrite an existing entry for schemaType?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430784057", "createdAt": "2020-05-27T00:45:29Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NDE2Nw==", "bodyText": "Are we not going to have an async client?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430784167", "createdAt": "2020-05-27T00:45:53Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a {@link CachedSchemaRegistryClient} based on options set in the builder.\n+     * Every time {@code buildClient()} is called a new instance of {@link CachedSchemaRegistryClient} is created.\n+     *\n+     * If {@link #pipeline(HttpPipeline) pipeline} is set, then all HTTP pipeline related settings are ignored\n+     * endpoint} are when creating the {@link CachedSchemaRegistryClient client}.\n+     *\n+     * @return A {@link CachedSchemaRegistryClient} with the options set from the builder.\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public CachedSchemaRegistryClient buildClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NTA4Ng==", "bodyText": "Consider naming this as createSchema as per guidelines here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430785086", "createdAt": "2020-05-27T00:49:39Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface that defines operation for registering and fetching schemas and schema information to and from a\n+ * schema registry store.\n+ */\n+public interface SchemaRegistryClient {\n+\n+    /**\n+     * Encoding used by registry client implementation.\n+     * @return encoding for registry client implementation\n+     */\n+    Charset getEncoding();\n+\n+    /**\n+     * Loads function for a given serialization format that can parse the registry-stored schema string into\n+     * usable schema object.\n+     *\n+     * @param serializationType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     */\n+    void loadSchemaParser(String serializationType, Function<String, Object> parseMethod);\n+\n+    /**\n+     * Registers a schema against backing schema registry store.\n+     *\n+     * @param schemaGroup schema group name\n+     * @param schemaName schema name\n+     * @param schemaString string representation of schema\n+     * @param serializationType string representation of serialization format type\n+     * @return SchemaRegistryObject containing information regarding registered schema.\n+     * @throws SchemaRegistryClientException if registration operation fails\n+     */\n+    SchemaRegistryObject register(String schemaGroup, String schemaName, String schemaString, String serializationType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NzA4MA==", "bodyText": "This interface won't work if we have to support both sync and async APIs as the return types will be different. In track 2, we don't have an interface like this for the client. We directly have 2 client classes - sync and async.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430787080", "createdAt": "2020-05-27T00:57:24Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface that defines operation for registering and fetching schemas and schema information to and from a\n+ * schema registry store.\n+ */\n+public interface SchemaRegistryClient {\n+\n+    /**\n+     * Encoding used by registry client implementation.\n+     * @return encoding for registry client implementation\n+     */\n+    Charset getEncoding();\n+\n+    /**\n+     * Loads function for a given serialization format that can parse the registry-stored schema string into\n+     * usable schema object.\n+     *\n+     * @param serializationType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     */\n+    void loadSchemaParser(String serializationType, Function<String, Object> parseMethod);\n+\n+    /**\n+     * Registers a schema against backing schema registry store.\n+     *\n+     * @param schemaGroup schema group name\n+     * @param schemaName schema name\n+     * @param schemaString string representation of schema\n+     * @param serializationType string representation of serialization format type\n+     * @return SchemaRegistryObject containing information regarding registered schema.\n+     * @throws SchemaRegistryClientException if registration operation fails\n+     */\n+    SchemaRegistryObject register(String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException;\n+\n+    /**\n+     * Fetches schema specified by the GUID.\n+     * <p>\n+     * GUID can be assumed to be unique within a schema registry store.\n+     *\n+     * @param schemaGuid GUID reference to specific schema within configured schema registry store.\n+     * @return SchemaRegistryObject containing information regarding matching schema.\n+     * @throws SchemaRegistryClientException if fetch operation fails\n+     */\n+    SchemaRegistryObject getSchemaByGuid(String schemaGuid) throws SchemaRegistryClientException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODQxMw==", "bodyText": "Shouldn't this check happen in the constructor itself?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430788413", "createdAt": "2020-05-27T01:02:50Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryObject.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ */\n+public class SchemaRegistryObject {\n+    private final ClientLogger logger = new ClientLogger(SchemaRegistryObject.class);\n+\n+    private final String schemaId;\n+    private final String schemaType;\n+    private final Function<String, Object> parseMethod;\n+    private final byte[] schemaByteArray;\n+\n+    private Object deserialized;\n+\n+    /**\n+     * Initializes SchemaRegistryObject instance.\n+     *\n+     * @param schemaId schema ID\n+     * @param schemaType type of schema, e.g. avro, json\n+     * @param schemaByteArray byte payload representing schema, returned from Azure Schema Registry\n+     * @param parseMethod method to deserialize schema payload into Object\n+     */\n+    public SchemaRegistryObject(\n+        String schemaId,\n+        String schemaType,\n+        byte[] schemaByteArray,\n+        Function<String, Object> parseMethod) {\n+        this.schemaId = schemaId;\n+        this.schemaType = schemaType;\n+        this.schemaByteArray = schemaByteArray.clone();\n+        this.deserialized = null;\n+        this.parseMethod = parseMethod;\n+    }\n+\n+    /**\n+     * @return schema ID\n+     */\n+    public String getSchemaId() {\n+        return schemaId;\n+    }\n+\n+    /**\n+     * @return schema type associated with the schema payload\n+     */\n+    public String getSchemaType() {\n+        return schemaType;\n+    }\n+\n+    /**\n+     *  Deserialize schema bytes returned from Schema Registry.  If deserialization has happened once, the deserialized\n+     *  object is stored and returned.\n+     *\n+     *  @return schema object, deserialized using stored schema parser method.\n+     */\n+    public Object deserialize() {\n+        if (parseMethod == null) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"No loaded parser for %s format. Schema guid: %s\",\n+                    this.schemaType, this.schemaId)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODgxOQ==", "bodyText": "You might want to synchronize access to this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430788819", "createdAt": "2020-05-27T01:04:31Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryObject.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ */\n+public class SchemaRegistryObject {\n+    private final ClientLogger logger = new ClientLogger(SchemaRegistryObject.class);\n+\n+    private final String schemaId;\n+    private final String schemaType;\n+    private final Function<String, Object> parseMethod;\n+    private final byte[] schemaByteArray;\n+\n+    private Object deserialized;\n+\n+    /**\n+     * Initializes SchemaRegistryObject instance.\n+     *\n+     * @param schemaId schema ID\n+     * @param schemaType type of schema, e.g. avro, json\n+     * @param schemaByteArray byte payload representing schema, returned from Azure Schema Registry\n+     * @param parseMethod method to deserialize schema payload into Object\n+     */\n+    public SchemaRegistryObject(\n+        String schemaId,\n+        String schemaType,\n+        byte[] schemaByteArray,\n+        Function<String, Object> parseMethod) {\n+        this.schemaId = schemaId;\n+        this.schemaType = schemaType;\n+        this.schemaByteArray = schemaByteArray.clone();\n+        this.deserialized = null;\n+        this.parseMethod = parseMethod;\n+    }\n+\n+    /**\n+     * @return schema ID\n+     */\n+    public String getSchemaId() {\n+        return schemaId;\n+    }\n+\n+    /**\n+     * @return schema type associated with the schema payload\n+     */\n+    public String getSchemaType() {\n+        return schemaType;\n+    }\n+\n+    /**\n+     *  Deserialize schema bytes returned from Schema Registry.  If deserialization has happened once, the deserialized\n+     *  object is stored and returned.\n+     *\n+     *  @return schema object, deserialized using stored schema parser method.\n+     */\n+    public Object deserialize() {\n+        if (parseMethod == null) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"No loaded parser for %s format. Schema guid: %s\",\n+                    this.schemaType, this.schemaId)));\n+        }\n+\n+        if (this.deserialized == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDYxOQ==", "bodyText": "This should be in implementation package as it's the convention we follow to denote packages that users shouldn't use.\nhttps://azure.github.io/azure-sdk/java_design.html#example-namespaces", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430790619", "createdAt": "2020-05-27T01:11:35Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/rest/AzureSchemaRegistryRestServiceClientBuilder.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client.rest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MTA0Nw==", "bodyText": "This should not be used directly by the user. So, move this to implementation package. Same for any other classes that shouldn't in public API view.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430791047", "createdAt": "2020-05-27T01:13:16Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/rest/AzureSchemaRegistryRestService.java", "diffHunk": "@@ -0,0 +1,1411 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client.rest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MzAyMw==", "bodyText": "Does this package have to be exported? It contains codgen rest service client and builder which shouldn't be used anywhere outside this module.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430793023", "createdAt": "2020-05-27T01:15:43Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,14 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.schemaregistry.client {\n+    requires transitive com.azure.core;\n+\n+    exports com.azure.schemaregistry.client;\n+    exports com.azure.schemaregistry.client.rest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MzUxMw==", "bodyText": "Move this inside a directory called swagger.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430793513", "createdAt": "2020-05-27T01:16:20Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/swagger.yaml", "diffHunk": "@@ -0,0 +1,378 @@\n+openapi: 3.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5NTMzMA==", "bodyText": "We make all HTTP based clients use azure-core-http-netty as the default http client plugin. So, add that dependency as well so the service loaded can automatically create the http client.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430795330", "createdAt": "2020-05-27T01:18:35Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-schemaregistry-client/pom.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-schemaregistry-client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-schemaregistry-client;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - REST Client</name>\n+  <description>REST client implementation for Azure Schema Registry</description>\n+  <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+  <distributionManagement>\n+    <site>\n+      <id>azure-java-build-docs</id>\n+      <url>${site.url}/site/${project.artifactId}</url>\n+    </site>\n+  </distributionManagement>\n+\n+  <scm>\n+    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+\n+  <!-- SchemaRegistrySkip - Needed temporary values to not fail. -->\n+  <properties>\n+    <jacoco.min.linecoverage>0.10</jacoco.min.linecoverage>\n+    <jacoco.min.branchcoverage>0.01</jacoco.min.branchcoverage>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core</artifactId>\n+      <version>1.5.0</version> <!-- {x-version-update;com.azure:azure-core;dependency} -->\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d25047fd1cfd114aec2b106aae454e1237d841ed", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d25047fd1cfd114aec2b106aae454e1237d841ed", "committedDate": "2020-05-27T15:36:49Z", "message": "netty dep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cd191ebe22a464348914279d96db3cf321871ea", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9cd191ebe22a464348914279d96db3cf321871ea", "committedDate": "2020-05-27T15:38:52Z", "message": "hashmap to concurrent hashmap, slf4j format pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59d8f9d2fd1c4ea421a774ed95c98a9a85d73a06", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/59d8f9d2fd1c4ea421a774ed95c98a9a85d73a06", "committedDate": "2020-05-27T15:39:37Z", "message": "builder cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a04c3835260f66214ce8618ec632e7e8774e03eb", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a04c3835260f66214ce8618ec632e7e8774e03eb", "committedDate": "2020-05-27T15:40:01Z", "message": "remove runtime error from method signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1656da90030e3ca9f610132ba3b4537dfa049910", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1656da90030e3ca9f610132ba3b4537dfa049910", "committedDate": "2020-05-27T20:56:46Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81682bcf0e27294f75d434f047e63ed5eda9e110", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/81682bcf0e27294f75d434f047e63ed5eda9e110", "committedDate": "2020-05-28T00:33:25Z", "message": "change group name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b855cd00761662d2d845a68ea753ef0a5e96d29e", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b855cd00761662d2d845a68ea753ef0a5e96d29e", "committedDate": "2020-05-28T00:42:18Z", "message": "move rest service builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "850201a2c0e6907248dd8ff0ff2b9d5234c87150", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/850201a2c0e6907248dd8ff0ff2b9d5234c87150", "committedDate": "2020-05-28T00:47:26Z", "message": "update dirs and repo files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b1ee4e13efcd0ec118bdafc4d273b01874131ab", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b1ee4e13efcd0ec118bdafc4d273b01874131ab", "committedDate": "2020-05-28T19:46:17Z", "message": "update package structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6e0941bd0ecbd4918935608d447047be7fe7795", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6e0941bd0ecbd4918935608d447047be7fe7795", "committedDate": "2020-05-28T19:46:42Z", "message": "update versioning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec", "committedDate": "2020-05-28T20:05:03Z", "message": "fix jacoco test pom"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwOTQ3NTk2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-420947596", "createdAt": "2020-05-29T13:25:45Z", "commit": {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMzoyNTo0NVrOGcchPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMzozMzoxOVrOGccysg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4MDU3NQ==", "bodyText": "nit: please put these in alphabetical order, they should be immediately after com.azure:azure-data-appconfiguration", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432480575", "createdAt": "2020-05-29T13:25:45Z", "author": {"login": "JimSuplizio"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -26,6 +26,8 @@ com.azure:azure-identity-perf;1.0.0-beta.1;1.0.0-beta.1\n com.azure:azure-messaging-eventhubs;5.1.0;5.2.0-beta.1\n com.azure:azure-messaging-eventhubs-checkpointstore-blob;1.1.0;1.2.0-beta.1\n com.azure:azure-messaging-servicebus;7.0.0-beta.2;7.0.0-beta.3\n+com.azure:azure-data-schemaregistry;1.0.0-beta.1;1.0.0-beta.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4MjkyOQ==", "bodyText": "Please put a comment in here something like <!-- SchemaRegistrySkip temporarily relaxing code coverage --> to indicate that the coverage skip is temporary and file an issue to remove this entry when you've got tests/coverage numbers.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432482929", "createdAt": "2020-05-29T13:29:39Z", "author": {"login": "JimSuplizio"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml", "diffHunk": "@@ -0,0 +1,98 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-data-schemaregistry-avro</artifactId>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry-avro;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - Avro-specific package for client library</name>\n+  <description>Avro-specih,fic package for Azure Schema Registry client library</description>\n+  <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+  <distributionManagement>\n+    <site>\n+      <id>azure-java-build-docs</id>\n+      <url>${site.url}/site/${project.artifactId}</url>\n+    </site>\n+  </distributionManagement>\n+\n+  <scm>\n+    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+  <properties>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4NDQxMg==", "bodyText": "Same comment as sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml, add the same comment here and ensure that issue filed includes both libraries.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432484412", "createdAt": "2020-05-29T13:32:09Z", "author": {"login": "JimSuplizio"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/pom.xml", "diffHunk": "@@ -0,0 +1,108 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-data-schemaregistry</artifactId>\n+  <packaging>jar</packaging>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - Common Client/SerDe Package for client library</name>\n+  <description>\n+    Common SerDe Package containing client and base serialization/deserialization implementation for Azure Schema Registry client library\n+  </description>\n+  <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+  <distributionManagement>\n+    <site>\n+      <id>azure-java-build-docs</id>\n+      <url>${site.url}/site/${project.artifactId}</url>\n+    </site>\n+  </distributionManagement>\n+\n+  <scm>\n+    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+  <properties>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4NTA0Mg==", "bodyText": "You shouldn't need this if your only non-test dependencies are com.azure, it'll inherit that from azure-client-sdk-parent", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432485042", "createdAt": "2020-05-29T13:33:19Z", "author": {"login": "JimSuplizio"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/pom.xml", "diffHunk": "@@ -0,0 +1,108 @@\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-data-schemaregistry</artifactId>\n+  <packaging>jar</packaging>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - Common Client/SerDe Package for client library</name>\n+  <description>\n+    Common SerDe Package containing client and base serialization/deserialization implementation for Azure Schema Registry client library\n+  </description>\n+  <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+  <distributionManagement>\n+    <site>\n+      <id>azure-java-build-docs</id>\n+      <url>${site.url}/site/${project.artifactId}</url>\n+    </site>\n+  </distributionManagement>\n+\n+  <scm>\n+    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+  <properties>\n+    <jacoco.skip.coverage.check>true</jacoco.skip.coverage.check>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core</artifactId>\n+      <version>1.5.0</version> <!-- {x-version-update;com.azure:azure-core;dependency} -->\n+    </dependency>\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-http-netty</artifactId>\n+      <version>1.5.1</version> <!-- {x-version-update;com.azure:azure-core-http-netty;dependency} -->\n+    </dependency>\n+\n+    <!-- Test dependencies -->\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-api</artifactId>\n+      <version>5.6.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-api;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-engine</artifactId>\n+      <version>5.6.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-engine;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-params</artifactId>\n+      <version>5.6.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-params;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <version>3.0.0</version> <!-- {x-version-update;org.mockito:mockito-core;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.avro</groupId>\n+      <artifactId>avro</artifactId>\n+      <version>1.9.2</version> <!-- {x-version-update;org.apache.avro:avro;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-enforcer-plugin</artifactId>\n+        <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-enforcer-plugin;external_dependency} -->\n+        <configuration>\n+          <rules>\n+            <bannedDependencies>\n+              <includes>\n+                <include>com.azure:*</include>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/93defa9bdfacb71789c231eb2cb9980f80c0ea01", "committedDate": "2020-05-29T16:15:06Z", "message": "fix eng system comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTAwNjc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-421100676", "createdAt": "2020-05-29T16:20:27Z", "commit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTAzMDY5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-421103069", "createdAt": "2020-05-29T16:23:54Z", "commit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjoyMzo1NFrOGcjnbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0MjoyOFrOGcmRQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5Njg0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              <description>Avro-specih,fic package for Azure Schema Registry client library</description>\n          \n          \n            \n              <description>Avro-specific package for Azure Schema Registry client library</description>", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432596844", "createdAt": "2020-05-29T16:23:54Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml", "diffHunk": "@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-data-schemaregistry-avro</artifactId>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry-avro;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - Avro-specific package for client library</name>\n+  <description>Avro-specih,fic package for Azure Schema Registry client library</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5NzI1MA==", "bodyText": "Generally we leave scope blank unless it is something other than compile (the Maven default).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432597250", "createdAt": "2020-05-29T16:24:43Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml", "diffHunk": "@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-data-schemaregistry-avro</artifactId>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry-avro;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - Avro-specific package for client library</name>\n+  <description>Avro-specih,fic package for Azure Schema Registry client library</description>\n+  <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+  <distributionManagement>\n+    <site>\n+      <id>azure-java-build-docs</id>\n+      <url>${site.url}/site/${project.artifactId}</url>\n+    </site>\n+  </distributionManagement>\n+\n+  <scm>\n+    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+  <properties>\n+    <!-- SchemaRegistrySkip temporarily relaxing code coverage -->\n+    <jacoco.skip.coverage.check>true</jacoco.skip.coverage.check>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-data-schemaregistry</artifactId>\n+      <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry;dependency} -->\n+      <scope>compile</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwODYyMw==", "bodyText": "Do you know if it would be better to phrase the exception in the \"why this happened\" instead of \"what happened\"?\nAttempted to decode with non-Avro schema object in AvroByteDecoder.\nvs\nobject must be an Avro Schema.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432608623", "createdAt": "2020-05-29T16:46:44Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(\"Attempted to decode with non-Avro schema object in AvroByteDecoder\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDAzNA==", "bodyText": "I'm not sure this is completely correct, based on the Avro spec bytes will contain a leading long indicating the number of bytes in the byte[]. Based on my testing having Apache's implementation parse this is safe, though it may return ByteBuffer which could be unwrapped to byte[].", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432610034", "createdAt": "2020-05-29T16:49:16Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(\"Attempted to decode with non-Avro schema object in AvroByteDecoder\"));\n+        }\n+        Schema schema = (Schema) object;\n+\n+        if (schema.getType().equals(Schema.Type.BYTES)) {\n+            return b;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDc5Mw==", "bodyText": "From what I remember DecoderFactory should be thread safe, this could be made static.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432610793", "createdAt": "2020-05-29T16:50:37Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMjI3OA==", "bodyText": "I would also conditionally check !(result instanceof String). It is possible to configure your schema with \"avro.java.stringType\":\"String\" to tell the parser to read the string type as java.lang.String instead of Apache's Utf8 CharSequence implementation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432612278", "createdAt": "2020-05-29T16:53:28Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(\"Attempted to decode with non-Avro schema object in AvroByteDecoder\"));\n+        }\n+        Schema schema = (Schema) object;\n+\n+        if (schema.getType().equals(Schema.Type.BYTES)) {\n+            return b;\n+        }\n+\n+        DatumReader<?> reader = getDatumReader(schema);\n+\n+        try {\n+            Object result = reader.read(null, decoderFactory.binaryDecoder(b, null));\n+\n+            if (schema.getType().equals(Schema.Type.STRING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMzIwMg==", "bodyText": "Same comment about byte deserialization, this will need a leading long to indicate the number of bytes in the byte[].", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432613202", "createdAt": "2020-05-29T16:55:13Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }\n+\n+    /**\n+     * Returns ByteArrayOutputStream containing Avro encoding of object parameter\n+     * @param object Object to be encoded into byte stream\n+     * @return closed ByteArrayOutputStream\n+     * @throws SerializationException wraps runtime exceptions\n+     */\n+    public ByteArrayOutputStream encode(Object object) throws SerializationException {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            if (object instanceof byte[]) {\n+                out.write((byte[]) object);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNjI1Nw==", "bodyText": "Should we be checking both the object and primitive representations here? boolean and Boolean, int and Integer, etc.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432616257", "createdAt": "2020-05-29T16:58:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroSchemaUtils.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericContainer;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utility class for Avro schema functionality.\n+ */\n+class AvroSchemaUtils {\n+    private static final Map<String, Schema> PRIMITIVE_SCHEMAS;\n+\n+    static {\n+        Schema.Parser parser = new Schema.Parser();\n+        PRIMITIVE_SCHEMAS = new HashMap<>();\n+        PRIMITIVE_SCHEMAS.put(\"Null\", createPrimitiveSchema(parser, \"null\"));\n+        PRIMITIVE_SCHEMAS.put(\"Boolean\", createPrimitiveSchema(parser, \"boolean\"));\n+        PRIMITIVE_SCHEMAS.put(\"Integer\", createPrimitiveSchema(parser, \"int\"));\n+        PRIMITIVE_SCHEMAS.put(\"Long\", createPrimitiveSchema(parser, \"long\"));\n+        PRIMITIVE_SCHEMAS.put(\"Float\", createPrimitiveSchema(parser, \"float\"));\n+        PRIMITIVE_SCHEMAS.put(\"Double\", createPrimitiveSchema(parser, \"double\"));\n+        PRIMITIVE_SCHEMAS.put(\"String\", createPrimitiveSchema(parser, \"string\"));\n+        PRIMITIVE_SCHEMAS.put(\"Bytes\", createPrimitiveSchema(parser, \"bytes\"));\n+    }\n+\n+    /**\n+     * Generates Avro Schema object for the specified primitive type.\n+     * @param parser Avro schema parser\n+     * @param type primitive schema type\n+     * @return Avro Schema object for corresponding primitive type\n+     */\n+    private static Schema createPrimitiveSchema(Schema.Parser parser, String type) {\n+        String schemaString = String.format(\"{\\\"type\\\" : \\\"%s\\\"}\", type);\n+        return parser.parse(schemaString);\n+    }\n+\n+    /**\n+     * Maintains map of primitive schemas.\n+     * @return Map containing string representation of primitive type to corresponding Avro primitive schema\n+     */\n+    public static Map<String, Schema> getPrimitiveSchemas() {\n+        return Collections.unmodifiableMap(PRIMITIVE_SCHEMAS);\n+    }\n+\n+    /**\n+     * Returns Avro schema for specified object, including null values\n+     *\n+     * @param object object for which Avro schema is being returned\n+     * @return Avro schema for object's data structure\n+     *\n+     * @throws IllegalArgumentException if object type is unsupported\n+     */\n+    public static Schema getSchema(Object object) throws IllegalArgumentException {\n+        if (object == null) {\n+            return PRIMITIVE_SCHEMAS.get(\"Null\");\n+        } else if (object instanceof Boolean) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzA5MQ==", "bodyText": "This exception doesn't match the conditionals, unless IndexedRecord is a subclass of GenericContainer.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432617091", "createdAt": "2020-05-29T16:59:15Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroSchemaUtils.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericContainer;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utility class for Avro schema functionality.\n+ */\n+class AvroSchemaUtils {\n+    private static final Map<String, Schema> PRIMITIVE_SCHEMAS;\n+\n+    static {\n+        Schema.Parser parser = new Schema.Parser();\n+        PRIMITIVE_SCHEMAS = new HashMap<>();\n+        PRIMITIVE_SCHEMAS.put(\"Null\", createPrimitiveSchema(parser, \"null\"));\n+        PRIMITIVE_SCHEMAS.put(\"Boolean\", createPrimitiveSchema(parser, \"boolean\"));\n+        PRIMITIVE_SCHEMAS.put(\"Integer\", createPrimitiveSchema(parser, \"int\"));\n+        PRIMITIVE_SCHEMAS.put(\"Long\", createPrimitiveSchema(parser, \"long\"));\n+        PRIMITIVE_SCHEMAS.put(\"Float\", createPrimitiveSchema(parser, \"float\"));\n+        PRIMITIVE_SCHEMAS.put(\"Double\", createPrimitiveSchema(parser, \"double\"));\n+        PRIMITIVE_SCHEMAS.put(\"String\", createPrimitiveSchema(parser, \"string\"));\n+        PRIMITIVE_SCHEMAS.put(\"Bytes\", createPrimitiveSchema(parser, \"bytes\"));\n+    }\n+\n+    /**\n+     * Generates Avro Schema object for the specified primitive type.\n+     * @param parser Avro schema parser\n+     * @param type primitive schema type\n+     * @return Avro Schema object for corresponding primitive type\n+     */\n+    private static Schema createPrimitiveSchema(Schema.Parser parser, String type) {\n+        String schemaString = String.format(\"{\\\"type\\\" : \\\"%s\\\"}\", type);\n+        return parser.parse(schemaString);\n+    }\n+\n+    /**\n+     * Maintains map of primitive schemas.\n+     * @return Map containing string representation of primitive type to corresponding Avro primitive schema\n+     */\n+    public static Map<String, Schema> getPrimitiveSchemas() {\n+        return Collections.unmodifiableMap(PRIMITIVE_SCHEMAS);\n+    }\n+\n+    /**\n+     * Returns Avro schema for specified object, including null values\n+     *\n+     * @param object object for which Avro schema is being returned\n+     * @return Avro schema for object's data structure\n+     *\n+     * @throws IllegalArgumentException if object type is unsupported\n+     */\n+    public static Schema getSchema(Object object) throws IllegalArgumentException {\n+        if (object == null) {\n+            return PRIMITIVE_SCHEMAS.get(\"Null\");\n+        } else if (object instanceof Boolean) {\n+            return PRIMITIVE_SCHEMAS.get(\"Boolean\");\n+        } else if (object instanceof Integer) {\n+            return PRIMITIVE_SCHEMAS.get(\"Integer\");\n+        } else if (object instanceof Long) {\n+            return PRIMITIVE_SCHEMAS.get(\"Long\");\n+        } else if (object instanceof Float) {\n+            return PRIMITIVE_SCHEMAS.get(\"Float\");\n+        } else if (object instanceof Double) {\n+            return PRIMITIVE_SCHEMAS.get(\"Double\");\n+        } else if (object instanceof CharSequence) {\n+            return PRIMITIVE_SCHEMAS.get(\"String\");\n+        } else if (object instanceof byte[]) {\n+            return PRIMITIVE_SCHEMAS.get(\"Bytes\");\n+        } else if (object instanceof GenericContainer) {\n+            return ((GenericContainer) object).getSchema();\n+        } else {\n+            ClientLogger logger = new ClientLogger(AvroSchemaUtils.class);\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                \"Unsupported Avro type. Supported types are null, Boolean, Integer, Long, \"\n+                    + \"Float, Double, String, byte[] and IndexedRecord\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzI3OA==", "bodyText": "Should ByteBuffer fall into this category.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432617278", "createdAt": "2020-05-29T16:59:36Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroSchemaUtils.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericContainer;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utility class for Avro schema functionality.\n+ */\n+class AvroSchemaUtils {\n+    private static final Map<String, Schema> PRIMITIVE_SCHEMAS;\n+\n+    static {\n+        Schema.Parser parser = new Schema.Parser();\n+        PRIMITIVE_SCHEMAS = new HashMap<>();\n+        PRIMITIVE_SCHEMAS.put(\"Null\", createPrimitiveSchema(parser, \"null\"));\n+        PRIMITIVE_SCHEMAS.put(\"Boolean\", createPrimitiveSchema(parser, \"boolean\"));\n+        PRIMITIVE_SCHEMAS.put(\"Integer\", createPrimitiveSchema(parser, \"int\"));\n+        PRIMITIVE_SCHEMAS.put(\"Long\", createPrimitiveSchema(parser, \"long\"));\n+        PRIMITIVE_SCHEMAS.put(\"Float\", createPrimitiveSchema(parser, \"float\"));\n+        PRIMITIVE_SCHEMAS.put(\"Double\", createPrimitiveSchema(parser, \"double\"));\n+        PRIMITIVE_SCHEMAS.put(\"String\", createPrimitiveSchema(parser, \"string\"));\n+        PRIMITIVE_SCHEMAS.put(\"Bytes\", createPrimitiveSchema(parser, \"bytes\"));\n+    }\n+\n+    /**\n+     * Generates Avro Schema object for the specified primitive type.\n+     * @param parser Avro schema parser\n+     * @param type primitive schema type\n+     * @return Avro Schema object for corresponding primitive type\n+     */\n+    private static Schema createPrimitiveSchema(Schema.Parser parser, String type) {\n+        String schemaString = String.format(\"{\\\"type\\\" : \\\"%s\\\"}\", type);\n+        return parser.parse(schemaString);\n+    }\n+\n+    /**\n+     * Maintains map of primitive schemas.\n+     * @return Map containing string representation of primitive type to corresponding Avro primitive schema\n+     */\n+    public static Map<String, Schema> getPrimitiveSchemas() {\n+        return Collections.unmodifiableMap(PRIMITIVE_SCHEMAS);\n+    }\n+\n+    /**\n+     * Returns Avro schema for specified object, including null values\n+     *\n+     * @param object object for which Avro schema is being returned\n+     * @return Avro schema for object's data structure\n+     *\n+     * @throws IllegalArgumentException if object type is unsupported\n+     */\n+    public static Schema getSchema(Object object) throws IllegalArgumentException {\n+        if (object == null) {\n+            return PRIMITIVE_SCHEMAS.get(\"Null\");\n+        } else if (object instanceof Boolean) {\n+            return PRIMITIVE_SCHEMAS.get(\"Boolean\");\n+        } else if (object instanceof Integer) {\n+            return PRIMITIVE_SCHEMAS.get(\"Integer\");\n+        } else if (object instanceof Long) {\n+            return PRIMITIVE_SCHEMAS.get(\"Long\");\n+        } else if (object instanceof Float) {\n+            return PRIMITIVE_SCHEMAS.get(\"Float\");\n+        } else if (object instanceof Double) {\n+            return PRIMITIVE_SCHEMAS.get(\"Double\");\n+        } else if (object instanceof CharSequence) {\n+            return PRIMITIVE_SCHEMAS.get(\"String\");\n+        } else if (object instanceof byte[]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDE0Ng==", "bodyText": "This package doesn't exist, this should be com.azure.data.schemaregistry.avro right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432620146", "createdAt": "2020-05-29T17:05:14Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,8 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.avro {\n+    requires transitive com.azure.core;\n+\n+    exports com.azure.data.schemaregistry.serde.avro;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMTYyMw==", "bodyText": "If you look at this PR (https://github.com/Azure/azure-sdk-for-java/pull/10195/files#diff-f42ef09d2743baecc7f1c205f31c0351R113) it includes a plugin which can generate Java source code from given schemas, should be helpful for testing.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432621623", "createdAt": "2020-05-29T17:07:17Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml", "diffHunk": "@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (c) Microsoft Corporation. All rights reserved.\n+  ~ Licensed under the MIT License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-client-sdk-parent</artifactId>\n+    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+    <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+  </parent>\n+\n+  <groupId>com.azure</groupId>\n+  <artifactId>azure-data-schemaregistry-avro</artifactId>\n+  <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry-avro;current} -->\n+\n+  <name>Microsoft Azure Schema Registry - Avro-specific package for client library</name>\n+  <description>Avro-specih,fic package for Azure Schema Registry client library</description>\n+  <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+  <distributionManagement>\n+    <site>\n+      <id>azure-java-build-docs</id>\n+      <url>${site.url}/site/${project.artifactId}</url>\n+    </site>\n+  </distributionManagement>\n+\n+  <scm>\n+    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>\n+    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+  <properties>\n+    <!-- SchemaRegistrySkip temporarily relaxing code coverage -->\n+    <jacoco.skip.coverage.check>true</jacoco.skip.coverage.check>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-data-schemaregistry</artifactId>\n+      <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-data-schemaregistry;dependency} -->\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.avro</groupId>\n+      <artifactId>avro</artifactId>\n+      <version>1.9.2</version> <!-- {x-version-update;org.apache.avro:avro;external_dependency} -->\n+      <scope>compile</scope>\n+    </dependency>\n+\n+    <!-- Test dependencies -->\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-api</artifactId>\n+      <version>5.6.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-api;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-engine</artifactId>\n+      <version>5.6.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-engine;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-params</artifactId>\n+      <version>5.6.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-params;external_dependency} -->\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMjEzOA==", "bodyText": "Is there a specific reason we are creating a custom scheduler for deserialization?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432622138", "createdAt": "2020-05-29T17:07:53Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncDeserializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based deserializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncDeserializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroDeserializer deserializer;\n+    private final Scheduler scheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzM2Mg==", "bodyText": "Should we use Mono.empty() or Mono.just(new byte[0])? These will have two very different things happen when dealing with Reactor streams. The former will complete the stream without an onNext operation, the latter will trigger an onNext (triggering downstream map and flatMap operators) and will contain an empty byte[] as expected when Avro serializes a null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432623362", "createdAt": "2020-05-29T17:09:51Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncSerializer.java", "diffHunk": "@@ -0,0 +1,48 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.AbstractDataSerializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based serializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncSerializer extends AbstractDataSerializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroSerializer serializer;\n+    private final Scheduler scheduler;\n+\n+    /**\n+     * @param serializer synchronous Avro serializer implementation\n+     */\n+    SchemaRegistryAvroAsyncSerializer(SchemaRegistryAvroSerializer serializer) {\n+        this.serializer = serializer;\n+        this.scheduler = Schedulers.fromExecutor(Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n+    }\n+\n+    /**\n+     * Async wrapper around sync serialization operation\n+     *\n+     * @param object object to be serialized to bytes\n+     * @return Avro byte representation of object\n+     * @throws SerializationException upon serialization operation failure\n+     */\n+    public Mono<byte[]> serializeAsync(Object object) throws SerializationException {\n+        if (object == null) {\n+            return Mono.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDY0NA==", "bodyText": "For these Javadocs is the but about instanceof meant to go into the overview of the method or specific to the return portion? Also, Javadocs are HTML so any newlines are scrubbed, if you need line separators you'll need to add <p> where newlines are (except when transitioning Javadoc sections such as param to param, return to throws, etc.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432624644", "createdAt": "2020-05-29T17:12:30Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializer.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.data.schemaregistry.AbstractDataDeserializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import com.azure.data.schemaregistry.client.CachedSchemaRegistryClientBuilder;\n+\n+/**\n+ * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n+ * fetching payload-specified schemas from the Azure Schema Registry store.\n+ *\n+ * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n+ *\n+ * Pluggable with the core Azure SDK Deserializer interface.\n+ *\n+ * @see AbstractDataDeserializer See AbstractDataDeserializer for internal deserialization implementation\n+ */\n+public class SchemaRegistryAvroDeserializer extends AbstractDataDeserializer {\n+    SchemaRegistryAvroDeserializer(String registryUrl,\n+                                   TokenCredential credential,\n+                                   boolean avroSpecificReader,\n+                                   Integer maxSchemaMapSize) {\n+        super(new CachedSchemaRegistryClientBuilder()\n+            .endpoint(registryUrl)\n+            .credential(credential)\n+            .maxSchemaMapSize(maxSchemaMapSize)\n+            .buildClient());\n+\n+        loadByteDecoder(new AvroByteDecoder(avroSpecificReader));\n+    }\n+\n+    /**\n+     * Deserializes byte array into Java object using payload-specified schema.\n+     *\n+     * @param data Byte array containing serialized bytes\n+     * @return Java object.\n+     *\n+     * Object type is testable with instanceof operator.  Return value can be casted in the caller layer.\n+     *\n+     * @throws SerializationException Throws on deserialization failure.\n+     * Exception may contain inner exceptions detailing failure condition.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDk3OQ==", "bodyText": "Need to add <p> tags to have Javadocs generate with line separators.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n          \n          \n            \n             * fetching payload-specified schemas from the Azure Schema Registry store.\n          \n          \n            \n             *\n          \n          \n            \n             * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n          \n          \n            \n             *\n          \n          \n            \n             * Pluggable with the core Azure SDK Deserializer interface.\n          \n          \n            \n             * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n          \n          \n            \n             * fetching payload-specified schemas from the Azure Schema Registry store.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Pluggable with the core Azure SDK Deserializer interface.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432624979", "createdAt": "2020-05-29T17:13:10Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializer.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.data.schemaregistry.AbstractDataDeserializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import com.azure.data.schemaregistry.client.CachedSchemaRegistryClientBuilder;\n+\n+/**\n+ * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n+ * fetching payload-specified schemas from the Azure Schema Registry store.\n+ *\n+ * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n+ *\n+ * Pluggable with the core Azure SDK Deserializer interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTA3OQ==", "bodyText": "Was this made protected to sub-classes could interact with it? Generally we stay away from protected as it is part of the public API.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432631079", "createdAt": "2020-05-29T17:25:01Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/AbstractDataDeserializer.java", "diffHunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.client.SchemaRegistryObject;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClient;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClientException;\n+\n+import java.nio.BufferUnderflowException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Common implementation for all registry-based deserializers.\n+ */\n+public abstract class AbstractDataDeserializer extends AbstractDataSerDe {\n+    private final ClientLogger logger = new ClientLogger(AbstractDataDeserializer.class);\n+\n+    protected final Map<String, ByteDecoder> byteDecoderMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjI1NQ==", "bodyText": "I think throwing is the correct choice here, if we can't determine the schema there isn't much we can do.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432632255", "createdAt": "2020-05-29T17:27:08Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/AbstractDataDeserializer.java", "diffHunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.client.SchemaRegistryObject;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClient;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClientException;\n+\n+import java.nio.BufferUnderflowException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Common implementation for all registry-based deserializers.\n+ */\n+public abstract class AbstractDataDeserializer extends AbstractDataSerDe {\n+    private final ClientLogger logger = new ClientLogger(AbstractDataDeserializer.class);\n+\n+    protected final Map<String, ByteDecoder> byteDecoderMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor called by all concrete implementation constructors.\n+     * Should only call parent constructor.\n+     * @param schemaRegistryClient client to be used for fetching schemas by ID\n+     */\n+    protected AbstractDataDeserializer(SchemaRegistryClient schemaRegistryClient) {\n+        super(schemaRegistryClient);\n+    }\n+\n+    /**\n+     * Special case constructor for Kafka deserializer's empty constructors.\n+     */\n+    protected AbstractDataDeserializer() { }\n+\n+    /**\n+     * Fetches schema referenced by prefixed ID and deserializes the subsequent payload into Java object.\n+     *\n+     * @param payload byte payload, produced by an Azure Schema Registry client producer\n+     * @return object, deserialized with the prefixed schema\n+     * @throws SerializationException if deserialization of registry schema or message payload fails.\n+     */\n+    protected Object deserialize(byte[] payload) throws SerializationException {\n+        if (payload == null) {\n+            return null;\n+        }\n+\n+        ByteBuffer buffer = ByteBuffer.wrap(payload);\n+        String schemaGuid = getSchemaGuidFromPayload(buffer);\n+        SchemaRegistryObject registryObject;\n+        Object payloadSchema;\n+\n+        try {\n+            registryObject = this.schemaRegistryClient.getSchemaByGuid(schemaGuid);\n+            payloadSchema = registryObject.deserialize();\n+        } catch (SchemaRegistryClientException e) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(String.format(\"Failed to retrieve schema for id %s\", schemaGuid), e));\n+        }\n+\n+        // TODO: how to handle unknown formats", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzkyMA==", "bodyText": "Should this be switched to OutputStream in case we want to change the internal return type in the future.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432637920", "createdAt": "2020-05-29T17:37:53Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/ByteEncoder.java", "diffHunk": "@@ -0,0 +1,40 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+/**\n+ * An interface defining operations required for registry serializer to convert object to bytes.\n+ */\n+public interface ByteEncoder extends Codec {\n+    /**\n+     * Return schema name for storing in registry store\n+     * @param object Schema object\n+     * Refer to Schema Registry documentation for information on schema grouping and naming.\n+     *\n+     * @return schema name\n+     * @throws SerializationException runtime exception in error cases\n+     */\n+    String getSchemaName(Object object) throws SerializationException;\n+\n+    /**\n+     * Returns string representation of schema object to be stored in the service.\n+     *\n+     * @param object Schema object used to generate schema string\n+     * @return String representation of schema object parameter\n+     * @throws SerializationException if generating string representation of schema fails\n+     */\n+    String getSchemaString(Object object) throws SerializationException;\n+\n+    // TODO: Method does not currently require schema object to be passed since schemas can be derived from\n+    // Avro objects. JSON implementation would be the same.\n+    /**\n+     * Converts object into stream containing the encoded representation of the object.\n+     * @param object Object to be encoded into byte stream\n+     * @return output stream containing byte representation of object\n+     * @throws SerializationException if generating byte representation of object fails\n+     */\n+    ByteArrayOutputStream encode(Object object) throws SerializationException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MDMyMA==", "bodyText": "Should the swagger be merged into azure-sdk-for-java? I thought this was meant to go into azure-rest-api-specs.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432640320", "createdAt": "2020-05-29T17:42:28Z", "author": {"login": "alzimmermsft"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/swagger/swagger.yaml", "diffHunk": "@@ -0,0 +1,378 @@\n+openapi: 3.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cea60ee4b0f1327bbcd6ed5231f8a23ac3faef83", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cea60ee4b0f1327bbcd6ed5231f8a23ac3faef83", "committedDate": "2020-05-29T17:47:34Z", "message": "Update sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ffe75968536564b10be6f66ec76e925c9679c6c", "committedDate": "2020-05-29T18:30:29Z", "message": "Update sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializer.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTk5MDcw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-421199070", "createdAt": "2020-05-29T18:41:52Z", "commit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxODo0MTo1MlrOGcoDow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTo1MToyMVrOGcqIUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTYwMw==", "bodyText": "nit: specify that this is Apache Avro specific implementation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432669603", "createdAt": "2020-05-29T18:41:52Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTkxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public AvroByteDecoder(Boolean avroSpecificReader) {\n          \n          \n            \n                public AvroByteDecoder(boolean avroSpecificReader) {", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432669911", "createdAt": "2020-05-29T18:42:34Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDc4NQ==", "bodyText": "Extend from AzureException instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432670785", "createdAt": "2020-05-29T18:44:16Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/SerializationException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+/**\n+ * Exception thrown by Schema Registry serializer/deserializer implementations for runtime error cases.\n+ */\n+public class SerializationException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTU5NQ==", "bodyText": "Don't need to include throws SerializationException as it's a RuntimeException. Having @throws in JavaDoc is sufficient.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432671595", "createdAt": "2020-05-29T18:45:54Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3Mjg5NQ==", "bodyText": "If the object is null, throw NPE instead of SerializationException.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432672895", "createdAt": "2020-05-29T18:48:38Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NjI0NA==", "bodyText": "This ctor is available by default. It can be removed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432676244", "createdAt": "2020-05-29T18:55:36Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODg4Mg==", "bodyText": "Both these methods can be moved to AvroSchemaUtils and can be made static.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432678882", "createdAt": "2020-05-29T19:01:28Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTI0OA==", "bodyText": "Same here - throws SerializationException is not required.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432679248", "createdAt": "2020-05-29T19:02:17Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }\n+\n+    /**\n+     * Returns ByteArrayOutputStream containing Avro encoding of object parameter\n+     * @param object Object to be encoded into byte stream\n+     * @return closed ByteArrayOutputStream\n+     * @throws SerializationException wraps runtime exceptions\n+     */\n+    public ByteArrayOutputStream encode(Object object) throws SerializationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MTQ4OA==", "bodyText": "Don't need to close ByteArrayOutputStream.\nFrom javadoc:\n\nClosing a ByteArrayOutputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432681488", "createdAt": "2020-05-29T19:07:11Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }\n+\n+    /**\n+     * Returns ByteArrayOutputStream containing Avro encoding of object parameter\n+     * @param object Object to be encoded into byte stream\n+     * @return closed ByteArrayOutputStream\n+     * @throws SerializationException wraps runtime exceptions\n+     */\n+    public ByteArrayOutputStream encode(Object object) throws SerializationException {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            if (object instanceof byte[]) {\n+                out.write((byte[]) object);\n+            } else {\n+                BinaryEncoder encoder = encoderFactory.directBinaryEncoder(out, null);\n+                DatumWriter<Object> writer;\n+                if (object instanceof SpecificRecord) {\n+                    writer = new SpecificDatumWriter<>(schema);\n+                } else {\n+                    writer = new GenericDatumWriter<>(schema);\n+                }\n+                writer.write(object, encoder);\n+                encoder.flush();\n+            }\n+            out.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4Mjc2MQ==", "bodyText": "Add @OverRide annotation for both these methods.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432682761", "createdAt": "2020-05-29T19:10:14Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroCodec.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.Codec;\n+import org.apache.avro.Schema;\n+\n+/**\n+ * Base Codec class for Avro encoder and decoder implementations\n+ */\n+abstract class AvroCodec implements Codec {\n+    public String schemaType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NDQyMA==", "bodyText": "Name this class ApacheAvroByteDecoder so that  we can support Jackson avro later if required. (If this is going away after switching to azure-core implementation, then you can leave it as-is).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432684420", "createdAt": "2020-05-29T19:14:08Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjM4NQ==", "bodyText": "Don't need async suffix since the class is called SchemaRegistryAvroAsyncDeserializer", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432686385", "createdAt": "2020-05-29T19:18:50Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncDeserializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based deserializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncDeserializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroDeserializer deserializer;\n+    private final Scheduler scheduler;\n+\n+    /**\n+     * Instantiates instance of async deserializer.\n+     *\n+     * @param deserializer synchronous internal deserializer implementation\n+     */\n+    SchemaRegistryAvroAsyncDeserializer(SchemaRegistryAvroDeserializer deserializer) {\n+        this.deserializer = deserializer;\n+        this.scheduler = Schedulers.fromExecutor(Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n+    }\n+\n+    /**\n+     * Async wrapper around synchronous deserialization method\n+     * @param data bytes containing schema ID and encoded byte representation of object\n+     * @return Mono wrapper around deserialized object\n+     * @throws SerializationException if deserialization operation fails\n+     */\n+    public Mono<Object> deserializeAsync(byte[] data) throws SerializationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NzQxNg==", "bodyText": "Agree. This should return Mono.just(new byte[0])", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432687416", "createdAt": "2020-05-29T19:21:16Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncSerializer.java", "diffHunk": "@@ -0,0 +1,48 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.AbstractDataSerializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based serializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncSerializer extends AbstractDataSerializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroSerializer serializer;\n+    private final Scheduler scheduler;\n+\n+    /**\n+     * @param serializer synchronous Avro serializer implementation\n+     */\n+    SchemaRegistryAvroAsyncSerializer(SchemaRegistryAvroSerializer serializer) {\n+        this.serializer = serializer;\n+        this.scheduler = Schedulers.fromExecutor(Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n+    }\n+\n+    /**\n+     * Async wrapper around sync serialization operation\n+     *\n+     * @param object object to be serialized to bytes\n+     * @return Avro byte representation of object\n+     * @throws SerializationException upon serialization operation failure\n+     */\n+    public Mono<byte[]> serializeAsync(Object object) throws SerializationException {\n+        if (object == null) {\n+            return Mono.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzM2Mg=="}, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTAzNA==", "bodyText": "Consider using no-args ctor for builder and have a setter method for registryUrl", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432689034", "createdAt": "2020-05-29T19:25:05Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializerBuilder.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+\n+/**\n+ * Builder class for constructing {@link SchemaRegistryAvroDeserializer} and {@link SchemaRegistryAvroAsyncDeserializer}\n+ */\n+public class SchemaRegistryAvroDeserializerBuilder {\n+\n+    private final String registryUrl;\n+    private TokenCredential credential;\n+    private boolean avroSpecificReader;\n+    private Integer maxSchemaMapSize;\n+\n+    /**\n+     * Instantiates instance of Builder class.\n+     * Supplies client defaults.\n+     *\n+     * @param registryUrl base schema registry URL for storing and fetching schemas\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder(String registryUrl) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MDE4NQ==", "bodyText": "Check if credential and registryUrl are null before creating the Deserializer.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432690185", "createdAt": "2020-05-29T19:27:46Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializerBuilder.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+\n+/**\n+ * Builder class for constructing {@link SchemaRegistryAvroDeserializer} and {@link SchemaRegistryAvroAsyncDeserializer}\n+ */\n+public class SchemaRegistryAvroDeserializerBuilder {\n+\n+    private final String registryUrl;\n+    private TokenCredential credential;\n+    private boolean avroSpecificReader;\n+    private Integer maxSchemaMapSize;\n+\n+    /**\n+     * Instantiates instance of Builder class.\n+     * Supplies client defaults.\n+     *\n+     * @param registryUrl base schema registry URL for storing and fetching schemas\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder(String registryUrl) {\n+        this.registryUrl = registryUrl;\n+        this.credential = null;\n+        this.avroSpecificReader = false;\n+        this.maxSchemaMapSize = null;\n+    }\n+\n+    /**\n+     *\n+     * @param credential TokenCredential to be used for authenticating with Azure Schema Registry Service\n+     * @return updated {@link SchemaRegistryAvroDeserializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder credential(TokenCredential credential) {\n+        this.credential = credential;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies if objects should be deserialized into Avro SpecificRecords via Avro SpecificDatumReader\n+     * @param avroSpecificReader specific reader flag\n+     * @return updated {@link SchemaRegistryAvroDeserializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder avroSpecificReader(boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies maximum schema object cache size for underlying CachedSchemaRegistryClient.  If specified cache\n+     * size is exceeded, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize maximum number of schemas per cache\n+     * @return updated {@link SchemaRegistryAvroDeserializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder maxSchemaMapSize(int maxSchemaMapSize) {\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Construct instance of {@link SchemaRegistryAvroAsyncDeserializer}\n+     *\n+     * @return {@link SchemaRegistryAvroAsyncDeserializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroAsyncDeserializer buildAsyncClient() {\n+        return new SchemaRegistryAvroAsyncDeserializer(this.buildSyncClient());\n+    }\n+\n+    /**\n+     * Construct instance of {@link SchemaRegistryAvroDeserializer}\n+     *\n+     * @return {@link SchemaRegistryAvroDeserializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroDeserializer buildSyncClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjY5Ng==", "bodyText": "Validate inputs to check if all required fields like registryUrl and credential are set.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432692696", "createdAt": "2020-05-29T19:33:35Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroSerializerBuilder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.data.schemaregistry.AbstractDataSerializer;\n+\n+/**\n+ * Builder implemenation for building {@link SchemaRegistryAvroSerializer} and {@link SchemaRegistryAvroAsyncSerializer}\n+ */\n+public final class SchemaRegistryAvroSerializerBuilder {\n+    private final String registryUrl;\n+    private TokenCredential credential;\n+    private boolean autoRegisterSchemas;\n+    private String schemaGroup;\n+    private Integer maxSchemaMapSize;\n+\n+    /**\n+     * Instantiates instance of Builder class.\n+     * Supplies client defaults.\n+     *\n+     * @param registryUrl base schema registry URL for storing and fetching schemas\n+     */\n+    private SchemaRegistryAvroSerializerBuilder(String registryUrl) {\n+        this.registryUrl = registryUrl;\n+        this.credential = null;\n+        this.autoRegisterSchemas = AbstractDataSerializer.AUTO_REGISTER_SCHEMAS_DEFAULT;\n+        this.schemaGroup = AbstractDataSerializer.SCHEMA_GROUP_DEFAULT;\n+        this.maxSchemaMapSize = null;\n+    }\n+\n+    /**\n+     * Specifies schema group for interacting with Azure Schema Registry service.\n+     *\n+     * If auto-registering schemas, schema will be stored under this group.\n+     * If not auto-registering, serializer will request schema ID for matching data schema under specified group.\n+     *\n+     * @param schemaGroup Azure Schema Registry schema group\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder schemaGroup(String schemaGroup) {\n+        this.schemaGroup = schemaGroup;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies authentication behavior with Azure Schema Registry\n+     * @param credential TokenCredential to be used to authenticate with Azure Schema Registry service\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder credential(TokenCredential credential) {\n+        this.credential = credential;\n+        return this;\n+    }\n+\n+    /**\n+     * If specified true, serializer will register schemas against Azure Schema Registry service under the specified\n+     * group.  See Azure Schema Registry documentation for a description of schema registration behavior.\n+     *\n+     * If specified false, serializer will simply query the service for an existing ID given schema content.\n+     * Serialization will fail if the schema has not been pre-created.\n+     *\n+     * Auto-registration is **NOT RECOMMENDED** for production scenarios.\n+     *\n+     * @param autoRegisterSchemas flag for schema auto-registration\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder autoRegisterSchema(boolean autoRegisterSchemas) {\n+        this.autoRegisterSchemas = autoRegisterSchemas;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies maximum schema object cache size for underlying CachedSchemaRegistryClient.  If specified cache\n+     * size is exceeded, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize maximum number of schemas per cache\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder maxSchemaMapSize(int maxSchemaMapSize) {\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Instantiates SchemaRegistry\n+     * @return {@link SchemaRegistryAvroAsyncSerializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroAsyncSerializer buildAsyncClient() {\n+        return new SchemaRegistryAvroAsyncSerializer(this.buildSyncClient());\n+    }\n+\n+    /**\n+     * Instantiates {@link SchemaRegistryAvroSerializer}\n+     * @return {@link SchemaRegistryAvroSerializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroSerializer buildSyncClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzA3MA==", "bodyText": "This should be named as com.azure.data.schemaregistry.avro", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432693070", "createdAt": "2020-05-29T19:34:33Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,8 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.avro {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5ODQ4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");\n          \n          \n            \n                    Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432698484", "createdAt": "2020-05-29T19:43:01Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.Codec;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestService;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestServiceClientBuilder;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-data-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final ConcurrentSkipListMap<String, Function<String, Object>> typeParserMap;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private String schemaRegistryUrl;\n+    private HttpClient httpClient;\n+    private Integer maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Constructor for CachedSchemaRegistryClientBuilder.  Supplies client defaults.\n+     */\n+    public CachedSchemaRegistryClientBuilder() {\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = null;\n+        this.typeParserMap = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     *\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL\n+     */\n+    public CachedSchemaRegistryClientBuilder endpoint(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5ODg2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));\n          \n          \n            \n                        throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432698869", "createdAt": "2020-05-29T19:43:30Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.Codec;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestService;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestServiceClientBuilder;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-data-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final ConcurrentSkipListMap<String, Function<String, Object>> typeParserMap;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private String schemaRegistryUrl;\n+    private HttpClient httpClient;\n+    private Integer maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Constructor for CachedSchemaRegistryClientBuilder.  Supplies client defaults.\n+     */\n+    public CachedSchemaRegistryClientBuilder() {\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = null;\n+        this.typeParserMap = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     *\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL\n+     */\n+    public CachedSchemaRegistryClientBuilder endpoint(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5OTcyMw==", "bodyText": "Check if codec is null before checking codec.schemaType.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432699723", "createdAt": "2020-05-29T19:44:40Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.Codec;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestService;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestServiceClientBuilder;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-data-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final ConcurrentSkipListMap<String, Function<String, Object>> typeParserMap;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private String schemaRegistryUrl;\n+    private HttpClient httpClient;\n+    private Integer maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Constructor for CachedSchemaRegistryClientBuilder.  Supplies client defaults.\n+     */\n+    public CachedSchemaRegistryClientBuilder() {\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = null;\n+        this.typeParserMap = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     *\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL\n+     */\n+    public CachedSchemaRegistryClientBuilder endpoint(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.data.schemaregistry.ByteEncoder or com.azure.data.schemaregistry.ByteDecoder class will implement\n+     * - schemaType(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param codec Codec class implementation\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder addSchemaParser(Codec codec) {\n+        if (CoreUtils.isNullOrEmpty(codec.schemaType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMTgxOA==", "bodyText": "This should be named as com.azure.data.schemaregistry", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432701818", "createdAt": "2020-05-29T19:47:34Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,11 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.common {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMjgyNA==", "bodyText": "This should transitively require core.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432702824", "createdAt": "2020-05-29T19:49:43Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,11 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.common {\n+    requires com.azure.core;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMzU3MQ==", "bodyText": "Swagger will go into azure-rest-api-specs once the swagger review board approves it. Since this swagger has not yet been reviewed, I am fine with having it in this repo until then.\n@arerlend Can you checkin the json version of swagger instead of yaml", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432703571", "createdAt": "2020-05-29T19:51:21Z", "author": {"login": "srnagar"}, "path": "sdk/schemaregistry/azure-data-schemaregistry/swagger/swagger.yaml", "diffHunk": "@@ -0,0 +1,378 @@\n+openapi: 3.0.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MDMyMA=="}, "originalCommit": {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5c40b1d74f2ba4462e9ec347998c876458c017a", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5c40b1d74f2ba4462e9ec347998c876458c017a", "committedDate": "2020-05-29T20:49:46Z", "message": "fix comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "101aeebbd0ab2198e58b83c5deeddcd80660ef4b", "author": {"user": {"login": "arerlend", "name": "Arthur Erlendsson"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/101aeebbd0ab2198e58b83c5deeddcd80660ef4b", "committedDate": "2020-05-29T20:49:58Z", "message": "spotbugs update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzQ4Nzg3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-421348787", "createdAt": "2020-05-29T23:34:27Z", "commit": {"oid": "101aeebbd0ab2198e58b83c5deeddcd80660ef4b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzUxNjQ3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#pullrequestreview-421351647", "createdAt": "2020-05-29T23:47:37Z", "commit": {"oid": "101aeebbd0ab2198e58b83c5deeddcd80660ef4b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4512, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}