{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTU1MzM0", "number": 10022, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjowOTo1NVrODwyikQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjozMTowOVrODwy47w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg2Mjg5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjowOTo1NVrOGD-vNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDo1ODowMlrOGEFucg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjgwNg==", "bodyText": "It is confusing to call it SUBSCRIPTION in sender. But I understand why you have done it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406826806", "createdAt": "2020-04-10T16:09:55Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -432,7 +433,7 @@ public ServiceBusSenderAsyncClient buildAsyncClient() {\n                 case QUEUE:\n                     entityName = queueName;\n                     break;\n-                case TOPIC:\n+                case SUBSCRIPTION:\n                     entityName = topicName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0MTI5OA==", "bodyText": "Yes. To match the entity type passed to Service Bus.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406941298", "createdAt": "2020-04-10T20:58:02Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -432,7 +433,7 @@ public ServiceBusSenderAsyncClient buildAsyncClient() {\n                 case QUEUE:\n                     entityName = queueName;\n                     break;\n-                case TOPIC:\n+                case SUBSCRIPTION:\n                     entityName = topicName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjgwNg=="}, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg4Mzc2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoxNzoyM1rOGD-7tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoxNzoyM1rOGD-7tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMDAwNw==", "bodyText": "Did you miss using sendMessage(messageToSend) here  and  adding timeout?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406830007", "createdAt": "2020-04-10T16:17:23Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -476,11 +523,14 @@ void sendReceiveMessageWithVariousPropertyTypes() {\n         sentProperties.put(\"UUIDProperty\", UUID.randomUUID());\n         sentProperties.put(\"StringProperty\", \"string\");\n \n-        sender.send(messageToSend).block(TIMEOUT);\n+        sender.send(messageToSend);\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 607}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDkwNjY0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoyNTo1OFrOGD_J0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzoxMTo1OFrOGEAU2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMzYxNg==", "bodyText": "I can see that quickly we will have to change this to include other input parameters, for example\nqueuename / topic names , sessionId for receivers . So instead of taking taking just one parameters entityType, it should take a bag of things and  use that  bag to create receivers.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406833616", "createdAt": "2020-04-10T16:25:58Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientIntegrationTest.java", "diffHunk": "@@ -62,6 +96,47 @@ void nonSessionMessageBatch() {\n         for (ServiceBusMessage message : messages) {\n             Assertions.assertTrue(batch.tryAdd(message));\n         }\n+\n         sender.send(batch);\n+\n+        for (int i = 0; i < messages.size(); i++) {\n+            messagesPending.incrementAndGet();\n+        }\n+    }\n+\n+    void setSenderAndReceiver(MessagingEntityType entityType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg1MjgyNA==", "bodyText": "This is for sender. There are not many properties. And the receiver will always be the same so that we can clean up the messaging entity in the case of a failure.\nIn receiver, there is an overload that takes: Function<ServiceBusReceiverClientBuilder, ServiceBusReceiverClientBuilder> onCreate, where you can apply any other custom modifications.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406852824", "createdAt": "2020-04-10T17:11:58Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientIntegrationTest.java", "diffHunk": "@@ -62,6 +96,47 @@ void nonSessionMessageBatch() {\n         for (ServiceBusMessage message : messages) {\n             Assertions.assertTrue(batch.tryAdd(message));\n         }\n+\n         sender.send(batch);\n+\n+        for (int i = 0; i < messages.size(); i++) {\n+            messagesPending.incrementAndGet();\n+        }\n+    }\n+\n+    void setSenderAndReceiver(MessagingEntityType entityType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMzYxNg=="}, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDkyMDE1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjozMTowOVrOGD_SHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzoxNDo0NFrOGEAZhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTc0MQ==", "bodyText": "Why we are not using TIMEOUT ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406835741", "createdAt": "2020-04-10T16:31:09Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -22,178 +24,165 @@\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n import java.util.stream.Stream;\n \n+import static com.azure.messaging.servicebus.TestUtils.MESSAGE_POSITION_ID;\n import static com.azure.messaging.servicebus.TestUtils.MESSAGE_TRACKING_ID;\n import static com.azure.messaging.servicebus.TestUtils.getServiceBusMessage;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+/**\n+ * Integration tests for {@link ServiceBusReceiverAsyncClient} from queues or subscriptions.\n+ */\n class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n-    private static final String CONTENTS = \"Test-contents\";\n+    private static final byte[] CONTENTS_BYTES = \"Some-contents\".getBytes(StandardCharsets.UTF_8);\n     private final ClientLogger logger = new ClientLogger(ServiceBusReceiverAsyncClientIntegrationTest.class);\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n \n     private ServiceBusReceiverAsyncClient receiver;\n-    private ServiceBusReceiverAsyncClient receiveDeleteModeReceiver;\n+    private ServiceBusReceiverAsyncClient receiveAndDeleteReceiver;\n     private ServiceBusSenderAsyncClient sender;\n \n     ServiceBusReceiverAsyncClientIntegrationTest() {\n         super(new ClientLogger(ServiceBusReceiverAsyncClientIntegrationTest.class));\n     }\n \n     @Override\n-    protected void beforeTest() {\n-        final String queueName = getQueueName();\n-        assertNotNull(queueName, \"'queueName' cannot be null.\");\n-\n-        sender = createBuilder().sender().queueName(queueName).buildAsyncClient();\n-        receiver = createBuilder()\n-            .receiver()\n-            .queueName(queueName)\n-            .buildAsyncClient();\n-\n-        receiveDeleteModeReceiver = createBuilder()\n-            .receiver()\n-            .queueName(queueName)\n-            .receiveMode(ReceiveMode.RECEIVE_AND_DELETE)\n-            .buildAsyncClient();\n+    protected void afterTest() {\n+        if (messagesPending.get() == 0) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        try {\n+            receiveAndDeleteReceiver.receive(new ReceiveAsyncOptions().setEnableAutoComplete(false))\n+                .take(messagesPending.get())\n+                .map(message -> {\n+                    logger.info(\"Message received: {}\", message.getSequenceNumber());\n+                    return message;\n+                })\n+                .timeout(Duration.ofSeconds(5), Mono.empty())\n+                .blockLast();\n+        } catch (Exception e) {\n+            logger.warning(\"Error occurred when draining queue.\", e);\n+        } finally {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+        }\n     }\n \n-    @Override\n-    protected void afterTest() {\n-        dispose(receiver, receiveDeleteModeReceiver, sender);\n+    static Stream<Arguments> receiverTypesProvider() {\n+        return Stream.of(\n+            Arguments.of(MessagingEntityType.QUEUE),\n+            Arguments.of(MessagingEntityType.SUBSCRIPTION)\n+        );\n     }\n \n     /**\n      * Verifies that we can send and receive two messages.\n      */\n     @Disabled(\"Problem when receiving two messages. Link is closed prematurely.\")\n-    @Test\n-    void receiveTwoMessagesAutoComplete() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n-        final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n+        final int position = 10;\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, position);\n+\n+        Mono.when(sendMessage(message), sendMessage(message)).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).then(sender.send(message))\n-            .thenMany(receiver.receive(options)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.receive())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, position))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, position))\n             .thenCancel()\n             .verify();\n     }\n \n     /**\n      * Verifies that we can send and receive a message.\n      */\n-    @Test\n-    void receiveMessageAutoComplete() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n-        final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n+\n+        sendMessage(message).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).thenMany(receiver.receive(options)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.receive())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, 0))\n             .thenCancel()\n             .verify();\n     }\n \n     /**\n      * Verifies that we can send and peek a message.\n      */\n-    @Test\n-    void peekMessage() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n+\n+        sendMessage(message).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).then(receiver.peek()))\n-            .assertNext(receivedMessage -> assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.peek())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, 0))\n             .verifyComplete();\n     }\n \n     /**\n      * Verifies that we can schedule and receive a message.\n      */\n-    @Test\n-    void sendScheduledMessageAndReceive() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void sendScheduledMessageAndReceive(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final String contents = \"Some-contents\";\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n         final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n-\n-        sender.scheduleMessage(message, scheduledEnqueueTime)\n-            .delaySubscription(Duration.ofSeconds(3))\n-            .block();\n-\n-        // Assert & Act\n-        StepVerifier.create(receiver.receive().take(1))\n-            .assertNext(receivedMessage -> {\n-                assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n-            })\n-            .verifyComplete();\n-    }\n-\n-    /**\n-     * Verifies that we can schedule and receive multiple messages.\n-     */\n-    @Test\n-    void sendMultipleScheduledMessageAndReceive() {\n-        // Arrange\n-        final String messageId1 = UUID.randomUUID().toString();\n-        final String messageId2 = UUID.randomUUID().toString();\n-        final ServiceBusMessage message1 = TestUtils.getServiceBusMessage(CONTENTS, messageId1, 0);\n-        final ServiceBusMessage message2 = TestUtils.getServiceBusMessage(CONTENTS, messageId2, 0);\n-        final Duration duration = Duration.ofSeconds(10);\n-        final Instant scheduledEnqueueTime = Instant.now().plus(duration);\n         final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n \n-        sender.scheduleMessage(message1, scheduledEnqueueTime)\n-            .block(TIMEOUT);\n-        sender.scheduleMessage(message2, scheduledEnqueueTime)\n-            .block(TIMEOUT);\n+        sender.scheduleMessage(message, scheduledEnqueueTime).block();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg1NDAyMQ==", "bodyText": "In IntegrationTestBase, we set the StepVerifier.setDefaultTimeout(), so it'll use that. Practically, we can remove all the .block(TIMEOUT).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406854021", "createdAt": "2020-04-10T17:14:44Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -22,178 +24,165 @@\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n import java.util.stream.Stream;\n \n+import static com.azure.messaging.servicebus.TestUtils.MESSAGE_POSITION_ID;\n import static com.azure.messaging.servicebus.TestUtils.MESSAGE_TRACKING_ID;\n import static com.azure.messaging.servicebus.TestUtils.getServiceBusMessage;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+/**\n+ * Integration tests for {@link ServiceBusReceiverAsyncClient} from queues or subscriptions.\n+ */\n class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n-    private static final String CONTENTS = \"Test-contents\";\n+    private static final byte[] CONTENTS_BYTES = \"Some-contents\".getBytes(StandardCharsets.UTF_8);\n     private final ClientLogger logger = new ClientLogger(ServiceBusReceiverAsyncClientIntegrationTest.class);\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n \n     private ServiceBusReceiverAsyncClient receiver;\n-    private ServiceBusReceiverAsyncClient receiveDeleteModeReceiver;\n+    private ServiceBusReceiverAsyncClient receiveAndDeleteReceiver;\n     private ServiceBusSenderAsyncClient sender;\n \n     ServiceBusReceiverAsyncClientIntegrationTest() {\n         super(new ClientLogger(ServiceBusReceiverAsyncClientIntegrationTest.class));\n     }\n \n     @Override\n-    protected void beforeTest() {\n-        final String queueName = getQueueName();\n-        assertNotNull(queueName, \"'queueName' cannot be null.\");\n-\n-        sender = createBuilder().sender().queueName(queueName).buildAsyncClient();\n-        receiver = createBuilder()\n-            .receiver()\n-            .queueName(queueName)\n-            .buildAsyncClient();\n-\n-        receiveDeleteModeReceiver = createBuilder()\n-            .receiver()\n-            .queueName(queueName)\n-            .receiveMode(ReceiveMode.RECEIVE_AND_DELETE)\n-            .buildAsyncClient();\n+    protected void afterTest() {\n+        if (messagesPending.get() == 0) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        try {\n+            receiveAndDeleteReceiver.receive(new ReceiveAsyncOptions().setEnableAutoComplete(false))\n+                .take(messagesPending.get())\n+                .map(message -> {\n+                    logger.info(\"Message received: {}\", message.getSequenceNumber());\n+                    return message;\n+                })\n+                .timeout(Duration.ofSeconds(5), Mono.empty())\n+                .blockLast();\n+        } catch (Exception e) {\n+            logger.warning(\"Error occurred when draining queue.\", e);\n+        } finally {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+        }\n     }\n \n-    @Override\n-    protected void afterTest() {\n-        dispose(receiver, receiveDeleteModeReceiver, sender);\n+    static Stream<Arguments> receiverTypesProvider() {\n+        return Stream.of(\n+            Arguments.of(MessagingEntityType.QUEUE),\n+            Arguments.of(MessagingEntityType.SUBSCRIPTION)\n+        );\n     }\n \n     /**\n      * Verifies that we can send and receive two messages.\n      */\n     @Disabled(\"Problem when receiving two messages. Link is closed prematurely.\")\n-    @Test\n-    void receiveTwoMessagesAutoComplete() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n-        final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n+        final int position = 10;\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, position);\n+\n+        Mono.when(sendMessage(message), sendMessage(message)).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).then(sender.send(message))\n-            .thenMany(receiver.receive(options)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.receive())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, position))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, position))\n             .thenCancel()\n             .verify();\n     }\n \n     /**\n      * Verifies that we can send and receive a message.\n      */\n-    @Test\n-    void receiveMessageAutoComplete() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n-        final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n+\n+        sendMessage(message).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).thenMany(receiver.receive(options)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.receive())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, 0))\n             .thenCancel()\n             .verify();\n     }\n \n     /**\n      * Verifies that we can send and peek a message.\n      */\n-    @Test\n-    void peekMessage() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n+\n+        sendMessage(message).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).then(receiver.peek()))\n-            .assertNext(receivedMessage -> assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.peek())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, 0))\n             .verifyComplete();\n     }\n \n     /**\n      * Verifies that we can schedule and receive a message.\n      */\n-    @Test\n-    void sendScheduledMessageAndReceive() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void sendScheduledMessageAndReceive(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final String contents = \"Some-contents\";\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n         final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n-\n-        sender.scheduleMessage(message, scheduledEnqueueTime)\n-            .delaySubscription(Duration.ofSeconds(3))\n-            .block();\n-\n-        // Assert & Act\n-        StepVerifier.create(receiver.receive().take(1))\n-            .assertNext(receivedMessage -> {\n-                assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n-            })\n-            .verifyComplete();\n-    }\n-\n-    /**\n-     * Verifies that we can schedule and receive multiple messages.\n-     */\n-    @Test\n-    void sendMultipleScheduledMessageAndReceive() {\n-        // Arrange\n-        final String messageId1 = UUID.randomUUID().toString();\n-        final String messageId2 = UUID.randomUUID().toString();\n-        final ServiceBusMessage message1 = TestUtils.getServiceBusMessage(CONTENTS, messageId1, 0);\n-        final ServiceBusMessage message2 = TestUtils.getServiceBusMessage(CONTENTS, messageId2, 0);\n-        final Duration duration = Duration.ofSeconds(10);\n-        final Instant scheduledEnqueueTime = Instant.now().plus(duration);\n         final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n \n-        sender.scheduleMessage(message1, scheduledEnqueueTime)\n-            .block(TIMEOUT);\n-        sender.scheduleMessage(message2, scheduledEnqueueTime)\n-            .block(TIMEOUT);\n+        sender.scheduleMessage(message, scheduledEnqueueTime).block();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTc0MQ=="}, "originalCommit": {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0"}, "originalPosition": 234}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1929, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}