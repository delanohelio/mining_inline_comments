{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzEyNTc5", "number": 7336, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMjo1MTozMFrODXJOkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMzowMjo0NVrODXJYeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NTk1MDI0OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AzureTokenManagerProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMjo1MTozMFrOFcTOeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMjo1MTozMFrOFcTOeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIxOTQ1MA==", "bodyText": "getScopesFromResource() might be a better name for this method?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7336#discussion_r365219450", "createdAt": "2020-01-10T12:51:30Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AzureTokenManagerProvider.java", "diffHunk": "@@ -47,7 +47,7 @@ public TokenManager getTokenManager(Mono<ClaimsBasedSecurityNode> cbsNodeMono, S\n         final String scopes = getResourceString(resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "437b1bc4484829d8e9402394b409090d20252182"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NTk3NTYwOnYy", "diffSide": "RIGHT", "path": "sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/EventHubPartitionAsyncConsumer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMzowMjo0NVrOFcTdnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNzoyOTo1NVrOFca_qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIyMzMyNQ==", "bodyText": "Would it be more efficient if we just kept track of offset (long value) and convert to EventPosition only when the link goes down to restore the link? It prevents creating a lot of EventPosition objects.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7336#discussion_r365223325", "createdAt": "2020-01-10T13:02:45Z", "author": {"login": "srnagar"}, "path": "sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/EventHubPartitionAsyncConsumer.java", "diffHunk": "@@ -3,127 +3,68 @@\n \n package com.azure.messaging.eventhubs;\n \n-import com.azure.core.amqp.implementation.AmqpReceiveLink;\n import com.azure.core.amqp.implementation.MessageSerializer;\n import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.eventhubs.implementation.AmqpReceiveLinkProcessor;\n+import com.azure.messaging.eventhubs.models.EventPosition;\n import com.azure.messaging.eventhubs.models.LastEnqueuedEventProperties;\n import com.azure.messaging.eventhubs.models.PartitionContext;\n import com.azure.messaging.eventhubs.models.PartitionEvent;\n import com.azure.messaging.eventhubs.models.ReceiveOptions;\n import org.apache.qpid.proton.message.Message;\n import reactor.core.publisher.EmitterProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n  * A package-private consumer responsible for reading {@link EventData} from a specific Event Hub partition in the\n  * context of a specific consumer group.\n  */\n class EventHubPartitionAsyncConsumer implements AutoCloseable {\n-    private static final AtomicReferenceFieldUpdater<EventHubPartitionAsyncConsumer, AmqpReceiveLink>\n-        RECEIVE_LINK_FIELD_UPDATER = AtomicReferenceFieldUpdater.newUpdater(\n-        EventHubPartitionAsyncConsumer.class, AmqpReceiveLink.class, \"receiveLink\");\n-\n-    // We don't want to dump too many credits on the link at once. It's easy enough to ask for more.\n-    private static final int MINIMUM_REQUEST = 0;\n-    private static final int MAXIMUM_REQUEST = 100;\n-\n-    private final AtomicInteger creditsToRequest = new AtomicInteger(1);\n+    private final ClientLogger logger = new ClientLogger(EventHubPartitionAsyncConsumer.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n     private final AtomicReference<LastEnqueuedEventProperties> lastEnqueuedEventProperties = new AtomicReference<>();\n-    private final ClientLogger logger = new ClientLogger(EventHubPartitionAsyncConsumer.class);\n+    private final AmqpReceiveLinkProcessor amqpReceiveLinkProcessor;\n     private final MessageSerializer messageSerializer;\n     private final String fullyQualifiedNamespace;\n     private final String eventHubName;\n     private final String consumerGroup;\n     private final String partitionId;\n-    private final EmitterProcessor<PartitionEvent> emitterProcessor;\n-    private final Flux<PartitionEvent> messageFlux;\n     private final boolean trackLastEnqueuedEventProperties;\n+    private final EmitterProcessor<PartitionEvent> emitterProcessor;\n \n-    private volatile AmqpReceiveLink receiveLink;\n-\n-    EventHubPartitionAsyncConsumer(Mono<AmqpReceiveLink> receiveLinkMono, MessageSerializer messageSerializer,\n-        String fullyQualifiedNamespace, String eventHubName, String consumerGroup, String partitionId,\n-        int prefetchCount, boolean trackLastEnqueuedEventProperties) {\n+    EventHubPartitionAsyncConsumer(AmqpReceiveLinkProcessor amqpReceiveLinkProcessor,\n+        MessageSerializer messageSerializer, String fullyQualifiedNamespace, String eventHubName, String consumerGroup,\n+        String partitionId, AtomicReference<EventPosition> currentEventPosition,\n+        boolean trackLastEnqueuedEventProperties) {\n+        this.amqpReceiveLinkProcessor = amqpReceiveLinkProcessor;\n         this.messageSerializer = messageSerializer;\n         this.fullyQualifiedNamespace = fullyQualifiedNamespace;\n         this.eventHubName = eventHubName;\n         this.consumerGroup = consumerGroup;\n         this.partitionId = partitionId;\n-        this.emitterProcessor = EmitterProcessor.create(prefetchCount, false);\n+        this.emitterProcessor = amqpReceiveLinkProcessor\n+            .map(message -> onMessageReceived(message))\n+            .doOnNext(event -> {\n+                // Keep track of the last position so if the link goes down, we don't start from the original location.\n+                final Long offset = event.getData().getOffset();\n+                if (offset != null) {\n+                    currentEventPosition.set(EventPosition.fromOffset(offset));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "437b1bc4484829d8e9402394b409090d20252182"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NjcyOQ==", "bodyText": "Makes sense. I'll update it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7336#discussion_r365346729", "createdAt": "2020-01-10T17:29:55Z", "author": {"login": "conniey"}, "path": "sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/EventHubPartitionAsyncConsumer.java", "diffHunk": "@@ -3,127 +3,68 @@\n \n package com.azure.messaging.eventhubs;\n \n-import com.azure.core.amqp.implementation.AmqpReceiveLink;\n import com.azure.core.amqp.implementation.MessageSerializer;\n import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.eventhubs.implementation.AmqpReceiveLinkProcessor;\n+import com.azure.messaging.eventhubs.models.EventPosition;\n import com.azure.messaging.eventhubs.models.LastEnqueuedEventProperties;\n import com.azure.messaging.eventhubs.models.PartitionContext;\n import com.azure.messaging.eventhubs.models.PartitionEvent;\n import com.azure.messaging.eventhubs.models.ReceiveOptions;\n import org.apache.qpid.proton.message.Message;\n import reactor.core.publisher.EmitterProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n  * A package-private consumer responsible for reading {@link EventData} from a specific Event Hub partition in the\n  * context of a specific consumer group.\n  */\n class EventHubPartitionAsyncConsumer implements AutoCloseable {\n-    private static final AtomicReferenceFieldUpdater<EventHubPartitionAsyncConsumer, AmqpReceiveLink>\n-        RECEIVE_LINK_FIELD_UPDATER = AtomicReferenceFieldUpdater.newUpdater(\n-        EventHubPartitionAsyncConsumer.class, AmqpReceiveLink.class, \"receiveLink\");\n-\n-    // We don't want to dump too many credits on the link at once. It's easy enough to ask for more.\n-    private static final int MINIMUM_REQUEST = 0;\n-    private static final int MAXIMUM_REQUEST = 100;\n-\n-    private final AtomicInteger creditsToRequest = new AtomicInteger(1);\n+    private final ClientLogger logger = new ClientLogger(EventHubPartitionAsyncConsumer.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n     private final AtomicReference<LastEnqueuedEventProperties> lastEnqueuedEventProperties = new AtomicReference<>();\n-    private final ClientLogger logger = new ClientLogger(EventHubPartitionAsyncConsumer.class);\n+    private final AmqpReceiveLinkProcessor amqpReceiveLinkProcessor;\n     private final MessageSerializer messageSerializer;\n     private final String fullyQualifiedNamespace;\n     private final String eventHubName;\n     private final String consumerGroup;\n     private final String partitionId;\n-    private final EmitterProcessor<PartitionEvent> emitterProcessor;\n-    private final Flux<PartitionEvent> messageFlux;\n     private final boolean trackLastEnqueuedEventProperties;\n+    private final EmitterProcessor<PartitionEvent> emitterProcessor;\n \n-    private volatile AmqpReceiveLink receiveLink;\n-\n-    EventHubPartitionAsyncConsumer(Mono<AmqpReceiveLink> receiveLinkMono, MessageSerializer messageSerializer,\n-        String fullyQualifiedNamespace, String eventHubName, String consumerGroup, String partitionId,\n-        int prefetchCount, boolean trackLastEnqueuedEventProperties) {\n+    EventHubPartitionAsyncConsumer(AmqpReceiveLinkProcessor amqpReceiveLinkProcessor,\n+        MessageSerializer messageSerializer, String fullyQualifiedNamespace, String eventHubName, String consumerGroup,\n+        String partitionId, AtomicReference<EventPosition> currentEventPosition,\n+        boolean trackLastEnqueuedEventProperties) {\n+        this.amqpReceiveLinkProcessor = amqpReceiveLinkProcessor;\n         this.messageSerializer = messageSerializer;\n         this.fullyQualifiedNamespace = fullyQualifiedNamespace;\n         this.eventHubName = eventHubName;\n         this.consumerGroup = consumerGroup;\n         this.partitionId = partitionId;\n-        this.emitterProcessor = EmitterProcessor.create(prefetchCount, false);\n+        this.emitterProcessor = amqpReceiveLinkProcessor\n+            .map(message -> onMessageReceived(message))\n+            .doOnNext(event -> {\n+                // Keep track of the last position so if the link goes down, we don't start from the original location.\n+                final Long offset = event.getData().getOffset();\n+                if (offset != null) {\n+                    currentEventPosition.set(EventPosition.fromOffset(offset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIyMzMyNQ=="}, "originalCommit": {"oid": "437b1bc4484829d8e9402394b409090d20252182"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 552, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}