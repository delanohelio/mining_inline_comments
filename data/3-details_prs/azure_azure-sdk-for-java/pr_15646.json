{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNzQwNDQ0", "number": 15646, "title": "Decouple PagedIterable and PagedFlux to Prevent Background Page Requests", "bodyText": "Fixes #15575\nThis PR decouples some ContinuablePagedIterable implementations from ContinuablePagedFlux when the ContinuablePagedFlux implementation is an instanceof ContinuablePagedFluxCore. This change allows for finer control of page enumeration by removing our dependency on Reactor's toIterable and toStream implementations on a Flux.\nPreviously, when our implementation used Reactor's toIterable and toStream to implement ContinuablePagedIterable's functionality we would see additional pages getting requested. Calling into these methods we passed a batchSize of 1 which indicated to the backing Flux to only request one element, paged, from upstream at time. But this also served a dual purpose of internal tracking for the backing enumerable to determine when it needed to make additional requests to upstream, so on every next iteration it would hit its internal limit of 1 and make another page request. So, calling ContinuablePagedIterable.streamByPage().findFirst() or ContinuablePagedIterable.iterableByPage().iterator().next() would result in two page requests. Additionally, due to the reactive, event loop, driven nature of the backing enumerable these additional page requests could happen after the execution of the mentioned calling patterns completed.\nNow, during construction of ContinuablePagedIterable we will check the instanceof the backing ContinuablePagedFlux and if it is ContinuablePagedFluxCore the PageRetriever and batchSize configuration will be taken from the object and ContinuablePagedIterable will handle page enumeration with finer grain controls. To maintain current functionality that Flux.toStream() has a page will be eagerly requested when a Iterator or Stream is created from the ContinuablePagedIterable. Internally, these will be backed by one of two Iterable implementations, ContinuablePagedByItemIterable or ContinuablePagedByPageIterable. The implementations will only make additional page requests when needed, for page item iterators it will be when the most recently retrieved page has no additional elements and for page iterators it will be once the next page is requested. The page requests will be blocking which is functionally equivalent to the previous experience, where both implementations would throw if called from within a non-blocking reactive thread.\nIn the future we may investigate completely decoupling ContinuablePagedIterable and ContinuablePagedFlux by having both be constructed with PagedRetriever and handle their own enumeration of pages.", "createdAt": "2020-09-24T22:57:54Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646", "merged": true, "mergeCommit": {"oid": "af97f53095da369d9e99de280fc77e189dba424a"}, "closed": true, "closedAt": "2020-10-01T21:49:15Z", "author": {"login": "alzimmermsft"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMJVwRAH2gAyNDkyNzQwNDQ0OjcxMTM3MDU2NzI4OWIwNjE4N2M2OWQ4NDA1M2Y5OGM3N2M1ODdhNjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOXVangH2gAyNDkyNzQwNDQ0OjQ5MzhmNTdmOWNkY2VjM2VlMDg3YmIzNzU1ZmUxMDNkMmUyNjNkOWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "711370567289b06187c69d84053f98c77c587a66", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/711370567289b06187c69d84053f98c77c587a66", "committedDate": "2020-09-24T22:57:14Z", "message": "Reproduction of PagedIterable eagerly consuming entire paged sequence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7839f44350b8b6a9e1de79b43d3357759aca4dd1", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7839f44350b8b6a9e1de79b43d3357759aca4dd1", "committedDate": "2020-09-25T17:58:29Z", "message": "Example of operator that properly handles reactively requesting pages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NzM4NDI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-496738427", "createdAt": "2020-09-25T19:26:07Z", "commit": {"oid": "7839f44350b8b6a9e1de79b43d3357759aca4dd1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyNjowN1rOHYP6Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyNjowN1rOHYP6Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODU0Mw==", "bodyText": "I think the latch.await() is something we have to be cautious about.\nOur \"drain + subscribe + latch.await\" could gets executes in the context of a non-blocking Thread. As an example, say app is running in a single thread, thread_0:\nthe drain() is executing in thread_0.\nsubscribe() results in queueing a n/w call and return.\nlatch.await() executed in thread_0, blocking it for the result.\nscheduled n/w call cannot be completed as thread_0 is waiting it\u2019s a deadlock.\nReactor marks some threads as non-blocking https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/NonBlocking.html.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r495188543", "createdAt": "2020-09-25T19:26:07Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedFluxCore.java", "diffHunk": "@@ -228,4 +230,179 @@ boolean isDone() {\n             return this.isDone;\n         }\n     }\n+\n+    private static abstract class BaseSubscription<C, T, P extends ContinuablePage<C, T>, U, V>\n+        implements Subscription {\n+        private final Subscriber<? super U> subscriber;\n+        private final ContinuationState<C> continuationState;\n+        private final PageRetriever<C, P> pageRetriever;\n+        private final Integer defaultPageSize;\n+\n+        volatile boolean done;\n+        volatile V next;\n+        private Throwable error;\n+        private volatile boolean cancelled;\n+\n+        volatile int wip;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicIntegerFieldUpdater<BaseSubscription> WIP =\n+            AtomicIntegerFieldUpdater.newUpdater(BaseSubscription.class, \"wip\");\n+\n+        volatile long requested;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicLongFieldUpdater<BaseSubscription> REQUESTED =\n+            AtomicLongFieldUpdater.newUpdater(BaseSubscription.class, \"requested\");\n+\n+        BaseSubscription(Subscriber<? super U> subscriber, ContinuationState<C> continuationState,\n+            PageRetriever<C, P> pageRetriever, Integer defaultPageSize) {\n+            this.subscriber = subscriber;\n+            this.continuationState = continuationState;\n+            this.pageRetriever = pageRetriever;\n+            this.defaultPageSize = defaultPageSize;\n+        }\n+\n+        @Override\n+        public void request(long l) {\n+            if (Operators.validate(l)) {\n+                Operators.addCap(REQUESTED, this, l);\n+                drain();\n+            }\n+        }\n+\n+        private void drain() {\n+            if (WIP.getAndIncrement(this) != 0) {\n+                return;\n+            }\n+\n+            // On the first request or once the iterator is consumed request a page.\n+            if (needToRequestPage()) {\n+                requestPage();\n+            }\n+\n+            int missed = 1;\n+            while (true) {\n+                if (cancelled) {\n+                    return;\n+                }\n+\n+                if (REQUESTED.get(this) > 0) {\n+                    boolean emitted = false;\n+                    // read d before next to avoid race\n+                    boolean d = done;\n+                    if (hasNext()) {\n+                        subscriber.onNext(getNext());\n+                        emitted = true;\n+                    }\n+\n+                    if (d) {\n+                        if (error != null) {\n+                            subscriber.onError(error);\n+                        } else {\n+                            subscriber.onComplete();\n+                        }\n+\n+                        // exit without reducing wip so that further drains will be NOOP\n+                        return;\n+                    }\n+\n+                    if (emitted) {\n+                        // do this after checking d to avoid calling read\n+                        // when done\n+                        Operators.produced(REQUESTED, this, 1);\n+                    }\n+                }\n+\n+                missed = WIP.addAndGet(this, -missed);\n+                if (missed == 0) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        abstract boolean needToRequestPage();\n+        abstract boolean hasNext();\n+        abstract U getNext();\n+\n+        private void requestPage() {\n+            CountDownLatch countDownLatch = new CountDownLatch(1);\n+            pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+                .singleOrEmpty()\n+                .subscribe(this::setNext, this::setError, countDownLatch::countDown);\n+\n+            try {\n+                countDownLatch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7839f44350b8b6a9e1de79b43d3357759aca4dd1"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85aab67d7db58ab25232098082f7ed7eb33bd12e", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/85aab67d7db58ab25232098082f7ed7eb33bd12e", "committedDate": "2020-09-25T23:37:02Z", "message": "Additional fixes and updates to Subscriber implementations, added tests for PagedFlux"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f124ec2e679139c1df72536dba3a80e6b7308ed9", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f124ec2e679139c1df72536dba3a80e6b7308ed9", "committedDate": "2020-09-26T03:00:53Z", "message": "Only have ContinuablePagedIterable use the synchronous page retrieving subscription"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3a7a1ccb4ac112ae9aaafb904cc42a3565b8572", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a3a7a1ccb4ac112ae9aaafb904cc42a3565b8572", "committedDate": "2020-09-28T16:09:20Z", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3344457a2fec9cf0564aa284d8d2e9dd94d393d6", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3344457a2fec9cf0564aa284d8d2e9dd94d393d6", "committedDate": "2020-09-28T16:35:06Z", "message": "Updated logic to check if by item subscription has another element to emit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed9c589045cdba01a7b19987f303fb03539fb79a", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed9c589045cdba01a7b19987f303fb03539fb79a", "committedDate": "2020-09-28T18:48:35Z", "message": "Changes to when last page is signalled and updating the work in progress tracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f501d7174ec3e7b97836c6aca46f86bdbb6b9bc", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f501d7174ec3e7b97836c6aca46f86bdbb6b9bc", "committedDate": "2020-09-28T19:46:04Z", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b24d53d4f27c65745142aa59ec4565ac2be3dfc", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4b24d53d4f27c65745142aa59ec4565ac2be3dfc", "committedDate": "2020-09-29T01:08:33Z", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5819d1baa06bc4f419ea6e1a349b9b6f6dc28a53", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5819d1baa06bc4f419ea6e1a349b9b6f6dc28a53", "committedDate": "2020-09-29T03:03:41Z", "message": "Move latch countdown to prevent race condition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83c42f1a78793463c5ecc93e7c3c829295679adc", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/83c42f1a78793463c5ecc93e7c3c829295679adc", "committedDate": "2020-09-29T18:11:44Z", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "996c4c8b26db9b7dc2831a1660fe64d9e31c7fcb", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/996c4c8b26db9b7dc2831a1660fe64d9e31c7fcb", "committedDate": "2020-09-29T20:34:10Z", "message": "Add iterator implementation that backs PagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "416380a374df31d7f8e6d508895a1e50b3be6549", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/416380a374df31d7f8e6d508895a1e50b3be6549", "committedDate": "2020-09-29T21:59:16Z", "message": "Update pattern to use block instead of locking subscription"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d43e6d7bd005e331ede66d6e19795f04f598430f", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d43e6d7bd005e331ede66d6e19795f04f598430f", "committedDate": "2020-09-29T22:21:48Z", "message": "Fix IndexOutOfBounds exceptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed6c397f4aea5f749045684f847d399b3dc78cd8", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed6c397f4aea5f749045684f847d399b3dc78cd8", "committedDate": "2020-09-30T00:37:55Z", "message": "Remove synchronized keyword to prevent deadlock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39f753c997be3526747dd59b20fcffbcb74f585c", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/39f753c997be3526747dd59b20fcffbcb74f585c", "committedDate": "2020-09-30T05:14:35Z", "message": "Fix edge case when pages with zero elements are returned to the by item iterator, updated test recording given the eager first page retrieval change when getting an iterator, updated construction of the iterable when using non-ContinuablePagedFluxCore based implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17dc022be88013b00efe80e2fa99953aa01e8564", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/17dc022be88013b00efe80e2fa99953aa01e8564", "committedDate": "2020-09-30T15:16:10Z", "message": "Add missing playback file update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4c054f6d50f60edf52715059f2a486d9547e5c1", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a4c054f6d50f60edf52715059f2a486d9547e5c1", "committedDate": "2020-09-30T16:39:41Z", "message": "Removed subcription based prototype"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NzczMjc3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-499773277", "createdAt": "2020-09-30T20:09:26Z", "commit": {"oid": "a4c054f6d50f60edf52715059f2a486d9547e5c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDowOToyNlrOHathTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDowOToyNlrOHathTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MDgyOA==", "bodyText": "I would add some guard/assertion to all these new tests that makes sure that there's actually more than one page in the underlying data source. Otherwise it's easy to make this test worthless if someone changes underlying data source to have just one page. (btw. it's not that easy for me to trace data flow in these tests so I can't tell whether source has one or more pages... some check would be great.)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r497770828", "createdAt": "2020-09-30T20:09:26Z", "author": {"login": "kasobol-msft"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedFluxTest.java", "diffHunk": "@@ -284,15 +284,63 @@ public void testPagedFluxWithContext() throws Exception {\n             return Mono.empty();\n         }\n \n-        return Mono.just(pagedResponses.get(Integer.valueOf(continuationToken)));\n+        int parsedToken = Integer.parseInt(continuationToken);\n+        if (parsedToken >= pagedResponses.size()) {\n+            return Mono.empty();\n+        }\n+\n+        return Mono.just(pagedResponses.get(parsedToken));\n     }\n \n     private List<Integer> getItems(Integer i) {\n         return IntStream.range(i * 3, i * 3 + 3).boxed().collect(Collectors.toList());\n     }\n \n     private List<String> getStringItems(Integer i) {\n-        return IntStream.range(i * 3, i * 3 + 3).boxed().map(val -> String.valueOf(val)).collect(Collectors.toList());\n+        return IntStream.range(i * 3, i * 3 + 3).boxed().map(String::valueOf).collect(Collectors.toList());\n     }\n \n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        Integer next = new OnlyOnePagedFlux(() -> pageRetriever).blockFirst();\n+\n+        Thread.sleep(2000);\n+\n+        assertEquals(1, pageRetriever.getGetCount());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4c054f6d50f60edf52715059f2a486d9547e5c1"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e27799b6c11535dc63a36a933b0da8a7f9e348b4", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e27799b6c11535dc63a36a933b0da8a7f9e348b4", "committedDate": "2020-10-01T00:31:56Z", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8373c2e41396f04e7b914fc503f58e58e5ae334d", "committedDate": "2020-10-01T00:49:40Z", "message": "Add validation that PagedIterable/PagedFlux have more than one page before testing lazy consumption"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTYzNzAw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-499963700", "createdAt": "2020-10-01T02:00:43Z", "commit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTk0Njk5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-499994699", "createdAt": "2020-10-01T04:04:39Z", "commit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTI5MTM0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-500529134", "createdAt": "2020-10-01T16:37:19Z", "commit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjozNzoxOVrOHbSk4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjozNzoxOVrOHbSk4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3Nzk1NA==", "bodyText": "should we add a test for using pagedIterable.stream().parallel() and iteration on output of parallel? just double confirming our iterable impl is stream safe.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498377954", "createdAt": "2020-10-01T16:37:19Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedIterableTest.java", "diffHunk": "@@ -250,4 +256,90 @@ int getNextPageRetrievals() {\n             return nextPageRetrievals;\n         }\n     }\n+\n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        OnlyOnePagedIterable pagedIterable = new OnlyOnePagedIterable(new OnlyOnePagedFlux(() -> pageRetriever));\n+\n+        // Validation that there is more than one paged in the full return.\n+        pagedIterable.stream().count();\n+        int fullPageCount = pageRetriever.getGetCount();\n+        assertTrue(fullPageCount > 1);\n+\n+        Integer next = pagedIterable.stream().findFirst().get();\n+\n+        Thread.sleep(2000);\n+\n+        /*\n+         * Given that each page contains more than one element we are able to only retrieve a single page.\n+         */\n+        assertEquals(1, pageRetriever.getGetCount() - fullPageCount);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTQxNzI5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-500541729", "createdAt": "2020-10-01T16:53:47Z", "commit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1Mzo0OFrOHbTIdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1Mzo0OFrOHbTIdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzA2MA==", "bodyText": "Is then() required here since you have a block() after this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498387060", "createdAt": "2020-10-01T16:53:48Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedByIteratorBase.java", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.util.paging;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Internal class that is a blocking iterator base class.\n+ * <p>\n+ * This class manages retrieving and maintaining previously retrieve page/pages in a synchronous fashion. It will ensure\n+ * the minimum number of pages are retrieved from a service by checking if any additional items/pages could be emitted\n+ * before requesting additional ones from the service.\n+ *\n+ * @param <C> The continuation token type.\n+ * @param <T> The item type.\n+ * @param <P> The page type.\n+ * @param <E> The type that the {@link ContinuablePagedIterable} will emit.\n+ */\n+abstract class ContinuablePagedByIteratorBase<C, T, P extends ContinuablePage<C, T>, E> implements Iterator<E> {\n+    private final PageRetriever<C, P> pageRetriever;\n+    private final ContinuationState<C> continuationState;\n+    private final Integer defaultPageSize;\n+    private final ClientLogger logger;\n+\n+    private volatile boolean done;\n+\n+    ContinuablePagedByIteratorBase(PageRetriever<C, P> pageRetriever, ContinuationState<C> continuationState,\n+        Integer defaultPageSize, ClientLogger logger) {\n+        this.continuationState = continuationState;\n+        this.pageRetriever = pageRetriever;\n+        this.defaultPageSize = defaultPageSize;\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public E next() {\n+        if (!hasNext()) {\n+            throw logger.logExceptionAsError(new NoSuchElementException(\"Iterator contains no more elements.\"));\n+        }\n+\n+        return getNext();\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        // Request next pages in a loop in case we are returned empty pages for the by item implementation.\n+        while (!done && needToRequestPage()) {\n+            requestPage();\n+        }\n+\n+        return isNextAvailable();\n+    }\n+\n+    /*\n+     * Indicates if a page needs to be requested.\n+     */\n+    abstract boolean needToRequestPage();\n+\n+    /*\n+     * Indicates if another element is available.\n+     */\n+    abstract boolean isNextAvailable();\n+\n+    /*\n+     * Gets the next element to be emitted.\n+     */\n+    abstract E getNext();\n+\n+    synchronized void requestPage() {\n+        AtomicBoolean receivedPages = new AtomicBoolean(false);\n+        pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+            .map(page -> {\n+                receivedPages.set(true);\n+                addPage(page);\n+\n+                continuationState.setLastContinuationToken(page.getContinuationToken());\n+                this.done = continuationState.isDone();\n+\n+                return page;\n+            })\n+            .then()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjA0ODE5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#pullrequestreview-500604819", "createdAt": "2020-10-01T18:18:05Z", "commit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40452b17c9cbc8c82d01727dedec4ebbc5213875", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/40452b17c9cbc8c82d01727dedec4ebbc5213875", "committedDate": "2020-10-01T19:19:39Z", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4938f57f9cdcec3ee087bb3755fe103d2e263d9c", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4938f57f9cdcec3ee087bb3755fe103d2e263d9c", "committedDate": "2020-10-01T20:23:23Z", "message": "Add guard for requesting more pages than needed, added Stream.parallel tests to ensure the correct number of pages are requested"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3307, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}