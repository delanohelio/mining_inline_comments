{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1ODExNTk2", "number": 9689, "title": "Nio directory stream", "bodyText": "", "createdAt": "2020-03-30T18:06:55Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689", "merged": true, "mergeCommit": {"oid": "7609c781549a4f22a743cb3736137667e5902952"}, "closed": true, "closedAt": "2020-04-03T22:02:44Z", "author": {"login": "rickle-msft"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcS1ebBgFqTM4NDI0ODQ0Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUHka4gH2gAyMzk1ODExNTk2OjFhNTZlYzc1YWM5YTE5YTI1MGJlOWUxOTkzODk1MGZhY2E5OTEwYWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjQ4NDQ2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#pullrequestreview-384248446", "createdAt": "2020-03-30T21:34:54Z", "commit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTozNDo1NVrOF99GDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTozNDo1NVrOF99GDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwODQzMA==", "bodyText": "should these comments actually be bufferedNext? I'm assuming you just renamed the variable and forgot to change the comments", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400508430", "createdAt": "2020-03-30T21:34:55Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {\n+                        this.bufferedNext = nextPath;\n+                        return true;\n+                    }\n+                } catch (IOException e) {\n+                    throw LoggingUtility.logError(logger, new DirectoryIteratorException(e));\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Path next() {\n+            if (this.bufferedNext == null) {\n+                if (!this.hasNext()) { // This will populate cachedNext in the process.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 130}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjU0NDAz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#pullrequestreview-384254403", "createdAt": "2020-03-30T21:44:48Z", "commit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo0NDo0OFrOF99ZDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo0NDo0OFrOF99ZDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxMzI5Mg==", "bodyText": "is there a reason we can't just do this +next 3 lines once in the constructor for AzureDirectoryIterator?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400513292", "createdAt": "2020-03-30T21:44:48Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {\n+                        this.bufferedNext = nextPath;\n+                        return true;\n+                    }\n+                } catch (IOException e) {\n+                    throw LoggingUtility.logError(logger, new DirectoryIteratorException(e));\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Path next() {\n+            if (this.bufferedNext == null) {\n+                if (!this.hasNext()) { // This will populate cachedNext in the process.\n+                    throw LoggingUtility.logError(logger, new NoSuchElementException());\n+                }\n+            }\n+            Path next = this.bufferedNext; // cachedNext will have been populated by hasNext()\n+            this.bufferedNext = null;\n+            return next;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        private Path getNextListResult(BlobItem blobItem) {\n+            // Strip the root if it is present so we can relativize the list result, which never has a root.\n+            Path withoutRoot = this.path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjU2NDM1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#pullrequestreview-384256435", "createdAt": "2020-03-30T21:48:32Z", "commit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo0ODozMlrOF99fvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo0ODozMlrOF99fvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNTAwNA==", "bodyText": "Can we possibly swap all instances of NIOs DIR_METADATA_MARKER for the one in common? I just merged a PR today that added the constant for a datalake feature", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400515004", "createdAt": "2020-03-30T21:48:32Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureResource.java", "diffHunk": "@@ -34,10 +34,10 @@\n  * It also serves as the interface to Storage clients. Any operation that needs to use a client should first build an\n  * AzureResource using a path and then use the getter to access the client.\n  */\n-class AzureResource {\n+final class AzureResource {\n     private final ClientLogger logger = new ClientLogger(AzureResource.class);\n \n-    static final String DIR_METADATA_MARKER = \"is_hdi_folder\";\n+    static final String DIR_METADATA_MARKER = \"hdi_isfolder\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0Mjc3NzU1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#pullrequestreview-384277755", "createdAt": "2020-03-30T22:29:24Z", "commit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyOToyNFrOF9-luA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjo0NzowOFrOF9_B1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjkyMA==", "bodyText": "nit: an object is an instantiated class. I believe this comment describes class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400532920", "createdAt": "2020-03-30T22:29:24Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzNTU5MA==", "bodyText": "Files.newDirectoryStream throws NotDirectoryException if the file could not otherwise be opened because it is not a directory . Should we be consistent with that?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400535590", "createdAt": "2020-03-30T22:35:43Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzODQ1Mg==", "bodyText": "nit. should this be called !isDuplicate ? or something like that", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400538452", "createdAt": "2020-03-30T22:43:01Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MDExOQ==", "bodyText": "limitation on path type should be mentioned in javadoc I think and what is expected if somebody passes something other than AzurePath.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400540119", "createdAt": "2020-03-30T22:47:08Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -194,12 +193,18 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * Returns an {@link AzureDirectoryStream} for iterating over the contents of a directory.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public DirectoryStream<Path> newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)\n         throws IOException {\n-        return null;\n+        if (!(path instanceof AzurePath)) {\n+            throw LoggingUtility.logError(logger, new IllegalArgumentException(\"This provider cannot operate on \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb27c778e747104844c43217a78fa26f4bf61726", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cb27c778e747104844c43217a78fa26f4bf61726", "committedDate": "2020-04-03T18:54:03Z", "message": "Basic directoryStream test working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3514dfc88f9c6d12eb5eeacf13a478f0463299e1", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3514dfc88f9c6d12eb5eeacf13a478f0463299e1", "committedDate": "2020-04-03T18:54:03Z", "message": "Added lots of tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b76283b077dba1f125997374db3ff68848bbc280", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b76283b077dba1f125997374db3ff68848bbc280", "committedDate": "2020-04-03T18:54:03Z", "message": "Added support for listing root directories"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1688c7d51f55777fabfdca69c9a13c2078628161", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1688c7d51f55777fabfdca69c9a13c2078628161", "committedDate": "2020-04-03T18:54:05Z", "message": "Clean up and recordings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f39a9c2086506574f055396136a8b77c55a7f4c", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6f39a9c2086506574f055396136a8b77c55a7f4c", "committedDate": "2020-04-03T18:54:05Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dd147fe4056c8e1dd64d305fe8d5cbed3d24a3e", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0dd147fe4056c8e1dd64d305fe8d5cbed3d24a3e", "committedDate": "2020-04-03T19:33:22Z", "message": "More pr feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b", "committedDate": "2020-03-30T18:04:23Z", "message": "Clean up and recordings"}, "afterCommit": {"oid": "0dd147fe4056c8e1dd64d305fe8d5cbed3d24a3e", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0dd147fe4056c8e1dd64d305fe8d5cbed3d24a3e", "committedDate": "2020-04-03T19:33:22Z", "message": "More pr feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTMwNjc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#pullrequestreview-387530676", "createdAt": "2020-04-03T19:38:21Z", "commit": {"oid": "0dd147fe4056c8e1dd64d305fe8d5cbed3d24a3e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTMyOTI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#pullrequestreview-387532927", "createdAt": "2020-04-03T19:41:59Z", "commit": {"oid": "0dd147fe4056c8e1dd64d305fe8d5cbed3d24a3e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a56ec75ac9a19a250be9e19938950faca9910ab", "author": {"user": {"login": "rickle-msft", "name": "Rick Ley"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1a56ec75ac9a19a250be9e19938950faca9910ab", "committedDate": "2020-04-03T21:13:41Z", "message": "CI fixes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1439, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}