{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMzA4OTE3", "number": 13688, "title": "FixGroupByPaging", "bodyText": "Fix for Issue: #12910 (comment)", "createdAt": "2020-07-31T16:43:49Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13688", "merged": true, "mergeCommit": {"oid": "9b12aa4bbf3566c1ee03dfbe17f9a2aaf52d9597"}, "closed": true, "closedAt": "2020-08-02T19:40:14Z", "author": {"login": "xinlian12"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6XAZCAH2gAyNDYwMzA4OTE3OjIyZTA0ZDc5MzJiM2I4NjkwMjEyNjY1OTUzYjAzZWJiMTBiYTlmYjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6X2PUgH2gAyNDYwMzA4OTE3OmE3ODExMDExMmE1NjU2ZGJlNTllODNmODM4NjEyYmExZDVlNGQ5NzY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "22e04d7932b3b8690212665953b03ebb10ba9fb8", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/22e04d7932b3b8690212665953b03ebb10ba9fb8", "committedDate": "2020-07-31T16:41:56Z", "message": "FixGroupByPagingScenario"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50503046a4b9912df74df81138e58761c44e2f17", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/50503046a4b9912df74df81138e58761c44e2f17", "committedDate": "2020-07-31T17:20:35Z", "message": "fix compilation and add requestCharge test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzM5OTMy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13688#pullrequestreview-459339932", "createdAt": "2020-07-31T17:26:44Z", "commit": {"oid": "50503046a4b9912df74df81138e58761c44e2f17"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoyNjo0NFrOG6QQhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoyODowNlrOG6QS0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczNjk2NQ==", "bodyText": "Instead of casting it here twice (here and below), let's cast it in the createFeedResponseFromGroupingTable itself and return FeedResponse<T>\nWhat if it is null the very first time ?\nCasting will throw a NPE.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13688#discussion_r463736965", "createdAt": "2020-07-31T17:26:44Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/GroupByDocumentQueryExecutionContext.java", "diffHunk": "@@ -67,32 +68,49 @@\n     @Override\n     public Flux<FeedResponse<T>> drainAsync(int maxPageSize) {\n         return this.component.drainAsync(maxPageSize)\n-                   .collectList()\n-                   .map(superList -> {\n-                       double requestCharge = 0;\n-                       HashMap<String, String> headers = new HashMap<>();\n-                       List<Document> documentList = new ArrayList<>();\n-                       /* Do groupby stuff here */\n-                       // Stage 1:\n-                       // Drain the groupings fully from all continuation and all partitions\n-                       for (FeedResponse<T> page : superList) {\n-                           List<Document> results = (List<Document>) page.getResults();\n-                           documentList.addAll(results);\n-                       }\n-\n-                       this.aggregateGroupings(documentList);\n-\n-                       // Stage 2:\n-                       // Emit the results from the grouping table page by page\n-\n-                       List<Document> groupByResults = this.groupingTable.drain(maxPageSize);\n-\n-                       headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n-                       FeedResponse<Document> frp =\n-                           BridgeInternal.createFeedResponse(groupByResults, headers);\n-\n-                       return (FeedResponse<T>) frp;\n-                   }).flux();\n+            .collectList()\n+            .map(superList -> {\n+                double requestCharge = 0;\n+                HashMap<String, String> headers = new HashMap<>();\n+                List<Document> documentList = new ArrayList<>();\n+                /* Do groupBy stuff here */\n+                // Stage 1:\n+                // Drain the groupings fully from all continuation and all partitions\n+                for (FeedResponse<T> page : superList) {\n+                    List<Document> results = (List<Document>) page.getResults();\n+                    documentList.addAll(results);\n+                    requestCharge += page.getRequestCharge();\n+                }\n+\n+                this.aggregateGroupings(documentList);\n+\n+                // Stage 2:\n+                // Emit the results from the grouping table page by page\n+                return (FeedResponse<T>)createFeedResponseFromGroupingTable(maxPageSize, requestCharge);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50503046a4b9912df74df81138e58761c44e2f17"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczNzE0Ng==", "bodyText": "Please add some comments to expand (explaining how it will be called second time onwards)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13688#discussion_r463737146", "createdAt": "2020-07-31T17:27:07Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/GroupByDocumentQueryExecutionContext.java", "diffHunk": "@@ -67,32 +68,49 @@\n     @Override\n     public Flux<FeedResponse<T>> drainAsync(int maxPageSize) {\n         return this.component.drainAsync(maxPageSize)\n-                   .collectList()\n-                   .map(superList -> {\n-                       double requestCharge = 0;\n-                       HashMap<String, String> headers = new HashMap<>();\n-                       List<Document> documentList = new ArrayList<>();\n-                       /* Do groupby stuff here */\n-                       // Stage 1:\n-                       // Drain the groupings fully from all continuation and all partitions\n-                       for (FeedResponse<T> page : superList) {\n-                           List<Document> results = (List<Document>) page.getResults();\n-                           documentList.addAll(results);\n-                       }\n-\n-                       this.aggregateGroupings(documentList);\n-\n-                       // Stage 2:\n-                       // Emit the results from the grouping table page by page\n-\n-                       List<Document> groupByResults = this.groupingTable.drain(maxPageSize);\n-\n-                       headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n-                       FeedResponse<Document> frp =\n-                           BridgeInternal.createFeedResponse(groupByResults, headers);\n-\n-                       return (FeedResponse<T>) frp;\n-                   }).flux();\n+            .collectList()\n+            .map(superList -> {\n+                double requestCharge = 0;\n+                HashMap<String, String> headers = new HashMap<>();\n+                List<Document> documentList = new ArrayList<>();\n+                /* Do groupBy stuff here */\n+                // Stage 1:\n+                // Drain the groupings fully from all continuation and all partitions\n+                for (FeedResponse<T> page : superList) {\n+                    List<Document> results = (List<Document>) page.getResults();\n+                    documentList.addAll(results);\n+                    requestCharge += page.getRequestCharge();\n+                }\n+\n+                this.aggregateGroupings(documentList);\n+\n+                // Stage 2:\n+                // Emit the results from the grouping table page by page\n+                return (FeedResponse<T>)createFeedResponseFromGroupingTable(maxPageSize, requestCharge);\n+            }).expand(tFeedResponse -> {\n+                // Emit the results from the grouping table page by page", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50503046a4b9912df74df81138e58761c44e2f17"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczNzU1NA==", "bodyText": "You can do the same thing here, what you did down below, return an empty Mono to avoid NPE.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13688#discussion_r463737554", "createdAt": "2020-07-31T17:28:06Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/GroupByDocumentQueryExecutionContext.java", "diffHunk": "@@ -67,32 +68,49 @@\n     @Override\n     public Flux<FeedResponse<T>> drainAsync(int maxPageSize) {\n         return this.component.drainAsync(maxPageSize)\n-                   .collectList()\n-                   .map(superList -> {\n-                       double requestCharge = 0;\n-                       HashMap<String, String> headers = new HashMap<>();\n-                       List<Document> documentList = new ArrayList<>();\n-                       /* Do groupby stuff here */\n-                       // Stage 1:\n-                       // Drain the groupings fully from all continuation and all partitions\n-                       for (FeedResponse<T> page : superList) {\n-                           List<Document> results = (List<Document>) page.getResults();\n-                           documentList.addAll(results);\n-                       }\n-\n-                       this.aggregateGroupings(documentList);\n-\n-                       // Stage 2:\n-                       // Emit the results from the grouping table page by page\n-\n-                       List<Document> groupByResults = this.groupingTable.drain(maxPageSize);\n-\n-                       headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n-                       FeedResponse<Document> frp =\n-                           BridgeInternal.createFeedResponse(groupByResults, headers);\n-\n-                       return (FeedResponse<T>) frp;\n-                   }).flux();\n+            .collectList()\n+            .map(superList -> {\n+                double requestCharge = 0;\n+                HashMap<String, String> headers = new HashMap<>();\n+                List<Document> documentList = new ArrayList<>();\n+                /* Do groupBy stuff here */\n+                // Stage 1:\n+                // Drain the groupings fully from all continuation and all partitions\n+                for (FeedResponse<T> page : superList) {\n+                    List<Document> results = (List<Document>) page.getResults();\n+                    documentList.addAll(results);\n+                    requestCharge += page.getRequestCharge();\n+                }\n+\n+                this.aggregateGroupings(documentList);\n+\n+                // Stage 2:\n+                // Emit the results from the grouping table page by page\n+                return (FeedResponse<T>)createFeedResponseFromGroupingTable(maxPageSize, requestCharge);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczNjk2NQ=="}, "originalCommit": {"oid": "50503046a4b9912df74df81138e58761c44e2f17"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a78110112a5656dbe59e83f838612ba1d5e4d976", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a78110112a5656dbe59e83f838612ba1d5e4d976", "committedDate": "2020-07-31T17:40:45Z", "message": "resolve comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 902, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}