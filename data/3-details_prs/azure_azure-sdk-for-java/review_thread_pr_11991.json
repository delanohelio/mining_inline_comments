{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDA2NjAx", "number": 11991, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDoxNDo1OVrOEECcFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDoxNDo1OVrOEECcFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjY5NzE3OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDoxNDo1OVrOGhaj2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDoxNDo1OVrOGhaj2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MTM1NA==", "bodyText": "The issue was incorrect scoping of getDelay method.\nThe getDelay() method called once subscription on outer Flux is applied. This result in whatever value that call to getDelay returns (say 3 sec)  gets hardcoded in delaySubscription, it looks like:\nMono.defer(() -> this.pollOperation.apply(cxt))\n    .delaySubscription(3)\n    .switchIfEmpty(Mono.error(new IllegalStateException(\"PollOperation returned Mono.empty().\")))\n    .repeat()\nthen when we repeat, this fixed value applied instead of a new call to getDelay to retrieve the new value.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11991#discussion_r437691354", "createdAt": "2020-06-09T20:14:59Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -217,8 +217,12 @@ public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n             () -> this.rootContext.copy(),\n             // Do polling\n             // set|read to|from context as needed, reactor guarantee thread-safety of cxt object.\n-            cxt -> Mono.defer(() -> this.pollOperation.apply(cxt))\n-                .delaySubscription(getDelay(cxt.getLatestResponse()))\n+            cxt -> Mono.defer(() -> {\n+                final Mono<PollResponse<T>> pollOnceMono = this.pollOperation.apply(cxt);\n+                // Execute (subscribe to) the pollOnceMono after the default poll-interval\n+                // or duration specified in the last retry-after response header elapses.\n+                return pollOnceMono.delaySubscription(getDelay(cxt.getLatestResponse()));\n+            })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7cfdded00f6a1c2679731a0060972aacf27804"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3914, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}