{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMTYxMDc5", "number": 11355, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyNjozMlrOEAS9Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NzoxNlrOEBCQVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ2MDE0OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyNjozMlrOGbfUiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxMToxOFrOGbgSGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Nzg5OQ==", "bodyText": "Is there a case where authenticateWithConfidentialClientCache would return null? If not I believe these could be merged into the onErrorResume.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431477899", "createdAt": "2020-05-27T22:26:32Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzY1OQ==", "bodyText": "It could complete without calling onNext() so we cannot merge them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431493659", "createdAt": "2020-05-27T23:11:18Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Nzg5OQ=="}, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ2OTg3OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozMDozM1rOGbfapA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxMjowNVrOGbgTJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTQ2MA==", "bodyText": "I don't know if we need the Mono.defer here, I believe switchIfEmpty only processes if the upstream returns empty otherwise it is never ran.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431479460", "createdAt": "2020-05-27T22:30:33Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzkyNQ==", "bodyText": "switchIfEmpty only processes the Mono if the upstream returns empty, but the method call identityClient.authenticateWithConfidentialClient() would be executed before the stream starts.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431493925", "createdAt": "2020-05-27T23:12:05Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTQ2MA=="}, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ4MTc1OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozNjowMVrOGbfiFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxMzoxN1rOGbgUuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MTM2Ng==", "bodyText": "Not needed, but given this has a lot of nesting and all other conditionals hit terminal states above could the else be removed for a regular code block?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431481366", "createdAt": "2020-05-27T22:36:01Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDMzMQ==", "bodyText": "removed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431494331", "createdAt": "2020-05-27T23:13:17Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MTM2Ng=="}, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ4NzQ1OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozODozMFrOGbfljw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoxNDoxNVrOGbgV2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MjI1NQ==", "bodyText": "Thoughts on merging all these to use their super class GeneralSecurityException.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431482255", "createdAt": "2020-05-27T22:38:30Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDYxNg==", "bodyText": "works like a charm", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431494616", "createdAt": "2020-05-27T23:14:15Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MjI1NQ=="}, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ5MjQyOnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo0MDo0MlrOGbfoqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoyMzoyN1rOGbghhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MzA1MA==", "bodyText": "Would this be better off above attempting to retrieve the credential as this will fail without requiring IO or handling security? Basically, this is a lighter exception to have happen first.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431483050", "createdAt": "2020-05-27T22:40:42Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException\n+                    | IOException e) {\n+                    throw logger.logExceptionAsError(new RuntimeException(\n+                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+                }\n+            } else {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+            }\n+            ConfidentialClientApplication.Builder applicationBuilder =\n+                ConfidentialClientApplication.builder(clientId, credential);\n+            try {\n+                applicationBuilder = applicationBuilder.authority(authorityUrl);\n+            } catch (MalformedURLException e) {\n+                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NzYwNA==", "bodyText": "Unfortunately the ConfidentialClientApplication.Builder requires the credential to be passed in the constructor of the builder, not as a builder setter. So the authority has to be set after the credential.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431497604", "createdAt": "2020-05-27T23:23:27Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException\n+                    | IOException e) {\n+                    throw logger.logExceptionAsError(new RuntimeException(\n+                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+                }\n+            } else {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+            }\n+            ConfidentialClientApplication.Builder applicationBuilder =\n+                ConfidentialClientApplication.builder(clientId, credential);\n+            try {\n+                applicationBuilder = applicationBuilder.authority(authorityUrl);\n+            } catch (MalformedURLException e) {\n+                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MzA1MA=="}, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ5OTE4OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo0MzoyOVrOGbfsjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoyMDo1MVrOGbgeUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDA0Ng==", "bodyText": "Does Mono.fromFuture wrap the thrown exception into a Mono.error or will this need to be handled as a regular exception?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431484046", "createdAt": "2020-05-27T22:43:29Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,19 +493,38 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 throw logger.logExceptionAsError(Exceptions.propagate(e));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    throw logger.logExceptionAsError(Exceptions.propagate(e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5Njc4Nw==", "bodyText": "I'm not sure how reactor handles it. Since it's not documented even if there's anything, I'm returning CompletableFuture.failedFuture() instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431496787", "createdAt": "2020-05-27T23:20:51Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,19 +493,38 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 throw logger.logExceptionAsError(Exceptions.propagate(e));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    throw logger.logExceptionAsError(Exceptions.propagate(e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDA0Ng=="}, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTE0OTgzOnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo0Mzo1N1rOGcD5VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMTowMTowNFrOGcLkMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ==", "bodyText": "the logic to build httpPipelineAdapter from line 177 - 193, can be extracted in a common helper method, and used in getPublicClient / getCofidentialClient methods.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432077141", "createdAt": "2020-05-28T19:43:57Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,67 +127,143 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n-    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n-        if (publicClientApplication != null) {\n-            return publicClientApplication;\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n+            try {\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+            }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjA2NQ==", "bodyText": "That's not possible actually - the public client builder and the confidential client builder extends from a builder base that's not public. So from outside the MSAL library, the public client builder and confidential client builder are totally unrelated classes.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432182065", "createdAt": "2020-05-28T23:41:59Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,67 +127,143 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n-    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n-        if (publicClientApplication != null) {\n-            return publicClientApplication;\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n+            try {\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+            }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5OTQxMg==", "bodyText": "I am talking about this possible change/refactor which can be used in both getPublicClient and getConfidentialClient methods.\n`HttpPipelineAdapter httpPipelineAdapter = getHttpPipelineAdapter();\nif (httpPipelineAdapter != null) {\napplicationBuilder.httpClient(httpPipelineAdapter);\n}  else {\napplicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n}\nprivate HttpPipelineAdapter getHttpPipelineAdapter() {\nHttpPipeline httpPipeline = options.getHttpPipeline();\nif (httpPipeline != null) {\nreturn new HttpPipelineAdapter(httpPipeline);\n} else {\n// If http client is set on the credential, then it should override the proxy options if any configured.\nHttpClient httpClient = options.getHttpClient();\nif (httpClient != null) {\nreturn new HttpPipelineAdapter(setupPipeline(httpClient));\n} else if (options.getProxyOptions() != null) {\nreturn null;\n} else {\nreturn new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n}\n}`", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432199412", "createdAt": "2020-05-29T00:47:11Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,67 +127,143 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n-    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n-        if (publicClientApplication != null) {\n-            return publicClientApplication;\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n+            try {\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+            }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMjgwMw==", "bodyText": "Refactored.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432202803", "createdAt": "2020-05-29T01:01:04Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,67 +127,143 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n-    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n-        if (publicClientApplication != null) {\n-            return publicClientApplication;\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n+            try {\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+            }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY2NzMzOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjozMTo1MlrOGcI9jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMDozMzozN1rOGcLJdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA==", "bodyText": "we'll need to plumb this change in custom Token Credential Auth policies too where a cache is being maintained.\nWe can open an issue, for now, to track this work and get that change added to Track 2 SDKs when Identity is about to GA.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432160140", "createdAt": "2020-05-28T22:31:52Z", "author": {"login": "g2vinay"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -36,16 +34,15 @@ public BearerTokenAuthenticationPolicy(TokenCredential credential, String... sco\n         Objects.requireNonNull(scopes);\n         assert scopes.length > 0;\n         this.credential = credential;\n-        this.scopes = scopes;\n-        this.cache = new SimpleTokenCache(() -> credential.getToken(new TokenRequestContext().addScopes(scopes)));\n+        this.tokenRequestContext = new TokenRequestContext().addScopes(scopes);\n     }\n \n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n         if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n         }\n-        return cache.getToken()\n+        return credential.getToken(tokenRequestContext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjQ3MA==", "bodyText": "Which custom policies? You mean in service SDKs like Key Vault?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432182470", "createdAt": "2020-05-28T23:43:18Z", "author": {"login": "jianghaolu"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -36,16 +34,15 @@ public BearerTokenAuthenticationPolicy(TokenCredential credential, String... sco\n         Objects.requireNonNull(scopes);\n         assert scopes.length > 0;\n         this.credential = credential;\n-        this.scopes = scopes;\n-        this.cache = new SimpleTokenCache(() -> credential.getToken(new TokenRequestContext().addScopes(scopes)));\n+        this.tokenRequestContext = new TokenRequestContext().addScopes(scopes);\n     }\n \n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n         if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n         }\n-        return cache.getToken()\n+        return credential.getToken(tokenRequestContext)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NTk1Nw==", "bodyText": "This is no longer an issue since this change is reverted for now to keep backward compatibility in azure-core until Azure Identity releases a stable version.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432195957", "createdAt": "2020-05-29T00:33:37Z", "author": {"login": "jianghaolu"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -36,16 +34,15 @@ public BearerTokenAuthenticationPolicy(TokenCredential credential, String... sco\n         Objects.requireNonNull(scopes);\n         assert scopes.length > 0;\n         this.credential = credential;\n-        this.scopes = scopes;\n-        this.cache = new SimpleTokenCache(() -> credential.getToken(new TokenRequestContext().addScopes(scopes)));\n+        this.tokenRequestContext = new TokenRequestContext().addScopes(scopes);\n     }\n \n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n         if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n         }\n-        return cache.getToken()\n+        return credential.getToken(tokenRequestContext)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY4OTE4OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0MTo1OVrOGcJK0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzo0NDozMFrOGcKWMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MzUzNg==", "bodyText": "Why is this call not deferred ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432163536", "createdAt": "2020-05-28T22:41:59Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjgzNA==", "bodyText": "This call can happen when getToken() is called - it's not conditional on anything else.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432182834", "createdAt": "2020-05-28T23:44:30Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MzUzNg=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY5MjI2OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredential.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0MzoyMlrOGcJMpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzo0NjozMVrOGcKYiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDAwNQ==", "bodyText": "Why is this call not deferred ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432164005", "createdAt": "2020-05-28T22:43:22Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredential.java", "diffHunk": "@@ -44,13 +42,15 @@\n         identityClient = new IdentityClientBuilder()\n             .tenantId(tenantId)\n             .clientId(clientId)\n+            .clientSecret(clientSecret)\n             .identityClientOptions(identityClientOptions)\n             .build();\n-        this.clientSecret = clientSecret;\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return identityClient.authenticateWithClientSecret(clientSecret, request);\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MzQzMg==", "bodyText": "Same as above. We only need to defer a call when certain variables or conditions must be met. For example, 2 lines down - the authenticateWithConfidentialClient() should happen only if there's a cache miss. But for this line, we have all the variables needed initialized, and reading from the cache should always happen without conditions.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432183432", "createdAt": "2020-05-28T23:46:31Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredential.java", "diffHunk": "@@ -44,13 +42,15 @@\n         identityClient = new IdentityClientBuilder()\n             .tenantId(tenantId)\n             .clientId(clientId)\n+            .clientSecret(clientSecret)\n             .identityClientOptions(identityClientOptions)\n             .build();\n-        this.clientSecret = clientSecret;\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return identityClient.authenticateWithClientSecret(clientSecret, request);\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDAwNQ=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY5NDQ5OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0NDozN1rOGcJOEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzo0Nzo1OFrOGcKaIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDM3MA==", "bodyText": "Indicates whether to enable ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432164370", "createdAt": "2020-05-28T22:44:37Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4Mzg0Mw==", "bodyText": "Fixed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432183843", "createdAt": "2020-05-28T23:47:58Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDM3MA=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTcyNjQyOnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo1OToyMVrOGcJhVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMTowNToyOVrOGcLoOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg==", "bodyText": "Why are we doing Exceptions.propagate and not directly converting to Runtime Exception ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432169302", "createdAt": "2020-05-28T22:59:21Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MzkyNw==", "bodyText": "@alzimmermsft suggested this usage pattern to me.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432183927", "createdAt": "2020-05-28T23:48:17Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4NTE1Mw==", "bodyText": "Actually I know a reason - if e is already a subclass of RuntimeException, wrapping it in another RuntimeException is bad. Exceptions.propagate(e) will check if e is a RuntimeException first and only wrap if not.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432185153", "createdAt": "2020-05-28T23:52:51Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NTQxNQ==", "bodyText": "Okay,\nBut we already know, MalformedURLException is not a RuntimeException here.\nSo, that check is redundant.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432195415", "createdAt": "2020-05-29T00:31:24Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMzgzMw==", "bodyText": "That's correct. But at this point it's really a personal preference thing. I changed it to new RuntimeException() for the if check it saves. But one could argue in the future if more exceptions are thrown or this code path is refactored to merge with other paths that could throw RuntimeExceptions this could potentially be a point of failure. The point is, it's not critical.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432203833", "createdAt": "2020-05-29T01:05:29Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 377}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTczMDA3OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzowMDo1NlrOGcJjgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzo0OTo1M1rOGcKcJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTg1Nw==", "bodyText": "Do we expect MSAL to return an expired token ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432169857", "createdAt": "2020-05-28T23:00:56Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n+                }\n+            }).map(result -> new MsalToken(result, options)));\n+    }\n+\n+    /**\n+     * Asynchronously acquire a token from the currently logged in client.\n+     *\n+     * @param request the details of the token request\n+     * @return a Publisher that emits an AccessToken\n+     */\n+    public Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters.builder(\n+                new HashSet<>(request.getScopes()));\n             try {\n-                return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                return getConfidentialClientApplication().acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n-        }).map(result -> new MsalToken(result, options))));\n+        }).map(ar -> (AccessToken) new MsalToken(ar, options))\n+            .filter(t -> !t.isExpired());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4NDM1OA==", "bodyText": "No. But a non-expired IAuthenticationResult could be an expired AccessToken because of the offset. In my token refresh offset re-work, this line will be changed to .filter(t -> OffsetDateTime.now().isBefore(t.getExpiresAt().minus(identityClientOptions.getTokenRefreshOffset()))); But for now this may look a little confusing.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432184358", "createdAt": "2020-05-28T23:49:53Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n+                }\n+            }).map(result -> new MsalToken(result, options)));\n+    }\n+\n+    /**\n+     * Asynchronously acquire a token from the currently logged in client.\n+     *\n+     * @param request the details of the token request\n+     * @return a Publisher that emits an AccessToken\n+     */\n+    public Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters.builder(\n+                new HashSet<>(request.getScopes()));\n             try {\n-                return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                return getConfidentialClientApplication().acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n-        }).map(result -> new MsalToken(result, options))));\n+        }).map(ar -> (AccessToken) new MsalToken(ar, options))\n+            .filter(t -> !t.isExpired());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTg1Nw=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTczODIxOnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClientOptions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzowNDo1OVrOGcJojA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzo1MDoxOFrOGcKcpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTE0OA==", "bodyText": "Is this cache name going to be same across all languages ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432171148", "createdAt": "2020-05-28T23:04:59Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClientOptions.java", "diffHunk": "@@ -24,15 +24,18 @@\n  */\n public final class IdentityClientOptions {\n     private static final int MAX_RETRY_DEFAULT_LIMIT = 3;\n-    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_PUBLIC_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_CONFIDENTIAL_CACHE_FILE_NAME = \"msal.confidential.cache\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4NDQ4NA==", "bodyText": "Yes. This is the name for Windows regardless of languages.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432184484", "createdAt": "2020-05-28T23:50:18Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClientOptions.java", "diffHunk": "@@ -24,15 +24,18 @@\n  */\n public final class IdentityClientOptions {\n     private static final int MAX_RETRY_DEFAULT_LIMIT = 3;\n-    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_PUBLIC_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_CONFIDENTIAL_CACHE_FILE_NAME = \"msal.confidential.cache\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTE0OA=="}, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTE2NDczOnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDozOTo1OFrOGcrZVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMToyNzo1NFrOGcskHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDMwOA==", "bodyText": "Is Mono.defer() necessary? You can simply do switchIfEmpty(identityClient.authenticateWithConfidentialClient(request)) since this gets triggered only if the cache returns empty result and doesn't have to be deferred.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432724308", "createdAt": "2020-05-29T20:39:58Z", "author": {"login": "srnagar"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MzQ1Mw==", "bodyText": "@alzimmermsft asked the same question. if we do switchIfEmpty(identityClient.authenticateWithConfidentialClient(request)) the method call identityClient.authenticateWithConfidentialClient(request) will be evaluated first but we do not want that.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432743453", "createdAt": "2020-05-29T21:27:54Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDMwOA=="}, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTE3Nzg3OnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo0NDo1NFrOGcrhkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTozMzozOVrOGcssIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNjQxOQ==", "bodyText": "This reads a bit odd. You can simplify this: An updated instance of this builder.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432726419", "createdAt": "2020-05-29T20:44:54Z", "author": {"login": "srnagar"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled indicates whether to enable using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NTUwNQ==", "bodyText": "Simplified.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432745505", "createdAt": "2020-05-29T21:33:39Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled indicates whether to enable using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNjQxOQ=="}, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTIwOTgwOnYy", "diffSide": "RIGHT", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NzoxNlrOGcr1Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTozMTowOFrOGcsopQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTQ1MA==", "bodyText": "Should this throw an exception if httpClient is null and proxy options are set?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432731450", "createdAt": "2020-05-29T20:57:16Z", "author": {"login": "srnagar"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -877,4 +861,28 @@ void openUrl(String url) throws IOException {\n             logger.error(\"Browser could not be opened - please open {} in a browser on this device.\", url);\n         }\n     }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private void initializeHttpPipelineAdapter() {\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n+            } else if (options.getProxyOptions() == null) {\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NDYxMw==", "bodyText": "No - it's a valid scenario which is handled in line 177: https://github.com/Azure/azure-sdk-for-java/pull/11355/files/1c100d5ba097af9d5ba670b34d010f25d5606681#diff-56093106beda983b28894478869221c6R177. Basically, the only time we don't want to initialize the httpPipelineAdapter is when a proxy option is provided - in which case we pass the proxy option directly to MSAL for backward compatibility. New users should set the proxy options on the httpClient.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432744613", "createdAt": "2020-05-29T21:31:08Z", "author": {"login": "jianghaolu"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -877,4 +861,28 @@ void openUrl(String url) throws IOException {\n             logger.error(\"Browser could not be opened - please open {} in a browser on this device.\", url);\n         }\n     }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private void initializeHttpPipelineAdapter() {\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n+            } else if (options.getProxyOptions() == null) {\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTQ1MA=="}, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 438}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4111, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}