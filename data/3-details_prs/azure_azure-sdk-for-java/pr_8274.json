{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2ODA0MDQ2", "number": 8274, "title": "Add Missing Tests and Remove Exists APIs", "bodyText": "This PR adds tests that were missing from the Track 1 port and removes the exists APIs from clients. Additionally, general changes were made to documentation to follow Javadoc expectations, JUnit 4 code was removed from tests, and replaced a Storage Base64 encoding call with java.util.Base64.\nThe exists APIs were removed per request of Bruce as they didn't fit into the Search API well. The create APIs allow for create if not exists functionality which is one of the general uses of exists and is safe from race conditions, in the future if exists is wanted it is easier to add the APIs than remove them if we don't want them.", "createdAt": "2020-02-18T19:50:52Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274", "merged": true, "mergeCommit": {"oid": "10ed766b9800e4cc7b003c39c53332b1fec6063e"}, "closed": true, "closedAt": "2020-02-24T22:36:45Z", "author": {"login": "alzimmermsft"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcD_P9DAH2gAyMzc2ODA0MDQ2OjI4NWM0MGNkNmRhYTcxOTRhYzllYzAyZjJkYmY3ZWFlODIxNGQ2NmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHlXLCgFqTM2Mzc1MTAyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "285c40cd6daa7194ac9ec02f2dbf7eae8214d66d", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/285c40cd6daa7194ac9ec02f2dbf7eae8214d66d", "committedDate": "2020-02-13T18:29:18Z", "message": "Add missing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bc12c60d97fa39f309ec7de49489a9e0bdf1bfd", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bc12c60d97fa39f309ec7de49489a9e0bdf1bfd", "committedDate": "2020-02-13T23:01:42Z", "message": "Merge branch 'master' into AzSearch_AddMissingTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7af017686088ba00c6189f13271095583cff37", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ac7af017686088ba00c6189f13271095583cff37", "committedDate": "2020-02-14T00:12:57Z", "message": "Merge branch 'master' into AzSearch_AddMissingTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "796248e8c1e8f2d871881f11774628e0f62b60ff", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/796248e8c1e8f2d871881f11774628e0f62b60ff", "committedDate": "2020-02-14T00:13:26Z", "message": "Merged in master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b00bf5f7faed5bf72902df49cb80c7cb3023f4ca", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b00bf5f7faed5bf72902df49cb80c7cb3023f4ca", "committedDate": "2020-02-14T17:41:00Z", "message": "Merge branch 'master' into AzSearch_AddMissingTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c154b788235d1e9b97042b4ceaceba78103634b4", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c154b788235d1e9b97042b4ceaceba78103634b4", "committedDate": "2020-02-14T23:54:06Z", "message": "General code style refactoring and test cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "868711366e20679c32de29bce9c550758c3fb16e", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/868711366e20679c32de29bce9c550758c3fb16e", "committedDate": "2020-02-18T19:48:45Z", "message": "Removing more JUnit 4 code and use Java Base64.encodeToString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "committedDate": "2020-02-18T21:35:51Z", "message": "Removed Apache Commons code from tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9e9708e4024e0bd38b96df5e5d4b21761463442", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9e9708e4024e0bd38b96df5e5d4b21761463442", "committedDate": "2020-02-19T17:36:53Z", "message": "Merge branch 'master' into AzSearch_AddMissingTests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzYzMTAw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#pullrequestreview-361363100", "createdAt": "2020-02-19T19:12:58Z", "commit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "state": "DISMISSED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxMjo1OFrOFr0FpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxMDoyOFrOFr3u5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA==", "bodyText": "If you're planning to delete the async tests and inline the base classes into the sync tests, why not do that first? It would make changes like this much easier to make (and to review \ud83d\ude09).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381486500", "createdAt": "2020-02-19T19:12:58Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/test/java/com/azure/search/SearchTestBase.java", "diffHunk": "@@ -32,6 +31,10 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA==", "bodyText": "Does this encode to a URL-safe variant of Base64? Document keys can be used in URL paths, so certain characters used in vanilla Base64 are not allowed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381515764", "createdAt": "2020-02-19T20:08:05Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java", "diffHunk": "@@ -281,9 +267,90 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Mono<Document> result = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        StepVerifier.create(result)\n-            .assertNext(actualDoc -> Assert.assertEquals(expectedDoc, actualDoc))\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        IndexBatch<Document> batch = new IndexBatch<>();\n+        batch.addUploadAction(expectedDoc);\n+\n+        StepVerifier.create(client.index(batch))\n+            .expectNextCount(1)\n+            .verifyComplete();\n+\n+        // Select only the fields set in the test case so we don't get superfluous data back.\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", new ArrayList<>(indexedDoc.keySet()), null))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void canGetDocumentWithBase64EncodedKey() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        String complexKey = Base64.getEncoder().encodeToString(new byte[]{1, 2, 3, 4, 5});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ==", "bodyText": "Changing the casing of these fields/accessors is moving this class further away from its intended purpose (not that it ever properly fulfilled its purpose in the Java tests).\nIn the Track 1 .NET SDK, LoudHotel is used to test scenarios where a customer has implemented their own custom attributes that they use to control how model property names serialize/deserialize to index field names. For LoudHotel specifically, the corresponding index definition has camelCase field names, while LoudHotel has ALLCAPS property names.\nIf I understand correctly, @JsonProperty is part of a JSON library for Java and not something a customer would implement themselves, so this class isn't really fulfilling its intended purpose anyway. Are customer-authored attributes a thing when it comes to Java serialization (@JonathanGiles )? If not, we need to rethink this class.\nIf we keep this class though, the accessor/field names should be ALLCAPS or it isn't really \"loud\" anymore, is it? \ud83d\ude01", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381533229", "createdAt": "2020-02-19T20:44:09Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java", "diffHunk": "@@ -12,166 +12,166 @@\n \n public class LoudHotel {\n     @JsonProperty(value = \"HotelId\")\n-    private String HOTELID;\n+    private String hotelId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzODIzNg==", "bodyText": "Thank you very much for doing this. \ud83d\udc4d Good docs are so important!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381538236", "createdAt": "2020-02-19T20:54:38Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,256 +140,196 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA==", "bodyText": "Missing the Javadoc tags used elsewhere in this file", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381539190", "createdAt": "2020-02-19T20:56:21Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,256 +140,196 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.uploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return uploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return response containing the document index result.\n+     * @return A response containing the result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents) {\n+        return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+    }\n+\n+    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+            return indexWithResponse(buildIndexBatch(documents, IndexActionType.UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n-        IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.UPLOAD);\n-        return this.indexWithResponse(batch, context);\n-    }\n-\n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeOrUploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeOrUploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n-     * @return response containing the document index result.\n+     * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index. See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Exception IndexBatchException is thrown when some of the indexing actions failed, but other actions succeeded and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MTI0NA==", "bodyText": "I'm assuming that Arrays.asList(null, null) is returning an ArrayList of Object, not String. This is fine (since this SDK has never shipped, there are no backcompat concerns), but the comment and name of the test no longer reflect reality.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381541244", "createdAt": "2020-02-19T21:00:18Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java", "diffHunk": "@@ -242,15 +243,55 @@ public void canReadComplexCollection() {\n         Assert.assertEquals(expectedDoc, actualDoc);\n     }\n \n+    @Test\n+    public void canReadArraysOfMixedTypes() {\n+        // Azure Cognitive Search won't return payloads like this; This test is only for pinning purposes.\n+        String json = \"{\\\"field\\\": [\\\"hello\\\", 123, 3.14, { \\\"type\\\": \\\"Point\\\", \\\"coordinates\\\": [-122.131577, 47.678581] }, { \\\"name\\\": \\\"Arthur\\\", \\\"quest\\\": null }] }\";\n+\n+        GeoPoint point = GeoPoint.create(47.678581, -122.131577);\n+        Document innerDoc = new Document();\n+        innerDoc.put(\"name\", \"Arthur\");\n+        innerDoc.put(\"quest\", null);\n+        List<Object> value = Arrays.asList(\"hello\", 123, 3.14, point, innerDoc);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field\", value);\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n     @Test\n     public void dateTimeStringsAreReadAsDateTime() {\n         String json = \"{\\\"field1\\\":\\\"\".concat(testDateString).concat(\"\\\",\\\"field2\\\" : [\\\"\").concat(testDateString).concat(\"\\\", \\\"\").concat(testDateString).concat(\"\\\"]}\");\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"field1\", testDate);\n-                put(\"field2\", Arrays.asList(testDate, testDate));\n-            }\n-        };\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field1\", testDate);\n+        expectedDoc.put(\"field2\", Arrays.asList(testDate, testDate));\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n+    @Test\n+    public void emptyArraysReadAsObjectArrays() {\n+        String json = \"{ \\\"field\\\": [] }\";\n+\n+        // With no elements, we can't tell what type of collection it is, so we default to object.\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field\", new ArrayList<>());\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n+    @Test\n+    public void arraysWithOnlyNullsReadAsStringArrays() {\n+        String json = \"{ \\\"field\\\": [null, null] }\";\n+\n+        // With only null elements, we can't tell what type of collection it is. For backward compatibility, we assume type string.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ3Ng==", "bodyText": "Looks like the bug from the Track 1 tests got ported over. This should be uploading indexedDoc, not expectedDoc.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381543476", "createdAt": "2020-02-19T21:04:48Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java", "diffHunk": "@@ -281,9 +267,90 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Mono<Document> result = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        StepVerifier.create(result)\n-            .assertNext(actualDoc -> Assert.assertEquals(expectedDoc, actualDoc))\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        IndexBatch<Document> batch = new IndexBatch<>();\n+        batch.addUploadAction(expectedDoc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjIxNA==", "bodyText": "Should be uploading indexedDoc. I'm getting paranoid now that we've made this mistake in many places and copy-pasted. \ud83d\ude2c", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381546214", "createdAt": "2020-02-19T21:10:28Z", "author": {"login": "brjohnstmsft"}, "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java", "diffHunk": "@@ -266,8 +273,67 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Document actualDoc = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        Assert.assertEquals(expectedDoc, actualDoc);\n+        Response<Document> response = client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions(), Context.NONE);\n+        assertEquals(expectedDoc, response.getValue());\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        client.index(new IndexBatch<>().addUploadAction(expectedDoc));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72d24da813dae886b61905cd2ad893e6e16472df", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/72d24da813dae886b61905cd2ad893e6e16472df", "committedDate": "2020-02-19T22:15:58Z", "message": "Update Azure Core version to fix dependency conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eecc5809988b825e5869b10b76736bc94c9d5ab", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1eecc5809988b825e5869b10b76736bc94c9d5ab", "committedDate": "2020-02-20T17:23:42Z", "message": "Merge branch 'master' into AzSearch_AddMissingTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/51541a2f9d18712bffba2d5d452d469d09c1b1c4", "committedDate": "2020-02-20T21:56:47Z", "message": "Finished cleaning up client documentation and removed async test classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "435b6dc26c3b43f7b792a0e1acaf3b127a57866c", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/435b6dc26c3b43f7b792a0e1acaf3b127a57866c", "committedDate": "2020-02-20T22:39:27Z", "message": "Fixed Java 8 issues and update to use recording framework tools"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/04e612bfb79a7f2fe687e7eda3c3457707f8d066", "committedDate": "2020-02-20T23:06:16Z", "message": "Fix another Java 8 issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe4d5636d5129cd2363e630fa9000b6ee460bd28", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe4d5636d5129cd2363e630fa9000b6ee460bd28", "committedDate": "2020-02-21T22:17:01Z", "message": "Fixing unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyOTYyMTE2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#pullrequestreview-362962116", "createdAt": "2020-02-21T22:45:48Z", "commit": {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMzo0MTo0OFrOFtHqCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMzo1MjoxOFrOFtHy0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTY4OQ==", "bodyText": "Why do we remove the getCoordinates?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382855689", "createdAt": "2020-02-21T23:41:48Z", "author": {"login": "sima-zhu"}, "path": "sdk/search/azure-search/src/main/java/com/azure/search/models/GeoPoint.java", "diffHunk": "@@ -116,27 +116,19 @@ public String toString() {\n         return \"\";\n     }\n \n-    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzU2Mg==", "bodyText": "Not necessary to have the message.\nConsistent with other class\nthis.apiKey = Objects.requireNonNull(apiKey);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382857562", "createdAt": "2020-02-21T23:50:43Z", "author": {"login": "sima-zhu"}, "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchApiKeyPipelinePolicy.java", "diffHunk": "@@ -25,14 +26,13 @@\n      * @throws IllegalArgumentException when the api key is an empty string\n      */\n     public SearchApiKeyPipelinePolicy(SearchApiKeyCredential apiKey) {\n-        Objects.requireNonNull(apiKey);\n+        Objects.requireNonNull(apiKey, \"'apiKey' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzkzNg==", "bodyText": "I changed the API and document in my PR", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382857936", "createdAt": "2020-02-21T23:52:18Z", "author": {"login": "sima-zhu"}, "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,265 +140,207 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.uploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return uploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return response containing the document index result.\n+     * @return A response containing the result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents) {\n+        return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+    }\n+\n+    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+            return indexWithResponse(buildIndexBatch(documents, IndexActionType.UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n-        IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.UPLOAD);\n-        return this.indexWithResponse(batch, context);\n-    }\n-\n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeOrUploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeOrUploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n-     * @return response containing the document index result.\n+     * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index.\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n-     *\n-     * @param documents collection of documents to delete from the target Index.\n-     *                  Fields other than the key are ignored.\n+     * @param documents collection of documents to delete from the target Index. Fields other than the key are ignored.\n      * @return document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> deleteDocuments(Iterable<?> documents) {\n-        try {\n-            return this.deleteDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return deleteDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index.\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n-     *\n-     * @param documents collection of documents to delete from the target Index.\n-     *                  Fields other than the key are ignored.\n+     * @param documents collection of documents to delete from the target Index. Fields other than the key are ignored.\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> deleteDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> deleteDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.DELETE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.DELETE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Gets Client Api Version.\n+     * Gets the version of the Search service the client is using.\n      *\n-     * @return the apiVersion value.\n+     * @return The version of the Search service the client is using.\n      */\n     public SearchServiceVersion getApiVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066"}, "originalPosition": 387}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38b0626ed58b923f68a206b5857b2318e4a41db0", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/38b0626ed58b923f68a206b5857b2318e4a41db0", "committedDate": "2020-02-22T02:12:13Z", "message": "Fixing unit tests, making AccessConditionTests a static helper class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "feb0a14240bb75240155f21eda1731ccb72d4eec", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/feb0a14240bb75240155f21eda1731ccb72d4eec", "committedDate": "2020-02-24T20:47:58Z", "message": "Update session playback records"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "author": {"user": {"login": "alzimmermsft", "name": "Alan Zimmer"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "committedDate": "2020-02-24T20:59:31Z", "message": "Merged in master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzM1MDk1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#pullrequestreview-363735095", "createdAt": "2020-02-24T22:05:12Z", "commit": {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjowNToxM1rOFtxlZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjowNToxM1rOFtxlZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjYzMA==", "bodyText": "Why do we remove this API?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r383542630", "createdAt": "2020-02-24T22:05:13Z", "author": {"login": "sima-zhu"}, "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchServiceAsyncClient.java", "diffHunk": "@@ -1300,265 +1009,187 @@ public String getEndpoint() {\n      * @return the skillset that was created or updated.\n      */\n     public Mono<Skillset> createOrUpdateSkillset(Skillset skillset) {\n-        try {\n-            return this.createOrUpdateSkillsetWithResponse(skillset, null, null)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return createOrUpdateSkillsetWithResponse(skillset, null, null).map(Response::getValue);\n     }\n \n     /**\n      * Creates a new Azure Cognitive Search skillset or updates a skillset if it already exists.\n      *\n      * @param skillset the definition of the skillset to create or update\n      * @param accessCondition the condition where the operation will be performed if the ETag on the server matches or\n-     *                        doesn't match specified values\n-     * @param requestOptions additional parameters for the operation.\n-     *                       Contains the tracking ID sent with the request to help with debugging\n+     * doesn't match specified values\n+     * @param requestOptions additional parameters for the operation. Contains the tracking ID sent with the request to\n+     * help with debugging\n      * @return a response containing the skillset that was created or updated.\n      */\n     public Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset,\n-                                                                       AccessCondition accessCondition,\n-                                                                       RequestOptions requestOptions) {\n+        AccessCondition accessCondition, RequestOptions requestOptions) {\n+        return withContext(context ->\n+            createOrUpdateSkillsetWithResponse(skillset, accessCondition, requestOptions, context));\n+    }\n+\n+    Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset, AccessCondition accessCondition,\n+        RequestOptions requestOptions, Context context) {\n         try {\n-            return withContext(context -> this.createOrUpdateSkillsetWithResponse(skillset,\n-                accessCondition,\n-                requestOptions,\n-                context));\n+            return restClient.skillsets()\n+                .createOrUpdateWithRestResponseAsync(skillset.getName(), skillset, requestOptions, accessCondition,\n+                    context)\n+                .map(Function.identity());\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset,\n-                                                                AccessCondition accessCondition,\n-                                                                RequestOptions requestOptions,\n-                                                                Context context) {\n-        return restClient\n-            .skillsets()\n-            .createOrUpdateWithRestResponseAsync(skillset.getName(),\n-                skillset, requestOptions, accessCondition, context)\n-            .map(Function.identity());\n-    }\n-\n     /**\n      * Deletes a cognitive skillset in an Azure Cognitive Search service.\n      *\n      * @param skillsetName the name of the skillset to delete\n      * @return a response signalling completion.\n      */\n     public Mono<Void> deleteSkillset(String skillsetName) {\n-        try {\n-            return this.deleteSkillsetWithResponse(skillsetName, null, null)\n-                .flatMap(FluxUtil::toMono);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return deleteSkillsetWithResponse(skillsetName, null, null).flatMap(FluxUtil::toMono);\n     }\n \n     /**\n      * Deletes a cognitive skillset in an Azure Cognitive Search service.\n      *\n      * @param skillsetName the name of the skillset to delete\n      * @param accessCondition the condition where the operation will be performed if the ETag on the server matches or\n-     *                        doesn't match specified values\n-     * @param requestOptions additional parameters for the operation.\n-     *                       Contains the tracking ID sent with the request to help with debugging\n+     * doesn't match specified values\n+     * @param requestOptions additional parameters for the operation. Contains the tracking ID sent with the request to\n+     * help with debugging\n      * @return a response signalling completion.\n      */\n-    public Mono<Response<Void>> deleteSkillsetWithResponse(String skillsetName,\n-                                                           AccessCondition accessCondition,\n-                                                           RequestOptions requestOptions) {\n-        try {\n-            return withContext(context -> this.deleteSkillsetWithResponse(skillsetName, accessCondition, requestOptions,\n-                context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n-    }\n-\n-    Mono<Response<Void>> deleteSkillsetWithResponse(String skillsetName,\n-                                                    AccessCondition accessCondition,\n-                                                    RequestOptions requestOptions,\n-                                                    Context context) {\n-        return restClient\n-            .skillsets()\n-            .deleteWithRestResponseAsync(skillsetName, requestOptions, accessCondition, context)\n-            .map(Function.identity());\n-    }\n-\n-    /**\n-     * Determines whether or not the given skillset exists.\n-     *\n-     * @param skillsetName the name of the skillset\n-     * @return true if the skillset exists; false otherwise.\n-     */\n-    public Mono<Boolean> skillsetExists(String skillsetName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae"}, "originalPosition": 1603}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzM3MTQ3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#pullrequestreview-363737147", "createdAt": "2020-02-24T22:09:07Z", "commit": {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzUxMDI2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#pullrequestreview-363751026", "createdAt": "2020-02-24T22:35:21Z", "commit": {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2341, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}