{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4NTI5NzEz", "number": 14162, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxODo1NDozMlrOEZLuVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNTowNDoxMlrOEaBSwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODQxOTQzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxODo1NDozMlrOHB29IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOToyMTozM1rOHC-z-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ==", "bodyText": "I am concerned about this synchronized code piece, since this will be called on every request. My concern is this will slow down things.\nDo we need synchronized block here even though credential is volatile now ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r471711009", "createdAt": "2020-08-17T18:54:32Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -203,25 +202,28 @@ private Mac getMacInstance() {\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-            byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-            SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-            try {\n-                Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                macInstance.init(signingKey);\n-                //  Update the master key hash code\n-                this.masterKeyHashCode = masterKeyLatestHashCode;\n-                return macInstance;\n-            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        } else {\n-            //  Master key hasn't changed, return the cloned mac instance\n-            try {\n-                return (Mac)this.macInstance.clone();\n-            } catch (CloneNotSupportedException e) {\n-                throw new IllegalStateException(e);\n+            synchronized (this.credential) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c2f1c66b50127eb853e81600386db60d3ebec7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTY4Mw==", "bodyText": "this is very valid point. I also think will have perf impact", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r471711683", "createdAt": "2020-08-17T18:55:52Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -203,25 +202,28 @@ private Mac getMacInstance() {\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-            byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-            SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-            try {\n-                Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                macInstance.init(signingKey);\n-                //  Update the master key hash code\n-                this.masterKeyHashCode = masterKeyLatestHashCode;\n-                return macInstance;\n-            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        } else {\n-            //  Master key hasn't changed, return the cloned mac instance\n-            try {\n-                return (Mac)this.macInstance.clone();\n-            } catch (CloneNotSupportedException e) {\n-                throw new IllegalStateException(e);\n+            synchronized (this.credential) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, "originalCommit": {"oid": "50c2f1c66b50127eb853e81600386db60d3ebec7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYxNjQyOA==", "bodyText": "Only when the hashcode is different is when this code path hits.\nFew triggering points are\n\nnew client creation starting point\nkey-changed\n\nIf the assumption is that its a both credentials are valid for a good period of time, the refresh can be asynchronous.\nCan we make that assumption?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r472616428", "createdAt": "2020-08-19T02:49:48Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -203,25 +202,28 @@ private Mac getMacInstance() {\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-            byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-            SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-            try {\n-                Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                macInstance.init(signingKey);\n-                //  Update the master key hash code\n-                this.masterKeyHashCode = masterKeyLatestHashCode;\n-                return macInstance;\n-            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        } else {\n-            //  Master key hasn't changed, return the cloned mac instance\n-            try {\n-                return (Mac)this.macInstance.clone();\n-            } catch (CloneNotSupportedException e) {\n-                throw new IllegalStateException(e);\n+            synchronized (this.credential) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, "originalCommit": {"oid": "50c2f1c66b50127eb853e81600386db60d3ebec7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzMzUyMw==", "bodyText": "Yes, that is correct assumption. We can proceed with this PR. looks good to me.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r472633523", "createdAt": "2020-08-19T03:16:51Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -203,25 +202,28 @@ private Mac getMacInstance() {\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-            byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-            SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-            try {\n-                Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                macInstance.init(signingKey);\n-                //  Update the master key hash code\n-                this.masterKeyHashCode = masterKeyLatestHashCode;\n-                return macInstance;\n-            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        } else {\n-            //  Master key hasn't changed, return the cloned mac instance\n-            try {\n-                return (Mac)this.macInstance.clone();\n-            } catch (CloneNotSupportedException e) {\n-                throw new IllegalStateException(e);\n+            synchronized (this.credential) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, "originalCommit": {"oid": "50c2f1c66b50127eb853e81600386db60d3ebec7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4ODMxNA==", "bodyText": "Refreshed the implementation to eventually move to the new key.\nOne thread will try to refresh where as others will move forward with current key.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r472888314", "createdAt": "2020-08-19T09:21:33Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -203,25 +202,28 @@ private Mac getMacInstance() {\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-            byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-            SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-            try {\n-                Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                macInstance.init(signingKey);\n-                //  Update the master key hash code\n-                this.masterKeyHashCode = masterKeyLatestHashCode;\n-                return macInstance;\n-            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        } else {\n-            //  Master key hasn't changed, return the cloned mac instance\n-            try {\n-                return (Mac)this.macInstance.clone();\n-            } catch (CloneNotSupportedException e) {\n-                throw new IllegalStateException(e);\n+            synchronized (this.credential) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, "originalCommit": {"oid": "50c2f1c66b50127eb853e81600386db60d3ebec7"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NzE5NjE4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNTowNDoxM1rOHDLtvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzoxNDowMFrOHDRjWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA==", "bodyText": "what is the benefit of using ReentrantLock here?\nkey rotation doesn't happen often and this adds a bit to complexity.\nWhy aren't we simply using synchronized?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473099708", "createdAt": "2020-08-19T15:04:13Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -198,32 +200,51 @@ public String getAuthorizationTokenUsingResourceTokens(Map<String, String> resou\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca56f96945f53384c856c81d08519694754251c1"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3MTg5Mw==", "bodyText": "reEntrant lock comes into picture only when there is change detected. Otherwise no impact, no?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473171893", "createdAt": "2020-08-19T16:41:01Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -198,32 +200,51 @@ public String getAuthorizationTokenUsingResourceTokens(Map<String, String> resou\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, "originalCommit": {"oid": "ca56f96945f53384c856c81d08519694754251c1"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3MzQ1MQ==", "bodyText": "that's correct.\nmy question is: isn't synchronized(.) easier to use? what's the benefit of reEntrant lock here? I don't think you will get any benefit and its usage is slightly more complicated than using synchronized(.)\nis there any benefit in using reEntrant lock over synchrnozied()?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473173451", "createdAt": "2020-08-19T16:43:39Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -198,32 +200,51 @@ public String getAuthorizationTokenUsingResourceTokens(Map<String, String> resou\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, "originalCommit": {"oid": "ca56f96945f53384c856c81d08519694754251c1"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MDQ0Mg==", "bodyText": "synchronized is blocking, where as reEntry.TryLock is enabling non-blocking. So only one thread will go into re-initialization.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473190442", "createdAt": "2020-08-19T17:05:28Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -198,32 +200,51 @@ public String getAuthorizationTokenUsingResourceTokens(Map<String, String> resou\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, "originalCommit": {"oid": "ca56f96945f53384c856c81d08519694754251c1"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NTM1NA==", "bodyText": "if the key is rotated, then shouldn't the threads attempting to get a new macInstance wait and block till a new macInstance generated?\nIs the old macInstance value returned to the threads which don't get the lock a valid macInstance in the key-rotation scenario?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473195354", "createdAt": "2020-08-19T17:14:00Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -198,32 +200,51 @@ public String getAuthorizationTokenUsingResourceTokens(Map<String, String> resou\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, "originalCommit": {"oid": "ca56f96945f53384c856c81d08519694754251c1"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1625, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}