{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MTEyMTM4", "number": 16606, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzozMToxMlrOEwA7Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzoyMjo0MlrOEwoWdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzgyMjU4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzozMToxMlrOHlUwdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzozMToxMlrOHlUwdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5OTQ0Nw==", "bodyText": "This should be true by default. That was my understanding .", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r508899447", "createdAt": "2020-10-20T23:31:12Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -816,6 +831,7 @@ private boolean isRollingSessionReceiver() {\n      */\n     @ServiceClientBuilder(serviceClients = {ServiceBusReceiverClient.class, ServiceBusReceiverAsyncClient.class})\n     public final class ServiceBusReceiverClientBuilder {\n+        private boolean enableAutoComplete = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82e2c5f97deab271b4a51124086feb442f911cc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzgyNDkyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzozMjoyNlrOHlUx6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzozMjoyNlrOHlUx6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5OTgxOA==", "bodyText": "should we say disableAutoComplete because by default it it enable ? And do we need a boolean as args, it is already enabled and user can disable it.\ndisableAutoComplete() ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r508899818", "createdAt": "2020-10-20T23:32:26Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -826,6 +842,21 @@ private boolean isRollingSessionReceiver() {\n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Enables auto-complete and auto-abandon of received messages. By default, a successfully processed message is\n+         * {@link ServiceBusReceiverAsyncClient#complete(ServiceBusReceivedMessage) completed}. If an error happens when\n+         * the message is processed, it is\n+         * {@link ServiceBusReceiverAsyncClient#abandon(ServiceBusReceivedMessage) abandoned}.\n+         *\n+         * @param enableAutoComplete True to enable auto-complete and false otherwise.\n+         *\n+         * @return The modified {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder enableAutoComplete(boolean enableAutoComplete) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82e2c5f97deab271b4a51124086feb442f911cc"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Nzg0MzYzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0MDo1NVrOHlU8bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0MDo1NVrOHlU8bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMjUwOA==", "bodyText": "This validateAndThrow(prefetch) , in other PR we were validating earlier when user is setting prefetch . Should't this go there.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r508902508", "createdAt": "2020-10-20T23:40:55Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -948,7 +968,26 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n         public ServiceBusReceiverClient buildClient() {\n-            return new ServiceBusReceiverClient(buildAsyncClient(), retryOptions.getTryTimeout());\n+            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());\n+        }\n+\n+        ServiceBusReceiverAsyncClient buildAsyncClient(boolean isAutoCompleteAllowed) {\n+            final MessagingEntityType entityType = validateEntityPaths(logger, connectionStringEntityName, topicName,\n+                queueName);\n+            final String entityPath = getEntityPath(logger, entityType, queueName, topicName, subscriptionName,\n+                subQueue);\n+            validateAndThrow(prefetchCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82e2c5f97deab271b4a51124086feb442f911cc"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Nzg0NjMxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0MjowNlrOHlU99g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxODowOFrOHlWxGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMjkwMg==", "bodyText": "I thought that we are also doing this for sync clients ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r508902902", "createdAt": "2020-10-20T23:42:06Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -948,7 +968,26 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n         public ServiceBusReceiverClient buildClient() {\n-            return new ServiceBusReceiverClient(buildAsyncClient(), retryOptions.getTryTimeout());\n+            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());\n+        }\n+\n+        ServiceBusReceiverAsyncClient buildAsyncClient(boolean isAutoCompleteAllowed) {\n+            final MessagingEntityType entityType = validateEntityPaths(logger, connectionStringEntityName, topicName,\n+                queueName);\n+            final String entityPath = getEntityPath(logger, entityType, queueName, topicName, subscriptionName,\n+                subQueue);\n+            validateAndThrow(prefetchCount);\n+\n+            if (!isAutoCompleteAllowed && enableAutoComplete) {\n+                throw new IllegalStateException(\"'enableAutoComplete' is not support in synchronous client.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82e2c5f97deab271b4a51124086feb442f911cc"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjM3OQ==", "bodyText": "Yes. It's for the callback model. The pull model will not have that.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r508932379", "createdAt": "2020-10-21T01:18:08Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -948,7 +968,26 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n         public ServiceBusReceiverClient buildClient() {\n-            return new ServiceBusReceiverClient(buildAsyncClient(), retryOptions.getTryTimeout());\n+            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());\n+        }\n+\n+        ServiceBusReceiverAsyncClient buildAsyncClient(boolean isAutoCompleteAllowed) {\n+            final MessagingEntityType entityType = validateEntityPaths(logger, connectionStringEntityName, topicName,\n+                queueName);\n+            final String entityPath = getEntityPath(logger, entityType, queueName, topicName, subscriptionName,\n+                subQueue);\n+            validateAndThrow(prefetchCount);\n+\n+            if (!isAutoCompleteAllowed && enableAutoComplete) {\n+                throw new IllegalStateException(\"'enableAutoComplete' is not support in synchronous client.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMjkwMg=="}, "originalCommit": {"oid": "c82e2c5f97deab271b4a51124086feb442f911cc"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Nzg0ODY5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0MzoyM1rOHlU_Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0MzoyM1rOHlU_Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMzI3MQ==", "bodyText": "should this be info , since we are taking care of this for user, It should not create some kind of alarm for them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r508903271", "createdAt": "2020-10-20T23:43:23Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");\n+            } catch (Exception e) {\n+                logger.error(\"Error occurred processing message. Abandoning. sequenceNumber[{}]\",\n+                    sequenceNumber, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d46429425b01ca20a8df95ba9b0c591756abf44c"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDA2ODA3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjoxMTo0MVrOHmR9og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzo1ODoxOFrOHmVOEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwMjI0Mg==", "bodyText": "Why do we need a generic type that extends ServiceBusReceivedMessageContext? Also, this reminds me that ServiceBusReceivedMessageContext should be marked final too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509902242", "createdAt": "2020-10-22T06:11:41Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk1NTYwMQ==", "bodyText": "No reason. I have no qualms with making it specific.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509955601", "createdAt": "2020-10-22T07:58:18Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwMjI0Mg=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDA4MzEyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjoxNzoyMFrOHmSGLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODoyMTo0MVrOHmWIQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwNDQyOA==", "bodyText": "Why do we call  requestUnbounded()? The downstream should control the flow.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509904428", "createdAt": "2020-10-22T06:17:20Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MDQ5Nw==", "bodyText": "There's an exception that gets thrown because this operator itself should request something from upstream. When we get subscribed, we'll pass another subscription that is called and there it can restrict it if it wants.\ndownstreamSubscriber.onError(\n    java.lang.IllegalStateException: Can't deliver value due to lack of requests\n);\n-> at com.azure.messaging.servicebus/com.azure.messaging.servicebus.FluxAutoComplete$AutoCompleteSubscriber.hookOnError(FluxAutoComplete.java:96)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509970497", "createdAt": "2020-10-22T08:21:41Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwNDQyOA=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDA5NzQwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjoyMjozNVrOHmSONQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODoyMzo1N1rOHmWOPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwNjQ4NQ==", "bodyText": "This doesn't have to be called if the message is null. Same for abandon too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509906485", "createdAt": "2020-10-22T06:22:35Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNzg5OA==", "bodyText": "If complete fails , there is chance that message will be processed twice because it will go back to queue.\nFor now, we should log and continue ?\nBut as part of for-ever loop, this should me delivered to user in their error handler with indication that we fail to complete.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509927898", "createdAt": "2020-10-22T07:09:59Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwNjQ4NQ=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MjAyOQ==", "bodyText": "I separated that logic into the responsibility of the async client.\n            return new FluxAutoComplete(messageFlux,\n                context -> context.getMessage() != null ? complete(context.getMessage()) : Mono.empty(),\n                context -> context.getMessage() != null ? abandon(context.getMessage()) : Mono.empty());", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509972029", "createdAt": "2020-10-22T08:23:57Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwNjQ4NQ=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDExMDk3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjoyNzoyNFrOHmSWCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODoyNToxNVrOHmWRpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwODQ4OQ==", "bodyText": "Don't think we should call onError() here if the operation was to abandon. This will terminate the downstream. What is the expected behavior when a message cannot be completed successfully?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509908489", "createdAt": "2020-10-22T06:27:24Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");\n+            } catch (Exception e) {\n+                logger.error(\"Error occurred processing message. Abandoning. sequenceNumber[{}]\",\n+                    sequenceNumber, e);\n+\n+                applyWithCatch(onAbandon, value, \"abandon\");\n+            }\n+        }\n+\n+        /**\n+         * On an error, will pass the exception downstream.\n+         *\n+         * @param throwable Error to pass downstream.\n+         */\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.error(\"Error occurred. Passing downstream.\", throwable);\n+            downstream.onError(throwable);\n+        }\n+\n+        /**\n+         * On the completion. Will pass the complete signal downstream.\n+         */\n+        @Override\n+        protected void hookOnComplete() {\n+            logger.info(\"Completed. Passing downstream.\");\n+            downstream.onComplete();\n+        }\n+\n+        @Override\n+        public Context currentContext() {\n+            return downstream.currentContext();\n+        }\n+\n+        /**\n+         * Applies a function and catches then logs and closes any exceptions.\n+         *\n+         * @param function Function to apply.\n+         * @param message received message to apply function to.\n+         * @param operation The operation name.\n+         */\n+        private void applyWithCatch(Function<ServiceBusReceivedMessageContext, Mono<Void>> function, T message,\n+            String operation) {\n+            try {\n+                function.apply(message).block();\n+            } catch (Exception e) {\n+                logger.warning(\"Unable to '{}' message.\", operation, e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MjU4Mw==", "bodyText": "Yes. We should terminate the downstream. I want to wrap this with a retry().", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509972583", "createdAt": "2020-10-22T08:24:49Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");\n+            } catch (Exception e) {\n+                logger.error(\"Error occurred processing message. Abandoning. sequenceNumber[{}]\",\n+                    sequenceNumber, e);\n+\n+                applyWithCatch(onAbandon, value, \"abandon\");\n+            }\n+        }\n+\n+        /**\n+         * On an error, will pass the exception downstream.\n+         *\n+         * @param throwable Error to pass downstream.\n+         */\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.error(\"Error occurred. Passing downstream.\", throwable);\n+            downstream.onError(throwable);\n+        }\n+\n+        /**\n+         * On the completion. Will pass the complete signal downstream.\n+         */\n+        @Override\n+        protected void hookOnComplete() {\n+            logger.info(\"Completed. Passing downstream.\");\n+            downstream.onComplete();\n+        }\n+\n+        @Override\n+        public Context currentContext() {\n+            return downstream.currentContext();\n+        }\n+\n+        /**\n+         * Applies a function and catches then logs and closes any exceptions.\n+         *\n+         * @param function Function to apply.\n+         * @param message received message to apply function to.\n+         * @param operation The operation name.\n+         */\n+        private void applyWithCatch(Function<ServiceBusReceivedMessageContext, Mono<Void>> function, T message,\n+            String operation) {\n+            try {\n+                function.apply(message).block();\n+            } catch (Exception e) {\n+                logger.warning(\"Unable to '{}' message.\", operation, e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwODQ4OQ=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MjkwMg==", "bodyText": "This operator is just to complete/abandon. . . if it fails, it'll pass it downstream. the retries and infinite one is out of scope for this PR.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509972902", "createdAt": "2020-10-22T08:25:15Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");\n+            } catch (Exception e) {\n+                logger.error(\"Error occurred processing message. Abandoning. sequenceNumber[{}]\",\n+                    sequenceNumber, e);\n+\n+                applyWithCatch(onAbandon, value, \"abandon\");\n+            }\n+        }\n+\n+        /**\n+         * On an error, will pass the exception downstream.\n+         *\n+         * @param throwable Error to pass downstream.\n+         */\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.error(\"Error occurred. Passing downstream.\", throwable);\n+            downstream.onError(throwable);\n+        }\n+\n+        /**\n+         * On the completion. Will pass the complete signal downstream.\n+         */\n+        @Override\n+        protected void hookOnComplete() {\n+            logger.info(\"Completed. Passing downstream.\");\n+            downstream.onComplete();\n+        }\n+\n+        @Override\n+        public Context currentContext() {\n+            return downstream.currentContext();\n+        }\n+\n+        /**\n+         * Applies a function and catches then logs and closes any exceptions.\n+         *\n+         * @param function Function to apply.\n+         * @param message received message to apply function to.\n+         * @param operation The operation name.\n+         */\n+        private void applyWithCatch(Function<ServiceBusReceivedMessageContext, Mono<Void>> function, T message,\n+            String operation) {\n+            try {\n+                function.apply(message).block();\n+            } catch (Exception e) {\n+                logger.warning(\"Unable to '{}' message.\", operation, e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwODQ4OQ=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDEyMzEwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjozMTo1NVrOHmSdWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjozMTo1NVrOHmSdWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkxMDM2Mg==", "bodyText": "For the processor, autocomplete should still be possible right? So, the async client has to be built with autocomplete enabled by default.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509910362", "createdAt": "2020-10-22T06:31:55Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -744,16 +759,46 @@ public ServiceBusSessionReceiverClientBuilder topicName(String topicName) {\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n         public ServiceBusReceiverAsyncClient buildAsyncClient() {\n+            return buildAsyncClient(true);\n+        }\n+\n+        /**\n+         * Creates a <b>synchronous</b>, <b>session-aware</b> Service Bus receiver responsible for reading {@link\n+         * ServiceBusMessage messages} from a specific queue or topic.\n+         *\n+         * @return An new {@link ServiceBusReceiverClient} that receives messages from a queue or topic.\n+         * @throws IllegalStateException if {@link #queueName(String) queueName} or {@link #topicName(String)\n+         *     topicName} are not set or, both of these fields are set. It is also thrown if the Service Bus {@link\n+         *     #connectionString(String) connectionString} contains an {@code EntityPath} that does not match one set in\n+         *     {@link #queueName(String) queueName} or {@link #topicName(String) topicName}. Lastly, if a {@link\n+         *     #topicName(String) topicName} is set, but {@link #subscriptionName(String) subscriptionName} is not.\n+         * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n+         *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n+         */\n+        public ServiceBusReceiverClient buildClient() {\n+            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDEyNjgxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjozMzoyMFrOHmSflg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjozMzoyMFrOHmSflg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkxMDkzNA==", "bodyText": "Same as above. Async client should be built with autocomplete enabled for the processor. We may have to find a different way to disable it on the receive() method on the sync client.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509910934", "createdAt": "2020-10-22T06:33:20Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -948,7 +981,31 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n         public ServiceBusReceiverClient buildClient() {\n-            return new ServiceBusReceiverClient(buildAsyncClient(), retryOptions.getTryTimeout());\n+            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDIxNDg0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzowMjoyN1rOHmTT-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODoyNDowOFrOHmWOqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDM0NA==", "bodyText": "verbose ? since it does not help in regular scenario.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509924344", "createdAt": "2020-10-22T07:02:27Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");\n+            } catch (Exception e) {\n+                logger.error(\"Error occurred processing message. Abandoning. sequenceNumber[{}]\",\n+                    sequenceNumber, e);\n+\n+                applyWithCatch(onAbandon, value, \"abandon\");\n+            }\n+        }\n+\n+        /**\n+         * On an error, will pass the exception downstream.\n+         *\n+         * @param throwable Error to pass downstream.\n+         */\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.error(\"Error occurred. Passing downstream.\", throwable);\n+            downstream.onError(throwable);\n+        }\n+\n+        /**\n+         * On the completion. Will pass the complete signal downstream.\n+         */\n+        @Override\n+        protected void hookOnComplete() {\n+            logger.info(\"Completed. Passing downstream.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MjEzNg==", "bodyText": "Sure", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509972136", "createdAt": "2020-10-22T08:24:08Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoComplete.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Flux operator that auto-completes or auto-abandons messages when control is returned successfully.\n+ */\n+class FluxAutoComplete<T extends ServiceBusReceivedMessageContext> extends FluxOperator<T, T> {\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+    private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+    private final ClientLogger logger = new ClientLogger(FluxAutoComplete.class);\n+\n+    FluxAutoComplete(Flux<? extends T> upstream, Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+        Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon) {\n+        super(upstream);\n+        this.onComplete = Objects.requireNonNull(onComplete, \"'onComplete' cannot be null.\");\n+        this.onAbandon = Objects.requireNonNull(onAbandon, \"'onAbandon' cannot be null.\");\n+    }\n+\n+    /**\n+     * Invoked when a downstream subscriber is interested in objects published from this operator.\n+     *\n+     * @param coreSubscriber The subscriber interested in the published items.\n+     */\n+    @Override\n+    public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n+        Objects.requireNonNull(coreSubscriber, \"'coreSubscriber' cannot be null.\");\n+\n+        final AutoCompleteSubscriber<T> subscriber =\n+            new AutoCompleteSubscriber<T>(coreSubscriber, onComplete, onAbandon, logger);\n+\n+        source.subscribe(subscriber);\n+    }\n+\n+    static final class AutoCompleteSubscriber<T extends ServiceBusReceivedMessageContext> extends BaseSubscriber<T> {\n+        private final CoreSubscriber<? super T> downstream;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete;\n+        private final Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon;\n+        private final ClientLogger logger;\n+\n+        AutoCompleteSubscriber(CoreSubscriber<? super T> downstream,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onComplete,\n+            Function<ServiceBusReceivedMessageContext, Mono<Void>> onAbandon, ClientLogger logger) {\n+            this.downstream = downstream;\n+            this.onComplete = onComplete;\n+            this.onAbandon = onAbandon;\n+            this.logger = logger;\n+        }\n+\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            logger.info(\"Subscription received. Subscribing downstream. {}\", subscription);\n+            downstream.onSubscribe(this);\n+            requestUnbounded();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(T value) {\n+            final ServiceBusReceivedMessage message = value.getMessage();\n+            final String sequenceNumber = message != null ? String.valueOf(message.getSequenceNumber()) : \"n/a\";\n+\n+            logger.verbose(\"Passing message downstream. sequenceNumber[{}]\", sequenceNumber);\n+\n+            try {\n+                downstream.onNext(value);\n+                applyWithCatch(onComplete, value, \"complete\");\n+            } catch (Exception e) {\n+                logger.error(\"Error occurred processing message. Abandoning. sequenceNumber[{}]\",\n+                    sequenceNumber, e);\n+\n+                applyWithCatch(onAbandon, value, \"abandon\");\n+            }\n+        }\n+\n+        /**\n+         * On an error, will pass the exception downstream.\n+         *\n+         * @param throwable Error to pass downstream.\n+         */\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.error(\"Error occurred. Passing downstream.\", throwable);\n+            downstream.onError(throwable);\n+        }\n+\n+        /**\n+         * On the completion. Will pass the complete signal downstream.\n+         */\n+        @Override\n+        protected void hookOnComplete() {\n+            logger.info(\"Completed. Passing downstream.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDM0NA=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDI4MjE0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoCompleteTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzoyMjo0MlrOHmT8tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODoyNjowNFrOHmWT1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNDc3NA==", "bodyText": "Like we spoke above test for scenario where onComplete, onAbandon fails.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509934774", "createdAt": "2020-10-22T07:22:42Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoCompleteTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests {@link FluxAutoComplete} for abandoning messages.\n+ */\n+class FluxAutoCompleteTest {\n+    @Mock", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MzQ2MQ==", "bodyText": "Line 195 has the scenario.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16606#discussion_r509973461", "createdAt": "2020-10-22T08:26:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoCompleteTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests {@link FluxAutoComplete} for abandoning messages.\n+ */\n+class FluxAutoCompleteTest {\n+    @Mock", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNDc3NA=="}, "originalCommit": {"oid": "45bf11a550e505d17f5c5bf009b7b0688cbfa972"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3970, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}