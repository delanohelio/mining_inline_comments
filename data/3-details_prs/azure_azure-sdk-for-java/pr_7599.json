{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NjM2Mjgz", "number": 7599, "title": "Adding PollerFlux::create to support ActivationOp variant that returns PollResponse", "bodyText": "", "createdAt": "2020-01-22T02:46:49Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599", "merged": true, "mergeCommit": {"oid": "cf75890ec7b97256a390ff2776d1a1b6d022e523"}, "closed": true, "closedAt": "2020-02-19T03:32:56Z", "author": {"login": "anuchandy"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8sjdEAH2gAyMzY1NjM2MjgzOjNiYzM5ZDQxNzNmNGJhZjlmYzU3YTQ0NTUyYmM3YzRiOWJkOGYwZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFTJedgFqTM1OTk0ODMzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "committedDate": "2020-01-22T02:44:56Z", "message": "Adding PollerFlux::create to support ActivationOp variant that returns PollResponse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MDM2OTUz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#pullrequestreview-347036953", "createdAt": "2020-01-23T03:05:09Z", "commit": {"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTMwMzg4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#pullrequestreview-347530388", "createdAt": "2020-01-23T18:54:25Z", "commit": {"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1NDoyNVrOFhJCCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1ODozOVrOFhJJ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NTMwNQ==", "bodyText": "nit: rename this to activationOperationWithResponse to make it clear that this is different from activationOperation which doesn't have the PollResponse.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370295305", "createdAt": "2020-01-23T18:54:25Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -89,17 +90,94 @@ public PollerFlux(Duration defaultPollInterval,\n         this.defaultPollInterval = defaultPollInterval;\n         this.activationOperation = Objects.requireNonNull(activationOperation,\n             \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        this.activationOperationEx = null;\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = oneTimeActivationMono();\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, response holds the result. The PollerFlux created from constructor uses\n+     * an activationOperation which returns a Mono that directly emits result. Since the first variant of\n+     * PollerFlux has access to the response, it can skip the polling loop if the response indicate that\n+     * LRO is completed. Whereas the second PollerFlux variant calls pollFunction at least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+               BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+               Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n+        return new PollerFlux<>(defaultPollInterval,\n+            activationOperation,\n+            pollOperation,\n+            cancelOperation,\n+            fetchResultOperation,\n+            true);\n+    }\n+\n+    private PollerFlux(Duration defaultPollInterval,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+                       Function<PollingContext<T>, Mono<U>> fetchResultOperation,\n+                       boolean ignored) {\n+        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n+        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\n+                \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n+        }\n+        this.defaultPollInterval = defaultPollInterval;\n+        this.activationOperation = null;\n+        this.activationOperationEx = Objects.requireNonNull(activationOperation,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NjcwNg==", "bodyText": "Would be good to add a unit test case for this change.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370296706", "createdAt": "2020-01-23T18:57:30Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -89,17 +90,94 @@ public PollerFlux(Duration defaultPollInterval,\n         this.defaultPollInterval = defaultPollInterval;\n         this.activationOperation = Objects.requireNonNull(activationOperation,\n             \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        this.activationOperationEx = null;\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = oneTimeActivationMono();\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, response holds the result. The PollerFlux created from constructor uses\n+     * an activationOperation which returns a Mono that directly emits result. Since the first variant of\n+     * PollerFlux has access to the response, it can skip the polling loop if the response indicate that\n+     * LRO is completed. Whereas the second PollerFlux variant calls pollFunction at least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+               BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+               Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n+        return new PollerFlux<>(defaultPollInterval,\n+            activationOperation,\n+            pollOperation,\n+            cancelOperation,\n+            fetchResultOperation,\n+            true);\n+    }\n+\n+    private PollerFlux(Duration defaultPollInterval,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+                       Function<PollingContext<T>, Mono<U>> fetchResultOperation,\n+                       boolean ignored) {\n+        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n+        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\n+                \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n+        }\n+        this.defaultPollInterval = defaultPollInterval;\n+        this.activationOperation = null;\n+        this.activationOperationEx = Objects.requireNonNull(activationOperation,\n+            \"'activationOperation' cannot be null.\");\n+        this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n+        this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n+        this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n+            \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = oneTimeActivationMono();\n     }\n \n     @Override\n     public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n         this.oneTimeActivationMono\n-            .flatMapMany(ignored -> pollingLoop())\n+            .flatMapMany(ignored -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NzI5Nw==", "bodyText": "same here - maybe name this as isActivationWithResponse", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370297297", "createdAt": "2020-01-23T18:58:39Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -129,34 +207,43 @@ public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n      * The decorated Mono also handles concurrent calls to activation. Only one of them will be able to call\n      * activation and other subscriptions will keep resubscribing until it sees a activation happened or get a chance\n      * to call activation as the one previously entered the critical section got an error on activation.\n-     *\n-     * @param activationOperation a supplier that provide a Mono upon subscription execute activation operation.\n+\n      * @return a one time activation mono\n      */\n-    private Mono<Boolean> oneTimeActivationMono(final Function<PollingContext<T>, Mono<T>> activationOperation) {\n+    @SuppressWarnings(\"unchecked\")\n+    private Mono<Boolean> oneTimeActivationMono() {\n         return Mono.defer(() -> {\n             if (this.activated) {\n                 return Mono.just(true);\n             }\n             if (this.guardActivationCall.compareAndSet(this, 0, 1)) {\n-                final Mono<T> activationMono;\n+                final boolean isEx = this.activationOperationEx != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "276cc411e8327da3b8a2916e3193d12311e3655c", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/276cc411e8327da3b8a2916e3193d12311e3655c", "committedDate": "2020-01-24T15:40:30Z", "message": "Merge branch 'master' of github.com:azure/azure-sdk-for-java into poller-lro-init"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1db603ffb0e37a5115706307d829ea448f051ca", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d1db603ffb0e37a5115706307d829ea448f051ca", "committedDate": "2020-01-24T21:15:33Z", "message": "PollerFlux: Simplifying one-time-activation logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b73748b66cc8c5c62a78b1874f01347ef7a70a53", "committedDate": "2020-01-24T22:19:25Z", "message": "PollerTests: adding tests for PollerFlux::create factory method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDE5MjE3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#pullrequestreview-349019217", "createdAt": "2020-01-27T22:26:02Z", "commit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjoyNjowMlrOFiTooQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjozMDoyN1rOFiTvkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxNzYwMQ==", "bodyText": "Can you please improve this wording - I'm not entirely sure what it means.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371517601", "createdAt": "2020-01-27T22:26:02Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -38,10 +38,7 @@\n      * Creates DefaultSyncPoller.\n      *\n      * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param syncActivationOperation the activation function upon call synchronously execute the activation operation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODI5Mg==", "bodyText": "If you're meaning to contrast this method against the constructor, be more explicit. \"This create method differs from the PollerFlux constructor in that the constructor uses an ....\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371518292", "createdAt": "2020-01-27T22:27:47Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODQ5OA==", "bodyText": "Avoid acronyms, e.g, \"that the long-running operation\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371518498", "createdAt": "2020-01-27T22:28:20Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODg4Mg==", "bodyText": "Similarly, I'm not entirely clear what you mean by 'first variant' and 'second variant'. Try to be more explicit to avoid any confusion.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371518882", "createdAt": "2020-01-27T22:29:09Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODQ5OA=="}, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxOTE4MA==", "bodyText": "Don't worry about this kind of indentation - checkstyle should be warning against this too - please check if checkstyle passes.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371519180", "createdAt": "2020-01-27T22:29:55Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxOTM3Nw==", "bodyText": "This is a very long, single sentence. Break it down into a few sentences.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371519377", "createdAt": "2020-01-27T22:30:27Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxOTE4MA=="}, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MDcxOTg5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#pullrequestreview-349071989", "createdAt": "2020-01-28T00:43:46Z", "commit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMDo0Mzo0NlrOFiWRcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMTowMDowNVrOFiWhPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MDgxOQ==", "bodyText": "Is it necessary to do this blocking operation in PollerFlux if the sync poller is not going to be used? It might be better to move this to SyncPoller.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371560819", "createdAt": "2020-01-28T00:43:46Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTIwMQ==", "bodyText": "Change name to pollInterval instead as it's not a default and can be customized.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371561201", "createdAt": "2020-01-28T00:45:18Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDE0NA==", "bodyText": "Same here - might be better to defer this blocking operation until it's needed (when getSyncPoller() is called).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371564144", "createdAt": "2020-01-28T00:57:00Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+               BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+               Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n+        return new PollerFlux<>(defaultPollInterval,\n+            activationOperation,\n+            pollOperation,\n+            cancelOperation,\n+            fetchResultOperation,\n+            true);\n+    }\n+\n+    private PollerFlux(Duration defaultPollInterval,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+                       Function<PollingContext<T>, Mono<U>> fetchResultOperation,\n+                       boolean ignored) {\n+        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n+        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\n+                \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n+        }\n+        this.defaultPollInterval = defaultPollInterval;\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n+        this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n+        this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n+        this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n+            \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            Function.identity()).getMono();\n+        this.syncActivationOperation = cxt -> activationOperation.apply(cxt).block();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDg2Mg==", "bodyText": "Here you can do ctx -> this.activationOperation.apply(ctx).block() instead of eagerly creating syncActivationOperation", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371564862", "createdAt": "2020-01-28T01:00:05Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -108,61 +187,12 @@ public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n      */\n     public SyncPoller<T, U> getSyncPoller() {\n         return new DefaultSyncPoller<>(this.defaultPollInterval,\n-                this.activationOperation,\n+                this.syncActivationOperation,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e154db233567c22e241efbe2fcb241b4d09b21a", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e154db233567c22e241efbe2fcb241b4d09b21a", "committedDate": "2020-01-30T04:34:44Z", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into poller-lro-init"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "committedDate": "2020-01-30T05:32:27Z", "message": "Improving PollerFlux javadoc and renaming the parameter defaultPollInterval to pollInterval."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMDA4NDE2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#pullrequestreview-352008416", "createdAt": "2020-02-03T03:44:31Z", "commit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMzo0NDozMVrOFklxeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMzo1MDoxNVrOFkl0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMTkyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param <U> The type of the final result of long running operation\n          \n          \n            \n             * @param <U> The type of the final result of the long running operation", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373911928", "createdAt": "2020-02-03T03:44:31Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -22,7 +22,7 @@\n  * it is possible to be so, e.g. by using volatile and copying context.\n  *\n  * @param <T> The type of poll response value\n- * @param <U> The type of the final result of long-running operation\n+ * @param <U> The type of the final result of long running operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMTk0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param pollInterval the polling interval\n          \n          \n            \n                 * @param pollInterval the polling interval.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373911949", "createdAt": "2020-02-03T03:44:44Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjA2Ng==", "bodyText": "This still lacks clarity to me. I don't know, as a user of this API, what exactly I should supply here. In other words, you're telling me how this is used, rather than how I use it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912066", "createdAt": "2020-02-03T03:45:46Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param syncActivationOperation the operation to synchronously activate (start) the long running operation,\n+     *     this operation will be called with a new {@link PollingContext}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjI3Mg==", "bodyText": "Break some of these sentences up - in a few places you flow straight into \"this parameter is required\" when a full stop and a new sentence would improve readability.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912272", "createdAt": "2020-02-03T03:47:29Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param syncActivationOperation the operation to synchronously activate (start) the long running operation,\n+     *     this operation will be called with a new {@link PollingContext}.\n      * @param pollOperation the operation to poll the current state of long running operation, this parameter\n-     *                      is required and the operation will be called with current {@link PollingContext}.\n-     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n-     *                        if service supports cancellation, this parameter is required and if service does not\n-     *                        support cancellation then the implementer should return Mono.error with an error message\n-     *                        indicating absence of cancellation support, the operation will be called with current\n-     *                        {@link PollingContext}.\n+     *     is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long running operation\n+     *     if service supports cancellation, this parameter is required and if service does not support cancellation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjMwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Objects.requireNonNull(pollInterval, \"'defaultPollInterval' cannot be null.\");\n          \n          \n            \n                    Objects.requireNonNull(pollInterval, \"'pollInterval' cannot be null.\");", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912309", "createdAt": "2020-02-03T03:47:48Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param syncActivationOperation the operation to synchronously activate (start) the long running operation,\n+     *     this operation will be called with a new {@link PollingContext}.\n      * @param pollOperation the operation to poll the current state of long running operation, this parameter\n-     *                      is required and the operation will be called with current {@link PollingContext}.\n-     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n-     *                        if service supports cancellation, this parameter is required and if service does not\n-     *                        support cancellation then the implementer should return Mono.error with an error message\n-     *                        indicating absence of cancellation support, the operation will be called with current\n-     *                        {@link PollingContext}.\n+     *     is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long running operation\n+     *     if service supports cancellation, this parameter is required and if service does not support cancellation\n+     *     then the implementer should return Mono.error with an error message indicating absence of cancellation\n+     *     support, the operation will be called with current {@link PollingContext}.\n      * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n-     *                             the long-running operation if service support it, this parameter is required and\n-     *                             operation will be called current {@link PollingContext}, if service does not have an\n-     *                             api to fetch final result and if final result is same as final poll response value\n-     *                             then implementer can choose to simply return value from provided final poll response.\n+     *     the long running operation if service support it, this parameter is required and operation will be called\n+     *     current {@link PollingContext}, if service does not have an api to fetch final result and if final result\n+     *     is same as final poll response value then implementer can choose to simply return value from provided\n+     *     final poll response.\n      */\n-    DefaultSyncPoller(Duration defaultPollInterval,\n-                             Function<PollingContext<T>, Mono<T>> activationOperation,\n+    DefaultSyncPoller(Duration pollInterval,\n+                             Function<PollingContext<T>, PollResponse<T>> syncActivationOperation,\n                              Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n                              BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n                              Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n-        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n-        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+        Objects.requireNonNull(pollInterval, \"'defaultPollInterval' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjQ3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A subscription to {@link PollerFlux} initiate a long running operation and polls the status\n          \n          \n            \n             * A subscription to {@link PollerFlux} initiates a long running operation and polls the status", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912475", "createdAt": "2020-02-03T03:49:00Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -11,13 +11,13 @@\n \n import java.time.Duration;\n import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.BiFunction;\n import java.util.function.Function;\n \n /**\n- * A Flux that simplifies the task of executing long-running operations against an Azure service.\n- * A subscription to {@link PollerFlux} initiate a long-running operation and polls the status\n+ * A Flux that simplifies the task of executing long running operations against an Azure service.\n+ * A subscription to {@link PollerFlux} initiate a long running operation and polls the status", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjYyOA==", "bodyText": "Provide a better first sentence, as this is the most visible text in the JavaDoc.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912628", "createdAt": "2020-02-03T03:50:15Z", "author": {"login": "JonathanGiles"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -38,68 +38,143 @@\n  * {@codesnippet com.azure.core.util.polling.poller.cancelOperation}\n  *\n  * @param <T> The type of poll response value.\n- * @param <U> The type of the final result of long-running operation.\n+ * @param <U> The type of the final result of long running operation.\n  */\n public final class PollerFlux<T, U> extends Flux<AsyncPollResponse<T, U>> {\n     private final ClientLogger logger = new ClientLogger(PollerFlux.class);\n     private final PollingContext<T> rootContext = new PollingContext<>();\n     private final Duration defaultPollInterval;\n-    private final Function<PollingContext<T>, Mono<T>> activationOperation;\n     private final Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation;\n     private final BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation;\n     private final Function<PollingContext<T>, Mono<U>> fetchResultOperation;\n     private final Mono<Boolean> oneTimeActivationMono;\n-    private volatile boolean activated = false;\n-    private volatile int activationGuardFlag = 0;\n-    @SuppressWarnings({\"rawtypes\"})\n-    private final AtomicIntegerFieldUpdater<PollerFlux> guardActivationCall =\n-        AtomicIntegerFieldUpdater.newUpdater(PollerFlux.class, \"activationGuardFlag\");\n+    private final Function<PollingContext<T>, PollResponse<T>> syncActivationOperation;\n \n     /**\n      * Creates PollerFlux.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n-     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n-     *                      is required and the operation will be called with current {@link PollingContext}.\n-     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n-     *                        if service supports cancellation, this parameter is required and if service does not\n-     *                        support cancellation then the implementer should return Mono.error with an error message\n-     *                        indicating absence of cancellation support, the operation will be called with current\n-     *                        {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param activationOperation the activation operation to activate (start) the long running operation.\n+     *     This operation will be invoked at most once across all subscriptions. This parameter is required.\n+     *     If there is no specific activation work to be done then invocation should return Mono.empty(),\n+     *     this operation will be called with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation. This parameter\n+     *     is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long running operation\n+     *     if service supports cancellation. This parameter is required. If service does not support cancellation\n+     *     then the implementer should return Mono.error with an error message indicating absence of cancellation\n+     *     support. The operation will be called with current {@link PollingContext}.\n      * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n-     *                             the long-running operation if service support it, this parameter is required and\n-     *                             operation will be called current {@link PollingContext}, if service does not have an\n-     *                             api to fetch final result and if final result is same as final poll response value\n-     *                             then implementer can choose to simply return value from provided final poll response.\n+     *     the long running operation if service support it. This parameter is required and operation will be called\n+     *     current {@link PollingContext}. If service does not have an api to fetch final result and if final result\n+     *     is same as final poll response value then implementer can choose to simply return value from provided\n+     *     final poll response.\n      */\n-    public PollerFlux(Duration defaultPollInterval,\n+    public PollerFlux(Duration pollInterval,\n                       Function<PollingContext<T>, Mono<T>> activationOperation,\n                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n                       Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n-        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n-        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+        Objects.requireNonNull(pollInterval, \"'pollInterval' cannot be null.\");\n+        if (pollInterval.compareTo(Duration.ZERO) <= 0) {\n             throw logger.logExceptionAsWarning(new IllegalArgumentException(\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n-        this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        this.defaultPollInterval = pollInterval;\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf958c6f31a44317f4102978f5b70971ea488365", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf958c6f31a44317f4102978f5b70971ea488365", "committedDate": "2020-02-03T04:44:20Z", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3846e276483222866322858e84534762d3502991", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3846e276483222866322858e84534762d3502991", "committedDate": "2020-02-03T04:44:38Z", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4377fcb463bb3c0f8a23fc2ca7b728d94cdb4468", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4377fcb463bb3c0f8a23fc2ca7b728d94cdb4468", "committedDate": "2020-02-03T04:44:51Z", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e9e6658f21f02b0b19d9ac300cc99763e301844", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0e9e6658f21f02b0b19d9ac300cc99763e301844", "committedDate": "2020-02-03T04:45:03Z", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTQ4MzM2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#pullrequestreview-359948336", "createdAt": "2020-02-17T20:14:15Z", "commit": {"oid": "0e9e6658f21f02b0b19d9ac300cc99763e301844"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 488, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}