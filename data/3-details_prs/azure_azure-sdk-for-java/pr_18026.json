{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NzY3MDE2", "number": 18026, "title": "Conflict read/query support.", "bodyText": "This PR will cover below points\n\nProvided getItem(Class klass) api on CosmosConflictProperties, so user can consume the content and take action accordingly.\nAdded PartitionKey on CosmosConflictRequestOptions\nFixes conflict query pipeline by moving to partitioned query for conflicts as it is for document. With older code service was throwing x-ms-documentdb-query-enablecrosspartition required.\nAdded integration testing (CosmosConflictsTest) to cover 4 scenarios , default LWW, custom LWW, custom sproc, custom invalid sproc resolution.\nAdded test case in MultiMasterConflictResolutionTest.java to validate service will throw exception if we try to update the existing conflict resolution policy on container.", "createdAt": "2020-12-08T22:25:35Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026", "merged": true, "mergeCommit": {"oid": "657e9a47e4b4c7e7e7eee4100273c09468a30c63"}, "closed": true, "closedAt": "2020-12-11T20:58:53Z", "author": {"login": "simplynaveen20"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdj-0vFAH2gAyNTM0NzY3MDE2OjdiOGU4MGNhZjdhZWVhNDkzOGM4OGRkOGM3YzUxMTIwOTIwMTc0NWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdk89yVAFqTU0OTcyMTYxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7b8e80caf7aeea4938c88dd8c7c511209201745b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7b8e80caf7aeea4938c88dd8c7c511209201745b", "committedDate": "2020-12-08T00:16:18Z", "message": "Initial commit for conflict support in V4 java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39471ac555293c4327a1472f5904fdc4fccf29ea", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/39471ac555293c4327a1472f5904fdc4fccf29ea", "committedDate": "2020-12-08T21:47:06Z", "message": "refactoring test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e2608d40e9f2c6932f95e64ca5e3a6c9464be3d", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e2608d40e9f2c6932f95e64ca5e3a6c9464be3d", "committedDate": "2020-12-08T21:54:10Z", "message": "Merge branch 'latest-master' into users/nakumars/conflictApiSupport"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d30afe9a0be59a9285e3296b71faaca0233ce80", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d30afe9a0be59a9285e3296b71faaca0233ce80", "committedDate": "2020-12-08T21:54:59Z", "message": "adding timeout in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/70d8b6a8f7365683559c1f7be9b87f653f24eea2", "committedDate": "2020-12-08T22:03:56Z", "message": "fixing documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Njg2MTc0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-547686174", "createdAt": "2020-12-08T22:28:14Z", "commit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoyODoxNFrOIB5I7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozMToyNFrOIB5PbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTY2Mg==", "bodyText": "Idea of this api is customer can use their own serializer to read conflict resource . But I am doubtful as we don't support this kind of api in item read. Thoughts ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538855662", "createdAt": "2020-12-08T22:28:14Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosConflictProperties.java", "diffHunk": "@@ -55,6 +55,24 @@ Resource getResource() {\n         return this.conflict;\n     }\n \n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T> T getItem(Class<T> klass) {\n+        return this.conflict.getItem(klass);\n+    }\n+\n+    /**\n+     * Gets the json content of the conflict.\n+     * @return The content string.\n+     */\n+    public String getItemAsJson() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1Njc0Mg==", "bodyText": "Adding this api because as of now customer need to pass the self link by themselves, and in V4 we don't have a way of getting self link from resources. Only way for user is if they manually create the URL.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538856742", "createdAt": "2020-12-08T22:30:12Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzMyNQ==", "bodyText": "Adding this api because as of now customer need to pass the self link by themselves, and in V4 we don't have a way of getting self link from resources. Only way for user is if they manually create the URL.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538857325", "createdAt": "2020-12-08T22:31:24Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {\n+        ConflictResolutionPolicy policy = new ConflictResolutionPolicy();\n+        policy.setMode(ConflictResolutionMode.CUSTOM);\n+        if (storedProcedure != null) {\n+            policy.setConflictResolutionProcedure(getLink(storedProcedure));\n+        }\n+        return policy;\n+    }\n+\n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosAsyncStoredProcedure storedProcedure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzUxMjY2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-547751266", "createdAt": "2020-12-09T00:46:22Z", "commit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDo0NjoyMlrOIB8-Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTowNTowNVrOIB9bVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxODQ1MQ==", "bodyText": "nit: remove additional empty line", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538918451", "createdAt": "2020-12-09T00:46:22Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -641,6 +641,17 @@ public static RequestOptions toRequestOptions(TransactionalBatchRequestOptions t\n         return transactionalBatchRequestOptions.toRequestOptions();\n     }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxODYyNQ==", "bodyText": "nice catch. thank you.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538918625", "createdAt": "2020-12-09T00:46:45Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncConflict.java", "diffHunk": "@@ -71,15 +71,15 @@ CosmosAsyncConflict setId(String id) {\n     }\n \n     /**\n-     * Reads all conflicts in a container.\n+     * Deletes a conflict.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxOTI2OA==", "bodyText": "fix the indentation. 4 spaces per indentation as similar to other places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538919268", "createdAt": "2020-12-09T00:48:29Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Conflict.java", "diffHunk": "@@ -74,4 +78,32 @@ public String getSourceResourceId() {\n             return null;\n         }\n     }\n+\n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T > T getItem(Class<T> klass) {\n+        String resourceAsString = super.getString(Constants.Properties.CONTENT);\n+\n+        if (!Strings.isNullOrEmpty(resourceAsString)) {\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxOTY2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getItemAsJson() {\n          \n          \n            \n                public String getItemAsJsonString() {", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538919663", "createdAt": "2020-12-09T00:49:35Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Conflict.java", "diffHunk": "@@ -74,4 +78,32 @@ public String getSourceResourceId() {\n             return null;\n         }\n     }\n+\n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T > T getItem(Class<T> klass) {\n+        String resourceAsString = super.getString(Constants.Properties.CONTENT);\n+\n+        if (!Strings.isNullOrEmpty(resourceAsString)) {\n+                try {\n+                    return mapper.readValue(resourceAsString, klass);\n+                } catch (JsonProcessingException ex) {\n+                    throw new IllegalStateException(\"Failed to deserialize  class object.\", ex);\n+                }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Gets the json content of the conflicting resource.\n+     * @return The content string.\n+     */\n+    public String getItemAsJson() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDgyMg==", "bodyText": "our data-model classes are free of notion of async-ness vs sync-ness.\nThis breaks that existing design and brings async-ness into the data-models. We should find a different approach for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538920822", "createdAt": "2020-12-09T00:52:34Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {\n+        ConflictResolutionPolicy policy = new ConflictResolutionPolicy();\n+        policy.setMode(ConflictResolutionMode.CUSTOM);\n+        if (storedProcedure != null) {\n+            policy.setConflictResolutionProcedure(getLink(storedProcedure));\n+        }\n+        return policy;\n+    }\n+\n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosAsyncStoredProcedure storedProcedure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMjQ0NA==", "bodyText": "I suggest we don't introduce this API for now. as you said we currently do not support getting string content from the CosmosItemResponse.\ngetItem(ObjectNode.class) should work the customer need.\nLater when we add the support for getting content from CosmosItemResponse we can revisit this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538922444", "createdAt": "2020-12-09T00:56:12Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosConflictProperties.java", "diffHunk": "@@ -55,6 +55,24 @@ Resource getResource() {\n         return this.conflict;\n     }\n \n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T> T getItem(Class<T> klass) {\n+        return this.conflict.getItem(klass);\n+    }\n+\n+    /**\n+     * Gets the json content of the conflict.\n+     * @return The content string.\n+     */\n+    public String getItemAsJson() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTY2Mg=="}, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNDMxNw==", "bodyText": "please use TestSuiteBase:safeClose that will do the null check.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538924317", "createdAt": "2020-12-09T01:00:50Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,461 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ConflictTests() throws Exception {\n+        sprocBody = IOUtils.toString(\n+            getClass().getClassLoader().getResourceAsStream(\"conflict-resolver-sproc\"), \"UTF-8\");\n+        globalClient = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .contentResponseOnWriteEnabled(true)\n+            .endpointDiscoveryEnabled(false)\n+            .directMode()\n+            .buildAsyncClient();\n+\n+        GlobalEndpointManager globalEndpointManager =\n+            ReflectionUtils.getGlobalEndpointManager((RxDocumentClientImpl) globalClient.getContextClient());\n+        DatabaseAccount databaseAccount = globalEndpointManager.getLatestDatabaseAccount();\n+        Iterator<DatabaseAccountLocation> locationIterator = databaseAccount.getWritableLocations().iterator();\n+        regionalClients = new ArrayList<>();\n+        while (locationIterator.hasNext()) {\n+            DatabaseAccountLocation accountLocation = locationIterator.next();\n+            CosmosAsyncClient regionalClient = new CosmosClientBuilder()\n+                .endpoint(accountLocation.getEndpoint())\n+                .key(TestConfigurations.MASTER_KEY)\n+                .contentResponseOnWriteEnabled(true)\n+                .endpointDiscoveryEnabled(false)\n+                .directMode()\n+                .buildAsyncClient();\n+            regionalClients.add(regionalClient);\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictDefaultLWW() throws InterruptedException {\n+        String conflictId = \"conflict\";\n+        CosmosAsyncContainer asyncContainer = getSharedMultiPartitionCosmosContainer(globalClient);\n+        if (this.regionalClients.size() > 1) {\n+            List<CosmosAsyncContainer> containers = new ArrayList<>();\n+            warmingUpClient(containers, asyncContainer.getDatabase().getId(), asyncContainer.getId());\n+            createItemsInParallelForConflicts(containers, conflictId);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+            List<ConflictTestPojo> testPojos = new ArrayList<>();\n+            readConflicts(iterator, testPojos, null);\n+            assertThat(testPojos.size()).isEqualTo(0);\n+\n+            CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+\n+            //Verify delete should always win\n+            replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            try {\n+                containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                fail(\"Delete should always win in conflict scenerio\");\n+            } catch (CosmosException ex) {\n+                assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomLWW() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictCustomLWWContainer\"\n+                , \"/mypk\");\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createLastWriterWinsPolicy(\n+                \"/regionId\");\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                //There should be no conflict\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Higher regionId item should win.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(containers.size() - 1);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                //create the sproc\n+                CosmosAsyncContainer asyncContainer = database.getContainer(containerProperties.getId());\n+                CosmosStoredProcedureProperties procedureProperties = new CosmosStoredProcedureProperties(sprocId,\n+                    sprocBody);\n+                asyncContainer.getScripts().createStoredProcedure(procedureProperties).block();\n+\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Lower regionId item should win as per sproc.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(0);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictNonExistingCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictNonExistingCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\n+                \"conflictNonExistingSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                String conflictId = \"conflict\";\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                List<String> conflictIds = new ArrayList<>();\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator = null;\n+                for (int j = 0; j < 5; j++) {\n+                    conflictId = conflictId + j;\n+                    boolean conflictCreated = false;\n+                    createItemsInParallelForConflicts(containers, conflictId);\n+\n+                    Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                    for (int i = 1; i < 4; i++) {\n+                        //Testing readAllConflicts()\n+                        iterator =\n+                            containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+\n+                        readConflicts(iterator, testPojos, conflictIds);\n+                        if (testPojos.size() == 0) {\n+                            logger.error(\"Conflict on {} insert operation has not reflected yet, retrying read after \" +\n+                                    \"5 sec\",\n+                                containers.get(0).getId());\n+                            Thread.sleep(5000); // retry after 5 sec\n+                        } else {\n+                            conflictCreated = true;\n+                            break;\n+                        }\n+                    }\n+                    if (conflictCreated) {\n+                        break;\n+                    }\n+                    logger.error(\"Conflict on {} not created, retrying again\",\n+                        containers.get(0).getId());\n+                }\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                //Testing queryConflicts(String query, CosmosQueryRequestOptions cosmosQueryRequestOptions)\n+                testPojos.clear();\n+                String query = String.format(\"SELECT * from c where c.id in (%s)\",\n+                    Strings.join(conflictIds.stream().map(s -> \"'\" + s + \"'\").collect(Collectors.toList())).with(\",\"));\n+                CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+                options.setPartitionKey(new PartitionKey(conflictId));\n+                iterator = containers.get(0).queryConflicts(query, options).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+\n+                //Testing queryConflicts(String query)\n+                testPojos.clear();\n+                iterator = containers.get(0).queryConflicts(query).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                for (String id : conflictIds) {\n+                    CosmosConflictRequestOptions requestOptions =\n+                        new CosmosConflictRequestOptions(new PartitionKey(conflictId));\n+                    containers.get(0).getConflict(id).delete(requestOptions).block();\n+                }\n+                Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                testPojos.clear();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //Making sure all conflicts are deleted\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Verifying during conflict on create we will have one winner item saved\n+                assertThat(itemResponse.getItem().getId()).isEqualTo(conflictId);\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @AfterClass(groups = {\"multi-master\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        if (this.globalClient != null) {\n+            this.globalClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNDM0Mg==", "bodyText": "ditto.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538924342", "createdAt": "2020-12-09T01:00:56Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,461 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ConflictTests() throws Exception {\n+        sprocBody = IOUtils.toString(\n+            getClass().getClassLoader().getResourceAsStream(\"conflict-resolver-sproc\"), \"UTF-8\");\n+        globalClient = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .contentResponseOnWriteEnabled(true)\n+            .endpointDiscoveryEnabled(false)\n+            .directMode()\n+            .buildAsyncClient();\n+\n+        GlobalEndpointManager globalEndpointManager =\n+            ReflectionUtils.getGlobalEndpointManager((RxDocumentClientImpl) globalClient.getContextClient());\n+        DatabaseAccount databaseAccount = globalEndpointManager.getLatestDatabaseAccount();\n+        Iterator<DatabaseAccountLocation> locationIterator = databaseAccount.getWritableLocations().iterator();\n+        regionalClients = new ArrayList<>();\n+        while (locationIterator.hasNext()) {\n+            DatabaseAccountLocation accountLocation = locationIterator.next();\n+            CosmosAsyncClient regionalClient = new CosmosClientBuilder()\n+                .endpoint(accountLocation.getEndpoint())\n+                .key(TestConfigurations.MASTER_KEY)\n+                .contentResponseOnWriteEnabled(true)\n+                .endpointDiscoveryEnabled(false)\n+                .directMode()\n+                .buildAsyncClient();\n+            regionalClients.add(regionalClient);\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictDefaultLWW() throws InterruptedException {\n+        String conflictId = \"conflict\";\n+        CosmosAsyncContainer asyncContainer = getSharedMultiPartitionCosmosContainer(globalClient);\n+        if (this.regionalClients.size() > 1) {\n+            List<CosmosAsyncContainer> containers = new ArrayList<>();\n+            warmingUpClient(containers, asyncContainer.getDatabase().getId(), asyncContainer.getId());\n+            createItemsInParallelForConflicts(containers, conflictId);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+            List<ConflictTestPojo> testPojos = new ArrayList<>();\n+            readConflicts(iterator, testPojos, null);\n+            assertThat(testPojos.size()).isEqualTo(0);\n+\n+            CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+\n+            //Verify delete should always win\n+            replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            try {\n+                containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                fail(\"Delete should always win in conflict scenerio\");\n+            } catch (CosmosException ex) {\n+                assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomLWW() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictCustomLWWContainer\"\n+                , \"/mypk\");\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createLastWriterWinsPolicy(\n+                \"/regionId\");\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                //There should be no conflict\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Higher regionId item should win.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(containers.size() - 1);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                //create the sproc\n+                CosmosAsyncContainer asyncContainer = database.getContainer(containerProperties.getId());\n+                CosmosStoredProcedureProperties procedureProperties = new CosmosStoredProcedureProperties(sprocId,\n+                    sprocBody);\n+                asyncContainer.getScripts().createStoredProcedure(procedureProperties).block();\n+\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Lower regionId item should win as per sproc.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(0);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictNonExistingCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictNonExistingCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\n+                \"conflictNonExistingSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                String conflictId = \"conflict\";\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                List<String> conflictIds = new ArrayList<>();\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator = null;\n+                for (int j = 0; j < 5; j++) {\n+                    conflictId = conflictId + j;\n+                    boolean conflictCreated = false;\n+                    createItemsInParallelForConflicts(containers, conflictId);\n+\n+                    Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                    for (int i = 1; i < 4; i++) {\n+                        //Testing readAllConflicts()\n+                        iterator =\n+                            containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+\n+                        readConflicts(iterator, testPojos, conflictIds);\n+                        if (testPojos.size() == 0) {\n+                            logger.error(\"Conflict on {} insert operation has not reflected yet, retrying read after \" +\n+                                    \"5 sec\",\n+                                containers.get(0).getId());\n+                            Thread.sleep(5000); // retry after 5 sec\n+                        } else {\n+                            conflictCreated = true;\n+                            break;\n+                        }\n+                    }\n+                    if (conflictCreated) {\n+                        break;\n+                    }\n+                    logger.error(\"Conflict on {} not created, retrying again\",\n+                        containers.get(0).getId());\n+                }\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                //Testing queryConflicts(String query, CosmosQueryRequestOptions cosmosQueryRequestOptions)\n+                testPojos.clear();\n+                String query = String.format(\"SELECT * from c where c.id in (%s)\",\n+                    Strings.join(conflictIds.stream().map(s -> \"'\" + s + \"'\").collect(Collectors.toList())).with(\",\"));\n+                CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+                options.setPartitionKey(new PartitionKey(conflictId));\n+                iterator = containers.get(0).queryConflicts(query, options).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+\n+                //Testing queryConflicts(String query)\n+                testPojos.clear();\n+                iterator = containers.get(0).queryConflicts(query).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                for (String id : conflictIds) {\n+                    CosmosConflictRequestOptions requestOptions =\n+                        new CosmosConflictRequestOptions(new PartitionKey(conflictId));\n+                    containers.get(0).getConflict(id).delete(requestOptions).block();\n+                }\n+                Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                testPojos.clear();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //Making sure all conflicts are deleted\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Verifying during conflict on create we will have one winner item saved\n+                assertThat(itemResponse.getItem().getId()).isEqualTo(conflictId);\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @AfterClass(groups = {\"multi-master\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        if (this.globalClient != null) {\n+            this.globalClient.close();\n+        }\n+        for (CosmosAsyncClient asyncClient : this.regionalClients)\n+            if (asyncClient != null) {\n+                asyncClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNTkxMQ==", "bodyText": "blocking on this one.\nadding @FabianMeiswinkel @kushagraThapar @kirankumarkolli for further discussion.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538925911", "createdAt": "2020-12-09T01:05:05Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {\n+        ConflictResolutionPolicy policy = new ConflictResolutionPolicy();\n+        policy.setMode(ConflictResolutionMode.CUSTOM);\n+        if (storedProcedure != null) {\n+            policy.setConflictResolutionProcedure(getLink(storedProcedure));\n+        }\n+        return policy;\n+    }\n+\n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosAsyncStoredProcedure storedProcedure) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDgyMg=="}, "originalCommit": {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a24a51a8441016214e9af1fa8e84c5199b3c94b7", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a24a51a8441016214e9af1fa8e84c5199b3c94b7", "committedDate": "2020-12-09T18:14:40Z", "message": "resolving comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NDcxMjgz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-548471283", "createdAt": "2020-12-09T18:21:47Z", "commit": {"oid": "a24a51a8441016214e9af1fa8e84c5199b3c94b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyMTo0N1rOICi85A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyMTo0N1rOICi85A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MDcwOA==", "bodyText": "you shouldn't pass the regional account endpoint to the CosmosClientBuilder.\ninstead you should pass the global account endpoint and set the preferred region to be the local region of interest.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539540708", "createdAt": "2020-12-09T18:21:47Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,457 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ConflictTests() throws Exception {\n+        sprocBody = IOUtils.toString(\n+            getClass().getClassLoader().getResourceAsStream(\"conflict-resolver-sproc\"), \"UTF-8\");\n+        globalClient = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .contentResponseOnWriteEnabled(true)\n+            .endpointDiscoveryEnabled(false)\n+            .directMode()\n+            .buildAsyncClient();\n+\n+        GlobalEndpointManager globalEndpointManager =\n+            ReflectionUtils.getGlobalEndpointManager((RxDocumentClientImpl) globalClient.getContextClient());\n+        DatabaseAccount databaseAccount = globalEndpointManager.getLatestDatabaseAccount();\n+        Iterator<DatabaseAccountLocation> locationIterator = databaseAccount.getWritableLocations().iterator();\n+        regionalClients = new ArrayList<>();\n+        while (locationIterator.hasNext()) {\n+            DatabaseAccountLocation accountLocation = locationIterator.next();\n+            CosmosAsyncClient regionalClient = new CosmosClientBuilder()\n+                .endpoint(accountLocation.getEndpoint())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a51a8441016214e9af1fa8e84c5199b3c94b7"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NDc0MjQ3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-548474247", "createdAt": "2020-12-09T18:23:58Z", "commit": {"oid": "a24a51a8441016214e9af1fa8e84c5199b3c94b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyMzo1OFrOICjCrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyMzo1OFrOICjCrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MjE5MQ==", "bodyText": "we had different multi-master CI accounts. One CI uses an account with multi-master enabled in the account but with a single region.\nYou should validate that if the account is single region this test class should be skipped.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539542191", "createdAt": "2020-12-09T18:23:58Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,457 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a51a8441016214e9af1fa8e84c5199b3c94b7"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1682d9985d9a8cddb12b3ff797808d110e30e1b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1682d9985d9a8cddb12b3ff797808d110e30e1b", "committedDate": "2020-12-09T19:29:15Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9df24556f2ee787fea0eab8e2dba622bacd5a341", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9df24556f2ee787fea0eab8e2dba622bacd5a341", "committedDate": "2020-12-09T19:48:11Z", "message": "Skipping test for single region multi master account"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "367e2e4f6de4fa952f9a6a65178820e8806f92b8", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/367e2e4f6de4fa952f9a6a65178820e8806f92b8", "committedDate": "2020-12-09T23:49:16Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "298bfa378c5e14741bc86cf895b38ff9225f0adc", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/298bfa378c5e14741bc86cf895b38ff9225f0adc", "committedDate": "2020-12-09T23:55:21Z", "message": "removing unnessary change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/920df6c6ac31c5f6bc71cd6f8ddb33455e55641f", "committedDate": "2020-12-10T18:57:10Z", "message": "adding sproc file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTk1Mzk2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-549595396", "createdAt": "2020-12-10T20:57:20Z", "commit": {"oid": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjU5NTcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-549659572", "createdAt": "2020-12-10T22:34:38Z", "commit": {"oid": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjozNDozOVrOIDgXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjozNDozOVrOIDgXRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0Njg4Ng==", "bodyText": "is this meant to be self link or name link?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540546886", "createdAt": "2020-12-10T22:34:39Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -111,23 +112,47 @@ public static ConflictResolutionPolicy createLastWriterWinsPolicy(String conflic\n      * required.\n      *\n      * <ul>\n+     * <li>This method requires conflictResolutionStoredProcFullPath in format\n+     * dbs/%s/colls/%s/sprocs/%s. User can also use equivalent method {@link #createCustomPolicy(String, String, String)}</li>\n      * <li>In case the stored procedure fails or throws an exception,\n      * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n      * <li>The user can provide the stored procedure @see {@link Resource#getId()} </li>\n      * </ul>\n      *\n-     * @param conflictResolutionStoredProcName stored procedure to perform conflict resolution.\n+     * @param conflictResolutionStoredProcFullPath stored procedure full path to perform conflict resolution.\n      * @return ConflictResolutionPolicy.\n      */\n-    public static ConflictResolutionPolicy createCustomPolicy(String conflictResolutionStoredProcName) {\n+    public static ConflictResolutionPolicy createCustomPolicy(String conflictResolutionStoredProcFullPath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NzIxNjEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#pullrequestreview-549721611", "createdAt": "2020-12-11T00:40:18Z", "commit": {"oid": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1411, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}