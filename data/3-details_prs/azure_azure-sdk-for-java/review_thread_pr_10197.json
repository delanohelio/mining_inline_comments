{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDg2NjEy", "number": 10197, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0NjoxM1rOD8P4AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjowMzowMFrOD8i9JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTAxMjQ4OnYy", "diffSide": "RIGHT", "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/EventHubClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0NjoxM1rOGVEqsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMjoxNToyNlrOGYftQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0OTc0NA==", "bodyText": "Is maximumSilentTime in seconds or minutes? Would it be better to take a Duration type here instead of int? That will allow the customer to specify the time unit.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r424749744", "createdAt": "2020-05-13T21:46:13Z", "author": {"login": "srnagar"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/EventHubClient.java", "diffHunk": "@@ -70,6 +70,27 @@ static EventHubClient createFromConnectionStringSync(final String connectionStri\n     }\n \n \n+    /**\n+     * Synchronous version of {@link #createFromConnectionString(String, RetryPolicy, ScheduledExecutorService, ProxyConfiguration, int)}.\n+     *\n+     * @param connectionString The connection string to be used. See {@link ConnectionStringBuilder} to construct a connectionString.\n+     * @param retryPolicy      A custom {@link RetryPolicy} to be used when communicating with EventHub.\n+     * @param executor         An {@link ScheduledExecutorService} to run all tasks performed by {@link EventHubClient}.\n+     * @param configuration    The proxy configuration for this EventHubClient connection; {@code null} or\n+     *      {@link ProxyConfiguration#SYSTEM_DEFAULTS} if the system configured proxy settings should be used.\n+     * @param maximumSilentTime Use {@link EventHubClientOptions#SILENT_OFF} except on recommendation from the product group.\n+     * @return EventHubClient which can be used to create Senders and Receivers to EventHub\n+     * @throws EventHubException If Service Bus service encountered problems during connection creation.\n+     * @throws IOException       If the underlying Proton-J layer encounter network errors.\n+     */\n+    static EventHubClient createFromConnectionStringSync(final String connectionString, final RetryPolicy retryPolicy,\n+                                                         final ScheduledExecutorService executor,\n+                                                         final ProxyConfiguration configuration,\n+                                                         final int maximumSilentTime)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzODQ5Nw==", "bodyText": "Changed to Duration", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r428338497", "createdAt": "2020-05-20T22:15:26Z", "author": {"login": "JamesBirdsall"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/EventHubClient.java", "diffHunk": "@@ -70,6 +70,27 @@ static EventHubClient createFromConnectionStringSync(final String connectionStri\n     }\n \n \n+    /**\n+     * Synchronous version of {@link #createFromConnectionString(String, RetryPolicy, ScheduledExecutorService, ProxyConfiguration, int)}.\n+     *\n+     * @param connectionString The connection string to be used. See {@link ConnectionStringBuilder} to construct a connectionString.\n+     * @param retryPolicy      A custom {@link RetryPolicy} to be used when communicating with EventHub.\n+     * @param executor         An {@link ScheduledExecutorService} to run all tasks performed by {@link EventHubClient}.\n+     * @param configuration    The proxy configuration for this EventHubClient connection; {@code null} or\n+     *      {@link ProxyConfiguration#SYSTEM_DEFAULTS} if the system configured proxy settings should be used.\n+     * @param maximumSilentTime Use {@link EventHubClientOptions#SILENT_OFF} except on recommendation from the product group.\n+     * @return EventHubClient which can be used to create Senders and Receivers to EventHub\n+     * @throws EventHubException If Service Bus service encountered problems during connection creation.\n+     * @throws IOException       If the underlying Proton-J layer encounter network errors.\n+     */\n+    static EventHubClient createFromConnectionStringSync(final String connectionString, final RetryPolicy retryPolicy,\n+                                                         final ScheduledExecutorService executor,\n+                                                         final ProxyConfiguration configuration,\n+                                                         final int maximumSilentTime)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0OTc0NA=="}, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTAyNzE0OnYy", "diffSide": "RIGHT", "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/EventHubClientOptions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo1MTozNlrOGVEz7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMjoxNTozOFrOGYftlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MjExMA==", "bodyText": "Consider using Duration instead of int. Also, I noticed that operationTimeout is using Duration. So, it would be consistent with other timeout types.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r424752110", "createdAt": "2020-05-13T21:51:36Z", "author": {"login": "srnagar"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/EventHubClientOptions.java", "diffHunk": "@@ -92,6 +96,30 @@ public EventHubClientOptions setProxyConfiguration(ProxyConfiguration proxyConfi\n      * @return Gets the proxy configuration.\n      */\n     public ProxyConfiguration getProxyConfiguration() {\n-        return proxyConfiguration;\n+        return this.proxyConfiguration;\n+    }\n+\n+    /**\n+     * Sets the maximum silent time, in seconds.\n+     * Use only on recommendation from the product group.\n+     * \n+     * @param maximumSilentTime The time in seconds, or SILENT_OFF. Time must be at least SILENT_MINIMUM_SECONDS.\n+     * @return The updated options object.\n+     */\n+    public EventHubClientOptions setMaximumSilentTime(int maximumSilentTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzODU4MQ==", "bodyText": "Also changed to Duration", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r428338581", "createdAt": "2020-05-20T22:15:38Z", "author": {"login": "JamesBirdsall"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/EventHubClientOptions.java", "diffHunk": "@@ -92,6 +96,30 @@ public EventHubClientOptions setProxyConfiguration(ProxyConfiguration proxyConfi\n      * @return Gets the proxy configuration.\n      */\n     public ProxyConfiguration getProxyConfiguration() {\n-        return proxyConfiguration;\n+        return this.proxyConfiguration;\n+    }\n+\n+    /**\n+     * Sets the maximum silent time, in seconds.\n+     * Use only on recommendation from the product group.\n+     * \n+     * @param maximumSilentTime The time in seconds, or SILENT_OFF. Time must be at least SILENT_MINIMUM_SECONDS.\n+     * @return The updated options object.\n+     */\n+    public EventHubClientOptions setMaximumSilentTime(int maximumSilentTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MjExMA=="}, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTEwNDcxOnYy", "diffSide": "RIGHT", "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/impl/MessagingFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjoyMTozNFrOGVFj7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzowMzo1N1rOGX1maw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2NDM5Ng==", "bodyText": "What happens when the executor is single-threaded? Having a Thread.sleep() on this thread can stall other operations scheduled in this executor.\nexecutor = Executors.newScheduledThreadPool(1);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r424764396", "createdAt": "2020-05-13T22:21:34Z", "author": {"login": "srnagar"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/impl/MessagingFactory.java", "diffHunk": "@@ -248,6 +283,100 @@ public void run() {\n         return messagingFactory.open;\n     }\n \n+    public void registerForWatchdog(final MessageReceiver rcvr) {\n+        if (this.watchdogTriggerSeconds > EventHubClientOptions.SILENT_OFF) {\n+            TRACE_LOGGER.info(\"Registering for watchdog: \" + rcvr.getClientId());\n+            synchronized (this.watchdogSyncObject) {\n+                this.watchdogReceivers.add(rcvr);\n+            }\n+        }\n+        // else ignore registration if watchdog is off\n+    }\n+\n+    public void unregisterForWatchdog(final MessageReceiver rcvr) {\n+        if (this.watchdogTriggerSeconds > EventHubClientOptions.SILENT_OFF) {\n+            TRACE_LOGGER.info(\"Unregistering for watchdog: \" + rcvr.getClientId());\n+            synchronized (this.watchdogSyncObject) {\n+                this.watchdogReceivers.remove(rcvr);\n+            }\n+        }\n+    }\n+\n+    private void startWatchdog() {\n+        if (this.watchdogTriggerSeconds > EventHubClientOptions.SILENT_OFF) {\n+            TRACE_LOGGER.info(\"Watchdog scheduling first run\");\n+            this.watchdogFuture = this.executor.schedule(new WatchDog(), this.watchdogScanSeconds, TimeUnit.SECONDS);\n+        } else {\n+            TRACE_LOGGER.info(\"Watchdog is OFF\");\n+        }\n+    }\n+\n+    private class WatchDog implements Runnable {\n+        @Override\n+        public void run() {\n+            TRACE_LOGGER.debug(\"Watchdog run\");\n+            if (MessagingFactory.this.getIsClosingOrClosed()) {\n+                return;\n+            }\n+            if (MessagingFactory.this.watchdogTriggerSeconds <= EventHubClientOptions.SILENT_OFF) {\n+                TRACE_LOGGER.warn(\"Watchdog should not run when trigger time is \" + MessagingFactory.this.watchdogTriggerSeconds + \" -- stopping\");\n+                return;\n+            }\n+\n+            LinkedList<MessageReceiver> copiedList = null;\n+            synchronized (MessagingFactory.this.watchdogSyncObject) {\n+                copiedList = new LinkedList<MessageReceiver>(MessagingFactory.this.watchdogReceivers);\n+            }\n+            if (!copiedList.isEmpty()) {\n+                boolean anyReceiverIsAlive = false;\n+                final long longestAgoAllowable = Instant.now().getEpochSecond()\n+                        - MessagingFactory.this.watchdogTriggerSeconds;\n+\n+                for (MessageReceiver rcvr : copiedList) {\n+                    TRACE_LOGGER.debug(\"Watchdog checking receiver \" + rcvr.getClientId() + \" last: \"\n+                            + rcvr.getLastReceivedTime() + \"  allowable: \" + longestAgoAllowable);\n+                    if (!rcvr.getIsClosingOrClosed() && (rcvr.getLastReceivedTime() >= longestAgoAllowable)) {\n+                        anyReceiverIsAlive = true;\n+                        // Found one live receiver, no need to check the rest.\n+                        break;\n+                    }\n+                }\n+\n+                if (!anyReceiverIsAlive && !MessagingFactory.this.getIsClosingOrClosed()) {\n+                    TRACE_LOGGER.warn(\"Watchdog forcing connection closed\");\n+                    ErrorCondition suspect = new ErrorCondition(ClientConstants.WATCHDOG_ERROR,\n+                            \"receiver watchdog has fired, all receivers silent\");\n+                    MessagingFactory.this.watchdogCleanupDone = false;\n+                    MessagingFactory.this.connection.setCondition(suspect);\n+                    MessagingFactory.this.connection.close();\n+                    // If the remote host is still responding at the TCP level, then the socket will\n+                    // close normally and cleanup/recreation will happen automatically. However, if it\n+                    // isn't, then we must call onConnectionError here in order to force cleanup and\n+                    // recreation.\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException e) {\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0ODYxOQ==", "bodyText": "A single-threaded executor will not perform adequately for the scenarios that this watchdog is intended for. Anyone who should be using this feature will have a real thread pool. If anyone else is fooling around with the watchdog without consulting us, the worst that can happen is five-second pauses.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r427648619", "createdAt": "2020-05-19T23:03:57Z", "author": {"login": "JamesBirdsall"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/impl/MessagingFactory.java", "diffHunk": "@@ -248,6 +283,100 @@ public void run() {\n         return messagingFactory.open;\n     }\n \n+    public void registerForWatchdog(final MessageReceiver rcvr) {\n+        if (this.watchdogTriggerSeconds > EventHubClientOptions.SILENT_OFF) {\n+            TRACE_LOGGER.info(\"Registering for watchdog: \" + rcvr.getClientId());\n+            synchronized (this.watchdogSyncObject) {\n+                this.watchdogReceivers.add(rcvr);\n+            }\n+        }\n+        // else ignore registration if watchdog is off\n+    }\n+\n+    public void unregisterForWatchdog(final MessageReceiver rcvr) {\n+        if (this.watchdogTriggerSeconds > EventHubClientOptions.SILENT_OFF) {\n+            TRACE_LOGGER.info(\"Unregistering for watchdog: \" + rcvr.getClientId());\n+            synchronized (this.watchdogSyncObject) {\n+                this.watchdogReceivers.remove(rcvr);\n+            }\n+        }\n+    }\n+\n+    private void startWatchdog() {\n+        if (this.watchdogTriggerSeconds > EventHubClientOptions.SILENT_OFF) {\n+            TRACE_LOGGER.info(\"Watchdog scheduling first run\");\n+            this.watchdogFuture = this.executor.schedule(new WatchDog(), this.watchdogScanSeconds, TimeUnit.SECONDS);\n+        } else {\n+            TRACE_LOGGER.info(\"Watchdog is OFF\");\n+        }\n+    }\n+\n+    private class WatchDog implements Runnable {\n+        @Override\n+        public void run() {\n+            TRACE_LOGGER.debug(\"Watchdog run\");\n+            if (MessagingFactory.this.getIsClosingOrClosed()) {\n+                return;\n+            }\n+            if (MessagingFactory.this.watchdogTriggerSeconds <= EventHubClientOptions.SILENT_OFF) {\n+                TRACE_LOGGER.warn(\"Watchdog should not run when trigger time is \" + MessagingFactory.this.watchdogTriggerSeconds + \" -- stopping\");\n+                return;\n+            }\n+\n+            LinkedList<MessageReceiver> copiedList = null;\n+            synchronized (MessagingFactory.this.watchdogSyncObject) {\n+                copiedList = new LinkedList<MessageReceiver>(MessagingFactory.this.watchdogReceivers);\n+            }\n+            if (!copiedList.isEmpty()) {\n+                boolean anyReceiverIsAlive = false;\n+                final long longestAgoAllowable = Instant.now().getEpochSecond()\n+                        - MessagingFactory.this.watchdogTriggerSeconds;\n+\n+                for (MessageReceiver rcvr : copiedList) {\n+                    TRACE_LOGGER.debug(\"Watchdog checking receiver \" + rcvr.getClientId() + \" last: \"\n+                            + rcvr.getLastReceivedTime() + \"  allowable: \" + longestAgoAllowable);\n+                    if (!rcvr.getIsClosingOrClosed() && (rcvr.getLastReceivedTime() >= longestAgoAllowable)) {\n+                        anyReceiverIsAlive = true;\n+                        // Found one live receiver, no need to check the rest.\n+                        break;\n+                    }\n+                }\n+\n+                if (!anyReceiverIsAlive && !MessagingFactory.this.getIsClosingOrClosed()) {\n+                    TRACE_LOGGER.warn(\"Watchdog forcing connection closed\");\n+                    ErrorCondition suspect = new ErrorCondition(ClientConstants.WATCHDOG_ERROR,\n+                            \"receiver watchdog has fired, all receivers silent\");\n+                    MessagingFactory.this.watchdogCleanupDone = false;\n+                    MessagingFactory.this.connection.setCondition(suspect);\n+                    MessagingFactory.this.connection.close();\n+                    // If the remote host is still responding at the TCP level, then the socket will\n+                    // close normally and cleanup/recreation will happen automatically. However, if it\n+                    // isn't, then we must call onConnectionError here in order to force cleanup and\n+                    // recreation.\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException e) {\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2NDM5Ng=="}, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODEzODYwOnYy", "diffSide": "RIGHT", "path": "sdk/eventhubs/microsoft-azure-eventhubs-eph/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjowMzowMFrOGVjWmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMjozMjoxMlrOGYgHbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MjUwNA==", "bodyText": "Jim has a script that updates all the version numbers so they are fixed in any other locations where it is used. If you open this file and update to 3.2.0 from -beta.1:\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/eng/versioning/version_data.txt#L27-L29\nthen run:\npython.exe .\\eng\\versioning\\update_versions.py --update-type library --build-type data --skip-readme", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r425252504", "createdAt": "2020-05-14T16:03:00Z", "author": {"login": "conniey"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs-eph/pom.xml", "diffHunk": "@@ -14,7 +14,7 @@\n   <modelVersion>4.0.0</modelVersion>\n   <groupId>com.microsoft.azure</groupId>\n   <artifactId>azure-eventhubs-eph</artifactId>\n-  <version>3.2.0-beta.1</version> <!-- {x-version-update;com.microsoft.azure:azure-eventhubs-eph;current} -->\n+  <version>3.2.0</version> <!-- {x-version-update;com.microsoft.azure:azure-eventhubs-eph;current} -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM0MTE0Mg==", "bodyText": "Done!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r428341142", "createdAt": "2020-05-20T22:21:54Z", "author": {"login": "JamesBirdsall"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs-eph/pom.xml", "diffHunk": "@@ -14,7 +14,7 @@\n   <modelVersion>4.0.0</modelVersion>\n   <groupId>com.microsoft.azure</groupId>\n   <artifactId>azure-eventhubs-eph</artifactId>\n-  <version>3.2.0-beta.1</version> <!-- {x-version-update;com.microsoft.azure:azure-eventhubs-eph;current} -->\n+  <version>3.2.0</version> <!-- {x-version-update;com.microsoft.azure:azure-eventhubs-eph;current} -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MjUwNA=="}, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM0NTE5OQ==", "bodyText": "Thank you @conniey for pointing it out and @JamesBirdsall for using it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10197#discussion_r428345199", "createdAt": "2020-05-20T22:32:12Z", "author": {"login": "JimSuplizio"}, "path": "sdk/eventhubs/microsoft-azure-eventhubs-eph/pom.xml", "diffHunk": "@@ -14,7 +14,7 @@\n   <modelVersion>4.0.0</modelVersion>\n   <groupId>com.microsoft.azure</groupId>\n   <artifactId>azure-eventhubs-eph</artifactId>\n-  <version>3.2.0-beta.1</version> <!-- {x-version-update;com.microsoft.azure:azure-eventhubs-eph;current} -->\n+  <version>3.2.0</version> <!-- {x-version-update;com.microsoft.azure:azure-eventhubs-eph;current} -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MjUwNA=="}, "originalCommit": {"oid": "38af4b749897fc59dba0eb063d526936f0a6199d"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1892, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}