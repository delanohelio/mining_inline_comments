{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MzM4MzQx", "number": 10382, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozODowMlrODz9BCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTowNDo1N1rOD5KhgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODAzNjU4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/BlobFlatListSegment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozODowMlrOGIqg8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo1Nzo0MFrOGJdYRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODM1Mw==", "bodyText": "Need to consider if this is a breaking change and possibly revert", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411738353", "createdAt": "2020-04-20T22:38:02Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/BlobFlatListSegment.java", "diffHunk": "@@ -21,14 +21,14 @@\n      * The blobItems property.\n      */\n     @JsonProperty(\"Blob\")\n-    private List<BlobItem> blobItems = new ArrayList<>();\n+    private List<BlobItemInternal> blobItems = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MTcxOQ==", "bodyText": "It is not because we process this type internally and convert the elements into a PagedFlux. Even byPage on the paged flux doesn't use this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412571719", "createdAt": "2020-04-21T23:57:40Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/BlobFlatListSegment.java", "diffHunk": "@@ -21,14 +21,14 @@\n      * The blobItems property.\n      */\n     @JsonProperty(\"Blob\")\n-    private List<BlobItem> blobItems = new ArrayList<>();\n+    private List<BlobItemInternal> blobItems = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODM1Mw=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODAzNzc4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/BlobHierarchyListSegment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozODoyN1rOGIqhmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo1Nzo1NlrOGJdYow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODUyMw==", "bodyText": "Need to consider if this is a breaking change and possibly revert", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411738523", "createdAt": "2020-04-20T22:38:27Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/BlobHierarchyListSegment.java", "diffHunk": "@@ -57,7 +57,7 @@ public BlobHierarchyListSegment setBlobPrefixes(List<BlobPrefix> blobPrefixes) {\n      *\n      * @return the blobItems value.\n      */\n-    public List<BlobItem> getBlobItems() {\n+    public List<BlobItemInternal> getBlobItems() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MTgxMQ==", "bodyText": "See comment on FlatListSegment.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412571811", "createdAt": "2020-04-21T23:57:56Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/BlobHierarchyListSegment.java", "diffHunk": "@@ -57,7 +57,7 @@ public BlobHierarchyListSegment setBlobPrefixes(List<BlobPrefix> blobPrefixes) {\n      *\n      * @return the blobItems value.\n      */\n-    public List<BlobItem> getBlobItems() {\n+    public List<BlobItemInternal> getBlobItems() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODUyMw=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA0MTQyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozOTozOFrOGIqjqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozOTozOFrOGIqjqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczOTA0OQ==", "bodyText": "Formatting?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411739049", "createdAt": "2020-04-20T22:39:38Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1226,8 +1317,9 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n                     hd.getCopyCompletionTime(), hd.getCopyStatusDescription(), hd.isServerEncrypted(),\n                     hd.isIncrementalCopy(), hd.getDestinationSnapshot(), AccessTier.fromString(hd.getAccessTier()),\n                     hd.isAccessTierInferred(), ArchiveStatus.fromString(hd.getArchiveStatus()),\n-                    hd.getEncryptionKeySha256(), hd.getAccessTierChangeTime(), hd.getMetadata(),\n-                    hd.getBlobCommittedBlockCount(), hd.getVersionId(), hd.isCurrentVersion());\n+                    hd.getEncryptionKeySha256(), hd.getEncryptionScope(), hd.getAccessTierChangeTime(),\n+                        hd.getMetadata(), hd.getBlobCommittedBlockCount(), hd.getVersionId(), hd.isCurrentVersion(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA1NjgwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo0NDoyMlrOGIqr2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo0NDoyMlrOGIqr2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MTE0NQ==", "bodyText": "if possible please use Collections.emptyMap(). It's immutable singleton so less allocation.\n(Same could be applied to metadata I guess.)\n(And other places we do that for metadata and tags).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411741145", "createdAt": "2020-04-20T22:44:22Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobAsyncClient.java", "diffHunk": "@@ -241,11 +241,55 @@\n     public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n         ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n         AccessTier tier, BlobRequestConditions requestConditions) {\n+        return this.uploadWithResponse(data, parallelTransferOptions, headers, metadata, null, tier, requestConditions);\n+    }\n+\n+    /**\n+     * Creates a new block blob, or updates the content of an existing block blob. Updating an existing block blob\n+     * overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of\n+     * the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use {@link\n+     * BlockBlobAsyncClient#stageBlock(String, Flux, long) stageBlock} and\n+     * {@link BlockBlobAsyncClient#commitBlockList(List)}, which this method uses internally. For more information,\n+     * see the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block\">Azure\n+     * Docs for Put Block</a> and the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block-list\">Azure\n+     * Docs for Put Block List</a>.\n+     * <p>\n+     * The data passed need not support multiple subscriptions/be replayable as is required in other upload methods when\n+     * retries are enabled, and the length of the data need not be known in advance. Therefore, this method should\n+     * support uploading any arbitrary data source, including network streams. This behavior is possible because this\n+     * method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while\n+     * this method may offer additional convenience, it will not be as performant as other options, which should be\n+     * preferred when possible.\n+     * <p>\n+     * Typically, the greater the number of buffers used, the greater the possible parallelism when transferring the\n+     * data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The\n+     * trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs\n+     * for a given scenario.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.cryptography.EncryptedBlobAsyncClient.uploadWithResponse#Flux-ParallelTransferOptions-BlobHttpHeaders-Map-AccessTier-BlobRequestConditions}\n+     *\n+     * @param data The data to write to the blob. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link BlobHttpHeaders}\n+     * @param metadata Metadata to associate with the blob.\n+     * @param tags Tags to associate with the destination blob.\n+     * @param tier {@link AccessTier} for the destination blob.\n+     * @param requestConditions {@link BlobRequestConditions}\n+     * @return A reactive response containing the information of the uploaded block blob.\n+     */\n+    public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n+        ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n+        Map<String, String> tags, AccessTier tier, BlobRequestConditions requestConditions) {\n         try {\n             final Map<String, String> metadataFinal = metadata == null ? new HashMap<>() : metadata;\n+            final Map<String, String> tagsFinal = tags == null ? new HashMap<>() : tags;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA3MTUxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo0OToxMlrOGIq0Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo0OToxMlrOGIq0Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MzI3NA==", "bodyText": "Collections.emptyList() would be better here (and other similar places)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411743274", "createdAt": "2020-04-20T22:49:12Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerAsyncClient.java", "diffHunk": "@@ -778,7 +779,9 @@ public String getEncryptionScope() {\n                 .map(response -> {\n                     List<BlobItem> value = response.getValue().getSegment() == null\n                         ? new ArrayList<>(0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA3Mzc3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1MDowMVrOGIq1ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoxNjo1MFrOGIs9TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MzU4OQ==", "bodyText": "Yes.\nThis could have only two overloads findBlobsByTags(query) and findBlobsByTags(query,options)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411743589", "createdAt": "2020-04-20T22:50:01Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobAsyncServiceClient.filterBlobs#String-Integer}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage) {\n+        try {\n+            return findBlobsByTags(query, maxResultsPerPage, null);\n+        } catch (RuntimeException ex) {\n+            return pagedFluxError(logger, ex);\n+        }\n+    }\n+\n+    // TODO: options instead of maxResults?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3ODM4MA==", "bodyText": "Yeah I like the idea of making it an Options since that matches what we do with listing in general", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411778380", "createdAt": "2020-04-21T00:16:50Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobAsyncServiceClient.filterBlobs#String-Integer}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage) {\n+        try {\n+            return findBlobsByTags(query, maxResultsPerPage, null);\n+        } catch (RuntimeException ex) {\n+            return pagedFluxError(logger, ex);\n+        }\n+    }\n+\n+    // TODO: options instead of maxResults?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MzU4OQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA4MTc0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceVersion.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1Mjo1NFrOGIq56Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1Mjo1NFrOGIq56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NDc0NQ==", "bodyText": "If you're doing that please remove TODO.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411744745", "createdAt": "2020-04-20T22:52:54Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceVersion.java", "diffHunk": "@@ -11,7 +11,7 @@\n public enum BlobServiceVersion implements ServiceVersion {\n     V2019_02_02(\"2019-02-02\"),\n     V2019_07_07(\"2019-07-07\"),\n-    V2019_12_12(\"2019-10-10\"); // TODO (gapra) : Change this to 12-12 once stage gets to 12-12\n+    V2019_12_12(\"2019-12-12\"); // TODO (gapra) : Change this to 12-12 once stage gets to 12-12", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA4MzIyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1MzoxOVrOGIq6sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDowMjozNVrOGQQEhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NDk0NA==", "bodyText": "Do we want to introduce option bag here as well ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411744944", "createdAt": "2020-04-20T22:53:19Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceClient.java", "diffHunk": "@@ -193,6 +194,40 @@ public String getAccountUrl() {\n         return new PagedIterable<>(blobServiceAsyncClient.listBlobContainersWithOptionalTimeout(options, timeout));\n     }\n \n+    /**\n+     * Returns a lazy loaded list of blobs in this account whose tags match the query expression. The returned\n+     * {@link PagedIterable} can be consumed while new items are automatically retrieved as needed. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return The list of blobs.\n+     */\n+    public PagedIterable<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a lazy loaded list of blobs in this account whose tags match the query expression. The returned\n+     * {@link PagedIterable} can be consumed while new items are automatically retrieved as needed. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceClient.filterBlobs#String-Integer-Duration}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @param timeout An optional timeout value beyond which a {@link RuntimeException} will be raised.\n+     * @return The list of blobs.\n+     */\n+    public PagedIterable<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage, Duration timeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1NDA2Nw==", "bodyText": "Waiting on confirmation from Jonathan for this one.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413154067", "createdAt": "2020-04-22T16:58:16Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceClient.java", "diffHunk": "@@ -193,6 +194,40 @@ public String getAccountUrl() {\n         return new PagedIterable<>(blobServiceAsyncClient.listBlobContainersWithOptionalTimeout(options, timeout));\n     }\n \n+    /**\n+     * Returns a lazy loaded list of blobs in this account whose tags match the query expression. The returned\n+     * {@link PagedIterable} can be consumed while new items are automatically retrieved as needed. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return The list of blobs.\n+     */\n+    public PagedIterable<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a lazy loaded list of blobs in this account whose tags match the query expression. The returned\n+     * {@link PagedIterable} can be consumed while new items are automatically retrieved as needed. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceClient.filterBlobs#String-Integer-Duration}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @param timeout An optional timeout value beyond which a {@link RuntimeException} will be raised.\n+     * @return The list of blobs.\n+     */\n+    public PagedIterable<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage, Duration timeout) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NDk0NA=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY5MzcwMQ==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r419693701", "createdAt": "2020-05-04T20:02:35Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceClient.java", "diffHunk": "@@ -193,6 +194,40 @@ public String getAccountUrl() {\n         return new PagedIterable<>(blobServiceAsyncClient.listBlobContainersWithOptionalTimeout(options, timeout));\n     }\n \n+    /**\n+     * Returns a lazy loaded list of blobs in this account whose tags match the query expression. The returned\n+     * {@link PagedIterable} can be consumed while new items are automatically retrieved as needed. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return The list of blobs.\n+     */\n+    public PagedIterable<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a lazy loaded list of blobs in this account whose tags match the query expression. The returned\n+     * {@link PagedIterable} can be consumed while new items are automatically retrieved as needed. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceClient.filterBlobs#String-Integer-Duration}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @param timeout An optional timeout value beyond which a {@link RuntimeException} will be raised.\n+     * @return The list of blobs.\n+     */\n+    public PagedIterable<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage, Duration timeout) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NDk0NA=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEwMDI4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1OTowMFrOGIrEHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzowNTowNlrOGKBOmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzM1OQ==", "bodyText": "Should this work with versionID? It's already in stg73 branch.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411747359", "createdAt": "2020-04-20T22:59:00Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1348,6 +1440,108 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n             .map(response -> new SimpleResponse<>(response, null));\n     }\n \n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Map<String, String>> getTags() {\n+        return this.getTagsWithResponse().map(Response::getValue);\n+    }\n+\n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Response<Map<String, String>>> getTagsWithResponse() {\n+        try {\n+            return withContext(this::getTagsWithResponse);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Map<String, String>>> getTagsWithResponse(Context context) {\n+        return this.azureBlobStorage.blobs().getTagsWithRestResponseAsync(null, null, null, null, snapshot,\n+            null /* versionId */, context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDUzNA==", "bodyText": "What are all the null params in this? are they valid to put on the max overload?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412314534", "createdAt": "2020-04-21T16:40:11Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1348,6 +1440,108 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n             .map(response -> new SimpleResponse<>(response, null));\n     }\n \n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Map<String, String>> getTags() {\n+        return this.getTagsWithResponse().map(Response::getValue);\n+    }\n+\n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Response<Map<String, String>>> getTagsWithResponse() {\n+        try {\n+            return withContext(this::getTagsWithResponse);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Map<String, String>>> getTagsWithResponse(Context context) {\n+        return this.azureBlobStorage.blobs().getTagsWithRestResponseAsync(null, null, null, null, snapshot,\n+            null /* versionId */, context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzM1OQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1OTA2Ng==", "bodyText": "Container name, blob name, request id, timeout. I'm pretty sure we set those to null on all calls to the protocol layer", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413159066", "createdAt": "2020-04-22T17:05:06Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1348,6 +1440,108 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n             .map(response -> new SimpleResponse<>(response, null));\n     }\n \n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Map<String, String>> getTags() {\n+        return this.getTagsWithResponse().map(Response::getValue);\n+    }\n+\n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Response<Map<String, String>>> getTagsWithResponse() {\n+        try {\n+            return withContext(this::getTagsWithResponse);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Map<String, String>>> getTagsWithResponse(Context context) {\n+        return this.azureBlobStorage.blobs().getTagsWithRestResponseAsync(null, null, null, null, snapshot,\n+            null /* versionId */, context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzM1OQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEwMTU2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1OToyM1rOGIrEzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzo0MDo1M1rOGKC0WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzUzMw==", "bodyText": "same here. however I'm not sure if you can update tags on version. AFAIK version should be immutable and be result of write operations.\nDoes updating/setting tags bump blob version? (updating metadata does that)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411747533", "createdAt": "2020-04-20T22:59:23Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1348,6 +1440,108 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n             .map(response -> new SimpleResponse<>(response, null));\n     }\n \n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Map<String, String>> getTags() {\n+        return this.getTagsWithResponse().map(Response::getValue);\n+    }\n+\n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Response<Map<String, String>>> getTagsWithResponse() {\n+        try {\n+            return withContext(this::getTagsWithResponse);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Map<String, String>>> getTagsWithResponse(Context context) {\n+        return this.azureBlobStorage.blobs().getTagsWithRestResponseAsync(null, null, null, null, snapshot,\n+            null /* versionId */, context)\n+            .map(response -> {\n+                Map<String, String> tags = new HashMap<>();\n+                for(BlobTag tag : response.getValue().getBlobTagSet()) {\n+                    tags.put(tag.getKey(), tag.getValue());\n+                }\n+                return new SimpleResponse<>(response, tags);\n+            });\n+    }\n+\n+    /**\n+     * Sets user defined tags. The specified tags in this method will replace existing tags. If old values must be\n+     * preserved, they must be downloaded and included in the call to this method.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.setTags#Map}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"ADD DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @param tags Tags to associate with the blob.\n+     * @return A reactive response signaling completion.\n+     */\n+    public Mono<Void> setTags(Map<String, String> tags) {\n+        return this.setTagsWithResponse(tags).flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Sets user defined tags. The specified tags in this method will replace existing tags. If old values must be\n+     * preserved, they must be downloaded and included in the call to this method.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.setTagsWithResponse#Map}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"ADD DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @param tags Tags to associate with the blob.\n+     * @return A reactive response signaling completion.\n+     */\n+    public Mono<Response<Void>> setTagsWithResponse(Map<String, String> tags) {\n+        try {\n+            return withContext(context -> setTagsWithResponse(tags, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Void>> setTagsWithResponse(Map<String, String> tags, Context context) {\n+        List<BlobTag> tagList = null;\n+        if (tags != null) {\n+            tagList = new ArrayList<>();\n+            for (String tag : tags.keySet()) {\n+                tagList.add(new BlobTag().setKey(tag).setValue(tags.get(tag)));\n+            }\n+        }\n+        BlobTags t = new BlobTags().setBlobTagSet(tagList);\n+        return this.azureBlobStorage.blobs().setTagsWithRestResponseAsync(null, null, null, snapshot,\n+            null /* versionId */, null, null, null, t, context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDcwOQ==", "bodyText": "The spec says you can set tags on a version. It's unclear if it bumps the version number. It is, however, not allowed on a snapshot.\nDo you think we should throw if the client has a snapshot value so that customers don't think we're setting tags on their snapshot when we're really just ignoring it? For the record, we don't throw on setMetadata. We just don't pass the snapshot value.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412564709", "createdAt": "2020-04-21T23:39:11Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1348,6 +1440,108 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n             .map(response -> new SimpleResponse<>(response, null));\n     }\n \n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Map<String, String>> getTags() {\n+        return this.getTagsWithResponse().map(Response::getValue);\n+    }\n+\n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Response<Map<String, String>>> getTagsWithResponse() {\n+        try {\n+            return withContext(this::getTagsWithResponse);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Map<String, String>>> getTagsWithResponse(Context context) {\n+        return this.azureBlobStorage.blobs().getTagsWithRestResponseAsync(null, null, null, null, snapshot,\n+            null /* versionId */, context)\n+            .map(response -> {\n+                Map<String, String> tags = new HashMap<>();\n+                for(BlobTag tag : response.getValue().getBlobTagSet()) {\n+                    tags.put(tag.getKey(), tag.getValue());\n+                }\n+                return new SimpleResponse<>(response, tags);\n+            });\n+    }\n+\n+    /**\n+     * Sets user defined tags. The specified tags in this method will replace existing tags. If old values must be\n+     * preserved, they must be downloaded and included in the call to this method.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.setTags#Map}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"ADD DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @param tags Tags to associate with the blob.\n+     * @return A reactive response signaling completion.\n+     */\n+    public Mono<Void> setTags(Map<String, String> tags) {\n+        return this.setTagsWithResponse(tags).flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Sets user defined tags. The specified tags in this method will replace existing tags. If old values must be\n+     * preserved, they must be downloaded and included in the call to this method.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.setTagsWithResponse#Map}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"ADD DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @param tags Tags to associate with the blob.\n+     * @return A reactive response signaling completion.\n+     */\n+    public Mono<Response<Void>> setTagsWithResponse(Map<String, String> tags) {\n+        try {\n+            return withContext(context -> setTagsWithResponse(tags, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Void>> setTagsWithResponse(Map<String, String> tags, Context context) {\n+        List<BlobTag> tagList = null;\n+        if (tags != null) {\n+            tagList = new ArrayList<>();\n+            for (String tag : tags.keySet()) {\n+                tagList.add(new BlobTag().setKey(tag).setValue(tags.get(tag)));\n+            }\n+        }\n+        BlobTags t = new BlobTags().setBlobTagSet(tagList);\n+        return this.azureBlobStorage.blobs().setTagsWithRestResponseAsync(null, null, null, snapshot,\n+            null /* versionId */, null, null, null, t, context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzUzMw=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4NTExMw==", "bodyText": "then we should be passing versionId here (should be available by now).\nI think we can let service do the validation for snapshot (in case they change their mind).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413185113", "createdAt": "2020-04-22T17:40:53Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobAsyncClientBase.java", "diffHunk": "@@ -1348,6 +1440,108 @@ private void downloadToFileCleanup(AsynchronousFileChannel channel, String fileP\n             .map(response -> new SimpleResponse<>(response, null));\n     }\n \n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Map<String, String>> getTags() {\n+        return this.getTagsWithResponse().map(Response::getValue);\n+    }\n+\n+    /**\n+     * Returns the blob's tags.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"GET DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @return A reactive response containing the blob's tags.\n+     */\n+    public Mono<Response<Map<String, String>>> getTagsWithResponse() {\n+        try {\n+            return withContext(this::getTagsWithResponse);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Map<String, String>>> getTagsWithResponse(Context context) {\n+        return this.azureBlobStorage.blobs().getTagsWithRestResponseAsync(null, null, null, null, snapshot,\n+            null /* versionId */, context)\n+            .map(response -> {\n+                Map<String, String> tags = new HashMap<>();\n+                for(BlobTag tag : response.getValue().getBlobTagSet()) {\n+                    tags.put(tag.getKey(), tag.getValue());\n+                }\n+                return new SimpleResponse<>(response, tags);\n+            });\n+    }\n+\n+    /**\n+     * Sets user defined tags. The specified tags in this method will replace existing tags. If old values must be\n+     * preserved, they must be downloaded and included in the call to this method.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.setTags#Map}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"ADD DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @param tags Tags to associate with the blob.\n+     * @return A reactive response signaling completion.\n+     */\n+    public Mono<Void> setTags(Map<String, String> tags) {\n+        return this.setTagsWithResponse(tags).flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Sets user defined tags. The specified tags in this method will replace existing tags. If old values must be\n+     * preserved, they must be downloaded and included in the call to this method.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.BlobAsyncClientBase.setTagsWithResponse#Map}\n+     *\n+     * <p>For more information, see the\n+     * <a href=\"ADD DOCS LINK\">Azure Docs</a></p>\n+     *\n+     * @param tags Tags to associate with the blob.\n+     * @return A reactive response signaling completion.\n+     */\n+    public Mono<Response<Void>> setTagsWithResponse(Map<String, String> tags) {\n+        try {\n+            return withContext(context -> setTagsWithResponse(tags, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Void>> setTagsWithResponse(Map<String, String> tags, Context context) {\n+        List<BlobTag> tagList = null;\n+        if (tags != null) {\n+            tagList = new ArrayList<>();\n+            for (String tag : tags.keySet()) {\n+                tagList.add(new BlobTag().setKey(tag).setValue(tags.get(tag)));\n+            }\n+        }\n+        BlobTags t = new BlobTags().setBlobTagSet(tagList);\n+        return this.azureBlobStorage.blobs().setTagsWithRestResponseAsync(null, null, null, snapshot,\n+            null /* versionId */, null, null, null, t, context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzUzMw=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODExNDk4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/samples/java/com/azure/storage/blob/BlobClientJavaDocCodeSnippets.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowNDoxNFrOGIrMcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowNDoxNFrOGIrMcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0OTQ4OA==", "bodyText": "Please use long as block size and don't use deprecated constructor below.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411749488", "createdAt": "2020-04-20T23:04:14Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/samples/java/com/azure/storage/blob/BlobClientJavaDocCodeSnippets.java", "diffHunk": "@@ -429,4 +429,34 @@ public void uploadFromFile2() throws IOException {\n         }\n         // END: com.azure.storage.blob.BlobClient.uploadFromFile#String-ParallelTransferOptions-BlobHttpHeaders-Map-AccessTier-BlobRequestConditions-Duration\n     }\n+\n+    /**\n+     * Code snippet for {@link BlobClient#uploadFromFile(String, ParallelTransferOptions, BlobHttpHeaders, Map, Map, AccessTier, BlobRequestConditions, Duration)}\n+     *\n+     * @throws IOException If an I/O error occurs\n+     */\n+    public void uploadFromFile3() throws IOException {\n+        // BEGIN: com.azure.storage.blob.BlobClient.uploadFromFile#String-ParallelTransferOptions-BlobHttpHeaders-Map-Map-AccessTier-BlobRequestConditions-Duration\n+        BlobHttpHeaders headers = new BlobHttpHeaders()\n+            .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n+            .setContentLanguage(\"en-US\")\n+            .setContentType(\"binary\");\n+\n+        Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n+        Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n+        BlobRequestConditions requestConditions = new BlobRequestConditions()\n+            .setLeaseId(leaseId)\n+            .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n+        Integer blockSize = 100 * 1024 * 1024; // 100 MB;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODMxMDIxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoxMzozMlrOGIs43g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo0MTo1OVrOGJdBMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NzI0Ng==", "bodyText": "Is this method empty now?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411777246", "createdAt": "2020-04-21T00:13:32Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobClient.java", "diffHunk": "@@ -270,8 +295,34 @@ public void uploadFromFile(String filePath, boolean overwrite) {\n     public void uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions,\n         BlobHttpHeaders headers, Map<String, String> metadata, AccessTier tier, BlobRequestConditions requestConditions,\n         Duration timeout) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NTgwOA==", "bodyText": "Yikes good catch.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412565808", "createdAt": "2020-04-21T23:41:59Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobClient.java", "diffHunk": "@@ -270,8 +295,34 @@ public void uploadFromFile(String filePath, boolean overwrite) {\n     public void uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions,\n         BlobHttpHeaders headers, Map<String, String> metadata, AccessTier tier, BlobRequestConditions requestConditions,\n         Duration timeout) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NzI0Ng=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODMxNjMzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoxNjowNVrOGIs8Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoxNjowNVrOGIs8Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3ODExMA==", "bodyText": "rename code snippet", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411778110", "createdAt": "2020-04-21T00:16:05Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODMyMTQ5OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoxODoxM1rOGIs_AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo0NDozOVrOGJdFDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3ODgxNg==", "bodyText": "could we return like BlobItem? What are the properties we want to expose on this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411778816", "createdAt": "2020-04-21T00:18:13Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobAsyncServiceClient.filterBlobs#String-Integer}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage) {\n+        try {\n+            return findBlobsByTags(query, maxResultsPerPage, null);\n+        } catch (RuntimeException ex) {\n+            return pagedFluxError(logger, ex);\n+        }\n+    }\n+\n+    // TODO: options instead of maxResults?\n+    // TODO: Return type?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2Njc5OA==", "bodyText": "Unfortunately the results here only come back with container name, blob name, and tag key/value. Because BlobItem has so many properties, it seemed weird to return it when most of them would be null, also there's no place for the tag key/value to go. But it's also kinda lame that we have a whole different list result type for this.\nI don't really think there's a good alternative, but I left it open in case other people could think of one and because I can't", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412566798", "createdAt": "2020-04-21T23:44:39Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobAsyncServiceClient.filterBlobs#String-Integer}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage) {\n+        try {\n+            return findBlobsByTags(query, maxResultsPerPage, null);\n+        } catch (RuntimeException ex) {\n+            return pagedFluxError(logger, ex);\n+        }\n+    }\n+\n+    // TODO: options instead of maxResults?\n+    // TODO: Return type?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3ODgxNg=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODMzNjM0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyNDoyOFrOGItHAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo1MDoxNlrOGJdNNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4MDg2NQ==", "bodyText": "How do the tags get populated in swagger? Is it similar to metadata? Or completely different. Why do we need to do this set thing?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411780865", "createdAt": "2020-04-21T00:24:28Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItem.java", "diffHunk": "@@ -15,6 +18,35 @@\n @JacksonXmlRootElement(localName = \"Blob\")\n @Fluent\n public final class BlobItem {\n+\n+\n+    public BlobItem() {\n+\n+    }\n+\n+    /**\n+     * Initializes a new blob item.\n+     *\n+     * @param blobItemInternal The internal structure from which to pull state.\n+     */\n+    public BlobItem(BlobItemInternal blobItemInternal) {\n+        this.name = blobItemInternal.getName();\n+        this.deleted = blobItemInternal.isDeleted();\n+        this.snapshot = blobItemInternal.getSnapshot();\n+        this.properties = blobItemInternal.getProperties();\n+        this.metadata = blobItemInternal.getMetadata();\n+        this.versionId = blobItemInternal.getVersionId();\n+        this.isCurrentVersion = blobItemInternal.isCurrentVersion();\n+        this.isPrefix = blobItemInternal.isPrefix();\n+\n+        this.tags = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2ODg4NQ==", "bodyText": "Metadata looks like this:\n<Metadata>     \n        <Name>value</Name>  \n</Metadata>  \n\nTags looks like this:\n<Tags> \n    <TagSet> \n        <Tag> \n            <Key>key1</Key> \n            <Value>val1</Value> \n        </Tag> \n        <Tag> \n            <Key>key2</Key> \n            <Value>val2</Value> \n        </Tag> \n    </TagSet> \n</Tags> \n\nSo unfortunately there's a lot more hierarchy in the tags results, which gets generates as this gross object model that you need to call like Tags.getTagSet.getTag(i).getValue as opposed to being able to index into a map.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412568885", "createdAt": "2020-04-21T23:50:16Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItem.java", "diffHunk": "@@ -15,6 +18,35 @@\n @JacksonXmlRootElement(localName = \"Blob\")\n @Fluent\n public final class BlobItem {\n+\n+\n+    public BlobItem() {\n+\n+    }\n+\n+    /**\n+     * Initializes a new blob item.\n+     *\n+     * @param blobItemInternal The internal structure from which to pull state.\n+     */\n+    public BlobItem(BlobItemInternal blobItemInternal) {\n+        this.name = blobItemInternal.getName();\n+        this.deleted = blobItemInternal.isDeleted();\n+        this.snapshot = blobItemInternal.getSnapshot();\n+        this.properties = blobItemInternal.getProperties();\n+        this.metadata = blobItemInternal.getMetadata();\n+        this.versionId = blobItemInternal.getVersionId();\n+        this.isCurrentVersion = blobItemInternal.isCurrentVersion();\n+        this.isPrefix = blobItemInternal.isPrefix();\n+\n+        this.tags = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4MDg2NQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODMzODIyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItemInternal.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyNToyMFrOGItIAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyNToyMFrOGItIAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4MTEyMw==", "bodyText": "If this is internal only, it can go in implementation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411781123", "createdAt": "2020-04-21T00:25:20Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItemInternal.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.storage.blob.models;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODM0MDk0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyNjozNVrOGItJeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyNjozNVrOGItJeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4MTQ5Nw==", "bodyText": "Do we want to consider deprecating the setters if we no longer want people to use them?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r411781497", "createdAt": "2020-04-21T00:26:35Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobItem.java", "diffHunk": "@@ -124,82 +154,91 @@ public BlobItem setSnapshot(String snapshot) {\n     }\n \n     /**\n-     * Get the versionId property: The versionId property.\n+     * Get the properties property: The properties property.\n      *\n-     * @return the versionId value.\n+     * @return the properties value.\n      */\n-    public String getVersionId() {\n-        return this.versionId;\n+    public BlobItemProperties getProperties() {\n+        return this.properties;\n     }\n \n     /**\n-     * Set the versionId property: The versionId property.\n+     * Set the properties property: The properties property.\n      *\n-     * @param versionId the versionId value to set.\n+     * @param properties the properties value to set.\n      * @return the BlobItem object itself.\n      */\n-    public BlobItem setVersionId(String versionId) {\n-        this.versionId = versionId;\n+    public BlobItem setProperties(BlobItemProperties properties) {\n+        this.properties = properties;\n         return this;\n     }\n \n     /**\n-     * Get the isCurrentVersion property: The isCurrentVersion property.\n+     * Get the metadata property: The metadata property.\n      *\n-     * @return the isCurrentVersion value.\n+     * @return the metadata value.\n      */\n-    public Boolean isCurrentVersion() {\n-        return this.isCurrentVersion;\n+    public Map<String, String> getMetadata() {\n+        return this.metadata;\n     }\n \n     /**\n-     * Set the isCurrentVersion property: The isCurrentVersion property.\n+     * Set the metadata property: The metadata property.\n      *\n-     * @param isCurrentVersion the isCurrentVersion value to set.\n+     * @param metadata the metadata value to set.\n      * @return the BlobItem object itself.\n      */\n-    public BlobItem setIsCurrentVersion(Boolean isCurrentVersion) {\n-        this.isCurrentVersion = isCurrentVersion;\n+    public BlobItem setMetadata(Map<String, String> metadata) {\n+        this.metadata = metadata;\n         return this;\n     }\n \n     /**\n-     * Get the properties property: The properties property.\n+     * Get the tags property: The tag property.\n      *\n-     * @return the properties value.\n+     * @return the metadata value.\n      */\n-    public BlobItemProperties getProperties() {\n-        return this.properties;\n+    public Map<String, String> getTags() {\n+        return this.tags;\n     }\n \n     /**\n-     * Set the properties property: The properties property.\n+     * Get the versionId property: The versionId property.\n      *\n-     * @param properties the properties value to set.\n+     * @return the versionId value.\n+     */\n+    public String getVersionId() {\n+        return this.versionId;\n+    }\n+\n+    /**\n+     * Set the versionId property: The versionId property.\n+     *\n+     * @param versionId the versionId value to set.\n      * @return the BlobItem object itself.\n      */\n-    public BlobItem setProperties(BlobItemProperties properties) {\n-        this.properties = properties;\n+    public BlobItem setVersionId(String versionId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTgxODYzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobTagSet.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjowMTo0MlrOGJMoDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjowMTo0MlrOGJMoDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NzIzMA==", "bodyText": "Is this in a public API? If not should probably go in implementation", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412297230", "createdAt": "2020-04-21T16:01:42Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobTagSet.java", "diffHunk": "@@ -0,0 +1,59 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.storage.blob.implementation.models.BlobTag;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * a collection of blob tags.\n+ */\n+@Fluent\n+public final class BlobTagSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQ0NjEyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/samples/java/com/azure/storage/blob/specialized/BlobAsyncClientBaseJavaDocCodeSnippets.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo0MDozMFrOGJbdNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzo0NjoxNFrOGKDD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0MDIxMw==", "bodyText": "do we need a snippet for the max overloads too?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r412540213", "createdAt": "2020-04-21T22:40:30Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/samples/java/com/azure/storage/blob/specialized/BlobAsyncClientBaseJavaDocCodeSnippets.java", "diffHunk": "@@ -198,6 +198,25 @@ public void setMetadataCodeSnippet() {\n         // END: com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadata#Map\n     }\n \n+    /**\n+     * Code snippets for {@link BlobAsyncClientBase#getTags()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4OTExMA==", "bodyText": "There is one on line 463. This file is just structured such that all the min overloads are up top", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413189110", "createdAt": "2020-04-22T17:46:14Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/samples/java/com/azure/storage/blob/specialized/BlobAsyncClientBaseJavaDocCodeSnippets.java", "diffHunk": "@@ -198,6 +198,25 @@ public void setMetadataCodeSnippet() {\n         // END: com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadata#Map\n     }\n \n+    /**\n+     * Code snippets for {@link BlobAsyncClientBase#getTags()}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0MDIxMw=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzI5ODkzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobAsyncClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjowMjozMVrOGJ-TeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0MzoxN1rOGKNHuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzExMTE2MQ==", "bodyText": "Would we want to reorder the arguments so tags is at the end to promote an easier upgrade path for current SDK users?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413111161", "createdAt": "2020-04-22T16:02:31Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobAsyncClient.java", "diffHunk": "@@ -241,11 +241,55 @@\n     public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n         ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n         AccessTier tier, BlobRequestConditions requestConditions) {\n+        return this.uploadWithResponse(data, parallelTransferOptions, headers, metadata, null, tier, requestConditions);\n+    }\n+\n+    /**\n+     * Creates a new block blob, or updates the content of an existing block blob. Updating an existing block blob\n+     * overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of\n+     * the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use {@link\n+     * BlockBlobAsyncClient#stageBlock(String, Flux, long) stageBlock} and\n+     * {@link BlockBlobAsyncClient#commitBlockList(List)}, which this method uses internally. For more information,\n+     * see the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block\">Azure\n+     * Docs for Put Block</a> and the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block-list\">Azure\n+     * Docs for Put Block List</a>.\n+     * <p>\n+     * The data passed need not support multiple subscriptions/be replayable as is required in other upload methods when\n+     * retries are enabled, and the length of the data need not be known in advance. Therefore, this method should\n+     * support uploading any arbitrary data source, including network streams. This behavior is possible because this\n+     * method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while\n+     * this method may offer additional convenience, it will not be as performant as other options, which should be\n+     * preferred when possible.\n+     * <p>\n+     * Typically, the greater the number of buffers used, the greater the possible parallelism when transferring the\n+     * data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The\n+     * trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs\n+     * for a given scenario.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.cryptography.EncryptedBlobAsyncClient.uploadWithResponse#Flux-ParallelTransferOptions-BlobHttpHeaders-Map-AccessTier-BlobRequestConditions}\n+     *\n+     * @param data The data to write to the blob. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link BlobHttpHeaders}\n+     * @param metadata Metadata to associate with the blob.\n+     * @param tags Tags to associate with the destination blob.\n+     * @param tier {@link AccessTier} for the destination blob.\n+     * @param requestConditions {@link BlobRequestConditions}\n+     * @return A reactive response containing the information of the uploaded block blob.\n+     */\n+    public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n+        ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n+        Map<String, String> tags, AccessTier tier, BlobRequestConditions requestConditions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5MDIyOA==", "bodyText": "I get that, but I also think I don't agree with it. I think it's cleaner to have things sort of logically/consistently grouped, and requestConditions are always at the end. And tags and metadata are conceptually similar.\nI can be persuaded to the contrary if other folks agree we should always add new parameters to the end.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413190228", "createdAt": "2020-04-22T17:47:51Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobAsyncClient.java", "diffHunk": "@@ -241,11 +241,55 @@\n     public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n         ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n         AccessTier tier, BlobRequestConditions requestConditions) {\n+        return this.uploadWithResponse(data, parallelTransferOptions, headers, metadata, null, tier, requestConditions);\n+    }\n+\n+    /**\n+     * Creates a new block blob, or updates the content of an existing block blob. Updating an existing block blob\n+     * overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of\n+     * the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use {@link\n+     * BlockBlobAsyncClient#stageBlock(String, Flux, long) stageBlock} and\n+     * {@link BlockBlobAsyncClient#commitBlockList(List)}, which this method uses internally. For more information,\n+     * see the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block\">Azure\n+     * Docs for Put Block</a> and the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block-list\">Azure\n+     * Docs for Put Block List</a>.\n+     * <p>\n+     * The data passed need not support multiple subscriptions/be replayable as is required in other upload methods when\n+     * retries are enabled, and the length of the data need not be known in advance. Therefore, this method should\n+     * support uploading any arbitrary data source, including network streams. This behavior is possible because this\n+     * method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while\n+     * this method may offer additional convenience, it will not be as performant as other options, which should be\n+     * preferred when possible.\n+     * <p>\n+     * Typically, the greater the number of buffers used, the greater the possible parallelism when transferring the\n+     * data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The\n+     * trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs\n+     * for a given scenario.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.cryptography.EncryptedBlobAsyncClient.uploadWithResponse#Flux-ParallelTransferOptions-BlobHttpHeaders-Map-AccessTier-BlobRequestConditions}\n+     *\n+     * @param data The data to write to the blob. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link BlobHttpHeaders}\n+     * @param metadata Metadata to associate with the blob.\n+     * @param tags Tags to associate with the destination blob.\n+     * @param tier {@link AccessTier} for the destination blob.\n+     * @param requestConditions {@link BlobRequestConditions}\n+     * @return A reactive response containing the information of the uploaded block blob.\n+     */\n+    public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n+        ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n+        Map<String, String> tags, AccessTier tier, BlobRequestConditions requestConditions) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzExMTE2MQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzkxNQ==", "bodyText": "I think its fine to change groupings since we didnt deprecate the old method. If we forced everyone to bump to this new overload, then I could see a case for trying to make it easier to upgrade", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413353915", "createdAt": "2020-04-22T21:43:17Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobAsyncClient.java", "diffHunk": "@@ -241,11 +241,55 @@\n     public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n         ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n         AccessTier tier, BlobRequestConditions requestConditions) {\n+        return this.uploadWithResponse(data, parallelTransferOptions, headers, metadata, null, tier, requestConditions);\n+    }\n+\n+    /**\n+     * Creates a new block blob, or updates the content of an existing block blob. Updating an existing block blob\n+     * overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of\n+     * the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use {@link\n+     * BlockBlobAsyncClient#stageBlock(String, Flux, long) stageBlock} and\n+     * {@link BlockBlobAsyncClient#commitBlockList(List)}, which this method uses internally. For more information,\n+     * see the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block\">Azure\n+     * Docs for Put Block</a> and the <a href=\"https://docs.microsoft.com/rest/api/storageservices/put-block-list\">Azure\n+     * Docs for Put Block List</a>.\n+     * <p>\n+     * The data passed need not support multiple subscriptions/be replayable as is required in other upload methods when\n+     * retries are enabled, and the length of the data need not be known in advance. Therefore, this method should\n+     * support uploading any arbitrary data source, including network streams. This behavior is possible because this\n+     * method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while\n+     * this method may offer additional convenience, it will not be as performant as other options, which should be\n+     * preferred when possible.\n+     * <p>\n+     * Typically, the greater the number of buffers used, the greater the possible parallelism when transferring the\n+     * data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The\n+     * trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs\n+     * for a given scenario.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.specialized.cryptography.EncryptedBlobAsyncClient.uploadWithResponse#Flux-ParallelTransferOptions-BlobHttpHeaders-Map-AccessTier-BlobRequestConditions}\n+     *\n+     * @param data The data to write to the blob. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link BlobHttpHeaders}\n+     * @param metadata Metadata to associate with the blob.\n+     * @param tags Tags to associate with the destination blob.\n+     * @param tier {@link AccessTier} for the destination blob.\n+     * @param requestConditions {@link BlobRequestConditions}\n+     * @return A reactive response containing the information of the uploaded block blob.\n+     */\n+    public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data,\n+        ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String, String> metadata,\n+        Map<String, String> tags, AccessTier tier, BlobRequestConditions requestConditions) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzExMTE2MQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzM1MzgzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjoxMzo0N1rOGJ-00A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjoxMzo0N1rOGJ-00A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzExOTY5Ng==", "bodyText": "Collection.singletonList?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413119696", "createdAt": "2020-04-22T16:13:47Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {\n+        return this.findBlobsByTags(query, null, null);\n+    }\n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobAsyncServiceClient.filterBlobs#String-Integer}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @param maxResultsPerPage The maximum number of results to return in a given page.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query, Integer maxResultsPerPage) {\n+        try {\n+            return findBlobsByTags(query, maxResultsPerPage, null);\n+        } catch (RuntimeException ex) {\n+            return pagedFluxError(logger, ex);\n+        }\n+    }\n+\n+    // TODO: options instead of maxResults?\n+    // TODO: Return type?\n+    PagedFlux<FilterBlobItem> findBlobsByTags(String query, Integer maxResults, Duration timeout) {\n+        throwOnAnonymousAccess();\n+        Function<String, Mono<PagedResponse<FilterBlobItem>>> func =\n+            marker -> findBlobsByTags(query, marker, maxResults, timeout)\n+                .map(response -> {\n+                    List<FilterBlobItem> value = response.getValue().getBlobs() == null\n+                        ? new ArrayList<>(0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzM1ODg0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjoxNDo0OFrOGJ-32w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzo0OToxOVrOGKDMGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyMDQ3NQ==", "bodyText": "Thoughts on adding some convenience method to build a query?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413120475", "createdAt": "2020-04-22T16:14:48Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5MTE5NQ==", "bodyText": "I think this is a part of an ongoing email thread about what sort of object model we want to offer, if any, to support building queries.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r413191195", "createdAt": "2020-04-22T17:49:19Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobServiceAsyncClient.java", "diffHunk": "@@ -329,6 +331,72 @@ public String getAccountUrl() {\n                 null, Context.NONE), timeout);\n     }\n \n+\n+    /**\n+     * Returns a reactive Publisher emitting the blobs in this account whose tags match the query expression. For more\n+     * information, including information on the query syntax, see the <a href=\"DOC LINK NEEDED\">Azure Docs</a>.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.blob.BlobServiceAsyncClient.filterBlobs#String}\n+     *\n+     * @param query Filters the results to return only blobs whose tags match the specified expression.\n+     * @return A reactive response emitting the list of blobs.\n+     */\n+    public PagedFlux<FilterBlobItem> findBlobsByTags(String query) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyMDQ3NQ=="}, "originalCommit": {"oid": "cf0edae6d2d0f746f94c0fffe5d6abf91c9838dd"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjY0NTUwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDo1NToyMlrOGQR08g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTozMzoyOVrOGatM8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyMjQ4Mg==", "bodyText": "Do we want to deprecate these max overload methods ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r419722482", "createdAt": "2020-05-04T20:55:22Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobClient.java", "diffHunk": "@@ -270,8 +297,27 @@ public void uploadFromFile(String filePath, boolean overwrite) {\n     public void uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c360edc6f6ca4b7cd876b15ad5b7a2ac93959ff"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1Njc1NQ==", "bodyText": "I don't think we need to deprecate. There's nothing really wrong with them unless we want to be proactive about trimming older options", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r430656755", "createdAt": "2020-05-26T19:33:29Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobClient.java", "diffHunk": "@@ -270,8 +297,27 @@ public void uploadFromFile(String filePath, boolean overwrite) {\n     public void uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyMjQ4Mg=="}, "originalCommit": {"oid": "9c360edc6f6ca4b7cd876b15ad5b7a2ac93959ff"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjY1NTQ1OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/AzureBlobStorageImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDo1ODoyMFrOGQR7Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDo1ODoyMFrOGQR7Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNDA1NQ==", "bodyText": "I think this is regression. Please check generator version you're using with https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob/swagger#generation .", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r419724055", "createdAt": "2020-05-04T20:58:20Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/AzureBlobStorageImpl.java", "diffHunk": "@@ -203,7 +203,7 @@ public BlockBlobsImpl blockBlobs() {\n      * Initializes an instance of AzureBlobStorage client.\n      */\n     public AzureBlobStorageImpl() {\n-        this(new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy()).build());\n+        new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c360edc6f6ca4b7cd876b15ad5b7a2ac93959ff"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjY2NTA3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/CustomHierarchicalListingDeserializer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTowMDo1M1rOGQSA5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTozMjo1MlrOGatLgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNTU0Mw==", "bodyText": "Why this rename is required?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r419725543", "createdAt": "2020-05-04T21:00:53Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/CustomHierarchicalListingDeserializer.java", "diffHunk": "@@ -17,11 +16,11 @@\n \n     @Override\n     public BlobHierarchyListSegment deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-        ArrayList<BlobItem> blobItems = new ArrayList<>();\n+        ArrayList<BlobItemInternal> blobItems = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c360edc6f6ca4b7cd876b15ad5b7a2ac93959ff"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1NjM4NQ==", "bodyText": "Because the BlobItem type produced by the generator has a really bad interface for interacting with tags resulting from how it's structured in the payload/swagger. We want to get rid of that and just return a map, which required renaming the generated type to be internal", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r430656385", "createdAt": "2020-05-26T19:32:52Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/models/CustomHierarchicalListingDeserializer.java", "diffHunk": "@@ -17,11 +16,11 @@\n \n     @Override\n     public BlobHierarchyListSegment deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-        ArrayList<BlobItem> blobItems = new ArrayList<>();\n+        ArrayList<BlobItemInternal> blobItems = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNTU0Mw=="}, "originalCommit": {"oid": "9c360edc6f6ca4b7cd876b15ad5b7a2ac93959ff"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjY3ODQwOnYy", "diffSide": "LEFT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobOutputStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTowNDo1N1rOGQSJcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTowNDo1N1rOGQSJcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNzczMQ==", "bodyText": "we should preserve this comment.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10382#discussion_r419727731", "createdAt": "2020-05-04T21:04:57Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobOutputStream.java", "diffHunk": "@@ -186,9 +204,9 @@ void commit() {\n \n         private BlockBlobOutputStream(final BlobAsyncClient client,\n             final ParallelTransferOptions parallelTransferOptions, final BlobHttpHeaders headers,\n-            final Map<String, String> metadata, final AccessTier tier, final BlobRequestConditions requestConditions,\n-            Context context) {\n-            super(Integer.MAX_VALUE); // writeThreshold is effectively not used by BlockBlobOutputStream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c360edc6f6ca4b7cd876b15ad5b7a2ac93959ff"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4548, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}