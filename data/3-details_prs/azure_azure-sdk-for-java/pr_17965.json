{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxOTk2NzM1", "number": 17965, "title": "Query plan caching", "bodyText": "This PR adds some optimizations to query execution time by caching query plan where possible. This PR enables query plan caching for single partition queries with filters and orderby.\n\n Adds a new beta API on CosmosClientBuilder to enable query plan caching.\n\nQueryplan caching can be enabled using an env parameter\n\nPerf results for single partition query benchmark test with concurrency of 20:\nMaster -\nlatency\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 count = 100000\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 mean rate = 1756.32 calls/second\n\u00a0\u00a0 \u00a0 1-minute rate = 1306.94 calls/second\n\u00a0\u00a0 \u00a0 5-minute rate = 683.84 calls/second\n\u00a0 \u00a0 15-minute rate = 544.24 calls/second\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 min = 3.21 milliseconds\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 max = 128.97 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mean = 7.11 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 stddev = 3.41 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 median = 6.62 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 75% <= 8.00 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 95% <= 11.14 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 98% <= 13.37 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 99% <= 15.47 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 99.9% <= 39.58 milliseconds\nThis PR\nlatency\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 count = 100000\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 mean rate = 2560.71 calls/second\n\u00a0\u00a0 \u00a0 1-minute rate = 1476.54 calls/second\n\u00a0\u00a0 \u00a0 5-minute rate = 877.27 calls/second\n\u00a0 \u00a0 15-minute rate = 756.18 calls/second\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 min = 1.70 milliseconds\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 max = 95.42 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mean = 5.04 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 stddev = 3.11 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 median = 4.15 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 75% <= 5.70 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 95% <= 11.14 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 98% <= 14.48 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 99% <= 17.04 milliseconds\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 99.9% <= 23.99 milliseconds", "createdAt": "2020-12-03T18:44:32Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965", "merged": true, "mergeCommit": {"oid": "b1b129ffba10ea749673b5c02ee418ef95d68371"}, "closed": true, "closedAt": "2021-01-19T22:52:40Z", "author": {"login": "mbhaskar"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdincNNAH2gAyNTMxOTk2NzM1OjNlOWIwOWQxMzUzYWExODkzNWU3MDc0NzI4NDA1NjNjOWFlZDMzOGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdwpeFVAH2gAyNTMxOTk2NzM1OjUyNDhjNjAxMTQzZDE3YjhlY2JmOTIxYmVlMDFjNmM3ZmUzNTM0ODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3e9b09d1353aa18935e707472840563c9aed338e", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e9b09d1353aa18935e707472840563c9aed338e", "committedDate": "2020-12-03T18:27:46Z", "message": "This PR adds some optimizations to query execution time by caching query plan where possible."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a6ef72f231b3a7eda6217de0d03b2a195bceb96", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a6ef72f231b3a7eda6217de0d03b2a195bceb96", "committedDate": "2020-12-04T03:39:44Z", "message": "Cleanup and more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29c05d46ff0ce8fcb1a73736d74988169279d9ac", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/29c05d46ff0ce8fcb1a73736d74988169279d9ac", "committedDate": "2020-12-05T05:07:15Z", "message": "spot bug fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8b4a8581b77d92c48d409689fe12a3f236960c91", "committedDate": "2020-12-09T04:53:41Z", "message": "Fixing test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODYwNTE1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-547860515", "createdAt": "2020-12-09T05:52:54Z", "commit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNTo1Mjo1NFrOICDvDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNTo1NTo0NFrOICDyzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAyOTI2MA==", "bodyText": "doesn't guava library that is shaded into our code have a LRUCache we can re-use?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r539029260", "createdAt": "2020-12-09T05:52:54Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/LRUCache.java", "diffHunk": "@@ -0,0 +1,23 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+public class LRUCache<K, V> extends LinkedHashMap<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAyOTQyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.queryPlanCache = new LRUCache<>(30);\n          \n          \n            \n                        this.queryPlanCache = new LRUCache<>(CACHE_SIZE);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r539029423", "createdAt": "2020-12-09T05:53:29Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -341,6 +352,7 @@ private RxDocumentClientImpl(URI serviceEndpoint,\n             this.retryPolicy = new RetryPolicy(this, this.globalEndpointManager, this.connectionPolicy);\n             this.resetSessionTokenRetryPolicy = retryPolicy;\n             CpuMemoryMonitor.register(this);\n+            this.queryPlanCache = new LRUCache<>(30);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAyOTczNA==", "bodyText": "does anything throw this? ConcurrentModificationException", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r539029734", "createdAt": "2020-12-09T05:54:24Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/DocumentQueryExecutionContextFactory.java", "diffHunk": "@@ -21,11 +22,14 @@\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n import java.time.Instant;\n import java.util.Collections;\n+import java.util.ConcurrentModificationException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzMDIyMQ==", "bodyText": "is this thread safe?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r539030221", "createdAt": "2020-12-09T05:55:44Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/LRUCache.java", "diffHunk": "@@ -0,0 +1,23 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+public class LRUCache<K, V> extends LinkedHashMap<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/77e44c7800f83dc031f121f516cb13c5783a45b1", "committedDate": "2020-12-09T18:01:09Z", "message": "Implementing PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjQ4NDAx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-549648401", "createdAt": "2020-12-10T22:15:58Z", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjoxNTo1OFrOIDfxFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjoxNTo1OFrOIDfxFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNzExMA==", "bodyText": "I don't think we should add public surface area for this - why would you ever want to not cache query plan?\nHaving a system property override to disable it in case we cause some regression etc. is ok - but I would not allow this to be configurable in public API - especially where the best-practice is opt-in", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r540537110", "createdAt": "2020-12-10T22:15:58Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "diffHunk": "@@ -619,6 +621,23 @@ public CosmosClientBuilder readRequestsFallbackEnabled(boolean readRequestsFallb\n         return this;\n     }\n \n+    /**\n+     * Sets whether to allow the query plan to be cached when possible, during query execution. Caching query plan\n+     * improves the latency/throughput of the query execution when same queries are executed again. It is recommended\n+     * to use parameterized queries when trying to cache query plan.\n+     * <p>\n+     * DEFAULT value is false\n+     * </p>\n+     *\n+     * @param queryPlanCachingEnabled flag to enable query plan cache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjUxNjY3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-549651667", "createdAt": "2020-12-10T22:21:23Z", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjoyMToyNFrOIDf8cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjoyMToyNFrOIDf8cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MDAxOQ==", "bodyText": "Should we really make this configurable? And 30 is the number of query plans to be cached? I would argue that this value should be artificially high - so that we basically nearly always are able to cache query plans. Like at least in the order of thousands. Even if query plans are relatively large - like in the order of KBs if a customer is running a workload with hundreds of different queries a couple of MBs for this case memory will be the least of their problems :-) - Disabling/reducing config as System properties - fine - but not public surface area would be my recommendation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r540540019", "createdAt": "2020-12-10T22:21:24Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -136,6 +136,9 @@\n     private RxPartitionKeyRangeCache partitionKeyRangeCache;\n     private Map<String, List<PartitionKeyAndResourceTokenPair>> resourceTokensMap;\n     private final boolean contentResponseOnWriteEnabled;\n+    private boolean queryPlanCachingEnabled;\n+    private static final int CACHE_SIZE = 30; // This value will be made configurable in future", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjYwMjMz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-549660233", "createdAt": "2020-12-10T22:35:50Z", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjozNTo1MFrOIDgZew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjozNTo1MFrOIDgZew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0NzQ1MQ==", "bodyText": "getQueryText will return the query as specified by the user - so if user isn't using query parameters we would see a very high number of different queries even for the same shape, correct? I though the Sql parsing done with ANTLR would allow us to create the normalized query shape - like take parameter/filter values out of the equation etc.?\nI might be missing some context - so more a question that an ask to change anything...", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r540547451", "createdAt": "2020-12-10T22:35:50Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/DocumentQueryExecutionContextFactory.java", "diffHunk": "@@ -78,49 +84,105 @@\n         }\n \n         Instant startTime = Instant.now();\n-        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono =\n-            QueryPlanRetriever\n-                .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query, resourceLink);\n+        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono;\n+        if (queryPlanCachingEnabled &&\n+                isScopedToSinglePartition(cosmosQueryRequestOptions) &&\n+                queryPlanCache.containsKey(query.getQueryText())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjYyNjQ3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-549662647", "createdAt": "2020-12-10T22:38:28Z", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjozODoyOFrOIDggSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjozODoyOFrOIDggSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0OTE5NQ==", "bodyText": "Why would Top/Limit not work for single partition queries? Not even for relatively common model of Top 1?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r540549195", "createdAt": "2020-12-10T22:38:28Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/DocumentQueryExecutionContextFactory.java", "diffHunk": "@@ -78,49 +84,105 @@\n         }\n \n         Instant startTime = Instant.now();\n-        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono =\n-            QueryPlanRetriever\n-                .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query, resourceLink);\n+        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono;\n+        if (queryPlanCachingEnabled &&\n+                isScopedToSinglePartition(cosmosQueryRequestOptions) &&\n+                queryPlanCache.containsKey(query.getQueryText())) {\n+            Instant endTime = Instant.now(); // endTime for query plan diagnostics\n+            PartitionedQueryExecutionInfo partitionedQueryExecutionInfo = queryPlanCache.get(query.getQueryText());\n+            return getTargetRangesFromQueryPlan(cosmosQueryRequestOptions, collection, queryExecutionContext,\n+                                                partitionedQueryExecutionInfo, startTime, endTime);\n+        } else {\n+            queryExecutionInfoMono = QueryPlanRetriever\n+                                         .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query,\n+                                                                          resourceLink);\n+        }\n \n         return queryExecutionInfoMono.flatMap(\n             partitionedQueryExecutionInfo -> {\n \n                 Instant endTime = Instant.now();\n-                QueryInfo queryInfo =\n-                    partitionedQueryExecutionInfo.getQueryInfo();\n-                queryInfo.setQueryPlanDiagnosticsContext(new QueryInfo.QueryPlanDiagnosticsContext(startTime, endTime));\n-\n-                List<Range<String>> queryRanges =\n-                    partitionedQueryExecutionInfo.getQueryRanges();\n-\n-                if (cosmosQueryRequestOptions != null\n-                    && cosmosQueryRequestOptions.getPartitionKey() != null\n-                    && cosmosQueryRequestOptions.getPartitionKey() != PartitionKey.NONE) {\n-                    PartitionKeyInternal internalPartitionKey =\n-                        BridgeInternal.getPartitionKeyInternal(cosmosQueryRequestOptions.getPartitionKey());\n-                    Range<String> range = Range\n-                        .getPointRange(internalPartitionKey\n-                            .getEffectivePartitionKeyString(internalPartitionKey, collection.getPartitionKey()));\n-                    queryRanges = Collections.singletonList(range);\n+\n+                if (queryPlanCachingEnabled) {\n+                    tryCacheQueryPlan(query, partitionedQueryExecutionInfo, queryPlanCache);\n                 }\n-                return\n-                    queryExecutionContext.getTargetPartitionKeyRanges(collection.getResourceId(), queryRanges)\n-                    .map(pkRanges -> Pair.of(\n-                        pkRanges,\n-                        partitionedQueryExecutionInfo.getQueryInfo()));\n+\n+                return getTargetRangesFromQueryPlan(cosmosQueryRequestOptions, collection, queryExecutionContext,\n+                                                    partitionedQueryExecutionInfo, startTime, endTime);\n             });\n     }\n \n+    private static <T extends Resource> Mono<Pair<List<PartitionKeyRange>, QueryInfo>> getTargetRangesFromQueryPlan(\n+        CosmosQueryRequestOptions cosmosQueryRequestOptions, DocumentCollection collection,\n+        DefaultDocumentQueryExecutionContext<T> queryExecutionContext,\n+        PartitionedQueryExecutionInfo partitionedQueryExecutionInfo, Instant planFetchStartTime,\n+        Instant planFetchEndTime) {\n+        QueryInfo queryInfo =\n+            partitionedQueryExecutionInfo.getQueryInfo();\n+        queryInfo.setQueryPlanDiagnosticsContext(new QueryInfo.QueryPlanDiagnosticsContext(planFetchStartTime,\n+                                                                                           planFetchEndTime));\n+        List<Range<String>> queryRanges =\n+            partitionedQueryExecutionInfo.getQueryRanges();\n+\n+        if (isScopedToSinglePartition(cosmosQueryRequestOptions)) {\n+            PartitionKeyInternal internalPartitionKey =\n+                BridgeInternal.getPartitionKeyInternal(cosmosQueryRequestOptions.getPartitionKey());\n+            Range<String> range = Range\n+                                      .getPointRange(internalPartitionKey\n+                                                         .getEffectivePartitionKeyString(internalPartitionKey,\n+                                                                                         collection\n+                                                                                             .getPartitionKey()));\n+            queryRanges = Collections.singletonList(range);\n+        }\n+        return\n+            queryExecutionContext.getTargetPartitionKeyRanges(collection.getResourceId(), queryRanges)\n+                .map(pkRanges -> Pair.of(\n+                    pkRanges,\n+                    partitionedQueryExecutionInfo.getQueryInfo()));\n+    }\n+\n+    private static void tryCacheQueryPlan(\n+        SqlQuerySpec query,\n+        PartitionedQueryExecutionInfo partitionedQueryExecutionInfo,\n+        LRUCache<String, PartitionedQueryExecutionInfo> queryPlanCache) {\n+        QueryInfo queryInfo = partitionedQueryExecutionInfo.getQueryInfo();\n+        if (canCacheQuery(queryInfo) && !queryPlanCache.containsKey(query.getQueryText())) {\n+            try {\n+                queryPlanCache.put(query.getQueryText(), partitionedQueryExecutionInfo);\n+            } catch (ConcurrentModificationException exception) {\n+                logger.error(\"Error caching query plan: \", exception);\n+            }\n+        }\n+    }\n+\n+    private static boolean canCacheQuery(QueryInfo queryInfo) {\n+        // Query plan will not be cached for the types below\n+        return !queryInfo.hasAggregates()\n+                   && !queryInfo.hasDistinct()\n+                   && !queryInfo.hasGroupBy()\n+                   && !queryInfo.hasLimit()\n+                   && !queryInfo.hasTop()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNDMwNDM3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-550430437", "createdAt": "2020-12-11T18:28:33Z", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyODozNFrOIEEz-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyOTozN1rOIEE2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDA1OA==", "bodyText": "I don't think this is the current pattern. We shouldn't be using a cache which is not thread-safe.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r541144058", "createdAt": "2020-12-11T18:28:34Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/DocumentQueryExecutionContextFactory.java", "diffHunk": "@@ -78,49 +84,105 @@\n         }\n \n         Instant startTime = Instant.now();\n-        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono =\n-            QueryPlanRetriever\n-                .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query, resourceLink);\n+        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono;\n+        if (queryPlanCachingEnabled &&\n+                isScopedToSinglePartition(cosmosQueryRequestOptions) &&\n+                queryPlanCache.containsKey(query.getQueryText())) {\n+            Instant endTime = Instant.now(); // endTime for query plan diagnostics\n+            PartitionedQueryExecutionInfo partitionedQueryExecutionInfo = queryPlanCache.get(query.getQueryText());\n+            return getTargetRangesFromQueryPlan(cosmosQueryRequestOptions, collection, queryExecutionContext,\n+                                                partitionedQueryExecutionInfo, startTime, endTime);\n+        } else {\n+            queryExecutionInfoMono = QueryPlanRetriever\n+                                         .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query,\n+                                                                          resourceLink);\n+        }\n \n         return queryExecutionInfoMono.flatMap(\n             partitionedQueryExecutionInfo -> {\n \n                 Instant endTime = Instant.now();\n-                QueryInfo queryInfo =\n-                    partitionedQueryExecutionInfo.getQueryInfo();\n-                queryInfo.setQueryPlanDiagnosticsContext(new QueryInfo.QueryPlanDiagnosticsContext(startTime, endTime));\n-\n-                List<Range<String>> queryRanges =\n-                    partitionedQueryExecutionInfo.getQueryRanges();\n-\n-                if (cosmosQueryRequestOptions != null\n-                    && cosmosQueryRequestOptions.getPartitionKey() != null\n-                    && cosmosQueryRequestOptions.getPartitionKey() != PartitionKey.NONE) {\n-                    PartitionKeyInternal internalPartitionKey =\n-                        BridgeInternal.getPartitionKeyInternal(cosmosQueryRequestOptions.getPartitionKey());\n-                    Range<String> range = Range\n-                        .getPointRange(internalPartitionKey\n-                            .getEffectivePartitionKeyString(internalPartitionKey, collection.getPartitionKey()));\n-                    queryRanges = Collections.singletonList(range);\n+\n+                if (queryPlanCachingEnabled) {\n+                    tryCacheQueryPlan(query, partitionedQueryExecutionInfo, queryPlanCache);\n                 }\n-                return\n-                    queryExecutionContext.getTargetPartitionKeyRanges(collection.getResourceId(), queryRanges)\n-                    .map(pkRanges -> Pair.of(\n-                        pkRanges,\n-                        partitionedQueryExecutionInfo.getQueryInfo()));\n+\n+                return getTargetRangesFromQueryPlan(cosmosQueryRequestOptions, collection, queryExecutionContext,\n+                                                    partitionedQueryExecutionInfo, startTime, endTime);\n             });\n     }\n \n+    private static <T extends Resource> Mono<Pair<List<PartitionKeyRange>, QueryInfo>> getTargetRangesFromQueryPlan(\n+        CosmosQueryRequestOptions cosmosQueryRequestOptions, DocumentCollection collection,\n+        DefaultDocumentQueryExecutionContext<T> queryExecutionContext,\n+        PartitionedQueryExecutionInfo partitionedQueryExecutionInfo, Instant planFetchStartTime,\n+        Instant planFetchEndTime) {\n+        QueryInfo queryInfo =\n+            partitionedQueryExecutionInfo.getQueryInfo();\n+        queryInfo.setQueryPlanDiagnosticsContext(new QueryInfo.QueryPlanDiagnosticsContext(planFetchStartTime,\n+                                                                                           planFetchEndTime));\n+        List<Range<String>> queryRanges =\n+            partitionedQueryExecutionInfo.getQueryRanges();\n+\n+        if (isScopedToSinglePartition(cosmosQueryRequestOptions)) {\n+            PartitionKeyInternal internalPartitionKey =\n+                BridgeInternal.getPartitionKeyInternal(cosmosQueryRequestOptions.getPartitionKey());\n+            Range<String> range = Range\n+                                      .getPointRange(internalPartitionKey\n+                                                         .getEffectivePartitionKeyString(internalPartitionKey,\n+                                                                                         collection\n+                                                                                             .getPartitionKey()));\n+            queryRanges = Collections.singletonList(range);\n+        }\n+        return\n+            queryExecutionContext.getTargetPartitionKeyRanges(collection.getResourceId(), queryRanges)\n+                .map(pkRanges -> Pair.of(\n+                    pkRanges,\n+                    partitionedQueryExecutionInfo.getQueryInfo()));\n+    }\n+\n+    private static void tryCacheQueryPlan(\n+        SqlQuerySpec query,\n+        PartitionedQueryExecutionInfo partitionedQueryExecutionInfo,\n+        LRUCache<String, PartitionedQueryExecutionInfo> queryPlanCache) {\n+        QueryInfo queryInfo = partitionedQueryExecutionInfo.getQueryInfo();\n+        if (canCacheQuery(queryInfo) && !queryPlanCache.containsKey(query.getQueryText())) {\n+            try {\n+                queryPlanCache.put(query.getQueryText(), partitionedQueryExecutionInfo);\n+            } catch (ConcurrentModificationException exception) {\n+                logger.error(\"Error caching query plan: \", exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDY4MQ==", "bodyText": "I don't think we should be using a non-thread safe construct in a multi-threading fashion. I think relying on ConcurrentModificationException is not the correct pattern.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r541144681", "createdAt": "2020-12-11T18:29:37Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/LRUCache.java", "diffHunk": "@@ -0,0 +1,23 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+public class LRUCache<K, V> extends LinkedHashMap<K, V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzMDIyMQ=="}, "originalCommit": {"oid": "8b4a8581b77d92c48d409689fe12a3f236960c91"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTEyMTgy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-551912182", "createdAt": "2020-12-14T21:35:02Z", "commit": {"oid": "77e44c7800f83dc031f121f516cb13c5783a45b1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f92f176c50f90b946718634bca3ca12abd2829ce", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f92f176c50f90b946718634bca3ca12abd2829ce", "committedDate": "2020-12-18T22:26:58Z", "message": "Removing LRUCache and switching to ConcurrentMap."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1ODY5OTYx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-555869961", "createdAt": "2020-12-18T23:03:48Z", "commit": {"oid": "f92f176c50f90b946718634bca3ca12abd2829ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMzowMzo0OVrOII1djA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMzowMzo0OVrOII1djA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEzNTQzNg==", "bodyText": "We should track this TODO for future. as for now we are not using a LRU cache.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#discussion_r546135436", "createdAt": "2020-12-18T23:03:49Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/DocumentQueryExecutionContextFactory.java", "diffHunk": "@@ -78,49 +85,112 @@\n         }\n \n         Instant startTime = Instant.now();\n-        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono =\n-            QueryPlanRetriever\n-                .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query, resourceLink);\n+        Mono<PartitionedQueryExecutionInfo> queryExecutionInfoMono;\n+        if (queryPlanCachingEnabled &&\n+                isScopedToSinglePartition(cosmosQueryRequestOptions) &&\n+                queryPlanCache.containsKey(query.getQueryText())) {\n+            Instant endTime = Instant.now(); // endTime for query plan diagnostics\n+            PartitionedQueryExecutionInfo partitionedQueryExecutionInfo = queryPlanCache.get(query.getQueryText());\n+            if (partitionedQueryExecutionInfo != null) {\n+                return getTargetRangesFromQueryPlan(cosmosQueryRequestOptions, collection, queryExecutionContext,\n+                                                    partitionedQueryExecutionInfo, startTime, endTime);\n+            }\n+        }\n+\n+        queryExecutionInfoMono = QueryPlanRetriever\n+                                     .getQueryPlanThroughGatewayAsync(diagnosticsClientContext, client, query,\n+                                                                      resourceLink);\n \n         return queryExecutionInfoMono.flatMap(\n             partitionedQueryExecutionInfo -> {\n \n                 Instant endTime = Instant.now();\n-                QueryInfo queryInfo =\n-                    partitionedQueryExecutionInfo.getQueryInfo();\n-                queryInfo.setQueryPlanDiagnosticsContext(new QueryInfo.QueryPlanDiagnosticsContext(startTime, endTime));\n-\n-                List<Range<String>> queryRanges =\n-                    partitionedQueryExecutionInfo.getQueryRanges();\n-\n-                if (cosmosQueryRequestOptions != null\n-                    && cosmosQueryRequestOptions.getPartitionKey() != null\n-                    && cosmosQueryRequestOptions.getPartitionKey() != PartitionKey.NONE) {\n-                    PartitionKeyInternal internalPartitionKey =\n-                        BridgeInternal.getPartitionKeyInternal(cosmosQueryRequestOptions.getPartitionKey());\n-                    Range<String> range = Range\n-                        .getPointRange(internalPartitionKey\n-                            .getEffectivePartitionKeyString(internalPartitionKey, collection.getPartitionKey()));\n-                    queryRanges = Collections.singletonList(range);\n+\n+                if (queryPlanCachingEnabled) {\n+                    tryCacheQueryPlan(query, partitionedQueryExecutionInfo, queryPlanCache);\n                 }\n-                return\n-                    queryExecutionContext.getTargetPartitionKeyRanges(collection.getResourceId(), queryRanges)\n-                    .map(pkRanges -> Pair.of(\n-                        pkRanges,\n-                        partitionedQueryExecutionInfo.getQueryInfo()));\n+\n+                return getTargetRangesFromQueryPlan(cosmosQueryRequestOptions, collection, queryExecutionContext,\n+                                                    partitionedQueryExecutionInfo, startTime, endTime);\n             });\n     }\n \n+    private static <T extends Resource> Mono<Pair<List<PartitionKeyRange>, QueryInfo>> getTargetRangesFromQueryPlan(\n+        CosmosQueryRequestOptions cosmosQueryRequestOptions, DocumentCollection collection,\n+        DefaultDocumentQueryExecutionContext<T> queryExecutionContext,\n+        PartitionedQueryExecutionInfo partitionedQueryExecutionInfo, Instant planFetchStartTime,\n+        Instant planFetchEndTime) {\n+        QueryInfo queryInfo =\n+            partitionedQueryExecutionInfo.getQueryInfo();\n+        queryInfo.setQueryPlanDiagnosticsContext(new QueryInfo.QueryPlanDiagnosticsContext(planFetchStartTime,\n+                                                                                           planFetchEndTime));\n+        List<Range<String>> queryRanges =\n+            partitionedQueryExecutionInfo.getQueryRanges();\n+\n+        if (isScopedToSinglePartition(cosmosQueryRequestOptions)) {\n+            PartitionKeyInternal internalPartitionKey =\n+                BridgeInternal.getPartitionKeyInternal(cosmosQueryRequestOptions.getPartitionKey());\n+            Range<String> range = Range\n+                                      .getPointRange(internalPartitionKey\n+                                                         .getEffectivePartitionKeyString(internalPartitionKey,\n+                                                                                         collection\n+                                                                                             .getPartitionKey()));\n+            queryRanges = Collections.singletonList(range);\n+        }\n+        return\n+            queryExecutionContext.getTargetPartitionKeyRanges(collection.getResourceId(), queryRanges)\n+                .map(pkRanges -> Pair.of(\n+                    pkRanges,\n+                    partitionedQueryExecutionInfo.getQueryInfo()));\n+    }\n+\n+    private static void tryCacheQueryPlan(\n+        SqlQuerySpec query,\n+        PartitionedQueryExecutionInfo partitionedQueryExecutionInfo,\n+        ConcurrentMap<String, PartitionedQueryExecutionInfo> queryPlanCache) {\n+        QueryInfo queryInfo = partitionedQueryExecutionInfo.getQueryInfo();\n+        if (canCacheQuery(queryInfo) && !queryPlanCache.containsKey(query.getQueryText())) {\n+            if (queryPlanCache.size() > MAX_CACHE_SIZE) {\n+                // Clearing query plan cache if size is above max size. This can be optimized in future by using\n+                // a threadsafe LRU cache\n+                queryPlanCache.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92f176c50f90b946718634bca3ca12abd2829ce"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1ODcxMTQx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-555871141", "createdAt": "2020-12-18T23:07:38Z", "commit": {"oid": "f92f176c50f90b946718634bca3ca12abd2829ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "923f5541a2f82915f2920277eb76a42bc160cdd1", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/923f5541a2f82915f2920277eb76a42bc160cdd1", "committedDate": "2021-01-08T18:01:25Z", "message": "Removed the public API to enable cache\nQueryplan caching can now be enabled using a environment paramater"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38bf6178f3cf72d38251899dea4cd401db00a136", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/38bf6178f3cf72d38251899dea4cd401db00a136", "committedDate": "2021-01-08T18:57:18Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afdb42e00add177808dfa9377be04c2d2494ace3", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/afdb42e00add177808dfa9377be04c2d2494ace3", "committedDate": "2021-01-12T07:25:21Z", "message": "Removing public API related code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62274b3cca41b6b8fb6ff68b131cc5732da5744a", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/62274b3cca41b6b8fb6ff68b131cc5732da5744a", "committedDate": "2021-01-12T07:33:37Z", "message": "Merge remote-tracking branch 'upstream/master' into query-optimization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3bf546c21ece64198ca9a80336792160ae75144", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c3bf546c21ece64198ca9a80336792160ae75144", "committedDate": "2021-01-12T07:39:03Z", "message": "Merge remote-tracking branch 'upstream/master' into query-optimization\n\n# Conflicts:\n#\tsdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java\n#\tsdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93c816c7075bc2c6028286be97b77d2a31563354", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/93c816c7075bc2c6028286be97b77d2a31563354", "committedDate": "2021-01-12T07:50:57Z", "message": "clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ef7a7d46ac47f6693d0024063100455238c50d4", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ef7a7d46ac47f6693d0024063100455238c50d4", "committedDate": "2021-01-12T08:52:01Z", "message": "clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3Mjk0Nzk0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17965#pullrequestreview-567294794", "createdAt": "2021-01-13T14:48:49Z", "commit": {"oid": "5ef7a7d46ac47f6693d0024063100455238c50d4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5248c601143d17b8ecbf921bee01c6c7fe353485", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5248c601143d17b8ecbf921bee01c6c7fe353485", "committedDate": "2021-01-16T08:44:34Z", "message": "cleanup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1342, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}