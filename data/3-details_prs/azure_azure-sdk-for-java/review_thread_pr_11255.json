{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5Njk3OTcx", "number": 11255, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTozNjoxNFrOD9hwhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1Njo0OVrOD9jNiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQyODIzOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTozNjoxNFrOGXE6ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1MToxNFrOGXFWhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDkxNw==", "bodyText": "I guess you mean:\nreturn DEFAULT_ENCODING;", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426850917", "createdAt": "2020-05-18T19:36:14Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1ODExOQ==", "bodyText": "Thanks! Good catch.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426858119", "createdAt": "2020-05-18T19:51:14Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDkxNw=="}, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQzOTk4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0MDoxMVrOGXFBlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1NToxN1rOGXFekg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mjc1Nw==", "bodyText": "I think MIME types are case insensitive but good to double-check.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426852757", "createdAt": "2020-05-18T19:40:11Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"\n+                + \"Returning default: {}\", mimeType, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        for (SerializerEncodingMimeTypes serializerEncodingMimeTypes : SUPPORTED_MIME_TYPES) {\n+            if (serializerEncodingMimeTypes.matches(mimeTypeParts[0], mimeTypeParts[1])) {\n+                return serializerEncodingMimeTypes.getEncoding();\n+            }\n+        }\n+\n+        LOGGER.warning(\"Content-Type '{}' does not match any supported one. Returning default: {}\",\n+            mimeType, DEFAULT_ENCODING);\n+\n+        return DEFAULT_ENCODING;\n+    }\n+\n+    /**\n+     * A mapping of serialization type to the supported mime type.\n+     */\n+    private static final class SerializerEncodingMimeTypes {\n+        private final SerializerEncoding encoding;\n+        private final String suffix;\n+        private final List<MimeType> mimeTypes;\n+\n+        private SerializerEncodingMimeTypes(SerializerEncoding encoding, String suffix, MimeType... mimeTypes) {\n+            this.encoding = encoding;\n+            this.suffix = suffix;\n+            this.mimeTypes = Arrays.asList(mimeTypes);\n+        }\n+\n+        private boolean matches(String type, String subtype) {\n+            for (MimeType supported : mimeTypes) {\n+                if (supported.matches(type, subtype)) {\n+                    return true;\n+                }\n             }\n+\n+            // Check the suffix if it does not match the full types.\n+            final int lastIndex = subtype.lastIndexOf(\"+\");\n+            if (lastIndex == -1) {\n+                return false;\n+            }\n+\n+            final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+            return suffix.equals(mimeTypeSuffix);\n         }\n \n-        return JSON;\n+        public SerializerEncoding getEncoding() {\n+            return encoding;\n+        }\n+    }\n+\n+    private static final class MimeType {\n+        private final String type;\n+        private final String subType;\n+\n+        private MimeType(String rawMimeType) {\n+            final String[] parts = rawMimeType.split(\"/\");\n+            if (parts.length != 2) {\n+                throw new IllegalArgumentException(\"mimeType is not properly formatted with {type}/{subtype}: \"\n+                    + rawMimeType);\n+            }\n+\n+            this.type = parts[0];\n+            this.subType = parts[1];\n+        }\n+\n+        private boolean matches(String otherType, String otherSubType) {\n+            return type.equals(otherType) && subType.equals(otherSubType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1ODMwMg==", "bodyText": "in line 59, I do a .toLowerCase(Locale.ROOT), but I can update this to be case insensitive instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426858302", "createdAt": "2020-05-18T19:51:37Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"\n+                + \"Returning default: {}\", mimeType, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        for (SerializerEncodingMimeTypes serializerEncodingMimeTypes : SUPPORTED_MIME_TYPES) {\n+            if (serializerEncodingMimeTypes.matches(mimeTypeParts[0], mimeTypeParts[1])) {\n+                return serializerEncodingMimeTypes.getEncoding();\n+            }\n+        }\n+\n+        LOGGER.warning(\"Content-Type '{}' does not match any supported one. Returning default: {}\",\n+            mimeType, DEFAULT_ENCODING);\n+\n+        return DEFAULT_ENCODING;\n+    }\n+\n+    /**\n+     * A mapping of serialization type to the supported mime type.\n+     */\n+    private static final class SerializerEncodingMimeTypes {\n+        private final SerializerEncoding encoding;\n+        private final String suffix;\n+        private final List<MimeType> mimeTypes;\n+\n+        private SerializerEncodingMimeTypes(SerializerEncoding encoding, String suffix, MimeType... mimeTypes) {\n+            this.encoding = encoding;\n+            this.suffix = suffix;\n+            this.mimeTypes = Arrays.asList(mimeTypes);\n+        }\n+\n+        private boolean matches(String type, String subtype) {\n+            for (MimeType supported : mimeTypes) {\n+                if (supported.matches(type, subtype)) {\n+                    return true;\n+                }\n             }\n+\n+            // Check the suffix if it does not match the full types.\n+            final int lastIndex = subtype.lastIndexOf(\"+\");\n+            if (lastIndex == -1) {\n+                return false;\n+            }\n+\n+            final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+            return suffix.equals(mimeTypeSuffix);\n         }\n \n-        return JSON;\n+        public SerializerEncoding getEncoding() {\n+            return encoding;\n+        }\n+    }\n+\n+    private static final class MimeType {\n+        private final String type;\n+        private final String subType;\n+\n+        private MimeType(String rawMimeType) {\n+            final String[] parts = rawMimeType.split(\"/\");\n+            if (parts.length != 2) {\n+                throw new IllegalArgumentException(\"mimeType is not properly formatted with {type}/{subtype}: \"\n+                    + rawMimeType);\n+            }\n+\n+            this.type = parts[0];\n+            this.subType = parts[1];\n+        }\n+\n+        private boolean matches(String otherType, String otherSubType) {\n+            return type.equals(otherType) && subType.equals(otherSubType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mjc1Nw=="}, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDE3OA==", "bodyText": "ah, I missed that, thanks for the reference.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426860178", "createdAt": "2020-05-18T19:55:17Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"\n+                + \"Returning default: {}\", mimeType, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        for (SerializerEncodingMimeTypes serializerEncodingMimeTypes : SUPPORTED_MIME_TYPES) {\n+            if (serializerEncodingMimeTypes.matches(mimeTypeParts[0], mimeTypeParts[1])) {\n+                return serializerEncodingMimeTypes.getEncoding();\n+            }\n+        }\n+\n+        LOGGER.warning(\"Content-Type '{}' does not match any supported one. Returning default: {}\",\n+            mimeType, DEFAULT_ENCODING);\n+\n+        return DEFAULT_ENCODING;\n+    }\n+\n+    /**\n+     * A mapping of serialization type to the supported mime type.\n+     */\n+    private static final class SerializerEncodingMimeTypes {\n+        private final SerializerEncoding encoding;\n+        private final String suffix;\n+        private final List<MimeType> mimeTypes;\n+\n+        private SerializerEncodingMimeTypes(SerializerEncoding encoding, String suffix, MimeType... mimeTypes) {\n+            this.encoding = encoding;\n+            this.suffix = suffix;\n+            this.mimeTypes = Arrays.asList(mimeTypes);\n+        }\n+\n+        private boolean matches(String type, String subtype) {\n+            for (MimeType supported : mimeTypes) {\n+                if (supported.matches(type, subtype)) {\n+                    return true;\n+                }\n             }\n+\n+            // Check the suffix if it does not match the full types.\n+            final int lastIndex = subtype.lastIndexOf(\"+\");\n+            if (lastIndex == -1) {\n+                return false;\n+            }\n+\n+            final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+            return suffix.equals(mimeTypeSuffix);\n         }\n \n-        return JSON;\n+        public SerializerEncoding getEncoding() {\n+            return encoding;\n+        }\n+    }\n+\n+    private static final class MimeType {\n+        private final String type;\n+        private final String subType;\n+\n+        private MimeType(String rawMimeType) {\n+            final String[] parts = rawMimeType.split(\"/\");\n+            if (parts.length != 2) {\n+                throw new IllegalArgumentException(\"mimeType is not properly formatted with {type}/{subtype}: \"\n+                    + rawMimeType);\n+            }\n+\n+            this.type = parts[0];\n+            this.subType = parts[1];\n+        }\n+\n+        private boolean matches(String otherType, String otherSubType) {\n+            return type.equals(otherType) && subType.equals(otherSubType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mjc1Nw=="}, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ0NDcxOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0MTo0NlrOGXFEgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0MTo0NlrOGXFEgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MzUwNA==", "bodyText": "Going to need a Checkstyle suppression for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426853504", "createdAt": "2020-05-18T19:41:46Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ0NjUyOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0MjoyMlrOGXFFjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0MjoyMlrOGXFFjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mzc3NA==", "bodyText": "I believe we have static properties for these values in ContentType.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426853774", "createdAt": "2020-05-18T19:42:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ0NzQ4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0Mjo0MFrOGXFGJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0Mjo0MFrOGXFGJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MzkyNw==", "bodyText": "Should have a static property for this in ContentType.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426853927", "createdAt": "2020-05-18T19:42:40Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ1MjQwOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0NDoyNVrOGXFJRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo0NDoyNVrOGXFJRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1NDcyNw==", "bodyText": "Will need a Checkstyle suppression for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426854727", "createdAt": "2020-05-18T19:44:25Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"\n+                + \"Returning default: {}\", mimeType, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        for (SerializerEncodingMimeTypes serializerEncodingMimeTypes : SUPPORTED_MIME_TYPES) {\n+            if (serializerEncodingMimeTypes.matches(mimeTypeParts[0], mimeTypeParts[1])) {\n+                return serializerEncodingMimeTypes.getEncoding();\n+            }\n+        }\n+\n+        LOGGER.warning(\"Content-Type '{}' does not match any supported one. Returning default: {}\",\n+            mimeType, DEFAULT_ENCODING);\n+\n+        return DEFAULT_ENCODING;\n+    }\n+\n+    /**\n+     * A mapping of serialization type to the supported mime type.\n+     */\n+    private static final class SerializerEncodingMimeTypes {\n+        private final SerializerEncoding encoding;\n+        private final String suffix;\n+        private final List<MimeType> mimeTypes;\n+\n+        private SerializerEncodingMimeTypes(SerializerEncoding encoding, String suffix, MimeType... mimeTypes) {\n+            this.encoding = encoding;\n+            this.suffix = suffix;\n+            this.mimeTypes = Arrays.asList(mimeTypes);\n+        }\n+\n+        private boolean matches(String type, String subtype) {\n+            for (MimeType supported : mimeTypes) {\n+                if (supported.matches(type, subtype)) {\n+                    return true;\n+                }\n             }\n+\n+            // Check the suffix if it does not match the full types.\n+            final int lastIndex = subtype.lastIndexOf(\"+\");\n+            if (lastIndex == -1) {\n+                return false;\n+            }\n+\n+            final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+            return suffix.equals(mimeTypeSuffix);\n         }\n \n-        return JSON;\n+        public SerializerEncoding getEncoding() {\n+            return encoding;\n+        }\n+    }\n+\n+    private static final class MimeType {\n+        private final String type;\n+        private final String subType;\n+\n+        private MimeType(String rawMimeType) {\n+            final String[] parts = rawMimeType.split(\"/\");\n+            if (parts.length != 2) {\n+                throw new IllegalArgumentException(\"mimeType is not properly formatted with {type}/{subtype}: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ4Nzc4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1NToyMlrOGXFetQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1NjoxM1rOGXFgSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDIxMw==", "bodyText": "Thoughts on making this more simplified using a case insensitive TreeMap. Begin by adding in well known Content-Types such as application/json, text/xml, and application/xml (plus additional in the future as we expand), then add in a simple \"json\" -> SerializerEncoding.JSON and same for XML.\nDuring the conversion from HttpHeaders to SerializerEncoding we use the following checks:\n\nMissing ContentType or it is null or empty, log a warning and return JSON.\nCheck if the ContentType exists in the TreeMap, if it does return that value.\nUse string splitting logic, finding the sub-type and if it exists the + split.\n\nThis would simplify out a lot of the class overhead and generally have the same result. Additionally, the map could be updated with the Content-Types that weren't in the well known set to optimize them in future cases when they appear (this runs a risk of having many Content-Types if they get randomized a lot but I think that would be a bad design).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426860213", "createdAt": "2020-05-18T19:55:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDYxNg==", "bodyText": "Another option instead of TreeMap is ConcurrentSkipListMap which also has the option for a key comparator.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426860616", "createdAt": "2020-05-18T19:56:13Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDIxMw=="}, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQ5Mjc5OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1NzowN1rOGXFh1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1NzowN1rOGXFh1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MTAxNA==", "bodyText": "nit: This uses a slightly different error message than the same check in MimeType.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426861014", "createdAt": "2020-05-18T19:57:07Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4909c72804e1e8bde3e80a40a3f80a309e793c0f"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODY0ODI0OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1MDoyM1rOGXHDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1MDoyM1rOGXHDlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NjAzOQ==", "bodyText": "Could use String.CASE_INSENSITIVE_ORDER.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426886039", "createdAt": "2020-05-18T20:50:23Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODY1MDY2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1MToxNFrOGXHFDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTowMjoyN1rOGXHYnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NjQxMg==", "bodyText": "Watch out, this could hit transient concurrent modification errors. Mind trying out ConcurrentSkipListMap?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426886412", "createdAt": "2020-05-18T20:51:14Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MTQyMQ==", "bodyText": "We never modify this list other than at static construction.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426891421", "createdAt": "2020-05-18T21:02:27Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NjQxMg=="}, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODY1NzA2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1MzozM1rOGXHJEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTowMToxM1rOGXHWmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NzQ0MA==", "bodyText": "Should SUPPORTED_MIME_TYPES get updated with the Content-Type-SerializerEncoding value that we deduced.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426887440", "createdAt": "2020-05-18T20:53:33Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);\n+\n+        SUPPORTED_MIME_TYPES = new TreeMap<>(comparator);\n+        SUPPORTED_MIME_TYPES.put(\"text/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/json\", JSON);\n+\n+        SUPPORTED_SUFFIXES = new TreeMap<>(comparator);\n+        SUPPORTED_SUFFIXES.put(\"xml\", XML);\n+        SUPPORTED_SUFFIXES.put(\"json\", JSON);\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n-            }\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null || mimeContentType.isEmpty()) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n         }\n \n-        return JSON;\n+        final SerializerEncoding encoding = SUPPORTED_MIME_TYPES.get(mimeContentType);\n+        if (encoding != null) {\n+            return encoding;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+        final String[] mimeTypeParts = parts[0].split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type'/'subtype'. \"\n+                + \"Returning default: {}\", parts[0], DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        // Check the suffix if it does not match the full types.\n+        final String subtype = mimeTypeParts[1];\n+        final int lastIndex = subtype.lastIndexOf(\"+\");\n+        if (lastIndex == -1) {\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+        final SerializerEncoding serializerEncoding = SUPPORTED_SUFFIXES.get(mimeTypeSuffix);\n+        if (serializerEncoding != null) {\n+            return serializerEncoding;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MDkwNA==", "bodyText": "I'm generally not a fan of making this hold some sort of mutable state, especially since this is a static helper method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426890904", "createdAt": "2020-05-18T21:01:13Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);\n+\n+        SUPPORTED_MIME_TYPES = new TreeMap<>(comparator);\n+        SUPPORTED_MIME_TYPES.put(\"text/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/json\", JSON);\n+\n+        SUPPORTED_SUFFIXES = new TreeMap<>(comparator);\n+        SUPPORTED_SUFFIXES.put(\"xml\", XML);\n+        SUPPORTED_SUFFIXES.put(\"json\", JSON);\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n-            }\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null || mimeContentType.isEmpty()) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n         }\n \n-        return JSON;\n+        final SerializerEncoding encoding = SUPPORTED_MIME_TYPES.get(mimeContentType);\n+        if (encoding != null) {\n+            return encoding;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+        final String[] mimeTypeParts = parts[0].split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type'/'subtype'. \"\n+                + \"Returning default: {}\", parts[0], DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        // Check the suffix if it does not match the full types.\n+        final String subtype = mimeTypeParts[1];\n+        final int lastIndex = subtype.lastIndexOf(\"+\");\n+        if (lastIndex == -1) {\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+        final SerializerEncoding serializerEncoding = SUPPORTED_SUFFIXES.get(mimeTypeSuffix);\n+        if (serializerEncoding != null) {\n+            return serializerEncoding;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NzQ0MA=="}, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODY2NjMyOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1Njo0OVrOGXHOxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDo1OTozNVrOGXHTiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4ODkwMQ==", "bodyText": "This could be slightly wrong if we run across something like text/json, instead we should check:\nfinal String subType = mimeTypeParts[1];\nfinal int lastIndex = subType.lastIndexOf(\"+\");\n\nfinal String mimeType = (lastIndex == -1) ? subtype : subtype.substring(lastIndex + 1);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426888901", "createdAt": "2020-05-18T20:56:49Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);\n+\n+        SUPPORTED_MIME_TYPES = new TreeMap<>(comparator);\n+        SUPPORTED_MIME_TYPES.put(\"text/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/json\", JSON);\n+\n+        SUPPORTED_SUFFIXES = new TreeMap<>(comparator);\n+        SUPPORTED_SUFFIXES.put(\"xml\", XML);\n+        SUPPORTED_SUFFIXES.put(\"json\", JSON);\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n-            }\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null || mimeContentType.isEmpty()) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n         }\n \n-        return JSON;\n+        final SerializerEncoding encoding = SUPPORTED_MIME_TYPES.get(mimeContentType);\n+        if (encoding != null) {\n+            return encoding;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+        final String[] mimeTypeParts = parts[0].split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type'/'subtype'. \"\n+                + \"Returning default: {}\", parts[0], DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        // Check the suffix if it does not match the full types.\n+        final String subtype = mimeTypeParts[1];\n+        final int lastIndex = subtype.lastIndexOf(\"+\");\n+        if (lastIndex == -1) {\n+            return DEFAULT_ENCODING;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MDEyMA==", "bodyText": "text/json isn't a well-supported mimetype though, nor is it a proper suffix.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426890120", "createdAt": "2020-05-18T20:59:35Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);\n+\n+        SUPPORTED_MIME_TYPES = new TreeMap<>(comparator);\n+        SUPPORTED_MIME_TYPES.put(\"text/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/json\", JSON);\n+\n+        SUPPORTED_SUFFIXES = new TreeMap<>(comparator);\n+        SUPPORTED_SUFFIXES.put(\"xml\", XML);\n+        SUPPORTED_SUFFIXES.put(\"json\", JSON);\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n-            }\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null || mimeContentType.isEmpty()) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n         }\n \n-        return JSON;\n+        final SerializerEncoding encoding = SUPPORTED_MIME_TYPES.get(mimeContentType);\n+        if (encoding != null) {\n+            return encoding;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+        final String[] mimeTypeParts = parts[0].split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type'/'subtype'. \"\n+                + \"Returning default: {}\", parts[0], DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        // Check the suffix if it does not match the full types.\n+        final String subtype = mimeTypeParts[1];\n+        final int lastIndex = subtype.lastIndexOf(\"+\");\n+        if (lastIndex == -1) {\n+            return DEFAULT_ENCODING;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4ODkwMQ=="}, "originalCommit": {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4158, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}