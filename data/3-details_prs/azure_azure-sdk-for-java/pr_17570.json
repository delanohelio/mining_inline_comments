{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwNjQ1NzE5", "number": 17570, "title": "Adding basic FeedRanges API", "bodyText": "This is an initial version of the port of FeedRanges from .Net SDK to Java SDK.\nFeedRanges are basically just an abstract identifier for subsets of a Container (possible variations today are PKRange, logical partition or EPK)\nThis PR is adding the public surface area to retrieve the FeedRanges for a container - in the future we will add options for a customer to try to merge or split feed Ranges (for example the feed range of a PkRange can be split into multiple EPK feed ranges) - this mechanism will also be used for split and merge proofing of ReadFeed, Query and Changefeed in .Net SDK.\nThe plan is to start using this in the new Changefeed Pull Model to be merge-proof. Brandon is still actively iterating on his Pagination library that achieves split/merge safety across all feed operations including query.  I will slowly see which parts we can port (when they stabilize in .Net - and depending how much query pipeline is out-of-sync etc.)\nThis PR has the basic building blocks to represent FeedRanges - not yet the pagination aspects to iterate over feeds by filtering by feedRanges etc. That will be part of the next PR when using it for Change Feed Pull model.\nThis PR also has the public surface area - The additional steps above are not expected to change the public surface area anymore (except for adding user-support for merging/splitting feed ranges to decouple compute scale form number of physical partitions - but that public surface area hasn't even been finalized for .Net yet - so is at least several weeks out).", "createdAt": "2020-11-13T15:23:42Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570", "merged": true, "mergeCommit": {"oid": "dca8bcb7d2f1770c5d074cc9adc33b19ba1a25ed"}, "closed": true, "closedAt": "2020-11-18T14:09:52Z", "author": {"login": "FabianMeiswinkel"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZDC7FgH2gAyNTIwNjQ1NzE5OjIxZTI1ZTdlYzU5YWI0M2MwYmY2YTM3YWFkY2IzZTIxOGU1MWJhNmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddutucgH2gAyNTIwNjQ1NzE5OmVlNjA4MjZmZDgyNjU5MjYzMzMwN2MyNzU4MDc1ZDQyNDU2NGY0MDY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "committedDate": "2020-11-04T00:58:15Z", "message": "Initial draft of FeedRange artifacts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e6930098c1df358ec74f580cb3617df00dff471", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e6930098c1df358ec74f580cb3617df00dff471", "committedDate": "2020-11-04T10:30:17Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "committedDate": "2020-11-05T00:29:56Z", "message": "Iterating on FeedRange Apis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54bed2e218c4d42036e4c569c5df311420ac8850", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/54bed2e218c4d42036e4c569c5df311420ac8850", "committedDate": "2020-11-05T14:05:54Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58f98e7557075cc4859797a3d4841db3a6d3bd93", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/58f98e7557075cc4859797a3d4841db3a6d3bd93", "committedDate": "2020-11-11T23:05:03Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46662e06209505e511f01bd53027c378a375d28f", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/46662e06209505e511f01bd53027c378a375d28f", "committedDate": "2020-11-12T00:19:01Z", "message": "Adding public surface area"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03617a4b6c865db61b15eab54e644d2247028bbe", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/03617a4b6c865db61b15eab54e644d2247028bbe", "committedDate": "2020-11-12T23:13:26Z", "message": "Adding FeedRange unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "committedDate": "2020-11-13T00:03:45Z", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Refresh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4095bc5bc318c7c11178e3b2db19f9cec27d5637", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4095bc5bc318c7c11178e3b2db19f9cec27d5637", "committedDate": "2020-11-13T00:33:45Z", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "committedDate": "2020-11-13T10:18:21Z", "message": "Adding test feedRangeEPK_getPartitionKeyRangesAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "committedDate": "2020-11-13T10:27:33Z", "message": "Adding test feedRangePK_getPartitionKeyRangesAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "committedDate": "2020-11-13T10:32:17Z", "message": "Adding test feedRangePKRangeId_getPartitionKeyRangesAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "committedDate": "2020-11-13T11:22:22Z", "message": "Adding request visitor unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef3170e6b938b585218cb1274af297221a488a5", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ef3170e6b938b585218cb1274af297221a488a5", "committedDate": "2020-11-13T14:20:56Z", "message": "Finishing FeedRange tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "committedDate": "2020-11-13T14:48:00Z", "message": "Cleanup and prettifying"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4811e5034bea83f2555f13ab6fb51f9c7defbd68", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4811e5034bea83f2555f13ab6fb51f9c7defbd68", "committedDate": "2020-11-13T14:50:19Z", "message": "Prettifying feed range tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "committedDate": "2020-11-13T15:14:38Z", "message": "Fixes and new test for Conatiner.getFeedRanges()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "committedDate": "2020-11-13T17:31:29Z", "message": "Addressing some SpotBug violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b08488a3d52dd394fcd8bbd3de79184c796afe36", "committedDate": "2020-11-16T15:31:08Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMjY4NDEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#pullrequestreview-530268411", "createdAt": "2020-11-13T17:33:01Z", "commit": {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzozMzowMlrOHy4S9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxODo0MjoxNlrOH1D2VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMzIwNw==", "bodyText": "nit: license header", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r523113207", "createdAt": "2020-11-13T17:33:02Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ShouldRetryResult.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.azure.cosmos.implementation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNTQ2Ng==", "bodyText": "should this be list or Iterable? does indexing feedRange.get(1) a meaningful action?\nIf not probably Iterable is more suitable.\nthought?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r523115466", "createdAt": "2020-11-13T17:35:43Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -556,4 +557,23 @@ public CosmosScripts getScripts() {\n         return UtilBridgeInternal.createCosmosPagedIterable(cosmosPagedFlux);\n     }\n \n+    /**\n+     * Obtains a list of {@link FeedRange} that can be used to parallelize Feed\n+     * operations.\n+     *\n+     * @return An unmodifiable list of {@link FeedRange}\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public List<FeedRange> getFeedRanges() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzAwNw==", "bodyText": "List<FeedRange> feedRanges = new ArrayList<FeedRange>(feedRanges.size());", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525333007", "createdAt": "2020-11-17T17:06:59Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -3634,4 +3641,56 @@ private static SqlQuerySpec createLogicalPartitionScanQuerySpec(\n \n         return new SqlQuerySpec(queryStringBuilder.toString(), parameters);\n     }\n+\n+    @Override\n+    public Mono<List<FeedRange>> getFeedRanges(String collectionLink) {\n+\n+        if (StringUtils.isEmpty(collectionLink)) {\n+            throw new IllegalArgumentException(\"collectionLink\");\n+        }\n+\n+        RxDocumentServiceRequest request = RxDocumentServiceRequest.create(\n+            this,\n+            OperationType.Query,\n+            ResourceType.Document,\n+            collectionLink,\n+            null); // This should not go to backend\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionObs = collectionCache.resolveCollectionAsync(null,\n+            request);\n+\n+        return collectionObs.flatMap(documentCollectionResourceResponse -> {\n+            final DocumentCollection collection = documentCollectionResourceResponse.v;\n+            if (collection == null) {\n+                throw new IllegalStateException(\"Collection cannot be null\");\n+            }\n+\n+            Mono<Utils.ValueHolder<List<PartitionKeyRange>>> valueHolderMono = partitionKeyRangeCache\n+                .tryGetOverlappingRangesAsync(\n+                    BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n+                    collection.getResourceId(), RANGE_INCLUDING_ALL_PARTITION_KEY_RANGES, true, null);\n+\n+            return valueHolderMono.map(partitionKeyRangeListResponse -> {\n+                return toFeedRanges(partitionKeyRangeListResponse);\n+            });\n+        });\n+    }\n+\n+    private static List<FeedRange> toFeedRanges(\n+        Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) {\n+        final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v;\n+        if (partitionKeyRangeList == null) {\n+            throw new IllegalStateException(\"PartitionKeyRange list cannot be null\");\n+        }\n+\n+        List<FeedRange> feedRanges = new ArrayList<FeedRange>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDMzMg==", "bodyText": "our implementation is async. the async suffix not needed.\nhere and other places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525334332", "createdAt": "2020-11-17T17:08:16Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeAsyncVisitor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import reactor.core.publisher.Mono;\n+\n+abstract class FeedRangeAsyncVisitor<TResult> {\n+    public abstract Mono<TResult> visitAsync(FeedRangePartitionKeyImpl feedRange);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDU5Mw==", "bodyText": "ditto on Async suffix. as above.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525334593", "createdAt": "2020-11-17T17:08:38Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeAsyncVisitorWithArg.java", "diffHunk": "@@ -0,0 +1,15 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import reactor.core.publisher.Mono;\n+\n+abstract class FeedRangeAsyncVisitorWithArg<TResult, TArg> {\n+    public abstract Mono<TResult> visitAsync(FeedRangePartitionKeyImpl feedRange, TArg argument);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTIxMw==", "bodyText": "ranges.isEmpty()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525335213", "createdAt": "2020-11-17T17:09:36Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeCompositeContinuationImpl.java", "diffHunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.Integers;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.Strings;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxPartitionKeyRangeCache;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * FeedRangeContinuation using Composite Continuation Tokens and split proof.\n+ * It uses a breath-first approach to transverse Composite Continuation Tokens.\n+ */\n+final class FeedRangeCompositeContinuationImpl extends FeedRangeContinuation {\n+\n+    private final static ShouldRetryResult NO_RETRY = ShouldRetryResult.noRetry();\n+    private final static ShouldRetryResult RETRY = ShouldRetryResult.retryAfter(Duration.ZERO);\n+    private final Queue<CompositeContinuationToken> compositeContinuationTokens;\n+    private CompositeContinuationToken currentToken;\n+    private String initialNoResultsRange;\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges) {\n+\n+        this(containerRid, feedRange, ranges, null);\n+    }\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges,\n+        String continuation) {\n+\n+        this(containerRid, feedRange);\n+\n+        checkNotNull(ranges, \"'ranges' must not be null\");\n+\n+        if (ranges.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1MTQzNA==", "bodyText": "final List<Range<String>> feedRanges = new ArrayList<>(partitionKeyRangeList.size);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525351434", "createdAt": "2020-11-17T17:32:33Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeExtractorImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ResourceResponse;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.caches.RxPartitionKeyRangeCache;\n+import com.azure.cosmos.implementation.routing.Range;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+final class FeedRangePartitionKeyRangeExtractorImpl extends FeedRangeAsyncVisitor<List<Range<String>>> {\n+\n+    private final RxDocumentClientImpl client;\n+    private final String collectionLink;\n+\n+    public FeedRangePartitionKeyRangeExtractorImpl(\n+        RxDocumentClientImpl client,\n+        String collectionLink) {\n+\n+        checkNotNull(client, \"'client' must not be null\");\n+        checkNotNull(collectionLink, \"'collectionLink' must not be null\");\n+\n+        this.client = client;\n+        this.collectionLink = collectionLink;\n+    }\n+\n+    @Override\n+    public Mono<List<Range<String>>> visitAsync(FeedRangePartitionKeyImpl feedRange) {\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache =\n+            this.client.getPartitionKeyRangeCache();\n+        final Mono<ResourceResponse<DocumentCollection>> collectionResponseObservable = this.client\n+            .readCollection(this.collectionLink, null);\n+\n+        return collectionResponseObservable.flatMap(collectionResponse -> {\n+            final DocumentCollection collection = collectionResponse.getResource();\n+            return feedRange.getEffectiveRangesAsync(partitionKeyRangeCache,\n+                collection.getResourceId(),\n+                collection.getPartitionKey());\n+        });\n+    }\n+\n+    @Override\n+    public Mono<List<Range<String>>> visitAsync(FeedRangePartitionKeyRangeImpl feedRange) {\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache =\n+            this.client.getPartitionKeyRangeCache();\n+        final Mono<ResourceResponse<DocumentCollection>> collectionResponseObservable = this.client\n+            .readCollection(this.collectionLink, null);\n+\n+        return collectionResponseObservable.flatMap(collectionResponse -> {\n+            final DocumentCollection collection = collectionResponse.getResource();\n+            return feedRange.getEffectiveRangesAsync(partitionKeyRangeCache,\n+                collection.getResourceId(), null);\n+        });\n+    }\n+\n+    @Override\n+    public Mono<List<Range<String>>> visitAsync(FeedRangeEpkImpl feedRange) {\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache =\n+            this.client.getPartitionKeyRangeCache();\n+        final Mono<ResourceResponse<DocumentCollection>> collectionResponseObservable = this.client\n+            .readCollection(this.collectionLink, null);\n+\n+        final Mono<Utils.ValueHolder<List<PartitionKeyRange>>> valueHolderMono =\n+            collectionResponseObservable\n+                .flatMap(collectionResponse -> {\n+                    final DocumentCollection collection = collectionResponse.getResource();\n+                    return partitionKeyRangeCache.tryGetOverlappingRangesAsync(\n+                        BridgeInternal.getMetaDataDiagnosticContext(null),\n+                        collection.getResourceId(),\n+                        feedRange.getRange(), false, null);\n+                });\n+\n+        return valueHolderMono.map(FeedRangePartitionKeyRangeExtractorImpl::toFeedRanges);\n+    }\n+\n+    private static UnmodifiableList<Range<String>> toFeedRanges(\n+        final Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) {\n+        final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v;\n+        if (partitionKeyRangeList == null) {\n+            throw new IllegalStateException(\"PartitionKeyRange list cannot be null\");\n+        }\n+\n+        final List<Range<String>> feedRanges = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODY4OQ==", "bodyText": "header missing.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525368689", "createdAt": "2020-11-17T17:54:51Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/feedranges/FeedRangeTest.java", "diffHunk": "@@ -0,0 +1,503 @@\n+package com.azure.cosmos.implementation.feedranges;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDUxNQ==", "bodyText": "as an optimization; There are two public methods in the parent class (fromJsonString and toJsonString).\nas fromJsonString is the only to instantiate, you could cache the json value and return the same in the toJsonString", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525370515", "createdAt": "2020-11-17T17:57:25Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.FeedRange;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+\n+public abstract class FeedRangeInternal extends JsonSerializable implements FeedRange {\n+\n+    public abstract void accept(FeedRangeVisitor visitor);\n+\n+    public abstract <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input);\n+\n+    public abstract <T> Mono<T> acceptAsync(FeedRangeAsyncVisitor<T> visitor);\n+\n+    public static FeedRangeInternal convert(final FeedRange feedRange) {\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (feedRange instanceof FeedRangeInternal) {\n+            return (FeedRangeInternal)feedRange;\n+        }\n+\n+        String json = feedRange.toJsonString();\n+        return fromJsonString(json);\n+    }\n+\n+    /**\n+     * Creates a range from a previously obtained string representation.\n+     *\n+     * @param json A string representation of a feed range\n+     * @return A feed range\n+     */\n+    public static FeedRangeInternal fromJsonString(String json) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTIxNg==", "bodyText": "I would use checkNotNull pattern that you used elsewhere to be consistent and more succinct", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525371216", "createdAt": "2020-11-17T17:58:34Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -0,0 +1,161 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.PartitionKeyRangeGoneException;\n+import com.azure.cosmos.implementation.Utils.ValueHolder;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+\n+public final class FeedRangePartitionKeyRangeImpl extends FeedRangeInternal {\n+    private final String partitionKeyRangeId;\n+    private final PartitionKeyRangeIdentity partitionKeyRangeIdentity;\n+\n+    public FeedRangePartitionKeyRangeImpl(final String partitionKeyRangeId) {\n+        if (partitionKeyRangeId == null) {\n+            throw new NullPointerException(\"partitionKeyRangeId\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTM5Mw==", "bodyText": "I would use checkNotNull pattern that you used elsewhere to be consistent and more succinct.\nhere and everywhere else in the new code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525371393", "createdAt": "2020-11-17T17:58:49Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -0,0 +1,161 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.PartitionKeyRangeGoneException;\n+import com.azure.cosmos.implementation.Utils.ValueHolder;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+\n+public final class FeedRangePartitionKeyRangeImpl extends FeedRangeInternal {\n+    private final String partitionKeyRangeId;\n+    private final PartitionKeyRangeIdentity partitionKeyRangeIdentity;\n+\n+    public FeedRangePartitionKeyRangeImpl(final String partitionKeyRangeId) {\n+        if (partitionKeyRangeId == null) {\n+            throw new NullPointerException(\"partitionKeyRangeId\");\n+        }\n+\n+        this.partitionKeyRangeId = partitionKeyRangeId;\n+        this.partitionKeyRangeIdentity = new PartitionKeyRangeIdentity(partitionKeyRangeId);\n+    }\n+\n+    public String getPartitionKeyRangeId() {\n+        return this.partitionKeyRangeId;\n+    }\n+\n+    public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n+        return this.partitionKeyRangeIdentity;\n+    }\n+\n+    @Override\n+    public void accept(final FeedRangeVisitor visitor) {\n+        if (visitor == null) {\n+            throw new NullPointerException(\"visitor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5OTYzNg==", "bodyText": "why do we need the both version async and sync accept?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525399636", "createdAt": "2020-11-17T18:42:16Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+\n+final class FeedRangePartitionKeyImpl extends FeedRangeInternal {\n+    private final PartitionKeyInternal partitionKey;\n+\n+    public FeedRangePartitionKeyImpl(PartitionKeyInternal partitionKey) {\n+        if (partitionKey == null) {\n+            throw new NullPointerException(\"partitionKey\");\n+        }\n+\n+        this.partitionKey = partitionKey;\n+    }\n+\n+    public PartitionKeyInternal getPartitionKeyInternal() {\n+        return this.partitionKey;\n+    }\n+\n+    @Override\n+    public void accept(FeedRangeVisitor visitor) {\n+        if (visitor == null) {\n+            throw new NullPointerException(\"visitor\");\n+        }\n+\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzA4NTgw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#pullrequestreview-532708580", "createdAt": "2020-11-17T19:17:00Z", "commit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODEyMjM5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#pullrequestreview-532812239", "createdAt": "2020-11-17T21:06:30Z", "commit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMTowNjozMFrOH1LeEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMToyNjo0N1rOH1MH9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNDQ5OA==", "bodyText": "Shouldn't this be Flux<FeedRange> or CosmosPagedFlux<FeedRange> ? What is the benefit of Mono<List<FeedRange>> - as that will always have just one list of FeedRange ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525524498", "createdAt": "2020-11-17T21:06:30Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -1124,4 +1125,15 @@ String getLink() {\n     ItemDeserializer getItemDeserializer() {\n         return getDatabase().getDocClientWrapper().getItemDeserializer();\n     }\n+\n+    /**\n+     * Obtains a list of {@link FeedRange} that can be used to parallelize Feed\n+     * operations.\n+     *\n+     * @return An unmodifiable list of {@link FeedRange}\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public Mono<List<FeedRange>> getFeedRanges() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTAzMg==", "bodyText": "I am fine with List as compared to Iterable - as it gives user more flexibility on not having to cast it to lists or other >Iterables.\nThough I am wondering why are we not using CosmosPagedIterable<FeedRange>\n\n\nfabianm (response): Reason for using List of Iterable was that size will be often used by callers. Not using ComsosPagedIterable because it will always be exactly one page (IO op)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525525032", "createdAt": "2020-11-17T21:07:28Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -556,4 +557,23 @@ public CosmosScripts getScripts() {\n         return UtilBridgeInternal.createCosmosPagedIterable(cosmosPagedFlux);\n     }\n \n+    /**\n+     * Obtains a list of {@link FeedRange} that can be used to parallelize Feed\n+     * operations.\n+     *\n+     * @return An unmodifiable list of {@link FeedRange}\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public List<FeedRange> getFeedRanges() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNTQ2Ng=="}, "originalCommit": {"oid": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjE2NQ==", "bodyText": "What about 304 (NOT_MODIFIED) - does that not count in maximum success code?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525526165", "createdAt": "2020-11-17T21:09:48Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/HttpConstants.java", "diffHunk": "@@ -272,6 +272,9 @@\n     public static class StatusCodes {\n         public static final int OK = 200;\n         public static final int NOT_MODIFIED = 304;\n+        // Success\n+        public static final int MINIMUM_SUCCESS_STATUSCODE = 200;\n+        public static final int MAXIMUM_SUCCESS_STATUSCODE = 299;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyOTg2Nw==", "bodyText": "NIT: Can be final.\nAlso, we can use of java streams as well -\nfinal List<FeedRange> feedRanges = partitionKeyRangeList.stream().map(pkRange -> toFeedRange(pkRange)).collect(Collectors.toList())", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525529867", "createdAt": "2020-11-17T21:16:50Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -3634,4 +3641,56 @@ private static SqlQuerySpec createLogicalPartitionScanQuerySpec(\n \n         return new SqlQuerySpec(queryStringBuilder.toString(), parameters);\n     }\n+\n+    @Override\n+    public Mono<List<FeedRange>> getFeedRanges(String collectionLink) {\n+\n+        if (StringUtils.isEmpty(collectionLink)) {\n+            throw new IllegalArgumentException(\"collectionLink\");\n+        }\n+\n+        RxDocumentServiceRequest request = RxDocumentServiceRequest.create(\n+            this,\n+            OperationType.Query,\n+            ResourceType.Document,\n+            collectionLink,\n+            null); // This should not go to backend\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionObs = collectionCache.resolveCollectionAsync(null,\n+            request);\n+\n+        return collectionObs.flatMap(documentCollectionResourceResponse -> {\n+            final DocumentCollection collection = documentCollectionResourceResponse.v;\n+            if (collection == null) {\n+                throw new IllegalStateException(\"Collection cannot be null\");\n+            }\n+\n+            Mono<Utils.ValueHolder<List<PartitionKeyRange>>> valueHolderMono = partitionKeyRangeCache\n+                .tryGetOverlappingRangesAsync(\n+                    BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n+                    collection.getResourceId(), RANGE_INCLUDING_ALL_PARTITION_KEY_RANGES, true, null);\n+\n+            return valueHolderMono.map(partitionKeyRangeListResponse -> {\n+                return toFeedRanges(partitionKeyRangeListResponse);\n+            });\n+        });\n+    }\n+\n+    private static List<FeedRange> toFeedRanges(\n+        Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) {\n+        final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v;\n+        if (partitionKeyRangeList == null) {\n+            throw new IllegalStateException(\"PartitionKeyRange list cannot be null\");\n+        }\n+\n+        List<FeedRange> feedRanges = new ArrayList<FeedRange>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzAwNw=="}, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMDU2MQ==", "bodyText": "I am afraid to disagree here - this is not a nit :)\nWe need to have the license before this can go in.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525530561", "createdAt": "2020-11-17T21:18:16Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ShouldRetryResult.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.azure.cosmos.implementation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMzIwNw=="}, "originalCommit": {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMTg5OA==", "bodyText": "I agree, we should just keep the async word in the class name, and remove it from the APIs.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525531898", "createdAt": "2020-11-17T21:20:42Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeAsyncVisitor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import reactor.core.publisher.Mono;\n+\n+abstract class FeedRangeAsyncVisitor<TResult> {\n+    public abstract Mono<TResult> visitAsync(FeedRangePartitionKeyImpl feedRange);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDMzMg=="}, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTIyMg==", "bodyText": "Should we log the exception here for our own debugging purposes?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525535222", "createdAt": "2020-11-17T21:26:47Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeCompositeContinuationImpl.java", "diffHunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.Integers;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.Strings;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxPartitionKeyRangeCache;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * FeedRangeContinuation using Composite Continuation Tokens and split proof.\n+ * It uses a breath-first approach to transverse Composite Continuation Tokens.\n+ */\n+final class FeedRangeCompositeContinuationImpl extends FeedRangeContinuation {\n+\n+    private final static ShouldRetryResult NO_RETRY = ShouldRetryResult.noRetry();\n+    private final static ShouldRetryResult RETRY = ShouldRetryResult.retryAfter(Duration.ZERO);\n+    private final Queue<CompositeContinuationToken> compositeContinuationTokens;\n+    private CompositeContinuationToken currentToken;\n+    private String initialNoResultsRange;\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges) {\n+\n+        this(containerRid, feedRange, ranges, null);\n+    }\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges,\n+        String continuation) {\n+\n+        this(containerRid, feedRange);\n+\n+        checkNotNull(ranges, \"'ranges' must not be null\");\n+\n+        if (ranges.size() == 0) {\n+            throw new IllegalArgumentException(\"'ranges' must not be empty\");\n+        }\n+\n+        for (Range<String> range : ranges) {\n+            this.compositeContinuationTokens.add(\n+                FeedRangeCompositeContinuationImpl.createCompositeContinuationTokenForRange(\n+                    range.getMin(),\n+                    range.getMax(),\n+                    continuation)\n+            );\n+        }\n+\n+        this.currentToken = this.getCompositeContinuationTokens().peek();\n+    }\n+\n+    private FeedRangeCompositeContinuationImpl(String containerRid, FeedRangeInternal feedRange) {\n+        super(containerRid, feedRange);\n+\n+        this.compositeContinuationTokens = new LinkedList<>();\n+    }\n+\n+    public Queue<CompositeContinuationToken> getCompositeContinuationTokens() {\n+        return compositeContinuationTokens;\n+    }\n+\n+    public CompositeContinuationToken getCurrentToken() {\n+        return this.currentToken;\n+    }\n+\n+    @Override\n+    public FeedRangeInternal getFeedRange() {\n+        if (!(this.feedRange instanceof FeedRangeEpkImpl)) {\n+            return this.feedRange;\n+        }\n+\n+        if (this.currentToken != null) {\n+            return new FeedRangeEpkImpl(this.currentToken.getRange());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String getContinuation() {\n+        CompositeContinuationToken tokenSnapshot = this.currentToken;\n+        if (tokenSnapshot == null) {\n+            return null;\n+        }\n+\n+        return tokenSnapshot.getToken();\n+    }\n+\n+    @Override\n+    public void replaceContinuation(final String continuationToken) {\n+        final CompositeContinuationToken continuationTokenSnapshot = this.currentToken;\n+\n+        if (continuationTokenSnapshot == null) {\n+            return;\n+        }\n+\n+        continuationTokenSnapshot.setToken(continuationToken);\n+        this.moveToNextToken();\n+    }\n+\n+    @Override\n+    public boolean isDone() {\n+        return this.compositeContinuationTokens.size() == 0;\n+    }\n+\n+    @Override\n+    public void validateContainer(final String containerRid) throws IllegalArgumentException {\n+        if (Strings.isNullOrEmpty(containerRid) || !containerRid.equals(this.getContainerRid())) {\n+\n+            final String message = String.format(\n+                \"The continuation was generated for container %s but current container is %s.\",\n+                this.getContainerRid(), containerRid);\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    @Override\n+    public ShouldRetryResult handleChangeFeedNotModified(final RxDocumentServiceResponse response) {\n+        if (response == null) {\n+            throw new NullPointerException(\"response\");\n+        }\n+\n+        final int statusCode = response.getStatusCode();\n+        if (statusCode >= HttpConstants.StatusCodes.MINIMUM_SUCCESS_STATUSCODE\n+            && statusCode <= HttpConstants.StatusCodes.MAXIMUM_SUCCESS_STATUSCODE) {\n+\n+            this.initialNoResultsRange = null;\n+            return NO_RETRY;\n+        }\n+\n+        if (statusCode == HttpConstants.StatusCodes.NOT_MODIFIED && this.compositeContinuationTokens.size() > 1) {\n+\n+            final String eTag = response.getResponseHeaders().get(HttpConstants.HttpHeaders.E_TAG);\n+            if (this.initialNoResultsRange == null) {\n+\n+                this.initialNoResultsRange = this.currentToken.getRange().getMin();\n+                this.replaceContinuation(eTag);\n+                return RETRY;\n+            }\n+\n+            if (!this.initialNoResultsRange.equalsIgnoreCase(this.currentToken.getRange().getMin())) {\n+                this.replaceContinuation(eTag);\n+                return RETRY;\n+            }\n+        }\n+\n+        return NO_RETRY;\n+    }\n+\n+    @Override\n+    public Mono<ShouldRetryResult> handleSplitAsync(final RxDocumentClientImpl client,\n+                                                    final RxDocumentServiceResponse response) {\n+\n+        if (client == null) {\n+            throw new NullPointerException(\"client\");\n+        }\n+\n+        if (response == null) {\n+            throw new NullPointerException(\"response\");\n+        }\n+\n+        Integer nSubStatus = 0;\n+        final String valueSubStatus =\n+            response.getResponseHeaders().get(HttpConstants.HttpHeaders.SUB_STATUS);\n+        if (!Strings.isNullOrEmpty(valueSubStatus)) {\n+            nSubStatus = Integers.tryParse(valueSubStatus);\n+        }\n+\n+        final boolean partitionSplit =\n+            response.getStatusCode() == HttpConstants.StatusCodes.GONE && nSubStatus != null\n+                && (nSubStatus == HttpConstants.SubStatusCodes.PARTITION_KEY_RANGE_GONE\n+                || nSubStatus == HttpConstants.SubStatusCodes.COMPLETING_SPLIT);\n+\n+        if (!partitionSplit) {\n+            return Mono.just(NO_RETRY);\n+        }\n+\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache = client.getPartitionKeyRangeCache();\n+        final Mono<Utils.ValueHolder<List<PartitionKeyRange>>> resolvedRangesTask =\n+            this.tryGetOverlappingRangesAsync(\n+                partitionKeyRangeCache, this.currentToken.getRange().getMin(),\n+                this.currentToken.getRange().getMax(),\n+                true);\n+\n+        return resolvedRangesTask.flatMap(resolvedRanges -> {\n+            if (resolvedRanges.v != null && resolvedRanges.v.size() > 0) {\n+                this.createChildRanges(resolvedRanges.v);\n+            }\n+\n+            return Mono.just(RETRY);\n+        });\n+    }\n+\n+    @Override\n+    public void accept(final FeedRangeContinuationVisitor visitor) {\n+        if (visitor == null) {\n+            throw new NullPointerException(\"visitor\");\n+        }\n+\n+        visitor.visit(this);\n+    }\n+\n+    /**\n+     * Used for deserializtion only\n+     */\n+    public static FeedRangeCompositeContinuationImpl createFromDeserializedTokens(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<CompositeContinuationToken> deserializedTokens) {\n+\n+        FeedRangeCompositeContinuationImpl thisPtr =\n+            new FeedRangeCompositeContinuationImpl(containerRid, feedRange);\n+\n+        checkNotNull(deserializedTokens, \"'deserializedTokens' must not be null\");\n+\n+        if (deserializedTokens.size() == 0) {\n+            throw new IllegalArgumentException(\"'deserializedTokens' must not be empty\");\n+        }\n+\n+        thisPtr.compositeContinuationTokens.addAll(deserializedTokens);\n+\n+        thisPtr.currentToken = thisPtr.getCompositeContinuationTokens().peek();\n+\n+        return thisPtr;\n+    }\n+\n+    public static FeedRangeContinuation parse(final String jsonString) throws IOException {\n+        if (jsonString == null) {\n+            throw new NullPointerException(\"jsonString\");\n+        }\n+\n+        final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n+\n+        return mapper.readValue(jsonString, FeedRangeCompositeContinuationImpl.class);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        try {\n+            return Utils.getSimpleObjectMapper().writeValueAsString(this);\n+        } catch (final IOException e) {\n+            throw new IllegalArgumentException(\n+                \"Unable serialize the composite FeedRange continuation token into a JSON string\",\n+                e);\n+        }\n+    }\n+\n+    private void createChildRanges(final List<PartitionKeyRange> keyRanges) {\n+        final PartitionKeyRange firstRange = keyRanges.get(0);\n+        this.currentToken\n+            .setRange(new Range<>(firstRange.getMinInclusive(),\n+                firstRange.getMaxExclusive(), true, false));\n+\n+        final CompositeContinuationToken continuationAsComposite =\n+            tryParseAsCompositeContinuationToken(\n+                this.currentToken.getToken());\n+\n+        if (continuationAsComposite != null) {\n+            // Update the internal composite continuation\n+            continuationAsComposite.setRange(this.currentToken.getRange());\n+            this.currentToken.setToken(continuationAsComposite.toJson());\n+            // Add children\n+            final int size = keyRanges.size();\n+            for (int i = 1; i < size; i++) {\n+                final PartitionKeyRange keyRange = keyRanges.get(i);\n+                continuationAsComposite.setRange(keyRange.toRange());\n+                this.compositeContinuationTokens.add(createCompositeContinuationTokenForRange(\n+                    keyRange.getMinInclusive(), keyRange.getMaxExclusive(),\n+                    continuationAsComposite.toJson()));\n+            }\n+        } else {\n+            // Add children\n+            final int size = keyRanges.size();\n+            for (int i = 1; i < size; i++) {\n+                final PartitionKeyRange keyRange = keyRanges.get(i);\n+                this.compositeContinuationTokens.add(createCompositeContinuationTokenForRange(\n+                    keyRange.getMinInclusive(), keyRange.getMaxExclusive(),\n+                    this.currentToken.getToken()));\n+            }\n+        }\n+    }\n+\n+    private static CompositeContinuationToken createCompositeContinuationTokenForRange(\n+        String minInclusive,\n+        String maxExclusive,\n+        String token) {\n+        return new CompositeContinuationToken(\n+            token,\n+            new Range<>(minInclusive, maxExclusive, true, false));\n+    }\n+\n+    private void moveToNextToken() {\n+        final CompositeContinuationToken recentToken = this.compositeContinuationTokens.poll();\n+        if (recentToken.getToken() != null) {\n+            // Normal ReadFeed can signal termination by CT null, not NotModified\n+            // Change Feed never lands here, as it always provides a CT\n+            // Consider current range done, if this FeedToken contains multiple ranges due\n+            // to splits,\n+            // all of them need to be considered done\n+            this.compositeContinuationTokens.add(recentToken);\n+        }\n+\n+        if (this.compositeContinuationTokens.size() > 0) {\n+            this.currentToken = this.compositeContinuationTokens.peek();\n+        } else {\n+            this.currentToken = null;\n+        }\n+    }\n+\n+    private Mono<Utils.ValueHolder<List<PartitionKeyRange>>> tryGetOverlappingRangesAsync(\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache, final String min, final String max,\n+        final Boolean forceRefresh) {\n+\n+        return partitionKeyRangeCache.tryGetOverlappingRangesAsync(null, this.getContainerRid(),\n+            new Range<>(min, max, false, true), forceRefresh, null);\n+    }\n+\n+    private static CompositeContinuationToken tryParseAsCompositeContinuationToken(\n+        final String providedContinuation) {\n+\n+        try {\n+            final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n+\n+            if (providedContinuation.trim().startsWith(\"[\")) {\n+                final List<CompositeContinuationToken> compositeContinuationTokens = Arrays\n+                    .asList(mapper.readValue(providedContinuation,\n+                        CompositeContinuationToken[].class));\n+\n+                if (compositeContinuationTokens.size() > 0) {\n+                    return compositeContinuationTokens.get(0);\n+                }\n+\n+                return null;\n+            } else if (providedContinuation.trim().startsWith(\"{\")) {\n+                return mapper.readValue(providedContinuation, CompositeContinuationToken.class);\n+            }\n+\n+            return null;\n+        } catch (final IOException ioError) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36"}, "originalPosition": 363}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a4be2758a9872c554b3a73e74cecb6cdb2691c2", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a4be2758a9872c554b3a73e74cecb6cdb2691c2", "committedDate": "2020-11-17T23:37:46Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ac208ae1698576552b9455cf224391866055d91", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ac208ae1698576552b9455cf224391866055d91", "committedDate": "2020-11-17T23:38:04Z", "message": "Reacting to code review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyOTY4NTE1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#pullrequestreview-532968515", "createdAt": "2020-11-18T01:54:53Z", "commit": {"oid": "8ac208ae1698576552b9455cf224391866055d91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMTo1NDo1M1rOH1SwVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMTo1NDo1M1rOH1SwVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0Mzg2Mg==", "bodyText": "use slf4j logger placeholder instead of %s\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.debug(\"Failed to parse feed range JSON %s\", jsonString, ioError);\n          \n          \n            \n                        LOGGER.debug(\"Failed to parse feed range JSON {}\", jsonString, ioError);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525643862", "createdAt": "2020-11-18T01:54:53Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java", "diffHunk": "@@ -88,32 +83,36 @@ public String toJsonString() {\n         return this.toJson();\n     }\n \n-    public static FeedRangeInternal tryParse(final String jsonString) throws IOException {\n-        if (jsonString == null) {\n-            throw new NullPointerException(\"jsonString\");\n-        }\n-\n+    public static FeedRangeInternal tryParse(final String jsonString) {\n+        checkNotNull(jsonString, \"Argument 'jsonString' must not be null\");\n         final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n-        JsonNode rootNode = mapper.readTree(jsonString);\n-\n-        JsonNode rangeNode = rootNode.get(Constants.Properties.RANGE);\n-        if (rangeNode != null && rangeNode.isObject()) {\n-            Range<String> range = new Range<>((ObjectNode)rangeNode);\n-            return new FeedRangeEpkImpl(range);\n-        }\n \n-        JsonNode pkNode = rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY);\n-        if (pkNode != null && pkNode.isArray()) {\n-            PartitionKeyInternal pk = mapper.convertValue(pkNode, PartitionKeyInternal.class);\n-            return new FeedRangePartitionKeyImpl(pk);\n-        }\n-\n-        JsonNode pkRangeIdNode =\n-            rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID);\n-        if (pkRangeIdNode != null && pkRangeIdNode.isTextual()) {\n-            return new FeedRangePartitionKeyRangeImpl(pkRangeIdNode.asText());\n+        try {\n+            JsonNode rootNode = mapper.readTree(jsonString);\n+\n+            JsonNode rangeNode = rootNode.get(Constants.Properties.RANGE);\n+            if (rangeNode != null && rangeNode.isObject()) {\n+                Range<String> range = new Range<>((ObjectNode)rangeNode);\n+                return new FeedRangeEpkImpl(range);\n+            }\n+\n+            JsonNode pkNode = rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY);\n+            if (pkNode != null && pkNode.isArray()) {\n+                PartitionKeyInternal pk = mapper.convertValue(pkNode, PartitionKeyInternal.class);\n+                return new FeedRangePartitionKeyImpl(pk);\n+            }\n+\n+            JsonNode pkRangeIdNode =\n+                rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID);\n+            if (pkRangeIdNode != null && pkRangeIdNode.isTextual()) {\n+                return new FeedRangePartitionKeyRangeImpl(pkRangeIdNode.asText());\n+            }\n+\n+            return null;\n+\n+        } catch (final IOException ioError) {\n+            LOGGER.debug(\"Failed to parse feed range JSON %s\", jsonString, ioError);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac208ae1698576552b9455cf224391866055d91"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMDgyOTI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#pullrequestreview-533082927", "createdAt": "2020-11-18T03:44:24Z", "commit": {"oid": "8ac208ae1698576552b9455cf224391866055d91"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee60826fd826592633307c2758075d424564f406", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ee60826fd826592633307c2758075d424564f406", "committedDate": "2020-11-18T14:06:37Z", "message": "Update sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java\n\nCo-authored-by: Mohammad Derakhshani <moderakh@users.noreply.github.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1708, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}