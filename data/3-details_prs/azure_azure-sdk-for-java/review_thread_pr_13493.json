{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NDIzNzcz", "number": 13493, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NDoxOVrOER7nmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NToxN1rOER7osg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjM4MDQzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NDoxOVrOG26UAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOToyMjozOFrOG27GSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTY4Mg==", "bodyText": "Do 304 classified as non body status code ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460231682", "createdAt": "2020-07-24T18:54:19Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNzQyMQ==", "bodyText": "Yes, 304 will be a non body status code", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460237421", "createdAt": "2020-07-24T19:06:46Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTY4Mg=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NDU1Mg==", "bodyText": "So lets add that here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460244552", "createdAt": "2020-07-24T19:22:38Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTY4Mg=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjM4MjI1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NDo1N1rOG26VIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOToyOToxMVrOG27Rzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTk3MQ==", "bodyText": "I think some of 4xx error codes from Cosmos (e.g., 400 query plan) also have body.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460231971", "createdAt": "2020-07-24T18:54:57Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||\n+                method.equals(HttpMethod.HEAD) || headers().getContentLength() == 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MzM1MA==", "bodyText": "Would these be considered as error or success ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460243350", "createdAt": "2020-07-24T19:20:07Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||\n+                method.equals(HttpMethod.HEAD) || headers().getContentLength() == 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTk3MQ=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NDQzNg==", "bodyText": "this condition is already returning true for 4xx, isn't ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460244436", "createdAt": "2020-07-24T19:22:24Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||\n+                method.equals(HttpMethod.HEAD) || headers().getContentLength() == 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTk3MQ=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NzUwMg==", "bodyText": "Yes it is.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460247502", "createdAt": "2020-07-24T19:29:11Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||\n+                method.equals(HttpMethod.HEAD) || headers().getContentLength() == 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTk3MQ=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjM4MzIyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NToxN1rOG26VxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOToyNjoyNlrOG27NDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMjEzMg==", "bodyText": "Do we need mayHaveBody check , what happen if we clear on all cancel irrespective of body, we can avoid extra check ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460232132", "createdAt": "2020-07-24T18:55:17Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzODU3Mg==", "bodyText": "Since we are draining content here, we want to make sure we drain it under very specific conditions, specially when the body can be present.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460238572", "createdAt": "2020-07-24T19:09:14Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMjEzMg=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NjI4NA==", "bodyText": "That is fine ,but my doubt is if some valid response miss mayHaveBody  (due to any missed scenario), then we will still face issue , vs draining non body too along with body response (Its a trade off thing )", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460246284", "createdAt": "2020-07-24T19:26:26Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMjEzMg=="}, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 148}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4837, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}