{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMjk5Mzcw", "number": 9283, "title": "[Storage] Blob versioning.", "bodyText": "See https://review.docs.microsoft.com/en-us/azure/storage/blobs/versioning-overview?branch=pr-en-us-104390&tabs=powershell#blob-versioning-and-soft-delete .", "createdAt": "2020-03-20T00:31:27Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283", "merged": true, "mergeCommit": {"oid": "d69ec0e1798dd3d8cab3b38edfb56c0c3d7ef164"}, "closed": true, "closedAt": "2020-04-10T21:21:48Z", "author": {"login": "kasobol-msft"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOq4ZTAH2gAyMzkxMjk5MzcwOmZmZGVmZmMzMWRlNjIxZjVjZmU3ZjYwYWYxYTZiYWI2ZDE2YTFiYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWXWTyAH2gAyMzkxMjk5MzcwOmJkNzQ2NWFiYWIzNDA5NTEyOGJhNTkxMDc2ZTU4YjkxMTQ5ZGNiZjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ffdeffc31de621f5cfe7f60af1a6bab6d16a1bc2", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffdeffc31de621f5cfe7f60af1a6bab6d16a1bc2", "committedDate": "2020-03-17T22:58:38Z", "message": "create version and read version."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2ae5b127796ab75b498a1b7c4a7fc27b23726f2", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2ae5b127796ab75b498a1b7c4a7fc27b23726f2", "committedDate": "2020-03-18T23:50:16Z", "message": "Delete blob by version."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ef374d201b8d950a9a5107950bb50bbc112ce54", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ef374d201b8d950a9a5107950bb50bbc112ce54", "committedDate": "2020-03-19T20:13:06Z", "message": "Regenerate blob client."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "526098bcc948792244a6296e89c2e93fb092f56b", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/526098bcc948792244a6296e89c2e93fb092f56b", "committedDate": "2020-03-19T20:34:14Z", "message": "Generate client one more time."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbf63e263098de95ee9d81c923822c144f9d97fe", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbf63e263098de95ee9d81c923822c144f9d97fe", "committedDate": "2020-03-19T21:29:38Z", "message": "List blob and blob properties."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c16542496614b2b2d0a749305afe441084a5490", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c16542496614b2b2d0a749305afe441084a5490", "committedDate": "2020-03-19T23:28:42Z", "message": "Copy and get properties."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a894d50270c92a80a9cdccfb1e3eec2229fed23", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4a894d50270c92a80a9cdccfb1e3eec2229fed23", "committedDate": "2020-03-20T00:18:51Z", "message": "Snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ee6c4d78b8999b322cb3b1d730d65f4b956d9ca", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ee6c4d78b8999b322cb3b1d730d65f4b956d9ca", "committedDate": "2020-03-20T00:25:25Z", "message": "Recordings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a2ebd2bcd3b70372f4678a42f5bd1c3a08e9d98", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a2ebd2bcd3b70372f4678a42f5bd1c3a08e9d98", "committedDate": "2020-03-20T00:30:27Z", "message": "Recordings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43ea3124d55ba3fd48e35e783303c2e666722f34", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/43ea3124d55ba3fd48e35e783303c2e666722f34", "committedDate": "2020-03-20T00:55:24Z", "message": "Fix checkstyle errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ca9c6984de25b9633388f274c8b33cdf1cb6bc4", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ca9c6984de25b9633388f274c8b33cdf1cb6bc4", "committedDate": "2020-03-20T01:00:53Z", "message": "Recordings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf8a98f29d6b0140d8369bc94d508eaab22be5ff", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf8a98f29d6b0140d8369bc94d508eaab22be5ff", "committedDate": "2020-03-20T01:02:31Z", "message": "undo readme."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5e27d190d1bc71e5770169aada677b0a0a4a81f", "committedDate": "2020-03-20T01:07:38Z", "message": "make test compatible with java 8"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjU3NTA4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-378657508", "createdAt": "2020-03-20T16:59:01Z", "commit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjo1OTowMVrOF5b7TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjo1OTowMVrOF5b7TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MDcwMQ==", "bodyText": "Is it legal for a url to have a snapshot and a versionId? I would guess not, and it may be worth validating that here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395770701", "createdAt": "2020-03-20T16:59:01Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobClientBuilder.java", "diffHunk": "@@ -151,7 +152,7 @@ public EncryptedBlobAsyncClient buildEncryptedBlobAsyncClient() {\n \n         return new EncryptedBlobAsyncClient(getHttpPipeline(),\n             String.format(\"%s/%s/%s\", endpoint, containerName, blobName), serviceVersion, accountName, containerName,\n-            blobName, snapshot, customerProvidedKey, keyWrapper, keyWrapAlgorithm);\n+            blobName, snapshot, customerProvidedKey, keyWrapper, keyWrapAlgorithm, versionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Njc4Nzcw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-378678770", "createdAt": "2020-03-20T17:27:56Z", "commit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyNzo1NlrOF5c66A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyNzo1NlrOF5c66A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4Njk4NA==", "bodyText": "I think retrieve, properties, and delete are independent of blob type and should share the same code path regardless of blob type, so it may be better to only test that once.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395786984", "createdAt": "2020-03-20T17:27:56Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Njc5Mjgw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-378679280", "createdAt": "2020-03-20T17:28:42Z", "commit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyODo0MlrOF5c8eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyODo0MlrOF5c8eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4NzM4NA==", "bodyText": "nit: we usually use download instead of retrieve and get properties instead of retrieve properties for test naming", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395787384", "createdAt": "2020-03-20T17:28:42Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getBlockBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Retrieve Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getPageBlobClient().download(outputV2)\n+\n+        then:\n+        Arrays.equals(contentV1, outputV1.toByteArray())\n+        Arrays.equals(contentV2, outputV2.toByteArray())\n+    }\n+\n+    def \"Retrieve Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getAppendBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Delete Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Retrieve Block Blob Properties by Version\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjgwMTQ0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-378680144", "createdAt": "2020-03-20T17:29:54Z", "commit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyOTo1NFrOF5c_PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyOTo1NFrOF5c_PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODA5Mg==", "bodyText": "We shouldn't have to index into the raw headers to get this value. Maybe swagger needs to be updated to add this field to the deserialized headers?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395788092", "createdAt": "2020-03-20T17:29:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getBlockBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Retrieve Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getPageBlobClient().download(outputV2)\n+\n+        then:\n+        Arrays.equals(contentV1, outputV1.toByteArray())\n+        Arrays.equals(contentV2, outputV2.toByteArray())\n+    }\n+\n+    def \"Retrieve Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getAppendBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Delete Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Retrieve Block Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def responseV2 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getBlockBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Page Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def responseV2 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getPageBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Append Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        def responseV2 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getAppendBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"List Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(true)), null)\n+\n+        then:\n+        blobs.size() == 3\n+        blobs[0].getVersionId() == blobItemV1.getVersionId()\n+        blobs[1].getVersionId() == blobItemV2.getVersionId()\n+        blobs[2].getVersionId() == blobItemV3.getVersionId()\n+        blobs[0].isCurrentVersion() == null\n+        blobs[1].isCurrentVersion() == null\n+        blobs[2].isCurrentVersion()\n+    }\n+\n+    def \"List Blobs without Version\"() {\n+        given:\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(false)), null)\n+\n+        then:\n+        blobs.size() == 1\n+        blobs[0].getVersionId() == blobItemV3.getVersionId()\n+    }\n+\n+    def \"Begin Copy Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def pooler = blobClient.beginCopy(sourceBlob.getBlobUrl(), Duration.ofSeconds(1))\n+        def copyInfo = pooler.waitForCompletion().getValue()\n+\n+        then:\n+        copyInfo.getVersionId() != null\n+        copyInfo.getVersionId() != blobItemV1.getVersionId()\n+    }\n+\n+    def \"Copy From Url Blobs with Version\"() {\n+        given:\n+        blobContainerClient.setAccessPolicy(PublicAccessType.CONTAINER, null)\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def response = blobClient.copyFromUrlWithResponse(sourceBlob.getBlobUrl(), null, null, null, null, null, Context.NONE)\n+        def versionIdAfterCopy = response.getHeaders().getValue(\"x-ms-version-id\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "originalPosition": 307}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Njg1MDc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-378685076", "createdAt": "2020-03-20T17:36:54Z", "commit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzozNjo1NFrOF5dN_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzozNjo1NFrOF5dN_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MTg3MQ==", "bodyText": "It may also be worth testing copying from a non-current version. Or at least testing getBlobUrl and ensuring that the version query parameter is present", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395791871", "createdAt": "2020-03-20T17:36:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getBlockBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Retrieve Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getPageBlobClient().download(outputV2)\n+\n+        then:\n+        Arrays.equals(contentV1, outputV1.toByteArray())\n+        Arrays.equals(contentV2, outputV2.toByteArray())\n+    }\n+\n+    def \"Retrieve Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getAppendBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Delete Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Retrieve Block Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def responseV2 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getBlockBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Page Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def responseV2 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getPageBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Append Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        def responseV2 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getAppendBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"List Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(true)), null)\n+\n+        then:\n+        blobs.size() == 3\n+        blobs[0].getVersionId() == blobItemV1.getVersionId()\n+        blobs[1].getVersionId() == blobItemV2.getVersionId()\n+        blobs[2].getVersionId() == blobItemV3.getVersionId()\n+        blobs[0].isCurrentVersion() == null\n+        blobs[1].isCurrentVersion() == null\n+        blobs[2].isCurrentVersion()\n+    }\n+\n+    def \"List Blobs without Version\"() {\n+        given:\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(false)), null)\n+\n+        then:\n+        blobs.size() == 1\n+        blobs[0].getVersionId() == blobItemV3.getVersionId()\n+    }\n+\n+    def \"Begin Copy Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def pooler = blobClient.beginCopy(sourceBlob.getBlobUrl(), Duration.ofSeconds(1))\n+        def copyInfo = pooler.waitForCompletion().getValue()\n+\n+        then:\n+        copyInfo.getVersionId() != null\n+        copyInfo.getVersionId() != blobItemV1.getVersionId()\n+    }\n+\n+    def \"Copy From Url Blobs with Version\"() {\n+        given:\n+        blobContainerClient.setAccessPolicy(PublicAccessType.CONTAINER, null)\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def response = blobClient.copyFromUrlWithResponse(sourceBlob.getBlobUrl(), null, null, null, null, null, Context.NONE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f"}, "originalPosition": 306}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "committedDate": "2020-03-23T17:35:30Z", "message": "pr feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9e3a8c5f7b5a737cff85be906327911826ea72c", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c9e3a8c5f7b5a737cff85be906327911826ea72c", "committedDate": "2020-03-23T21:06:28Z", "message": "version delete sas permission (x)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ee2af67f235671c81cfcf01436f775ba0117c8d", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ee2af67f235671c81cfcf01436f775ba0117c8d", "committedDate": "2020-03-23T21:19:43Z", "message": "get client by version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88342b91f19b0ebc9902a5544e460b4f12d42b40", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/88342b91f19b0ebc9902a5544e460b4f12d42b40", "committedDate": "2020-03-23T21:38:48Z", "message": "recordings."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODgyNTg5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-379882589", "createdAt": "2020-03-23T22:53:12Z", "commit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjo1MzoxM1rOF6bDMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjo1MzoxM1rOF6bDMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNDkxNQ==", "bodyText": "typo - \"the a\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396804915", "createdAt": "2020-03-23T22:53:13Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobProperties.java", "diffHunk": "@@ -355,4 +420,18 @@ public OffsetDateTime getAccessTierChangeTime() {\n     public Integer getCommittedBlockCount() {\n         return committedBlockCount;\n     }\n+\n+    /**\n+     * @return the version identifier the blob.\n+     */\n+    public String getVersionId() {\n+        return versionId;\n+    }\n+\n+    /**\n+     * @return the a flag indicating whether version identifier points to current version of the blob.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODgyODIy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-379882822", "createdAt": "2020-03-23T22:53:41Z", "commit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjo1Mzo0MVrOF6bEqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjo1Mzo0MVrOF6bEqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNTI5MA==", "bodyText": "\"Flag indicating\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396805290", "createdAt": "2020-03-23T22:53:41Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobProperties.java", "diffHunk": "@@ -95,6 +97,67 @@ public BlobProperties(final OffsetDateTime creationTime, final OffsetDateTime la\n         final Boolean isAccessTierInferred, final ArchiveStatus archiveStatus, final String encryptionKeySha256,\n         final OffsetDateTime accessTierChangeTime, final Map<String, String> metadata,\n         final Integer committedBlockCount) {\n+        this(creationTime, lastModified, eTag, blobSize, contentType, contentMd5, contentEncoding, contentDisposition,\n+             contentLanguage, cacheControl, blobSequenceNumber, blobType, leaseStatus, leaseState, leaseDuration,\n+            copyId, copyStatus, copySource, copyProgress, copyCompletionTime, copyStatusDescription, isServerEncrypted,\n+            isIncrementalCopy, copyDestinationSnapshot, accessTier, isAccessTierInferred, archiveStatus,\n+            encryptionKeySha256, accessTierChangeTime, metadata, committedBlockCount, null, null);\n+    }\n+\n+    /**\n+     * Constructs a {@link BlobProperties}.\n+     *\n+     * @param creationTime Creation time of the blob.\n+     * @param lastModified Datetime when the blob was last modified.\n+     * @param eTag ETag of the blob.\n+     * @param blobSize Size of the blob.\n+     * @param contentType Content type specified for the blob.\n+     * @param contentMd5 Content MD5 specified for the blob.\n+     * @param contentEncoding Content encoding specified for the blob.\n+     * @param contentDisposition Content disposition specified for the blob.\n+     * @param contentLanguage Content language specified for the blob.\n+     * @param cacheControl Cache control specified for the blob.\n+     * @param blobSequenceNumber The current sequence number for a page blob, if the blob is an append or block blob\n+     * pass {@code null}.\n+     * @param blobType Type of the blob.\n+     * @param leaseStatus Status of the lease on the blob.\n+     * @param leaseState State of the lease on the blob.\n+     * @param leaseDuration Type of lease on the blob.\n+     * @param copyId Identifier of the last copy operation performed on the blob.\n+     * @param copyStatus Status of the last copy operation performed on the blob.\n+     * @param copySource Source of the last copy operation performed on the blob.\n+     * @param copyProgress Progress of the last copy operation performed on the blob.\n+     * @param copyCompletionTime Datetime when the last copy operation on the blob completed.\n+     * @param copyStatusDescription Description of the last copy operation on the blob.\n+     * @param isServerEncrypted Flag indicating if the blob's content is encrypted on the server.\n+     * @param isIncrementalCopy Flag indicating if the blob was incrementally copied.\n+     * @param copyDestinationSnapshot Snapshot identifier of the last incremental copy snapshot for the blob.\n+     * @param accessTier Access tier of the blob.\n+     * @param isAccessTierInferred Flag indicating if the access tier of the blob was inferred from properties of the\n+     * blob.\n+     * @param archiveStatus Archive status of the blob.\n+     * @param encryptionKeySha256 SHA256 of the customer provided encryption key used to encrypt the blob on the server.\n+     * @param accessTierChangeTime Datetime when the access tier of the blob last changed.\n+     * @param metadata Metadata associated with the blob.\n+     * @param committedBlockCount Number of blocks committed to an append blob, if the blob is a block or page blob\n+     * pass {@code null}.\n+     * @param versionId The version identifier of the blob.\n+     * @param isCurrentVersion Flag indication if version identifier points to current version of the blob.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODg0NTIz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-379884523", "createdAt": "2020-03-23T22:57:58Z", "commit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjo1Nzo1OVrOF6bMIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjo1Nzo1OVrOF6bMIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNzIwMA==", "bodyText": "did we create this new resource just cause versioning is still in stage? Would it eventually be available on any account?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396807200", "createdAt": "2020-03-23T22:57:59Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/APISpec.groovy", "diffHunk": "@@ -121,12 +121,14 @@ class APISpec extends Specification {\n     /* Unignore any managed disk tests if a managed disk account is available to be tested. They are difficult to\n      acquire so we do not run them in the nightly live run tests. */\n     static def MANAGED_DISK_STORAGE = \"MANAGED_DISK_STORAGE_\"\n+    static def VERSIONED_STORAGE = \"VERSIONED_STORAGE_\"\n \n     protected static StorageSharedKeyCredential primaryCredential\n     static StorageSharedKeyCredential alternateCredential\n     static StorageSharedKeyCredential blobCredential\n     static StorageSharedKeyCredential premiumCredential\n     static StorageSharedKeyCredential managedDiskCredential\n+    static StorageSharedKeyCredential versionedCredential", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca532b7ef803b8d24800d115bf3b07f277e08762", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca532b7ef803b8d24800d115bf3b07f277e08762", "committedDate": "2020-03-23T23:21:00Z", "message": "recordings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "committedDate": "2020-03-24T00:12:33Z", "message": "fix typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzI2ODIw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-380726820", "createdAt": "2020-03-24T21:57:37Z", "commit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzUxMjYw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-380751260", "createdAt": "2020-03-24T22:49:21Z", "commit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo0OToyMVrOF7F--Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzoxMDo1NlrOF7GebA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODM0NQ==", "bodyText": "I know this was a copy and paste, so the other locations will be wrong, but there is no WithPipeline method. Mind fixing the documentation here and either fixing the other locations or filing an issue to fix them, shouldn't reference something that doesn't exist \ud83d\ude03", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397508345", "createdAt": "2020-03-24T22:49:21Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerAsyncClient.java", "diffHunk": "@@ -161,6 +161,22 @@ public BlobAsyncClient getBlobAsyncClient(String blobName, String snapshot) {\n             getBlobContainerName(), blobName, snapshot, getCustomerProvidedKey(), encryptionScope);\n     }\n \n+    /**\n+     * Creates a new BlobAsyncClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobAsyncClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create\n+     * the BlobAsyncClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODUwMw==", "bodyText": "Same as the other comment about WithPipeline.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397508503", "createdAt": "2020-03-24T22:49:47Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerClient.java", "diffHunk": "@@ -98,6 +98,20 @@ public BlobClient getBlobClient(String blobName, String snapshot) {\n         return new BlobClient(client.getBlobAsyncClient(blobName, snapshot));\n     }\n \n+    /**\n+     * Initializes a new BlobClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create the\n+     * BlobClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this package's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwOTUxMA==", "bodyText": "Should a comment be added to state that passing null will interact with the latest blob?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397509510", "createdAt": "2020-03-24T22:52:37Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobClientBuilder.java", "diffHunk": "@@ -399,6 +401,17 @@ public EncryptedBlobClientBuilder snapshot(String snapshot) {\n         return this;\n     }\n \n+    /**\n+     * Sets the version identifier of the blob.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMDcxOA==", "bodyText": "Not this PR, but I don't fully understand what this Javadoc means by this package's getBlobAsyncClient, I'm not certain this is a thing. Unless it means BlobClientBuilder, which isn't very clear.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397510718", "createdAt": "2020-03-24T22:55:26Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerAsyncClient.java", "diffHunk": "@@ -161,6 +161,22 @@ public BlobAsyncClient getBlobAsyncClient(String blobName, String snapshot) {\n             getBlobContainerName(), blobName, snapshot, getCustomerProvidedKey(), encryptionScope);\n     }\n \n+    /**\n+     * Creates a new BlobAsyncClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobAsyncClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create\n+     * the BlobAsyncClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this\n+     * package's getBlobAsyncClient instead of calling this object's getBlobAsyncClient method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMTM1Ng==", "bodyText": "Please file an issue to cleanup the Javadocs where this was copied from, the mention incorrect things in some places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397511356", "createdAt": "2020-03-24T22:57:02Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerClient.java", "diffHunk": "@@ -98,6 +98,20 @@ public BlobClient getBlobClient(String blobName, String snapshot) {\n         return new BlobClient(client.getBlobAsyncClient(blobName, snapshot));\n     }\n \n+    /**\n+     * Initializes a new BlobClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create the\n+     * BlobClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this package's\n+     * getBlobAsyncClient instead of calling this object's getBlobAsyncClient method.\n+     *\n+     * @param blobName A {@code String} representing the name of the blob.\n+     * @param versionId the version identifier for the blob.\n+     * @return A new {@link BlobClient} object which references the blob with the specified name in this container.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMzkxMA==", "bodyText": "This code is in implementation so feel free to update the old API as it is non-breaking change.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397513910", "createdAt": "2020-03-24T23:03:50Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/util/BlobSasImplUtil.java", "diffHunk": "@@ -97,7 +104,25 @@ public BlobSasImplUtil(BlobServiceSasSignatureValues sasValues, String container\n      */\n     public BlobSasImplUtil(BlobServiceSasSignatureValues sasValues, String containerName, String blobName,\n         String snapshotId) {\n+        this(sasValues, containerName, blobName, snapshotId, null);\n+    }\n+\n+    /**\n+     * Creates a new {@link BlobSasImplUtil} with the specified parameters\n+     *\n+     * @param sasValues {@link BlobServiceSasSignatureValues}\n+     * @param containerName The container name\n+     * @param blobName The blob name\n+     * @param snapshotId The snapshot id\n+     * @param versionId The version id\n+     */\n+    public BlobSasImplUtil(BlobServiceSasSignatureValues sasValues, String containerName, String blobName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTAyNA==", "bodyText": "Mind filing an issue to investigate a way to make constructors which are capable of handling additional parameters that the service could add in the future. There are a few other classes that need a new constructor every time a new service return is added.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397515024", "createdAt": "2020-03-24T23:07:03Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/AppendBlobItem.java", "diffHunk": "@@ -55,6 +56,27 @@ public AppendBlobItem(final String eTag, final OffsetDateTime lastModified, fina\n     public AppendBlobItem(final String eTag, final OffsetDateTime lastModified, final byte[] contentMd5,\n         final boolean isServerEncrypted, final String encryptionKeySha256, final String encryptionScope,\n         final String blobAppendOffset, final Integer blobCommittedBlockCount) {\n+        this(eTag, lastModified, contentMd5, isServerEncrypted, encryptionKeySha256, encryptionScope, blobAppendOffset,\n+            blobCommittedBlockCount, null);\n+    }\n+\n+    /**\n+     * Constructs an {@link AppendBlobItem}.\n+     *\n+     * @param eTag ETag of the append blob.\n+     * @param lastModified Last modified time of the append blob.\n+     * @param contentMd5 Content MD5 of the append blob.\n+     * @param isServerEncrypted Flag indicating if the page blob is encrypted on the server.\n+     * @param encryptionKeySha256 The encryption key used to encrypt the append blob.\n+     * @param encryptionScope The encryption scope used to encrypt the append blob.\n+     * @param blobAppendOffset The offset at which the block was committed to the append blob.\n+     * @param blobCommittedBlockCount The number of committed blocks in the append blob.\n+     * @param versionId The version identifier of the append blob.\n+     */\n+    public AppendBlobItem(final String eTag, final OffsetDateTime lastModified, final byte[] contentMd5,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng==", "bodyText": "This is for another Storage Account resource correct? This will need an update to the ARM template which deploys resources before live test runs for these new tests to work in the nightly live test run.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397516396", "createdAt": "2020-03-24T23:10:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/APISpec.groovy", "diffHunk": "@@ -121,12 +121,14 @@ class APISpec extends Specification {\n     /* Unignore any managed disk tests if a managed disk account is available to be tested. They are difficult to\n      acquire so we do not run them in the nightly live run tests. */\n     static def MANAGED_DISK_STORAGE = \"MANAGED_DISK_STORAGE_\"\n+    static def VERSIONED_STORAGE = \"VERSIONED_STORAGE_\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d951b669c7e4f7c584fcd7e220e1a781623b8234", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d951b669c7e4f7c584fcd7e220e1a781623b8234", "committedDate": "2020-03-25T19:23:43Z", "message": "Remove obsolete javadoc statements."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb466015e306d704ca6f464b9a52c43626029720", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb466015e306d704ca6f464b9a52c43626029720", "committedDate": "2020-03-25T19:32:03Z", "message": "javadoc null version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea06ee5a86803c3bf35dd3dd5e82a60c0a05d80a", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea06ee5a86803c3bf35dd3dd5e82a60c0a05d80a", "committedDate": "2020-03-25T20:09:06Z", "message": "remove obsolete constructor in BlobSasImplUtil"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNTMzNDk0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#pullrequestreview-381533494", "createdAt": "2020-03-25T21:01:52Z", "commit": {"oid": "ea06ee5a86803c3bf35dd3dd5e82a60c0a05d80a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b54ed86c48e0dbf6420bce0d43636eb125945c56", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b54ed86c48e0dbf6420bce0d43636eb125945c56", "committedDate": "2020-04-09T21:47:28Z", "message": "Merge branch 'feature/storage/stg73' into feature/storage/blob-versioning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd7465abab34095128ba591076e58b91149dcbf2", "author": {"user": {"login": "kasobol-msft", "name": "Kamil Sobol"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bd7465abab34095128ba591076e58b91149dcbf2", "committedDate": "2020-04-10T20:44:36Z", "message": "define versioned storage account variables for static test resource injection until we figure out programmatic way."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 607, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}