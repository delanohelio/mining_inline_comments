{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NTc0MjI1", "number": 13599, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoyMzoxM1rOETWhOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoyNzo1OFrOETWoZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzI3MzUzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoyMzoxM1rOG5Cgsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxOTo1NjowMVrOG5H2lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzE1NQ==", "bodyText": "This will probably fail the analyze build - because of multiple spaces between java docs. I can share my intellij code styling file - which you can import and when you refactor code through intellij, it should automatically solve these issues.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13599#discussion_r462463155", "createdAt": "2020-07-29T17:23:13Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -2,73 +2,80 @@\n // Licensed under the MIT License.\n \n \n-package com.azure.cosmos;\n+package com.azure.cosmos.encryption;\n \n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.implementation.Document;\n import com.azure.cosmos.implementation.ItemDeserializer;\n import com.azure.cosmos.implementation.Utils;\n-import com.azure.cosmos.implementation.apachecommons.lang.NotImplementedException;\n import com.azure.cosmos.implementation.encryption.CosmosResponseFactory;\n import com.azure.cosmos.implementation.encryption.CosmosResponseFactoryCore;\n-import com.azure.cosmos.implementation.encryption.DecryptionResult;\n-import com.azure.cosmos.implementation.encryption.EncryptionItemRequestOptions;\n import com.azure.cosmos.implementation.encryption.EncryptionProcessor;\n+import com.azure.cosmos.implementation.encryption.EncryptionQueryRequestOption;\n import com.azure.cosmos.implementation.encryption.EncryptionUtils;\n import com.azure.cosmos.implementation.guava25.base.Preconditions;\n import com.azure.cosmos.models.CosmosItemRequestOptions;\n import com.azure.cosmos.models.CosmosItemResponse;\n-import com.azure.cosmos.models.EncryptionBridgeInternal;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.EncryptionModelBridgeInternal;\n import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.SqlQuerySpec;\n+import com.azure.cosmos.util.CosmosPagedFlux;\n import reactor.core.publisher.Mono;\n import reactor.core.scheduler.Schedulers;\n \n import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n \n // TODO: for now basic functionality is in. some APIs and some logic branch is not complete yet.\n-public class EncryptionCosmosAsyncContainer extends CosmosAsyncContainer {\n+public class EncryptionCosmosAsyncContainer {\n     private final Encryptor encryptor;\n     private final CosmosResponseFactory responseFactory = new CosmosResponseFactoryCore();\n+    private final CosmosAsyncContainer container;\n \n     EncryptionCosmosAsyncContainer(String id, CosmosAsyncDatabase database, Encryptor encryptor) {\n-        super(id, database);\n+        this.container = BridgeInternal.createCosmosAsyncContainer(id, database);\n         this.encryptor = encryptor;\n     }\n \n     private Mono<CosmosItemResponse<byte[]>> createItemStream(byte[] payload,\n                                                               PartitionKey partitionKey,\n-                                                              CosmosItemRequestOptions requestOptions) {\n+                                                              EncryptionItemRequestOptions encryptionItemRequestOptions) {\n         Preconditions.checkNotNull(payload, \"payload can't be null\");\n \n         // TODO: add diagnostics\n-        EncryptionItemRequestOptions encryptionItemRequestOptions = Utils.as(requestOptions, EncryptionItemRequestOptions.class);\n-        if (encryptionItemRequestOptions != null && encryptionItemRequestOptions.getEncryptionOptions() != null) {\n-\n-            payload = EncryptionProcessor.encryptAsync(payload, encryptor, encryptionItemRequestOptions.getEncryptionOptions());\n+        assert encryptionItemRequestOptions != null && encryptionItemRequestOptions.getEncryptionOptions() != null;\n+        payload = EncryptionProcessor.encryptAsync(payload, encryptor, encryptionItemRequestOptions.getEncryptionOptions());\n \n-            Mono<CosmosItemResponse<byte[]>> response = super.createItem(payload, partitionKey, requestOptions);\n+        Mono<CosmosItemResponse<byte[]>> response = container.createItem(payload, partitionKey, encryptionItemRequestOptions);\n \n-            return response\n-                .subscribeOn(Schedulers.elastic())\n-                .publishOn(Schedulers.elastic())\n-                .map(rsp -> {\n-                        EncryptionBridgeInternal.setByteArrayContent(rsp, decryptResponseAsync(EncryptionBridgeInternal.getByteArrayContent(rsp), encryptionItemRequestOptions.getDecryptionResultHandler()));\n-                        return rsp;\n-                    }\n-                );\n-\n-        } else {\n-            throw new NotImplementedException(\"TODO not implemented yet\");\n-            // TODO moderakh compelte the non encryption branch\n-            // return super.createItem()\n-        }\n+        return response\n+            .subscribeOn(Schedulers.elastic())\n+            .publishOn(Schedulers.elastic())\n+            .map(rsp -> {\n+                    EncryptionModelBridgeInternal.setByteArrayContent(\n+                        rsp,\n+                        decryptResponseAsync(\n+                            EncryptionModelBridgeInternal.getByteArrayContent(rsp),\n+                            encryptionItemRequestOptions.getDecryptionResultHandler()));\n+                    return rsp;\n+                }\n+            );\n     }\n \n     // TODO ensure all other apis call this guy\n+\n     /**\n      * create item and encrypts the requested fields\n-     * @param item the Cosmos item represented as a POJO or Cosmos item object.\n-     * @param partitionKey the partition key.\n+     *\n+     * @param item           the Cosmos item represented as a POJO or Cosmos item object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9822e2c34844894d500cbcc8232469842a83451f"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2ODU3Mw==", "bodyText": "thanks for pointing out. will fix and will ensure passes the analyzer.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13599#discussion_r462468573", "createdAt": "2020-07-29T17:32:14Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -2,73 +2,80 @@\n // Licensed under the MIT License.\n \n \n-package com.azure.cosmos;\n+package com.azure.cosmos.encryption;\n \n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.implementation.Document;\n import com.azure.cosmos.implementation.ItemDeserializer;\n import com.azure.cosmos.implementation.Utils;\n-import com.azure.cosmos.implementation.apachecommons.lang.NotImplementedException;\n import com.azure.cosmos.implementation.encryption.CosmosResponseFactory;\n import com.azure.cosmos.implementation.encryption.CosmosResponseFactoryCore;\n-import com.azure.cosmos.implementation.encryption.DecryptionResult;\n-import com.azure.cosmos.implementation.encryption.EncryptionItemRequestOptions;\n import com.azure.cosmos.implementation.encryption.EncryptionProcessor;\n+import com.azure.cosmos.implementation.encryption.EncryptionQueryRequestOption;\n import com.azure.cosmos.implementation.encryption.EncryptionUtils;\n import com.azure.cosmos.implementation.guava25.base.Preconditions;\n import com.azure.cosmos.models.CosmosItemRequestOptions;\n import com.azure.cosmos.models.CosmosItemResponse;\n-import com.azure.cosmos.models.EncryptionBridgeInternal;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.EncryptionModelBridgeInternal;\n import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.SqlQuerySpec;\n+import com.azure.cosmos.util.CosmosPagedFlux;\n import reactor.core.publisher.Mono;\n import reactor.core.scheduler.Schedulers;\n \n import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n \n // TODO: for now basic functionality is in. some APIs and some logic branch is not complete yet.\n-public class EncryptionCosmosAsyncContainer extends CosmosAsyncContainer {\n+public class EncryptionCosmosAsyncContainer {\n     private final Encryptor encryptor;\n     private final CosmosResponseFactory responseFactory = new CosmosResponseFactoryCore();\n+    private final CosmosAsyncContainer container;\n \n     EncryptionCosmosAsyncContainer(String id, CosmosAsyncDatabase database, Encryptor encryptor) {\n-        super(id, database);\n+        this.container = BridgeInternal.createCosmosAsyncContainer(id, database);\n         this.encryptor = encryptor;\n     }\n \n     private Mono<CosmosItemResponse<byte[]>> createItemStream(byte[] payload,\n                                                               PartitionKey partitionKey,\n-                                                              CosmosItemRequestOptions requestOptions) {\n+                                                              EncryptionItemRequestOptions encryptionItemRequestOptions) {\n         Preconditions.checkNotNull(payload, \"payload can't be null\");\n \n         // TODO: add diagnostics\n-        EncryptionItemRequestOptions encryptionItemRequestOptions = Utils.as(requestOptions, EncryptionItemRequestOptions.class);\n-        if (encryptionItemRequestOptions != null && encryptionItemRequestOptions.getEncryptionOptions() != null) {\n-\n-            payload = EncryptionProcessor.encryptAsync(payload, encryptor, encryptionItemRequestOptions.getEncryptionOptions());\n+        assert encryptionItemRequestOptions != null && encryptionItemRequestOptions.getEncryptionOptions() != null;\n+        payload = EncryptionProcessor.encryptAsync(payload, encryptor, encryptionItemRequestOptions.getEncryptionOptions());\n \n-            Mono<CosmosItemResponse<byte[]>> response = super.createItem(payload, partitionKey, requestOptions);\n+        Mono<CosmosItemResponse<byte[]>> response = container.createItem(payload, partitionKey, encryptionItemRequestOptions);\n \n-            return response\n-                .subscribeOn(Schedulers.elastic())\n-                .publishOn(Schedulers.elastic())\n-                .map(rsp -> {\n-                        EncryptionBridgeInternal.setByteArrayContent(rsp, decryptResponseAsync(EncryptionBridgeInternal.getByteArrayContent(rsp), encryptionItemRequestOptions.getDecryptionResultHandler()));\n-                        return rsp;\n-                    }\n-                );\n-\n-        } else {\n-            throw new NotImplementedException(\"TODO not implemented yet\");\n-            // TODO moderakh compelte the non encryption branch\n-            // return super.createItem()\n-        }\n+        return response\n+            .subscribeOn(Schedulers.elastic())\n+            .publishOn(Schedulers.elastic())\n+            .map(rsp -> {\n+                    EncryptionModelBridgeInternal.setByteArrayContent(\n+                        rsp,\n+                        decryptResponseAsync(\n+                            EncryptionModelBridgeInternal.getByteArrayContent(rsp),\n+                            encryptionItemRequestOptions.getDecryptionResultHandler()));\n+                    return rsp;\n+                }\n+            );\n     }\n \n     // TODO ensure all other apis call this guy\n+\n     /**\n      * create item and encrypts the requested fields\n-     * @param item the Cosmos item represented as a POJO or Cosmos item object.\n-     * @param partitionKey the partition key.\n+     *\n+     * @param item           the Cosmos item represented as a POJO or Cosmos item object.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzE1NQ=="}, "originalCommit": {"oid": "9822e2c34844894d500cbcc8232469842a83451f"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1MDY3Ng==", "bodyText": "javadoc analyze passed now. addressed. thanks.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13599#discussion_r462550676", "createdAt": "2020-07-29T19:56:01Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -2,73 +2,80 @@\n // Licensed under the MIT License.\n \n \n-package com.azure.cosmos;\n+package com.azure.cosmos.encryption;\n \n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.implementation.Document;\n import com.azure.cosmos.implementation.ItemDeserializer;\n import com.azure.cosmos.implementation.Utils;\n-import com.azure.cosmos.implementation.apachecommons.lang.NotImplementedException;\n import com.azure.cosmos.implementation.encryption.CosmosResponseFactory;\n import com.azure.cosmos.implementation.encryption.CosmosResponseFactoryCore;\n-import com.azure.cosmos.implementation.encryption.DecryptionResult;\n-import com.azure.cosmos.implementation.encryption.EncryptionItemRequestOptions;\n import com.azure.cosmos.implementation.encryption.EncryptionProcessor;\n+import com.azure.cosmos.implementation.encryption.EncryptionQueryRequestOption;\n import com.azure.cosmos.implementation.encryption.EncryptionUtils;\n import com.azure.cosmos.implementation.guava25.base.Preconditions;\n import com.azure.cosmos.models.CosmosItemRequestOptions;\n import com.azure.cosmos.models.CosmosItemResponse;\n-import com.azure.cosmos.models.EncryptionBridgeInternal;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.EncryptionModelBridgeInternal;\n import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.SqlQuerySpec;\n+import com.azure.cosmos.util.CosmosPagedFlux;\n import reactor.core.publisher.Mono;\n import reactor.core.scheduler.Schedulers;\n \n import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n \n // TODO: for now basic functionality is in. some APIs and some logic branch is not complete yet.\n-public class EncryptionCosmosAsyncContainer extends CosmosAsyncContainer {\n+public class EncryptionCosmosAsyncContainer {\n     private final Encryptor encryptor;\n     private final CosmosResponseFactory responseFactory = new CosmosResponseFactoryCore();\n+    private final CosmosAsyncContainer container;\n \n     EncryptionCosmosAsyncContainer(String id, CosmosAsyncDatabase database, Encryptor encryptor) {\n-        super(id, database);\n+        this.container = BridgeInternal.createCosmosAsyncContainer(id, database);\n         this.encryptor = encryptor;\n     }\n \n     private Mono<CosmosItemResponse<byte[]>> createItemStream(byte[] payload,\n                                                               PartitionKey partitionKey,\n-                                                              CosmosItemRequestOptions requestOptions) {\n+                                                              EncryptionItemRequestOptions encryptionItemRequestOptions) {\n         Preconditions.checkNotNull(payload, \"payload can't be null\");\n \n         // TODO: add diagnostics\n-        EncryptionItemRequestOptions encryptionItemRequestOptions = Utils.as(requestOptions, EncryptionItemRequestOptions.class);\n-        if (encryptionItemRequestOptions != null && encryptionItemRequestOptions.getEncryptionOptions() != null) {\n-\n-            payload = EncryptionProcessor.encryptAsync(payload, encryptor, encryptionItemRequestOptions.getEncryptionOptions());\n+        assert encryptionItemRequestOptions != null && encryptionItemRequestOptions.getEncryptionOptions() != null;\n+        payload = EncryptionProcessor.encryptAsync(payload, encryptor, encryptionItemRequestOptions.getEncryptionOptions());\n \n-            Mono<CosmosItemResponse<byte[]>> response = super.createItem(payload, partitionKey, requestOptions);\n+        Mono<CosmosItemResponse<byte[]>> response = container.createItem(payload, partitionKey, encryptionItemRequestOptions);\n \n-            return response\n-                .subscribeOn(Schedulers.elastic())\n-                .publishOn(Schedulers.elastic())\n-                .map(rsp -> {\n-                        EncryptionBridgeInternal.setByteArrayContent(rsp, decryptResponseAsync(EncryptionBridgeInternal.getByteArrayContent(rsp), encryptionItemRequestOptions.getDecryptionResultHandler()));\n-                        return rsp;\n-                    }\n-                );\n-\n-        } else {\n-            throw new NotImplementedException(\"TODO not implemented yet\");\n-            // TODO moderakh compelte the non encryption branch\n-            // return super.createItem()\n-        }\n+        return response\n+            .subscribeOn(Schedulers.elastic())\n+            .publishOn(Schedulers.elastic())\n+            .map(rsp -> {\n+                    EncryptionModelBridgeInternal.setByteArrayContent(\n+                        rsp,\n+                        decryptResponseAsync(\n+                            EncryptionModelBridgeInternal.getByteArrayContent(rsp),\n+                            encryptionItemRequestOptions.getDecryptionResultHandler()));\n+                    return rsp;\n+                }\n+            );\n     }\n \n     // TODO ensure all other apis call this guy\n+\n     /**\n      * create item and encrypts the requested fields\n-     * @param item the Cosmos item represented as a POJO or Cosmos item object.\n-     * @param partitionKey the partition key.\n+     *\n+     * @param item           the Cosmos item represented as a POJO or Cosmos item object.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzE1NQ=="}, "originalCommit": {"oid": "9822e2c34844894d500cbcc8232469842a83451f"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzI5MTg5OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DecryptionResult.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoyNzo1OFrOG5CsDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxOTo1NTozOVrOG5H1kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjA2MQ==", "bodyText": "You should probably start with all these classes as final", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13599#discussion_r462466061", "createdAt": "2020-07-29T17:27:58Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DecryptionResult.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+\n+package com.azure.cosmos.encryption;\n+\n+public class DecryptionResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9822e2c34844894d500cbcc8232469842a83451f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2ODY0MQ==", "bodyText": "will do. thanks.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13599#discussion_r462468641", "createdAt": "2020-07-29T17:32:21Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DecryptionResult.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+\n+package com.azure.cosmos.encryption;\n+\n+public class DecryptionResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjA2MQ=="}, "originalCommit": {"oid": "9822e2c34844894d500cbcc8232469842a83451f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1MDQxOQ==", "bodyText": "addressed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13599#discussion_r462550419", "createdAt": "2020-07-29T19:55:39Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DecryptionResult.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+\n+package com.azure.cosmos.encryption;\n+\n+public class DecryptionResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjA2MQ=="}, "originalCommit": {"oid": "9822e2c34844894d500cbcc8232469842a83451f"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4763, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}