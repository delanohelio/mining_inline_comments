{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNjk4ODI3", "number": 17048, "title": "Add Service Bus Processor Client to receive messages", "bodyText": "This PR is to add a new processor client that can be used for receiving messages from Service Bus. This processor provides a push-based mechanism for receiving messages which don't require using reactive streams. The processor will run until explicitly stopped by the calling application. The processor allows calling applications to focus on the business logic of processing a message and letting the processor handle receiving messages and dealing with errors to keep the receiving loop going.\nFixes #16087", "createdAt": "2020-11-01T21:47:21Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048", "merged": true, "mergeCommit": {"oid": "79fd66777ec55392071fa60c4e206c04a57b8bfd"}, "closed": true, "closedAt": "2020-11-02T21:56:02Z", "author": {"login": "srnagar"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWjNzBgH2gAyNTEzNjk4ODI3OmQyMTIwMzVlOTM1M2VlYzA1M2Q1MDRjYTdjYTFhYzQ3NGE1YTUwZTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYrlOsAFqTUyMjAxMTEyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d212035e9353eec053d504ca7ca1ac474a5a50e3", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d212035e9353eec053d504ca7ca1ac474a5a50e3", "committedDate": "2020-10-27T06:45:19Z", "message": "Initial commit for Service Bus processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6d3da5b7289f1cf96ab252c881ceb30a1734983", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a6d3da5b7289f1cf96ab252c881ceb30a1734983", "committedDate": "2020-10-31T09:17:20Z", "message": "Merge remote-tracking branch 'upstream/master' into sb-processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e2b8c6df6a902f48274e7e0f84f6c493f77f6b9", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0e2b8c6df6a902f48274e7e0f84f6c493f77f6b9", "committedDate": "2020-11-01T21:04:13Z", "message": "Service Bus processor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87a1fad3c55744b4d04562b7f4454b56db760748", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/87a1fad3c55744b4d04562b7f4454b56db760748", "committedDate": "2020-11-01T21:48:00Z", "message": "JavaDoc updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cadc9aebd8714e31e510f822fcf410c0dfc227e1", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cadc9aebd8714e31e510f822fcf410c0dfc227e1", "committedDate": "2020-11-02T04:49:19Z", "message": "Fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e137020007e26d47d17ce9ade0b08eefa4fc75cc", "committedDate": "2020-11-02T05:16:36Z", "message": "Make isRunning final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d15b453a31f306c8fdca44900c28f2124ec8fb3b", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d15b453a31f306c8fdca44900c28f2124ec8fb3b", "committedDate": "2020-11-02T17:58:40Z", "message": "Merge remote-tracking branch 'upstream/master' into sb-processor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc4MTQ3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#pullrequestreview-521878147", "createdAt": "2020-11-02T18:09:12Z", "commit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODowOToxMlrOHsQIEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODowOToxMlrOHsQIEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MzYwMg==", "bodyText": "I was wondering why we don't extend from AutoCloseable for this because the interface seems to be what this method is doing.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516163602", "createdAt": "2020-11-02T18:09:12Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODU4NTE1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#pullrequestreview-521858515", "createdAt": "2020-11-02T17:42:21Z", "commit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0MjoyMVrOHsPKxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozMToxNFrOHsQ38A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0NzkxMA==", "bodyText": "Since this is first split where user will be introduced to processor,  May be we can explain little bit about it and all the goodies  user get from it.  I see that you have explained it at ServiceBusSessionProcessorClientBuilder but a short explanation here will be good.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516147910", "createdAt": "2020-11-02T17:42:21Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -266,6 +294,23 @@ public ServiceBusSessionReceiverClientBuilder sessionReceiver() {\n         return new ServiceBusSessionReceiverClientBuilder();\n     }\n \n+    /**\n+     * A new instance of {@link ServiceBusProcessorClientBuilder} used to configure Service Bus processor instance.\n+     * @return A new instance of {@link ServiceBusProcessorClientBuilder}.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTY1Mg==", "bodyText": "Should we check for null processMessage.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516151652", "createdAt": "2020-11-02T17:48:23Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -574,6 +619,177 @@ public ServiceBusSenderClient buildClient() {\n         }\n     }\n \n+    /**\n+     * Builder for creating {@link ServiceBusProcessorClient} to consume messages from a session-based Service Bus\n+     * entity. {@link ServiceBusProcessorClient ServiceBusProcessorClients} provides a push-based mechanism that\n+     * invokes the message processing callback when a message is received or the error handler when an error occurs\n+     * when receiving messages. To create an instance, therefore, configuring the two callbacks -\n+     * {@link #processMessage(Consumer)} and {@link #processError(Consumer)} are necessary. By default, a\n+     * {@link ServiceBusProcessorClient} is configured with auto-completion and auto-lock renewal capabilities.\n+     * {@link ServiceBusProcessorClient ServiceBusProcessorClients} created by this builder can be configured to\n+     * consume messages from {@link #maxConcurrentSessions(int) multiple sessions concurrently}. By default, the\n+     * processor will receive messages from a single session with rollover.\n+     *\n+     * <p><strong>Sample code to instantiate a session-enabled processor client</strong></p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.sessionclientinstantiation}\n+     *\n+     * @see ServiceBusProcessorClient\n+     */\n+    public final class ServiceBusSessionProcessorClientBuilder {\n+        private final ServiceBusProcessorClientOptions processorClientOptions;\n+        private final ServiceBusSessionReceiverClientBuilder sessionReceiverClientBuilder;\n+        private Consumer<ServiceBusProcessorMessageContext> processMessage;\n+        private Consumer<Throwable> processError;\n+\n+        private ServiceBusSessionProcessorClientBuilder() {\n+            sessionReceiverClientBuilder = new ServiceBusSessionReceiverClientBuilder();\n+            processorClientOptions = new ServiceBusProcessorClientOptions();\n+            sessionReceiverClientBuilder.maxConcurrentSessions(1);\n+            processorClientOptions.setMaxConcurrentCalls(1);\n+        }\n+\n+        /**\n+         * Enables session processing roll-over by processing at most {@code maxConcurrentSessions}.\n+         *\n+         * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder maxConcurrentSessions(int maxConcurrentSessions) {\n+            if (maxConcurrentSessions < 1) {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"'maxConcurrentSessions' cannot be less than 1\"));\n+            }\n+            sessionReceiverClientBuilder.maxConcurrentSessions(maxConcurrentSessions);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the prefetch count of the processor. For both {@link ReceiveMode#PEEK_LOCK PEEK_LOCK} and {@link\n+         * ReceiveMode#RECEIVE_AND_DELETE RECEIVE_AND_DELETE} modes the default value is 1.\n+         *\n+         * Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when\n+         * and before the application starts the processor.\n+         * Setting a non-zero value will prefetch that number of messages. Setting the value to zero turns prefetch off.\n+         *\n+         * @param prefetchCount The prefetch count.\n+         *\n+         * @return The modified {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder prefetchCount(int prefetchCount) {\n+            sessionReceiverClientBuilder.prefetchCount(prefetchCount);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the queue to create a processor for.\n+         * @param queueName Name of the queue.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder queueName(String queueName) {\n+            sessionReceiverClientBuilder.queueName(queueName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the receive mode for the processor.\n+         * @param receiveMode Mode for receiving messages.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder receiveMode(ReceiveMode receiveMode) {\n+            sessionReceiverClientBuilder.receiveMode(receiveMode);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the subscription in the topic to listen to. <b>{@link #topicName(String)} must also be set.\n+         * </b>\n+         * @param subscriptionName Name of the subscription.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #topicName A topic name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder subscriptionName(String subscriptionName) {\n+            sessionReceiverClientBuilder.subscriptionName(subscriptionName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the topic. <b>{@link #subscriptionName(String)} must also be set.</b>\n+         * @param topicName Name of the topic.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #subscriptionName A subscription name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder topicName(String topicName) {\n+            sessionReceiverClientBuilder.topicName(topicName);\n+            return this;\n+        }\n+\n+        /**\n+         * The message processing callback for the processor that will be executed when a message is received.\n+         * @param processMessage The message processing consumer that will be executed when a message is received.\n+         *\n+         * @return The updated {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder processMessage(\n+            Consumer<ServiceBusProcessorMessageContext> processMessage) {\n+            this.processMessage = processMessage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTc4OA==", "bodyText": "same null check  ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516151788", "createdAt": "2020-11-02T17:48:36Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -574,6 +619,177 @@ public ServiceBusSenderClient buildClient() {\n         }\n     }\n \n+    /**\n+     * Builder for creating {@link ServiceBusProcessorClient} to consume messages from a session-based Service Bus\n+     * entity. {@link ServiceBusProcessorClient ServiceBusProcessorClients} provides a push-based mechanism that\n+     * invokes the message processing callback when a message is received or the error handler when an error occurs\n+     * when receiving messages. To create an instance, therefore, configuring the two callbacks -\n+     * {@link #processMessage(Consumer)} and {@link #processError(Consumer)} are necessary. By default, a\n+     * {@link ServiceBusProcessorClient} is configured with auto-completion and auto-lock renewal capabilities.\n+     * {@link ServiceBusProcessorClient ServiceBusProcessorClients} created by this builder can be configured to\n+     * consume messages from {@link #maxConcurrentSessions(int) multiple sessions concurrently}. By default, the\n+     * processor will receive messages from a single session with rollover.\n+     *\n+     * <p><strong>Sample code to instantiate a session-enabled processor client</strong></p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.sessionclientinstantiation}\n+     *\n+     * @see ServiceBusProcessorClient\n+     */\n+    public final class ServiceBusSessionProcessorClientBuilder {\n+        private final ServiceBusProcessorClientOptions processorClientOptions;\n+        private final ServiceBusSessionReceiverClientBuilder sessionReceiverClientBuilder;\n+        private Consumer<ServiceBusProcessorMessageContext> processMessage;\n+        private Consumer<Throwable> processError;\n+\n+        private ServiceBusSessionProcessorClientBuilder() {\n+            sessionReceiverClientBuilder = new ServiceBusSessionReceiverClientBuilder();\n+            processorClientOptions = new ServiceBusProcessorClientOptions();\n+            sessionReceiverClientBuilder.maxConcurrentSessions(1);\n+            processorClientOptions.setMaxConcurrentCalls(1);\n+        }\n+\n+        /**\n+         * Enables session processing roll-over by processing at most {@code maxConcurrentSessions}.\n+         *\n+         * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder maxConcurrentSessions(int maxConcurrentSessions) {\n+            if (maxConcurrentSessions < 1) {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"'maxConcurrentSessions' cannot be less than 1\"));\n+            }\n+            sessionReceiverClientBuilder.maxConcurrentSessions(maxConcurrentSessions);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the prefetch count of the processor. For both {@link ReceiveMode#PEEK_LOCK PEEK_LOCK} and {@link\n+         * ReceiveMode#RECEIVE_AND_DELETE RECEIVE_AND_DELETE} modes the default value is 1.\n+         *\n+         * Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when\n+         * and before the application starts the processor.\n+         * Setting a non-zero value will prefetch that number of messages. Setting the value to zero turns prefetch off.\n+         *\n+         * @param prefetchCount The prefetch count.\n+         *\n+         * @return The modified {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder prefetchCount(int prefetchCount) {\n+            sessionReceiverClientBuilder.prefetchCount(prefetchCount);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the queue to create a processor for.\n+         * @param queueName Name of the queue.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder queueName(String queueName) {\n+            sessionReceiverClientBuilder.queueName(queueName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the receive mode for the processor.\n+         * @param receiveMode Mode for receiving messages.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder receiveMode(ReceiveMode receiveMode) {\n+            sessionReceiverClientBuilder.receiveMode(receiveMode);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the subscription in the topic to listen to. <b>{@link #topicName(String)} must also be set.\n+         * </b>\n+         * @param subscriptionName Name of the subscription.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #topicName A topic name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder subscriptionName(String subscriptionName) {\n+            sessionReceiverClientBuilder.subscriptionName(subscriptionName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the topic. <b>{@link #subscriptionName(String)} must also be set.</b>\n+         * @param topicName Name of the topic.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #subscriptionName A subscription name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder topicName(String topicName) {\n+            sessionReceiverClientBuilder.topicName(topicName);\n+            return this;\n+        }\n+\n+        /**\n+         * The message processing callback for the processor that will be executed when a message is received.\n+         * @param processMessage The message processing consumer that will be executed when a message is received.\n+         *\n+         * @return The updated {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder processMessage(\n+            Consumer<ServiceBusProcessorMessageContext> processMessage) {\n+            this.processMessage = processMessage;\n+            return this;\n+        }\n+\n+        /**\n+         * The error handler for the processor which will be invoked in the event of an error while receiving messages.\n+         * @param processError The error handler which will be executed when an error occurs.\n+         *\n+         * @return The updated {@link ServiceBusProcessorClientBuilder} object\n+         */\n+        public ServiceBusSessionProcessorClientBuilder processError(Consumer<Throwable> processError) {\n+            this.processError = processError;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NjE5MA==", "bodyText": "If  user's processHandler throw error when they want to abandon the message , are we abandoning the message ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516166190", "createdAt": "2020-11-02T18:13:56Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {\n+        isRunning.set(false);\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().cancel();\n+        }\n+        asyncClient.get().close();\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the processor is running. If the processor is stopped or closed, this method returns\n+     * {@code false}.\n+     *\n+     * @return {@code true} if the processor is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return isRunning.get();\n+    }\n+\n+    private synchronized void receiveMessages() {\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().request(1);\n+            return;\n+        }\n+        ServiceBusReceiverAsyncClient receiverClient = asyncClient.get();\n+        receiverClient.receiveMessages()\n+            .parallel(processorOptions.getMaxConcurrentCalls())\n+            .runOn(Schedulers.boundedElastic())\n+            .subscribe(new Subscriber<ServiceBusReceivedMessageContext>() {\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    receiverSubscription.set(subscription);\n+                    receiverSubscription.get().request(1);\n+                }\n+\n+                @Override\n+                public void onNext(ServiceBusReceivedMessageContext serviceBusReceivedMessageContext) {\n+                    if (serviceBusReceivedMessageContext.hasError()) {\n+                        handleError(serviceBusReceivedMessageContext.getThrowable());\n+                    } else {\n+                        try {\n+                            ServiceBusProcessorMessageContext serviceBusProcessorMessageContext =\n+                                new ServiceBusProcessorMessageContext(receiverClient, serviceBusReceivedMessageContext);\n+                            processMessage.accept(serviceBusProcessorMessageContext);\n+                        } catch (Exception exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MTQ1MA==", "bodyText": "Could we also add  case where user processingHandler throw Exception and that trigger abandoning of the message.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516171450", "createdAt": "2020-11-02T18:23:17Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusProcessorTest.java", "diffHunk": "@@ -0,0 +1,238 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit tests for {@link ServiceBusProcessorClient}.\n+ */\n+public class ServiceBusProcessorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NTg1Ng==", "bodyText": "Once user calls close()  and start() after that ? Are we recreating Link ?\nprocessor.close();\nprocessor.start();", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516175856", "createdAt": "2020-11-02T18:31:14Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODg2MDU1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#pullrequestreview-521886055", "createdAt": "2020-11-02T18:20:28Z", "commit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODoyMDoyOFrOHsQgfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozNjo0N1rOHsRDKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2OTg1NQ==", "bodyText": "Nitpick. Do we need this to be synchronized? This is a read-only operation and isRunning is an AtomicBoolean.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516169855", "createdAt": "2020-11-02T18:20:28Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {\n+        isRunning.set(false);\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().cancel();\n+        }\n+        asyncClient.get().close();\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the processor is running. If the processor is stopped or closed, this method returns\n+     * {@code false}.\n+     *\n+     * @return {@code true} if the processor is running.\n+     */\n+    public synchronized boolean isRunning() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3ODczMQ==", "bodyText": "receiveMessages calls restartMessageReceiver, which will call receiveMessages again. Will this cause stackoverflow if the processor keeps running for long enough time?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516178731", "createdAt": "2020-11-02T18:36:47Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {\n+        isRunning.set(false);\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().cancel();\n+        }\n+        asyncClient.get().close();\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the processor is running. If the processor is stopped or closed, this method returns\n+     * {@code false}.\n+     *\n+     * @return {@code true} if the processor is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return isRunning.get();\n+    }\n+\n+    private synchronized void receiveMessages() {\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().request(1);\n+            return;\n+        }\n+        ServiceBusReceiverAsyncClient receiverClient = asyncClient.get();\n+        receiverClient.receiveMessages()\n+            .parallel(processorOptions.getMaxConcurrentCalls())\n+            .runOn(Schedulers.boundedElastic())\n+            .subscribe(new Subscriber<ServiceBusReceivedMessageContext>() {\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    receiverSubscription.set(subscription);\n+                    receiverSubscription.get().request(1);\n+                }\n+\n+                @Override\n+                public void onNext(ServiceBusReceivedMessageContext serviceBusReceivedMessageContext) {\n+                    if (serviceBusReceivedMessageContext.hasError()) {\n+                        handleError(serviceBusReceivedMessageContext.getThrowable());\n+                    } else {\n+                        try {\n+                            ServiceBusProcessorMessageContext serviceBusProcessorMessageContext =\n+                                new ServiceBusProcessorMessageContext(receiverClient, serviceBusReceivedMessageContext);\n+                            processMessage.accept(serviceBusProcessorMessageContext);\n+                        } catch (Exception exception) {\n+                            handleError(exception);\n+                        }\n+                    }\n+                    if (isRunning.get()) {\n+                        logger.verbose(\"Requesting 1 more message from upstream\");\n+                        receiverSubscription.get().request(1);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    logger.info(\"Error receiving messages.\", throwable);\n+                    handleError(throwable);\n+                    if (isRunning.get()) {\n+                        restartMessageReceiver();\n+                    }\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                    logger.info(\"Completed receiving messages.\");\n+                    if (isRunning.get()) {\n+                        restartMessageReceiver();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc"}, "originalPosition": 192}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "892d762c2bbf33e38611bcfa4abcf875551524f0", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/892d762c2bbf33e38611bcfa4abcf875551524f0", "committedDate": "2020-11-02T19:46:04Z", "message": "Pull in BinaryData changes and address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTYyNjY0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#pullrequestreview-521962664", "createdAt": "2020-11-02T20:17:42Z", "commit": {"oid": "892d762c2bbf33e38611bcfa4abcf875551524f0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b91216243936153ccb845c3561c3c497c189e01c", "author": {"user": {"login": "srnagar", "name": "Srikanta"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b91216243936153ccb845c3561c3c497c189e01c", "committedDate": "2020-11-02T21:24:39Z", "message": "Minor refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDExMTIw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#pullrequestreview-522011120", "createdAt": "2020-11-02T21:38:00Z", "commit": {"oid": "b91216243936153ccb845c3561c3c497c189e01c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 311, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}