{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4ODI1OTkz", "number": 10500, "title": "Field builder and Field annotation.", "bodyText": "Initial version of Field builder.\nWill add more test cases and comments.", "createdAt": "2020-04-25T01:19:23Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500", "merged": true, "mergeCommit": {"oid": "4f6773b244e7056c0ac395ac9a897b7afade906e"}, "closed": true, "closedAt": "2020-05-02T00:59:17Z", "author": {"login": "sima-zhu"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABca7gafgH2gAyNDA4ODI1OTkzOjhmMzJjOWViZWQ1OGU5NDExZTgyODJmZTdiNDNmODhmYzNlNTUyYjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdKjC-gH2gAyNDA4ODI1OTkzOmQ2MTc0NDY3Mzc0ODMxYTA4ZTIwYWEyNzMzMjMyNmI5MjQyZDUwNjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8f32c9ebed58e9411e8282fe7b43f88fc3e552b9", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8f32c9ebed58e9411e8282fe7b43f88fc3e552b9", "committedDate": "2020-04-25T01:07:55Z", "message": "Added field annotations and FieldBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b6bdb39139cebcf9b6cb8c82742daa1219bd1ea", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0b6bdb39139cebcf9b6cb8c82742daa1219bd1ea", "committedDate": "2020-04-25T01:10:23Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into FieldBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c33cb98bdf5dbf91b0e55b6f91744461868584a9", "committedDate": "2020-04-25T01:18:29Z", "message": "Rename the field"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNjU4OTcw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-400658970", "createdAt": "2020-04-27T06:31:08Z", "commit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNjozMTowOFrOGMS3kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNjo0NDo1NVrOGMTRMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NTIzNA==", "bodyText": "Is this auto-generated? Trying to understand why we would use this annotation without any documentation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415545234", "createdAt": "2020-04-27T06:31:08Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.azure.search.annotation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0Nzk4MA==", "bodyText": "Some documentation for this would be nice?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415547980", "createdAt": "2020-04-27T06:36:50Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ==", "bodyText": "Curious why this doesn't have default values like the FieldProperty?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415548289", "createdAt": "2020-04-27T06:37:30Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.azure.search.annotation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODcyOA==", "bodyText": "Why doesn't this extend from the one above?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415548728", "createdAt": "2020-04-27T06:38:30Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.azure.search.annotation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTA5NA==", "bodyText": "Looking at the properties on FieldProperty, couldn't we just use \"isSearchable\" to be true? I don't see the extra value in adding this annotation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415551094", "createdAt": "2020-04-27T06:43:31Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.azure.search.annotation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTI4NQ==", "bodyText": "Same here... Not sure of the value.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415551285", "createdAt": "2020-04-27T06:43:55Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.azure.search.annotation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTc5Mg==", "bodyText": "This should be a string constant \"null\". But why is the default \"null\" rather than just a null object?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415551792", "createdAt": "2020-04-27T06:44:55Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.FieldProperty;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.annotation.Annotation;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Helper to build search field\n+ */\n+public class FieldBuilder {\n+    /**\n+     * Creates a collection of <see cref=\"Field\"/> objects corresponding to\n+     * the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        java.lang.reflect.Field[] fields = modelClass.getFields();\n+        List<Field> searchFieldList = new ArrayList<>();\n+        for (java.lang.reflect.Field field: fields) {\n+            Annotation[] annotations = field.getAnnotations();\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof FieldIgnore) {\n+                    continue;\n+                }\n+                Field searchField = new Field();\n+                searchField.setName(field.getName());\n+                searchField.setType(covertToDataType(field, logger));\n+                if (annotation instanceof SimpleFieldProperty) {\n+                    buildSimpleField(searchField, (SimpleFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof SearchableFieldProperty) {\n+                    buildSearchableField(searchField, (SearchableFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof FieldProperty) {\n+                    buildField(searchField, (FieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                }\n+                logger.info(\"The property {} is not a search field.\", field.getName());\n+            }\n+        }\n+        return searchFieldList;\n+    }\n+\n+    private static void buildSimpleField(Field searchField, SimpleFieldProperty annotation) {\n+        searchField.setSearchable(true);\n+        searchField.setSortable(true);\n+        searchField.setFilterable(true);\n+        searchField.setFacetable(true);\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.analyzer())));\n+        }\n+        if (!\"null\".equals(annotation.searchAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.searchAnalyzer())));\n+        }\n+        if (!\"null\".equals(annotation.indexAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.indexAnalyzer())));\n+        }\n+        if (annotation.synonymMaps().length != 0) {\n+            searchField.setSynonymMaps(Arrays.asList(annotation.synonymMaps()));\n+        }\n+    }\n+\n+    private static void buildSearchableField(Field searchField, SearchableFieldProperty annotation) {\n+        searchField.setSearchable(true);\n+        searchField.setSortable(annotation.isSortable());\n+        searchField.setFilterable(annotation.isFilterable());\n+        searchField.setFacetable(annotation.isFacetable());\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.analyzer())));\n+        }\n+        if (!\"null\".equals(annotation.searchAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.searchAnalyzer())));\n+        }\n+        if (!\"null\".equals(annotation.indexAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.indexAnalyzer())));\n+        }\n+        if (annotation.synonymMaps().length != 0) {\n+            searchField.setSynonymMaps(Arrays.asList(annotation.synonymMaps()));\n+        }\n+    }\n+\n+    private static void buildField(Field searchField, FieldProperty annotation) {\n+        searchField.setSearchable(annotation.isSearchable());\n+        searchField.setSortable(annotation.isSortable());\n+        searchField.setFilterable(annotation.isFilterable());\n+        searchField.setFacetable(annotation.isFacetable());\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzA1OTMw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-401305930", "createdAt": "2020-04-27T20:35:38Z", "commit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozNTozOFrOGM2jAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDo0MTo0MVrOGM2w9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyOTc5Mw==", "bodyText": "What about IgnoreField? Not only does it read better, but fits word order better (comments below).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416129793", "createdAt": "2020-04-27T20:35:38Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.azure.search.annotation;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDUyNg==", "bodyText": "I thought we had agreed on using attribute names and properties that match the convenience fields, e.g. SimpleField, SearchableField, and ComplexField.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416130526", "createdAt": "2020-04-27T20:36:46Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+@Retention(RUNTIME)\n+@Target({FIELD})\n+public @interface FieldProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDk4OQ==", "bodyText": "Some of these can only be set on SearchableField and shouldn't appear here. Make sure they don't in the convenience classes as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416130989", "createdAt": "2020-04-27T20:37:39Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    boolean isKey();\n+    boolean isRetrievable();\n+    boolean isFacetable();\n+    boolean isSearchable();\n+    boolean isSortable();\n+    boolean isFilterable();\n+    String analyzer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA==", "bodyText": "What about ComplexField? Just not implemented yet?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416131404", "createdAt": "2020-04-27T20:38:21Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.FieldProperty;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.annotation.Annotation;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Helper to build search field\n+ */\n+public class FieldBuilder {\n+    /**\n+     * Creates a collection of <see cref=\"Field\"/> objects corresponding to\n+     * the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        java.lang.reflect.Field[] fields = modelClass.getFields();\n+        List<Field> searchFieldList = new ArrayList<>();\n+        for (java.lang.reflect.Field field: fields) {\n+            Annotation[] annotations = field.getAnnotations();\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof FieldIgnore) {\n+                    continue;\n+                }\n+                Field searchField = new Field();\n+                searchField.setName(field.getName());\n+                searchField.setType(covertToDataType(field, logger));\n+                if (annotation instanceof SimpleFieldProperty) {\n+                    buildSimpleField(searchField, (SimpleFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof SearchableFieldProperty) {\n+                    buildSearchableField(searchField, (SearchableFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof FieldProperty) {\n+                    buildField(searchField, (FieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                }\n+                logger.info(\"The property {} is not a search field.\", field.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTk0MA==", "bodyText": "Mentioned above, but just to reiterate here (and applies below): analyzers, synonymMaps, etc., are only settable on searchable fields and shouldn't be here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416131940", "createdAt": "2020-04-27T20:39:18Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.FieldProperty;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.annotation.Annotation;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Helper to build search field\n+ */\n+public class FieldBuilder {\n+    /**\n+     * Creates a collection of <see cref=\"Field\"/> objects corresponding to\n+     * the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        java.lang.reflect.Field[] fields = modelClass.getFields();\n+        List<Field> searchFieldList = new ArrayList<>();\n+        for (java.lang.reflect.Field field: fields) {\n+            Annotation[] annotations = field.getAnnotations();\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof FieldIgnore) {\n+                    continue;\n+                }\n+                Field searchField = new Field();\n+                searchField.setName(field.getName());\n+                searchField.setType(covertToDataType(field, logger));\n+                if (annotation instanceof SimpleFieldProperty) {\n+                    buildSimpleField(searchField, (SimpleFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof SearchableFieldProperty) {\n+                    buildSearchableField(searchField, (SearchableFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof FieldProperty) {\n+                    buildField(searchField, (FieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                }\n+                logger.info(\"The property {} is not a search field.\", field.getName());\n+            }\n+        }\n+        return searchFieldList;\n+    }\n+\n+    private static void buildSimpleField(Field searchField, SimpleFieldProperty annotation) {\n+        searchField.setSearchable(true);\n+        searchField.setSortable(true);\n+        searchField.setFilterable(true);\n+        searchField.setFacetable(true);\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMjIyMA==", "bodyText": "Couldn't you just use the same one as for the convenience classes?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416132220", "createdAt": "2020-04-27T20:39:52Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexDataType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+\n+/**\n+ * Simple DataType is used to create SimpleSearchField.\n+ */\n+public class ComplexDataType extends ExpandableStringEnum<ComplexDataType> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMjQ2OA==", "bodyText": "You mention \"search field\" here. Copy/paste error?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416132468", "createdAt": "2020-04-27T20:40:16Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzAyMw==", "bodyText": "You can't use the same one as for the convenience type? Less chance of breaking across generations.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416133023", "createdAt": "2020-04-27T20:41:10Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SimpleDataType.java", "diffHunk": "@@ -0,0 +1,59 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import java.util.Collection;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Simple DataType is used to create SimpleSearchField.\n+ */\n+public class SimpleDataType extends ExpandableStringEnum<SimpleDataType> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzM2NQ==", "bodyText": "This an others below are not supported on SimpleField. Only SearchableField.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416133365", "createdAt": "2020-04-27T20:41:41Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SimpleField.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class SimpleField {\n+    private String name;\n+    private PrimitiveType dataType;\n+    private Boolean facetable;\n+    private AnalyzerName analyzer;\n+    private AnalyzerName searchAnalyzer;\n+    private AnalyzerName indexAnalyzer;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public SimpleField setName(String name) {\n+        this.name = name;\n+        return this;\n+    }\n+\n+    public PrimitiveType getDataType() {\n+        return dataType;\n+    }\n+\n+    public SimpleField setDataType(PrimitiveType dataType) {\n+        this.dataType = dataType;\n+        return this;\n+    }\n+\n+\n+    public Boolean getFacetable() {\n+        return facetable;\n+    }\n+\n+    public SimpleField setFacetable(Boolean facetable) {\n+        this.facetable = facetable;\n+        return this;\n+    }\n+\n+    public AnalyzerName getAnalyzer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8292f6aafc9c61d66fc3ed94d7388ea02d6a9963", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8292f6aafc9c61d66fc3ed94d7388ea02d6a9963", "committedDate": "2020-04-28T16:38:55Z", "message": "Initial check in with implementations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bb3118ce5e2af5bb721ed4d28acf8cff5518bfa", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5bb3118ce5e2af5bb721ed4d28acf8cff5518bfa", "committedDate": "2020-04-28T17:40:34Z", "message": "Added some tests on failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3019557941bd81c08ad9fb8e18940c9ce02b922", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3019557941bd81c08ad9fb8e18940c9ce02b922", "committedDate": "2020-04-28T17:48:26Z", "message": "Remove unnecessary files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48ccdb589459a4e2cab093b6891e72f3cfe839c9", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/48ccdb589459a4e2cab093b6891e72f3cfe839c9", "committedDate": "2020-04-28T17:49:02Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into FieldBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "committedDate": "2020-04-28T19:36:50Z", "message": "Added change log"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjMxNzUw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-402231750", "createdAt": "2020-04-28T21:38:50Z", "commit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTozODo1MFrOGNn_bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyNToxM1rOGNpQzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzOTg4NA==", "bodyText": "Field should be SearchField.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416939884", "createdAt": "2020-04-28T21:38:50Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Added helper class `FieldBuilder` which coverts strongly-typed model class to `List<Field>`. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDUyMw==", "bodyText": "Why \"Property\" suffixes? It's redundant since you're putting these on properties. I wasn't planning on it for .NET and would rather not, though we could use slightly different names here if that's typical for Java. But I don't see that for FieldIgnore.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416940523", "createdAt": "2020-04-28T21:40:04Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Added helper class `FieldBuilder` which coverts strongly-typed model class to `List<Field>`. \n+- Added annotations `FieldIgnore`, `SimpleFieldProperty`, `SearchableFieldProperty` to define the `Field` on model properties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MTQ5Mg==", "bodyText": "Shouldn't the presence of the attribute always imply true, or is that not typical in Java? In .NET, similar attributes' existence means ignore with no possible way to author a value (e.g. [FieldIgnore(false)] is redundant with just not authoring it).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416941492", "createdAt": "2020-04-28T21:42:01Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker annotation that indicates the field is to be ignored by converting to SearchField.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {\n+    /**\n+     * Optional argument that defines whether this annotation is active or not.\n+     *\n+     * @return True if annotation is enabled (by default); false if it is to be ignored.\n+     */\n+    boolean value() default true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjEwMQ==", "bodyText": "Do we need the \"annotation\" namespace? I wasn't planning on it, just to reduce the number of usings/imports people have to author. com.azure.search.documents.indexes should be enough.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416942101", "createdAt": "2020-04-28T21:43:14Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.azure.search.annotation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjkzNQ==", "bodyText": "Why \"null\" as a string? Shouldn't it just be null? Not specifying this property in an attribute should just default to null (not defined) anyway, right? This seems like an anti-pattern. For example, you have false above for other boolean properties, not \"false\".", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416942935", "createdAt": "2020-04-28T21:44:58Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0Mzk2NA==", "bodyText": "For this and all attributes, what about the name? The name could be overridden. Example, maybe they want a property/field like keyId, but in the index it's the shorter kid.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416943964", "createdAt": "2020-04-28T21:47:04Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjE4Mg==", "bodyText": "I wouldn't hold up the PR for this, but why not map narrower-width field types? May overflow when parsing, but maybe we could log that and use the default value (e.g. numeric types 0). Maybe that's too presumptuous. I wouldn't do that here in this PR, but consider opening an issue to track.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416946182", "createdAt": "2020-04-28T21:52:10Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY5OQ==", "bodyText": "How was this value chosen? Can the user override, or is it based on index creation? /cc @brjohnstmsft", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416946699", "createdAt": "2020-04-28T21:53:19Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0ODgyMQ==", "bodyText": "Shouldn't you also check FieldIgnore.value if it's settable? Or just don't have it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416948821", "createdAt": "2020-04-28T21:57:48Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1MTA2NQ==", "bodyText": "Field should be SearchField per mode renames.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416951065", "createdAt": "2020-04-28T22:02:52Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return CLASS_FIELD_HASH_MAP.get(type);\n+        }\n+        List<Field> childFields = build((Class<?>)type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        searchField.setSearchable(false); // TODO\n+        searchField.setFilterable(false); // TODO\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>)componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Mzc3MA==", "bodyText": "If these all default to false, why set them just to potentially override them later with enrichWithAnnotations ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416953770", "createdAt": "2020-04-28T22:08:43Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return CLASS_FIELD_HASH_MAP.get(type);\n+        }\n+        List<Field> childFields = build((Class<?>)type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        searchField.setSearchable(false); // TODO\n+        searchField.setFilterable(false); // TODO\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>)componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType);\n+        searchField.setKey(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDM1NQ==", "bodyText": "Should just be a simple null check if not defined as a string, right? What if they set it to null explicitly when declaring?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416954355", "createdAt": "2020-04-28T22:10:00Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return CLASS_FIELD_HASH_MAP.get(type);\n+        }\n+        List<Field> childFields = build((Class<?>)type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        searchField.setSearchable(false); // TODO\n+        searchField.setFilterable(false); // TODO\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>)componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType);\n+        searchField.setKey(false);\n+        searchField.setSearchable(false);\n+        searchField.setFacetable(false);\n+        searchField.setHidden(false);\n+        searchField.setFilterable(false);\n+        searchField.setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger\n+                .logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously for %s\",\n+                        classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false);\n+            searchField.setSortable(simpleFieldPropertyAnnotation.isSortable());\n+            searchField.setFilterable(simpleFieldPropertyAnnotation.isFilterable());\n+            searchField.setFacetable(simpleFieldPropertyAnnotation.isFacetable());\n+            searchField.setKey(simpleFieldPropertyAnnotation.isKey());\n+            searchField.setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)){\n+            if (!searchField.getType().equals(DataType.EDM_STRING) &&\n+                !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true);\n+            searchField.setSortable(searchableFieldPropertyAnnotation.isSortable());\n+            searchField.setFilterable(searchableFieldPropertyAnnotation.isFilterable());\n+            searchField.setFacetable(searchableFieldPropertyAnnotation.isFacetable());\n+            searchField.setKey(searchableFieldPropertyAnnotation.isKey());\n+            searchField.setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!\"null\".equals(searchableFieldPropertyAnnotation.analyzer())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTY4NQ==", "bodyText": "Don't use FieldBase (at least in .NET, \"Base\" is not allowed for base classes). See the model rename issue for the suggestion (I forget off hand).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416955685", "createdAt": "2020-04-28T22:12:58Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTg2Mg==", "bodyText": "Just getFields. \"Sub\" is redundant and atypical.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416955862", "createdAt": "2020-04-28T22:13:24Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {\n+    private List<Field> subFields;\n+\n+    /**\n+     * Initializes a new instance of the {@link ComplexField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     */\n+    public ComplexField(String name, boolean collection) {\n+        super(name, collection ? DataType.collection(DataType.EDM_COMPLEX_TYPE) : DataType.EDM_COMPLEX_TYPE);\n+    }\n+\n+    /**\n+     * Gets a collection of {@link SimpleField} or {@link ComplexField} child fields.\n+     *\n+     * @return The list of sub-fields.\n+     */\n+    public List<Field> getSubFields() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTk4Ng==", "bodyText": "Just setFields.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416955986", "createdAt": "2020-04-28T22:13:43Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {\n+    private List<Field> subFields;\n+\n+    /**\n+     * Initializes a new instance of the {@link ComplexField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     */\n+    public ComplexField(String name, boolean collection) {\n+        super(name, collection ? DataType.collection(DataType.EDM_COMPLEX_TYPE) : DataType.EDM_COMPLEX_TYPE);\n+    }\n+\n+    /**\n+     * Gets a collection of {@link SimpleField} or {@link ComplexField} child fields.\n+     *\n+     * @return The list of sub-fields.\n+     */\n+    public List<Field> getSubFields() {\n+        return subFields;\n+    }\n+\n+    /**\n+     * Sets a collection of {@link SimpleField} or {@link ComplexField} child fields.\n+     *\n+     * @param subFields The list of sub-fields.\n+     * @return The {@link ComplexField} object itself.\n+     */\n+    public ComplexField setSubFields(List<Field> subFields) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1ODU0Mg==", "bodyText": "Need an overload for whether this is also a collection (like you did in ComplexField).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416958542", "createdAt": "2020-04-28T22:19:49Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SimpleField.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A helper Field model to build a simple {@link Field}.\n+ */\n+public class SimpleField extends FieldBase {\n+    private boolean key;\n+    private boolean facetable;\n+    private boolean sortable;\n+    private boolean filterable;\n+    private boolean hidden;\n+\n+    /**\n+     * Initializes a new instance of the {@link SimpleField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The {@link DataType} of the {@link Field}.\n+     * @throws NullPointerException when {@code name} is null.\n+     */\n+    public SimpleField(String name, DataType dataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1OTU0NQ==", "bodyText": "Nit: wouldn't \"build...FromModel\" mean using the field builder against a model type? This seems more like manual index creation / defining of fields.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416959545", "createdAt": "2020-04-28T22:22:09Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/FieldBuilderTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.azure.search.documents;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.ComplexField;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.SearchableField;\n+import com.azure.search.documents.models.SimpleField;\n+import com.azure.search.documents.test.environment.models.Hotel;\n+import com.azure.search.documents.test.environment.models.HotelSearchException;\n+import com.azure.search.documents.test.environment.models.HotelSearchableExceptionOnList;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class FieldBuilderTest {\n+    @Test\n+    public void hotelComparison() {\n+        List<Field> actualFields = sortByFieldName(FieldBuilder.build(Hotel.class));\n+        List<Field> expectedFields = sortByFieldName(buildHotelFieldsFromModel());\n+        assertEquals(expectedFields.size(), actualFields.size());\n+        for (int i = 0; i < expectedFields.size(); i++) {\n+            TestHelpers.assertObjectEquals(expectedFields.get(i), actualFields.get(i));\n+        }\n+    }\n+\n+    @Test\n+    public void hotelSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchException.class);\n+        });\n+        assertTrue(exception.getMessage().contains(\"hotelId\"));\n+        assertTrue(exception.getMessage().contains(DataType.EDM_INT32.toString()));\n+    }\n+\n+    @Test\n+    public void hotelListFieldSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchableExceptionOnList.class);\n+        });\n+        assertTrue(exception.getMessage().contains(\"passcode\"));\n+        assertTrue(exception.getMessage().contains(DataType.collection(DataType.EDM_INT32).toString()));\n+    }\n+\n+    private List<Field> buildHotelFieldsFromModel() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDcxNw==", "bodyText": "Might be good to have the cycle a level deeper just to make sure the recursive stack push/check is working correctly (and continues to do so when changed).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416960717", "createdAt": "2020-04-28T22:25:13Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/models/HotelSearchException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.azure.search.documents.test.environment.models;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjY2NDgw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-402266480", "createdAt": "2020-04-28T22:50:25Z", "commit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo1MDoyNVrOGNp22g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowNjo1NlrOGNqO4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDQ1OA==", "bodyText": "If we plan to keep this annotation this isn't needed, why would we allow FieldIgnore(false)? The simple existence of this annotation on a field should indicate that it won't be included in the generated FieldMapping.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416970458", "createdAt": "2020-04-28T22:50:25Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker annotation that indicates the field is to be ignored by converting to SearchField.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {\n+    /**\n+     * Optional argument that defines whether this annotation is active or not.\n+     *\n+     * @return True if annotation is enabled (by default); false if it is to be ignored.\n+     */\n+    boolean value() default true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDkzNQ==", "bodyText": "Do we want to use a pattern of all fields are included unless stated otherwise or fields are only included if stated?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416970935", "createdAt": "2020-04-28T22:51:36Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker annotation that indicates the field is to be ignored by converting to SearchField.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTIyMA==", "bodyText": "I'm not completely certain we want to copy JSON as this is more of an ORM concept.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416971220", "createdAt": "2020-04-28T22:52:19Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.azure.search.annotation;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyOTc5Mw=="}, "originalCommit": {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTU1MA==", "bodyText": "This should be null right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416971550", "createdAt": "2020-04-28T22:53:16Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTk0OA==", "bodyText": "SearchableFieldProperty feels to me that it indicates Filterable = true by default.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416971948", "createdAt": "2020-04-28T22:54:24Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzAwNg==", "bodyText": "XBase is the pattern we use in Java, but I would also say that FieldBase isn't really needed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416973006", "createdAt": "2020-04-28T22:57:18Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTY4NQ=="}, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzIzMw==", "bodyText": "Given this is a super class for some public APIs this should be public as well. Also, should this be an abstract class?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416973233", "createdAt": "2020-04-28T22:57:51Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+class FieldBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDczOQ==", "bodyText": "Shouldn't this be true to match the service documentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416974739", "createdAt": "2020-04-28T23:01:59Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDc2Mw==", "bodyText": "Shouldn't this be true to match the service documentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416974763", "createdAt": "2020-04-28T23:02:04Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDgwOQ==", "bodyText": "Shouldn't this be true to match the service documentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416974809", "createdAt": "2020-04-28T23:02:10Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTA3Ng==", "bodyText": "This should be null right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975076", "createdAt": "2020-04-28T23:02:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the search analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String searchAnalyzer() default \"null\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEwNQ==", "bodyText": "This should be null right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975105", "createdAt": "2020-04-28T23:03:01Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the search analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String searchAnalyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String indexAnalyzer() default \"null\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTE1NA==", "bodyText": "This should be null right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975154", "createdAt": "2020-04-28T23:03:11Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the search analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String searchAnalyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String indexAnalyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the array of synonymMaps used for the field.\n+     *\n+     * @return An array of synonym map values. Or default to empty string array.\n+     */\n+    String[] synonymMaps() default {};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTM0Nw==", "bodyText": "Shouldn't this be true to match the service documentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975347", "createdAt": "2020-04-28T23:03:42Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.Field;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a simple field. This annotation can only set boolean field of\n+ * {@link Field}. {@code isSearchable} will set to {@code false}.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTM3Ng==", "bodyText": "Shouldn't this be true to match the service documentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975376", "createdAt": "2020-04-28T23:03:49Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.Field;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a simple field. This annotation can only set boolean field of\n+ * {@link Field}. {@code isSearchable} will set to {@code false}.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTQwNg==", "bodyText": "Shouldn't this be true to match the service documentation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975406", "createdAt": "2020-04-28T23:03:54Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.Field;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a simple field. This annotation can only set boolean field of\n+ * {@link Field}. {@code isSearchable} will set to {@code false}.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjUzMQ==", "bodyText": "Are these imports being used?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416976531", "createdAt": "2020-04-28T23:06:41Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/setup/AzureSearchResources.java", "diffHunk": "@@ -22,6 +23,11 @@\n import java.io.IOException;\n import java.net.InetAddress;\n import java.security.SecureRandom;\n+import java.time.LocalDateTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjU5MQ==", "bodyText": "Is this import being used?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416976591", "createdAt": "2020-04-28T23:06:52Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/setup/AzureSearchResources.java", "diffHunk": "@@ -22,6 +23,11 @@\n import java.io.IOException;\n import java.net.InetAddress;\n import java.security.SecureRandom;\n+import java.time.LocalDateTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjYxMA==", "bodyText": "Is this import being used?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416976610", "createdAt": "2020-04-28T23:06:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/setup/AzureSearchResources.java", "diffHunk": "@@ -6,6 +6,7 @@\n import com.azure.core.test.utils.TestResourceNamer;\n import com.azure.core.util.Configuration;\n import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.DateTimeRfc1123;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32957663bff633afc3d0bd5fdf024c1a92b955a1", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/32957663bff633afc3d0bd5fdf024c1a92b955a1", "committedDate": "2020-04-29T02:55:33Z", "message": "String value defaults to empty"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c07a7338178c118ed9bee85acecbcbadf986b9c3", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c07a7338178c118ed9bee85acecbcbadf986b9c3", "committedDate": "2020-04-29T03:38:02Z", "message": "Address major comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/17650d0251551efd99d623e688a1ebe21074f7e9", "committedDate": "2020-04-29T06:39:58Z", "message": "Added tests for circular dependencies"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODcyNDQ5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-402872449", "createdAt": "2020-04-29T17:12:57Z", "commit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzoxMjo1N1rOGOI0RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzoxMjo1N1rOGOI0RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NzcwMQ==", "bodyText": "Do we want to log a warning for a circular dependency? There are a lot of data structures that will have this, for example a binary tree. Would it be better to just return null to break the cycle?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417477701", "createdAt": "2020-04-29T17:12:57Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaf3c46092de4e54f56708dd5fc786ba3f1364e8", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aaf3c46092de4e54f56708dd5fc786ba3f1364e8", "committedDate": "2020-04-29T18:13:01Z", "message": "Remove map since it needs deep copy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyOTA2MDEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-402906011", "createdAt": "2020-04-29T17:56:17Z", "commit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzo1NjoxN1rOGOKd9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoxNTowNFrOGOLJeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNDc1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n          \n          \n            \n            - Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditions`.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417504758", "createdAt": "2020-04-29T17:56:17Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNTAyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Added helper class `FieldBuilder` which coverts strongly-typed model class to `List<Field>`. \n          \n          \n            \n            - Added helper class `FieldBuilder` which converts strongly-typed model class to `List<Field>`.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417505023", "createdAt": "2020-04-29T17:56:38Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Added helper class `FieldBuilder` which coverts strongly-typed model class to `List<Field>`. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNzE1Mw==", "bodyText": "Do we need to create a new logger instance each time this method is called? If this method is called frequently, it's better to make the logger a static instance.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417507153", "createdAt": "2020-04-29T17:59:50Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjk0NQ==", "bodyText": "Use the fluent pattern instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417512945", "createdAt": "2020-04-29T18:10:00Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return deepCopyFieldWithName(CLASS_FIELD_HASH_MAP.get(type), classField.getName() ,logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static Field deepCopyFieldWithName(Field field, String name, ClientLogger logger) {\n+        try {\n+            Field copyField = new ObjectMapper().readValue(new ObjectMapper().writeValueAsString(field), Field.class);\n+            return copyField.setName(name);\n+        } catch (JsonProcessingException e) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"Something wrong when copy field of %s\", name)));\n+        }\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType);\n+        searchField.setKey(false);\n+        searchField.setSearchable(false);\n+        searchField.setFacetable(false);\n+        searchField.setHidden(false);\n+        searchField.setFilterable(false);\n+        searchField.setSortable(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMzg2NA==", "bodyText": "Since this class is a collection of static helper methods, it should be final and also add a private constructor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417513864", "createdAt": "2020-04-29T18:11:39Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMzk3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Helper to covert model class to search field {@link Field}.\n          \n          \n            \n             * Helper to convert model class to search field {@link Field}.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417513975", "createdAt": "2020-04-29T18:11:48Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNDkwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Package containing the annotations used by FieldBuilder which help covert\n          \n          \n            \n             * Package containing the annotations used by FieldBuilder which help convert", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417514904", "createdAt": "2020-04-29T18:13:25Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/package-info.java", "diffHunk": "@@ -0,0 +1,8 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+/**\n+ * Package containing the annotations used by FieldBuilder which help covert", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNTg5OA==", "bodyText": "It might be more readable if you have one setter per line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417515898", "createdAt": "2020-04-29T18:15:04Z", "author": {"login": "srnagar"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SearchableField.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+\n+/**\n+ * A helper Field model to build a searchable {@link Field}.\n+ */\n+public class SearchableField extends SimpleField {\n+    private AnalyzerName analyzer;\n+    private AnalyzerName searchAnalyzer;\n+    private AnalyzerName indexAnalyzer;\n+    private List<String> synonymMaps;\n+\n+    /**\n+     * Initializes a new instance of the {@link SearchableField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     * @throws NullPointerException when {@code name} is null.\n+     */\n+    public SearchableField(String name, boolean collection) {\n+        super(name, DataType.EDM_STRING, collection);\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for analyzer.\n+     */\n+    public AnalyzerName getAnalyzer() {\n+        return analyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @param analyzer The {@link AnalyzerName} used for analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setAnalyzer(AnalyzerName analyzer) {\n+        this.analyzer = analyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for search analyzer.\n+     */\n+    public AnalyzerName getSearchAnalyzer() {\n+        return searchAnalyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param searchAnalyzer The {@link AnalyzerName} used for search analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSearchAnalyzer(AnalyzerName searchAnalyzer) {\n+        this.searchAnalyzer = searchAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for index analyzer.\n+     */\n+    public AnalyzerName getIndexAnalyzer() {\n+        return indexAnalyzer;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param indexAnalyzer The {@link AnalyzerName} used for index analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setIndexAnalyzer(AnalyzerName indexAnalyzer) {\n+        this.indexAnalyzer = indexAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @return List of names of synonym maps to associate with this field.\n+     */\n+    public List<String> getSynonymMaps() {\n+        return synonymMaps;\n+    }\n+\n+    /**\n+     * Sets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @param synonymMaps list of names of synonym maps to associate with this field.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSynonymMaps(List<String> synonymMaps) {\n+        this.synonymMaps = synonymMaps;\n+        return this;\n+    }\n+\n+    /**\n+     * Convert SearchableField to {@link Field}.\n+     *\n+     * @return The {@link Field} object.\n+     */\n+    public Field build() {\n+        return new Field().setName(super.getName()).setType(super.getDataType()).setSearchable(true)\n+            .setKey(super.isKey()).setSortable(super.isSortable()).setFilterable(super.isFilterable())\n+            .setHidden(super.isHidden()).setFacetable(super.isFacetable()).setAnalyzer(this.analyzer)\n+            .setSearchAnalyzer(this.searchAnalyzer).setIndexAnalyzer(this.indexAnalyzer)\n+            .setSynonymMaps(this.synonymMaps);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec488d5d8f83599c0c3b3390823b9982a665e2b7", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ec488d5d8f83599c0c3b3390823b9982a665e2b7", "committedDate": "2020-04-29T18:18:37Z", "message": "Update sdk/search/azure-search-documents/CHANGELOG.md\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46e52f8e62a6a408ba43eaaa9f2f2d39a5d4a10b", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/46e52f8e62a6a408ba43eaaa9f2f2d39a5d4a10b", "committedDate": "2020-04-29T18:19:08Z", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/package-info.java\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36228d01d1438c5c96c0a9e7c5c23c5942515d8f", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/36228d01d1438c5c96c0a9e7c5c23c5942515d8f", "committedDate": "2020-04-29T18:19:24Z", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "738777b9587cfceb166b5f0750351454e4f405e2", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/738777b9587cfceb166b5f0750351454e4f405e2", "committedDate": "2020-04-29T18:19:53Z", "message": "Update sdk/search/azure-search-documents/CHANGELOG.md\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea804ece2154ae1009e82c3eebcfe00db0842a3e", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea804ece2154ae1009e82c3eebcfe00db0842a3e", "committedDate": "2020-04-29T19:17:40Z", "message": "CHnage to fluent pattern call"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97ed8fa3a24c4561fa1371e251dcaa258243b32d", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/97ed8fa3a24c4561fa1371e251dcaa258243b32d", "committedDate": "2020-04-29T19:17:46Z", "message": "Merge branch 'FieldBuilder' of https://github.com/sima-zhu/azure-sdk-for-java into FieldBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bd1d4675e883363ac55d106aab3f945244cf36b", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9bd1d4675e883363ac55d106aab3f945244cf36b", "committedDate": "2020-04-29T19:18:27Z", "message": "Added final the FieldBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e424f309bb0daf6f46e7247272077d5fa696c47a", "committedDate": "2020-04-30T03:23:03Z", "message": "add javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjg1ODE4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-403685818", "createdAt": "2020-04-30T16:30:22Z", "commit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjozMDoyMlrOGOxHow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzoxNDo0NFrOGOyuGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzODAxOQ==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Helper to convert model class to search field {@link Field}.\n          \n          \n            \n             * Helper to convert model class to Search {@link Field fields}.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418138019", "createdAt": "2020-04-30T16:30:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MjA4MQ==", "bodyText": "This name confuses me a bit, is this a mapping of parameterized types that aren't allowed?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418142081", "createdAt": "2020-04-30T16:37:01Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0Mjc5NA==", "bodyText": "Should CharSequence also be added as an EDM_STRING mapping? Do these mappings check for the type being an instanceof or child of said class?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418142794", "createdAt": "2020-04-30T16:38:10Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ==", "bodyText": "Should this check Collection as that is the super type for List and will capture Set, Queue, etc.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418157205", "createdAt": "2020-04-30T17:02:37Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzYzMQ==", "bodyText": "After looking at the PR further could we rename this SUPPORTED_SIMPLE_TYPES.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418157631", "createdAt": "2020-04-30T17:03:24Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MjA4MQ=="}, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODA0Nw==", "bodyText": "Is this helper method needed?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418158047", "createdAt": "2020-04-30T17:04:05Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODk1OA==", "bodyText": "Can we add an actual exception message if we ever run into this issue in production.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418158958", "createdAt": "2020-04-30T17:05:39Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MDUyOQ==", "bodyText": "Doesn't needed to be changed now, but does this make more sense as an IllegalStateException?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418160529", "createdAt": "2020-04-30T17:08:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzM0NQ==", "bodyText": "Should we attempt to cleanse any potential null values in the annotation value? Ignore this if Java doesn't allow { \"aSynonym\", null, \"anotherSynonym\" }.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418163345", "createdAt": "2020-04-30T17:13:16Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously \"\n+                        + \"for %s\", classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false)\n+                .setSortable(simpleFieldPropertyAnnotation.isSortable())\n+                .setFilterable(simpleFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(simpleFieldPropertyAnnotation.isFacetable())\n+                .setKey(simpleFieldPropertyAnnotation.isKey())\n+                .setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            if (!searchField.getType().equals(DataType.EDM_STRING)\n+                && !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true)\n+                .setSortable(searchableFieldPropertyAnnotation.isSortable())\n+                .setFilterable(searchableFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(searchableFieldPropertyAnnotation.isFacetable())\n+                .setKey(searchableFieldPropertyAnnotation.isKey())\n+                .setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!searchableFieldPropertyAnnotation.analyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.analyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.searchAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.searchAnalyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.indexAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.indexAnalyzer())));\n+            }\n+            if (searchableFieldPropertyAnnotation.synonymMaps().length != 0) {\n+                searchField.setSynonymMaps(Arrays.asList(searchableFieldPropertyAnnotation.synonymMaps()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NDI1MQ==", "bodyText": "Should we also validate that DataType != null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418164251", "createdAt": "2020-04-30T17:14:44Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {\n+    private final ClientLogger logger = new ClientLogger(FieldBase.class);\n+    private final String name;\n+    private final DataType dataType;\n+\n+    /**\n+     * Initializes a new instance of the {@link FieldBase} class.\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The data type of the field.\n+     */\n+    protected FieldBase(String name, DataType dataType) {\n+        if (CoreUtils.isNullOrEmpty(name)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e45de6ac543692b9f74c1540b6b6d6998c738adb", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e45de6ac543692b9f74c1540b6b6d6998c738adb", "committedDate": "2020-04-30T17:19:11Z", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e20f21b41b3b85eb357d88ebd3af7062e951183", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1e20f21b41b3b85eb357d88ebd3af7062e951183", "committedDate": "2020-04-30T23:05:50Z", "message": "Added blank field filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf8cfc346e018d748bfc93cc0574a7f85f0e4f3f", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf8cfc346e018d748bfc93cc0574a7f85f0e4f3f", "committedDate": "2020-04-30T23:06:15Z", "message": "Merge branch 'FieldBuilder' of https://github.com/sima-zhu/azure-sdk-for-java into FieldBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5659dec6b760fb1b886488c507163ebf145da78", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a5659dec6b760fb1b886488c507163ebf145da78", "committedDate": "2020-04-30T23:30:42Z", "message": "fixed linting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/86dc191974e68def26ceab4bcbaa320122a59a4b", "committedDate": "2020-04-30T23:49:20Z", "message": "Simplify the code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzOTUyNTM5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-403952539", "createdAt": "2020-04-30T23:53:15Z", "commit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MDU3NDQy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-404057442", "createdAt": "2020-05-01T07:52:12Z", "commit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNzo1MjoxMlrOGPERgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwODowNjo1NVrOGPEfPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MTg0MA==", "bodyText": "I'd stay away from abbreviations like this unless they're well-known. It makes it hard to read. currentClass reads better.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418451840", "createdAt": "2020-05-01T07:52:12Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MTkzMg==", "bodyText": "Do we really want to return null? Maybe an exception is better.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418451932", "createdAt": "2020-05-01T07:52:34Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MjQwNQ==", "bodyText": "Creating the list is not necessary. You can use Arrays.stream()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418452405", "createdAt": "2020-05-01T07:54:36Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MjkyMg==", "bodyText": "\"Collection type is not supported.\" rather than first person pronouns like \"We\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418452922", "createdAt": "2020-05-01T07:56:39Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"We currently do not support the collection type: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzU4OA==", "bodyText": "This is easier to read as:\nreturn type.getClass().isArray() || isList(type);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418453588", "createdAt": "2020-05-01T07:59:18Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1Mzk1MQ==", "bodyText": "I'm a fan of bailing out of a method early. I think it makes it easier to read and the actual logic isn't shifted to the right with a ton of spaces if there are nested if-statements. It's a personal preference. You can leave as-is if you want.\nif (!(type instanceof ParameterizedType)) {\n    return false;\n}\n\nType rawType = ((ParameterizedType) type).getRawType();\nreturn List.class.isAssignableFrom((Class<?>) rawType);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418453951", "createdAt": "2020-05-01T08:00:49Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1NDU1Ng==", "bodyText": "I'd invert this if to avoid the nested ifs.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418454556", "createdAt": "2020-05-01T08:03:29Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"We currently do not support the collection type: \"\n+                + arrayOrListType.getTypeName()));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously \"\n+                        + \"for %s\", classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false)\n+                .setSortable(simpleFieldPropertyAnnotation.isSortable())\n+                .setFilterable(simpleFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(simpleFieldPropertyAnnotation.isFacetable())\n+                .setKey(simpleFieldPropertyAnnotation.isKey())\n+                .setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            if (!searchField.getType().equals(DataType.EDM_STRING)\n+                && !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true)\n+                .setSortable(searchableFieldPropertyAnnotation.isSortable())\n+                .setFilterable(searchableFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(searchableFieldPropertyAnnotation.isFacetable())\n+                .setKey(searchableFieldPropertyAnnotation.isKey())\n+                .setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!searchableFieldPropertyAnnotation.analyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.analyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.searchAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.searchAnalyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.indexAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.indexAnalyzer())));\n+            }\n+            if (searchableFieldPropertyAnnotation.synonymMaps().length != 0) {\n+                List<String> synonymMaps = Arrays.stream(searchableFieldPropertyAnnotation.synonymMaps())\n+                    .filter(synonym -> !synonym.trim().isEmpty()).collect(Collectors.toList());\n+                searchField.setSynonymMaps(synonymMaps);\n+            }\n+        }\n+        return searchField;\n+    }\n+\n+    private static void validateType(Class<?> type, boolean hasArrayOrCollectionWrapped, ClientLogger logger) {\n+        if (Map.class.isAssignableFrom(type)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Map and its subclasses are not supported\"));\n+        }\n+        if (UNSUPPORTED_TYPES.contains(type)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(String.format(\"%s is not supported\",\n+                    type.getName())));\n+        }\n+        if (Collection.class.isAssignableFrom(type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1NDg4MA==", "bodyText": "You can save a line by using:\nthis.dataType = Objects.requireNonNull(dataType, \"'dataType' cannot be null.\");", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418454880", "createdAt": "2020-05-01T08:04:53Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {\n+    private final ClientLogger logger = new ClientLogger(FieldBase.class);\n+    private final String name;\n+    private final DataType dataType;\n+\n+    /**\n+     * Initializes a new instance of the {@link FieldBase} class.\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The data type of the field.\n+     */\n+    protected FieldBase(String name, DataType dataType) {\n+        if (CoreUtils.isNullOrEmpty(name)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\"));\n+        }\n+        Objects.requireNonNull(dataType, \"DataType cannot be null.\");\n+        this.name = name;\n+        this.dataType = dataType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1NTM1OA==", "bodyText": "Have you tried Collections.sort(fields, (o1, o2) -> {})? It'll save you from having to turn this from a list to a stream, then back into a list.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418455358", "createdAt": "2020-05-01T08:06:55Z", "author": {"login": "conniey"}, "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/FieldBuilderTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.ComplexField;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.SearchableField;\n+import com.azure.search.documents.models.SimpleField;\n+import com.azure.search.documents.test.environment.models.Hotel;\n+import com.azure.search.documents.test.environment.models.HotelCircularDependencies;\n+import com.azure.search.documents.test.environment.models.HotelSearchException;\n+import com.azure.search.documents.test.environment.models.HotelSearchableExceptionOnList;\n+import com.azure.search.documents.test.environment.models.HotelWithEmptyInSynonymMaps;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class FieldBuilderTest {\n+    @Test\n+    public void hotelComparison() {\n+        List<Field> actualFields = sortByFieldName(FieldBuilder.build(Hotel.class));\n+        List<Field> expectedFields = sortByFieldName(buildHotelFields());\n+        assertListFieldEquals(expectedFields, actualFields);\n+    }\n+\n+    @Test\n+    public void hotelSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchException.class);\n+        });\n+        assertExceptionMassageAndDataType(exception, \"hotelId\", DataType.EDM_INT32);\n+    }\n+\n+    @Test\n+    public void hotelListFieldSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchableExceptionOnList.class);\n+        });\n+        assertExceptionMassageAndDataType(exception, \"passcode\", DataType.collection(DataType.EDM_INT32));\n+    }\n+\n+    @Test\n+    public void hotelCircularDependencies() {\n+        List<Field> actualFields = sortByFieldName(FieldBuilder.build(HotelCircularDependencies.class));\n+        List<Field> expectedFields = sortByFieldName(buildHotelCircularDependenciesModel());\n+        assertListFieldEquals(expectedFields, actualFields);\n+    }\n+\n+    @Test\n+    public void hotelWithEmptySynonymMaps() {\n+        // We cannot put null in the annotation. So no need to test null case.\n+        List<Field> actualFields = FieldBuilder.build(HotelWithEmptyInSynonymMaps.class);\n+        List<Field> expectedFields = Collections.singletonList(new SearchableField(\"tags\", true)\n+            .setSynonymMaps(Arrays.asList(\"asynonymMaps\", \"maps\")).build());\n+        assertListFieldEquals(expectedFields, actualFields);\n+    }\n+\n+    private void assertListFieldEquals(List<Field> expected, List<Field> actual) {\n+        assertEquals(expected.size(), actual.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            TestHelpers.assertObjectEquals(expected.get(i), actual.get(i));\n+        }\n+    }\n+\n+    private void assertExceptionMassageAndDataType(Exception exception, String msg, DataType dataType) {\n+        assertTrue(exception.getMessage().contains(msg));\n+        assertTrue(exception.getMessage().contains(dataType.toString()));\n+    }\n+\n+    private List<Field> buildHotelCircularDependenciesModel() {\n+        Field homeAddress = new ComplexField(\"homeAddress\", false).setFields(buildHotelInAddress()).build();\n+        Field billingAddress = new ComplexField(\"billingAddress\", false).setFields(buildHotelInAddress()).build();\n+        return Arrays.asList(homeAddress, billingAddress);\n+    }\n+\n+    private List<Field> buildHotelInAddress() {\n+        Field hotel = new ComplexField(\"hotel\", false).build();\n+        return Collections.singletonList(hotel);\n+    }\n+\n+    private List<Field> buildHotelFields() {\n+        Field hotelId = new SimpleField(\"hotelId\", DataType.EDM_STRING, false).setSortable(true)\n+            .setKey(true).build();\n+        Field hotelName = new SearchableField(\"hotelName\", false).setAnalyzer(AnalyzerName.fromString(\"en.lucene\"))\n+            .setSortable(true).build();\n+        Field description = new SimpleField(\"description\", DataType.EDM_STRING, false).build();\n+        Field category = new SimpleField(\"category\", DataType.EDM_STRING, false).build();\n+        Field tags = new SearchableField(\"tags\", true).build();\n+        Field parkingIncluded = new SimpleField(\"parkingIncluded\", DataType.EDM_BOOLEAN, false).build();\n+        Field smokingAllowed = new SimpleField(\"smokingAllowed\", DataType.EDM_BOOLEAN, false).build();\n+        Field lastRenovationDate = new SimpleField(\"lastRenovationDate\", DataType.EDM_DATE_TIME_OFFSET, false).build();\n+        Field rating = new SimpleField(\"rating\", DataType.EDM_INT32, false).build();\n+        Field location = new SimpleField(\"location\", DataType.EDM_GEOGRAPHY_POINT, false).build();\n+        Field address = new ComplexField(\"address\", false)\n+            .setFields(buildHotelAddressField()).build();\n+        Field rooms = new ComplexField(\"rooms\", true).setFields(buildHotelRoomField()).build();\n+\n+        return Arrays.asList(hotelId, hotelName, description, category, tags, parkingIncluded, smokingAllowed,\n+            lastRenovationDate, rating, location, address, rooms);\n+    }\n+\n+    private List<Field> buildHotelAddressField() {\n+        Field streetAddress = new SimpleField(\"streetAddress\", DataType.EDM_STRING, false).setFacetable(true)\n+            .setKey(true).build();\n+        Field city = new SearchableField(\"city\", false).setFilterable(true).build();\n+        Field stateProvince = new SearchableField(\"stateProvince\", false).build();\n+        Field country = new SearchableField(\"country\", false)\n+            .setSynonymMaps(Arrays.asList(\"America -> USA\", \"USA -> US\")).build();\n+        Field postalCode = new SimpleField(\"postalCode\", DataType.EDM_STRING, false).build();\n+        return Arrays.asList(streetAddress, city, stateProvince, country, postalCode);\n+    }\n+\n+    private List<Field> buildHotelRoomField() {\n+        Field description = new SimpleField(\"description\", DataType.EDM_STRING, false).build();\n+        Field descriptionFr = new SimpleField(\"descriptionFr\", DataType.EDM_STRING, false).build();\n+        Field type = new SimpleField(\"type\", DataType.EDM_STRING, false).build();\n+        Field baseRate = new SimpleField(\"baseRate\", DataType.EDM_DOUBLE, false).build();\n+        Field bedOptions = new SimpleField(\"bedOptions\", DataType.EDM_STRING, false).build();\n+        Field sleepsCount = new SimpleField(\"sleepsCount\", DataType.EDM_INT32, false).build();\n+        Field smokingAllowed = new SimpleField(\"smokingAllowed\", DataType.EDM_BOOLEAN, false).build();\n+        Field tags = new SimpleField(\"tags\", DataType.EDM_STRING, true).build();\n+        return Arrays.asList(description, descriptionFr, type, baseRate, bedOptions, sleepsCount, smokingAllowed, tags);\n+    }\n+\n+    private List<Field> sortByFieldName(List<Field> fields) {\n+        return fields.stream().sorted((o1, o2) -> o1.getName().compareTo(o2.getName())).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "367a661aab0362a385c3e47f072401b5b0e409cd", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/367a661aab0362a385c3e47f072401b5b0e409cd", "committedDate": "2020-05-01T17:08:12Z", "message": "some changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8587a2f9990fd11130be940451b77bf7dec47168", "committedDate": "2020-05-01T18:04:09Z", "message": "Address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MzQ5NjQ0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-404349644", "createdAt": "2020-05-01T19:19:59Z", "commit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NDE2MDM5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#pullrequestreview-404416039", "createdAt": "2020-05-01T21:43:28Z", "commit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "state": "APPROVED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMTo0MzoyOFrOGPWhfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMjoxMjoyNVrOGPXD8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MDg0NQ==", "bodyText": "Nit: \"... converts a strongly-typed model class ...\" since you use singular, \"class\".", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418750845", "createdAt": "2020-05-01T21:43:28Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditions`.\n+- Added helper class `FieldBuilder` which converts strongly-typed model class to `List<Field>`. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MTAyMg==", "bodyText": "Nit: \", and SearchableFieldProperty\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418751022", "createdAt": "2020-05-01T21:43:59Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditions`.\n+- Added helper class `FieldBuilder` which converts strongly-typed model class to `List<Field>`. \n+- Added annotations `FieldIgnore`, `SimpleFieldProperty`, `SearchableFieldProperty` to define the `Field` on model properties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MTIwNg==", "bodyText": "Nit: Oxford comma, i.e. \"... , and ...\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418751206", "createdAt": "2020-05-01T21:44:28Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/CHANGELOG.md", "diffHunk": "@@ -1,7 +1,10 @@\n # Release History\n \n ## 1.0.0-beta.3 (Unreleased)\n-- Change `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditioans`.\n+- Changed `createOrUpdate*` and `delete*` APIs in `SearchServiceClient` to use boolean `onlyIfUnchanged` instead of `MatchConditions`.\n+- Added helper class `FieldBuilder` which converts strongly-typed model class to `List<Field>`. \n+- Added annotations `FieldIgnore`, `SimpleFieldProperty`, `SearchableFieldProperty` to define the `Field` on model properties.\n+- Added fluent class `SimpleField`, `SearchableField` and `ComplexField` to build `Field`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MjA1Nw==", "bodyText": "@brjohnstmsft is there a max depth for complex fields in the Search service itself we should use here - maybe even + some buffer in case the service changes?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418752057", "createdAt": "2020-05-01T21:47:02Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,256 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Mzg3Nw==", "bodyText": "But if there's a common base class for arrays, collections, lists, etc. (in .NET, this is ICollection<T> or ICollection), that's best. It's not about what comes back from the service, but what is passed in and can be reconstituted. Any collection (in the general sense) can send a JSON array. When round-tripping, as long as a set or queue can be instantiated with an array (they can in .NET - not sure about Java) then the class should work. I think the flexibility is worth it, but you could always punt this change to preview 4 (just open a separate bug to track). In .NET, I can say I'm not limiting the classes they can use - just that it implements IEnumerable<T>.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418753877", "createdAt": "2020-05-01T21:53:05Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ=="}, "originalCommit": {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Njk4Nw==", "bodyText": "The field name needs to be overridable. Imagine a key named \"hid\" but the field is hotelId.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418756987", "createdAt": "2020-05-01T22:03:08Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,256 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param currentClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code currentClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that currentClass is built to.\n+     */\n+    private static List<Field> build(Class<?> currentClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(currentClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, currentClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(currentClass);\n+        List<Field> searchFields = Arrays.stream(currentClass.getDeclaredFields())\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        return type.getClass().isArray() || isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (!(type instanceof ParameterizedType)) {\n+            return false;\n+        }\n+\n+        Type rawType = ((ParameterizedType) type).getRawType();\n+        return List.class.isAssignableFrom((Class<?>) rawType);\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        validateType(componentOrElementType, true, logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(String.format(\n+            \"Collection type %s is not supported.\", arrayOrListType.getTypeName())));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Nzc2Mw==", "bodyText": "After this, you should assert that only analyzer or both searchAnalyzer and indexAnalyzer are specified.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418757763", "createdAt": "2020-05-01T22:05:37Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,256 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param currentClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code currentClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that currentClass is built to.\n+     */\n+    private static List<Field> build(Class<?> currentClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(currentClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, currentClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(currentClass);\n+        List<Field> searchFields = Arrays.stream(currentClass.getDeclaredFields())\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        return type.getClass().isArray() || isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (!(type instanceof ParameterizedType)) {\n+            return false;\n+        }\n+\n+        Type rawType = ((ParameterizedType) type).getRawType();\n+        return List.class.isAssignableFrom((Class<?>) rawType);\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        validateType(componentOrElementType, true, logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(String.format(\n+            \"Collection type %s is not supported.\", arrayOrListType.getTypeName())));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously \"\n+                        + \"for %s\", classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false)\n+                .setSortable(simpleFieldPropertyAnnotation.isSortable())\n+                .setFilterable(simpleFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(simpleFieldPropertyAnnotation.isFacetable())\n+                .setKey(simpleFieldPropertyAnnotation.isKey())\n+                .setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            if (!searchField.getType().equals(DataType.EDM_STRING)\n+                && !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true)\n+                .setSortable(searchableFieldPropertyAnnotation.isSortable())\n+                .setFilterable(searchableFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(searchableFieldPropertyAnnotation.isFacetable())\n+                .setKey(searchableFieldPropertyAnnotation.isKey())\n+                .setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!searchableFieldPropertyAnnotation.analyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.analyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.searchAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.searchAnalyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.indexAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.indexAnalyzer())));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODM2OA==", "bodyText": "I'd call this synonymMapNames since it's the names of synonymMaps. IIRC, that's what I did for that reason.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418758368", "createdAt": "2020-05-01T22:07:39Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SearchableField.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+\n+/**\n+ * A helper Field model to build a searchable {@link Field}.\n+ */\n+public class SearchableField extends SimpleField {\n+    private AnalyzerName analyzer;\n+    private AnalyzerName searchAnalyzer;\n+    private AnalyzerName indexAnalyzer;\n+    private List<String> synonymMaps;\n+\n+    /**\n+     * Initializes a new instance of the {@link SearchableField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     * @throws NullPointerException when {@code name} is null.\n+     */\n+    public SearchableField(String name, boolean collection) {\n+        super(name, DataType.EDM_STRING, collection);\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for analyzer.\n+     */\n+    public AnalyzerName getAnalyzer() {\n+        return analyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @param analyzer The {@link AnalyzerName} used for analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setAnalyzer(AnalyzerName analyzer) {\n+        this.analyzer = analyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for search analyzer.\n+     */\n+    public AnalyzerName getSearchAnalyzer() {\n+        return searchAnalyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param searchAnalyzer The {@link AnalyzerName} used for search analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSearchAnalyzer(AnalyzerName searchAnalyzer) {\n+        this.searchAnalyzer = searchAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for index analyzer.\n+     */\n+    public AnalyzerName getIndexAnalyzer() {\n+        return indexAnalyzer;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param indexAnalyzer The {@link AnalyzerName} used for index analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setIndexAnalyzer(AnalyzerName indexAnalyzer) {\n+        this.indexAnalyzer = indexAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @return List of names of synonym maps to associate with this field.\n+     */\n+    public List<String> getSynonymMaps() {\n+        return synonymMaps;\n+    }\n+\n+    /**\n+     * Sets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @param synonymMaps list of names of synonym maps to associate with this field.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSynonymMaps(List<String> synonymMaps) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODczMg==", "bodyText": "When you do the renames, you might call this SearchFieldBase given our discussion internally.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418758732", "createdAt": "2020-05-01T22:09:00Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODkxNw==", "bodyText": "Nit: \"The name of the field cannot be null\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418758917", "createdAt": "2020-05-01T22:09:38Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {\n+    private final ClientLogger logger = new ClientLogger(FieldBase.class);\n+    private final String name;\n+    private final DataType dataType;\n+\n+    /**\n+     * Initializes a new instance of the {@link FieldBase} class.\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The data type of the field.\n+     */\n+    protected FieldBase(String name, DataType dataType) {\n+        if (CoreUtils.isNullOrEmpty(name)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTM0OQ==", "bodyText": "The comment is off, since the default is not \"null\". Also, why can't the default just be null (null reference, not a string with contents \"null\")? Is that not typical in Java?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418759349", "createdAt": "2020-05-01T22:11:21Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,82 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.indexes;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTY2NA==", "bodyText": "Missing name. The name must be overridable. It can default to the property name, but that isn't always desirable. Same for all other attribute classes below.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418759664", "createdAt": "2020-05-01T22:12:25Z", "author": {"login": "heaths"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,82 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.indexes;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8587a2f9990fd11130be940451b77bf7dec47168"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29f6ee7e95a6727a00176ac7e1b0b0fee8f935a9", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/29f6ee7e95a6727a00176ac7e1b0b0fee8f935a9", "committedDate": "2020-05-01T22:21:22Z", "message": "more link locale removal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b06281f7e16b1e5a12fdd2bf9bb703c3c5df9d06", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b06281f7e16b1e5a12fdd2bf9bb703c3c5df9d06", "committedDate": "2020-05-01T23:37:40Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6174467374831a08e20aa27332326b9242d5069", "author": {"user": {"login": "sima-zhu", "name": "Sima Zhu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6174467374831a08e20aa27332326b9242d5069", "committedDate": "2020-05-01T23:47:13Z", "message": "Merge from master"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4594, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}