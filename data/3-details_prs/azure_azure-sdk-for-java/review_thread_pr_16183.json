{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMzEyNTU5", "number": 16183, "reviewThreads": {"totalCount": 84, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowMDo0NlrOEtTlNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDoxNzozM1rOEwluZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQyMTk2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowMDo0NlrOHhBWcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowMDo0NlrOHhBWcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4NzE4Ng==", "bodyText": "Is this operator required even if the autoLockRenewal is set to false? Also, this member variable should now be renamed to renewOperator.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504387186", "createdAt": "2020-10-14T04:00:46Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -29,14 +33,19 @@\n     private final Flux<ServiceBusReceivedMessage> processor;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        this.processor = new ServiceBusRenewOperator(linkProcessor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQyOTM2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowNTozOFrOHhBa4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowNTozOFrOHhBa4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODMyMA==", "bodyText": "Setter methods on builder should not have set prefix.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388320", "createdAt": "2020-10-14T04:05:38Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder setMaxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQzMDA3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowNTo1OVrOHhBbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowNTo1OVrOHhBbOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODQxMQ==", "bodyText": "Same here. Remove set prefix.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388411", "createdAt": "2020-10-14T04:05:59Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +851,25 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO} or\n+         * {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder setMaxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQzMjU3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowNzozNlrOHhBcrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0OToyOVrOHktCZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODc4MQ==", "bodyText": "Not sure why we are passing connectionProcessor and connectionProcessor.getRetryOptions().getTryTimeout(). If the session manager has the connection processor, it should be able to get the retry options from it anyway. Also, it's weird to see retry options in connection processor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388781", "createdAt": "2020-10-14T04:07:36Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -763,19 +781,22 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final ReceiverOptions receiverOptions = new ReceiverOptions(receiveMode, prefetchCount,\n                 sessionId, isRollingSessionReceiver(), maxConcurrentSessions);\n \n+            final UnnamedSessionManager sessionManager;\n+\n             if (CoreUtils.isNullOrEmpty(sessionId)) {\n-                final UnnamedSessionManager sessionManager = new UnnamedSessionManager(entityPath, entityType,\n+                sessionManager = new UnnamedSessionManager(entityPath, entityType,\n                     connectionProcessor, connectionProcessor.getRetryOptions().getTryTimeout(), tracerProvider,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0ODY3OQ==", "bodyText": "I removed connectionProcessor.getRetryOptions().getTryTimeout() .\nretry options in connection processor This is being passed on to AMQP Channel Processor in  core-amqp library for retry policy.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508248679", "createdAt": "2020-10-20T06:49:29Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -763,19 +781,22 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final ReceiverOptions receiverOptions = new ReceiverOptions(receiveMode, prefetchCount,\n                 sessionId, isRollingSessionReceiver(), maxConcurrentSessions);\n \n+            final UnnamedSessionManager sessionManager;\n+\n             if (CoreUtils.isNullOrEmpty(sessionId)) {\n-                final UnnamedSessionManager sessionManager = new UnnamedSessionManager(entityPath, entityType,\n+                sessionManager = new UnnamedSessionManager(entityPath, entityType,\n                     connectionProcessor, connectionProcessor.getRetryOptions().getTryTimeout(), tracerProvider,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODc4MQ=="}, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQzNTM5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowOToxOFrOHhBePA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDowOToxOFrOHhBePA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4OTE4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n          \n          \n            \n                     * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504389180", "createdAt": "2020-10-14T04:09:18Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQzNzY4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoxMDozNFrOHhBfgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoxMDozNFrOHhBfgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4OTUwNA==", "bodyText": "I don't see this class being used anywhere outside this file. Do we need this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504389504", "createdAt": "2020-10-14T04:10:34Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageProcessor.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Processor that listens to upstream messages, pushes them downstream then completes it if necessary.\n+ */\n+class ServiceBusMessageProcessor extends FluxProcessor<ServiceBusReceivedMessage, ServiceBusReceivedMessage>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQ1NzUwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyMTozNlrOHhBrJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyMTozNlrOHhBrJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5MjQ4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {\n          \n          \n            \n                public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504392486", "createdAt": "2020-10-14T04:21:36Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+/**\n+ * Operate on messages from to upstream, pushes them downstream  and start lock renewal.\n+ */\n+final class ServiceBusRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage>  {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link org.reactivestreams.Publisher}\n+     * @param source the {@link org.reactivestreams.Publisher} to decorate\n+     */\n+    ServiceBusRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQ2MzYxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyNTozMFrOHhBuqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyNTozMFrOHhBuqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5MzM4Nw==", "bodyText": "What is the purpose of hasError? Also, we are swallowing the exception here. If actual.onNext() throws an exception, should we stop the source flux?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504393387", "createdAt": "2020-10-14T04:25:30Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+/**\n+ * Operate on messages from to upstream, pushes them downstream  and start lock renewal.\n+ */\n+final class ServiceBusRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage>  {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link org.reactivestreams.Publisher}\n+     * @param source the {@link org.reactivestreams.Publisher} to decorate\n+     */\n+    ServiceBusRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription s) {\n+                actual.onSubscribe(s);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+\n+                final long sequenceNumber = message.getSequenceNumber();\n+                final String lockToken = message.getLockToken();\n+                LockRenewalOperation renewLockOperation = null;\n+\n+                if (isAutoRenewLock) {\n+                    if (CoreUtils.isNullOrEmpty(lockToken)) {\n+                        throw logger.logExceptionAsError(new IllegalStateException(\n+                            \"Cannot auto-renew message without a lock token on message. Sequence number: \" + sequenceNumber));\n+                    } else if (message.getLockedUntil() ==  null) {\n+                        throw logger.logExceptionAsError(new IllegalStateException(\n+                            \"Cannot auto-renew message without a lock token until on message. Sequence number: \" + sequenceNumber));\n+                    }\n+\n+                    renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal, false,\n+                        onRenewLock, message.getLockedUntil());\n+                    messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                        renewLockOperation);\n+                }\n+\n+                final AtomicBoolean hasError = new AtomicBoolean();\n+                try {\n+                    actual.onNext(message);\n+                } catch (Exception e) {\n+                    hasError.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTQ2NjQwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyNzowNVrOHhBwRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyMjoxMlrOHkuFTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng==", "bodyText": "This should be available transitively through com.azure.core.amqp already.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504393796", "createdAt": "2020-10-14T04:27:05Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,7 @@\n \n module com.azure.messaging.servicebus {\n     requires transitive com.azure.core.amqp;\n+    requires transitive org.reactivestreams;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjQ0OQ==", "bodyText": "It is not available , thus I had to add it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508246449", "createdAt": "2020-10-20T06:44:31Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,7 @@\n \n module com.azure.messaging.servicebus {\n     requires transitive com.azure.core.amqp;\n+    requires transitive org.reactivestreams;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng=="}, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NTgwNg==", "bodyText": "com.azure.core module requires this transitively. So, anything depending on core should have it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508265806", "createdAt": "2020-10-20T07:22:12Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,7 @@\n \n module com.azure.messaging.servicebus {\n     requires transitive com.azure.core.amqp;\n+    requires transitive org.reactivestreams;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng=="}, "originalCommit": {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzA5MjMzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1ODoyMlrOHiMKNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1ODoyMlrOHiMKNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMjg1NQ==", "bodyText": "I notice this file keeps changing, but there are no functional changes here. You can revert them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505612855", "createdAt": "2020-10-15T14:58:22Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -5,6 +5,7 @@\n import com.azure.core.util.logging.ClientLogger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzA5OTA4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1OTo0MFrOHiMOVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1OTo0MFrOHiMOVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMzkxMQ==", "bodyText": "This comment isn't needed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505613911", "createdAt": "2020-10-15T14:59:40Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzEwNjUwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowMTowNlrOHiMS4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNjoyMjo1MlrOHiouJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNTA3NA==", "bodyText": "I think we should move the validation of this argument to here, so we don't need to bloat buildAsyncClient. Same with prefetch as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505615074", "createdAt": "2020-10-15T15:01:06Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {\n+            this.maxAutoRenewDuration = maxAutoRenewDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA4MDgwNQ==", "bodyText": "I did moved it once but later I saw a test which validating illegal value for prefetch thro error at time of buildClient().\nAlso from java convention point of view, I think We throw error when we people call .build() .\nThe flow as I see as user\n\nI configure values  in builder\nI build (This is the place, more appropriate to throw illegal value exception)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506080805", "createdAt": "2020-10-16T06:22:52Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {\n+            this.maxAutoRenewDuration = maxAutoRenewDuration;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNTA3NA=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzEyMjQ5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNDoxMFrOHiMc9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNDoxMFrOHiMc9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNzY1Mg==", "bodyText": "What about validation of these other parameters?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505617652", "createdAt": "2020-10-15T15:04:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzEyNjIzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNDo0MVrOHiMfCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxMjo1OFrOHiM54Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODE4NQ==", "bodyText": "Can you split this into another class instead of an anonymous one. This is hard to understand.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505618185", "createdAt": "2020-10-15T15:04:41Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTA1Nw==", "bodyText": "Does this anonymous class need to inherit from CoreSubscriber? BaseSubscriber does most of this for you already.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505625057", "createdAt": "2020-10-15T15:12:58Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODE4NQ=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzEyODUxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNTowM1rOHiMgTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNTowM1rOHiMgTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODUxMQ==", "bodyText": "Why do you need a lock?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505618511", "createdAt": "2020-10-15T15:05:03Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzEzNjUxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNjoyOFrOHiMlNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowODoyNVrOHiMrhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxOTc2NQ==", "bodyText": "Can we have a static \"Is complete\" lock renewal so we can make this variable final.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505619765", "createdAt": "2020-10-15T15:06:28Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMTM4Mg==", "bodyText": "final LockRenewalOperation operation;\nif (renewLock) {\n    operation = ...\n} else {\n    operation = COMPLETED_ONE;\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505621382", "createdAt": "2020-10-15T15:08:25Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxOTc2NQ=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzE0MTc0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowNzozMlrOHiMoiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMDoxNzo0OVrOHifxMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMDYxOQ==", "bodyText": "nit: change formatting of these if conditionals statements. I notice times you use Objects.isNull rather than comparing. Is there a reason for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505620619", "createdAt": "2020-10-15T15:07:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNDEzMQ==", "bodyText": "no specific reason,  I have now changed it to use Objects.isNull  , consistent with other places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505934131", "createdAt": "2020-10-16T00:17:49Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMDYxOQ=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzE0ODkwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowODo0OVrOHiMs5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTowODo0OVrOHiMs5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMTczMg==", "bodyText": "This can be dumped in the \"ReceiverOptions\"... so we wouldn't have to keep changing the ctor signature.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505621732", "createdAt": "2020-10-15T15:08:49Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -121,10 +123,12 @@\n      * @param tracerProvider Tracer for telemetry.\n      * @param messageSerializer Serializes and deserializes Service Bus messages.\n      * @param onClientClose Operation to run when the client completes.\n+     * @param maxAutoRenewLockDuration for which lock should be renewed.\n      */\n     ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType,\n         ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, Duration cleanupInterval,\n-        TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose) {\n+        TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose,\n+        Duration maxAutoRenewLockDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzE2MzgwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxMTo0OFrOHiM2Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxMTo0OFrOHiM2Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNDEzMA==", "bodyText": "Log the error, e?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505624130", "createdAt": "2020-10-15T15:11:48Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null\n+                       && message.getLockToken() != null) {\n+                       renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal,\n+                           false, onRenewLock, message.getLockedUntil());\n+\n+                       messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                           renewLockOperation);\n+                   }\n+\n+                   try {\n+                       actual.onNext(message);\n+                   } catch (Exception e) {\n+                       logger.error(\"Exception occurred while handling downstream onNext operation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzE2NjcwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxMjoyMFrOHiM3_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxMjoyMFrOHiM3_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNDU3NA==", "bodyText": "If you use the final suggestion above, this null check is not needed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505624574", "createdAt": "2020-10-15T15:12:20Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null\n+                       && message.getLockToken() != null) {\n+                       renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal,\n+                           false, onRenewLock, message.getLockedUntil());\n+\n+                       messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                           renewLockOperation);\n+                   }\n+\n+                   try {\n+                       actual.onNext(message);\n+                   } catch (Exception e) {\n+                       logger.error(\"Exception occurred while handling downstream onNext operation.\");\n+                       onError(e);\n+                   } finally {\n+                       if (renewLockOperation != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzE3NTEwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxNDowN1rOHiM9bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMzo1NlrOHiSURA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTk2Ng==", "bodyText": "Why the rename?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505625966", "createdAt": "2020-10-15T15:14:07Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,58 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzczMg==", "bodyText": "Because now we are using this class for named session also.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505713732", "createdAt": "2020-10-15T17:23:56Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,58 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTk2Ng=="}, "originalCommit": {"oid": "a5444892387a0184eba361884203bb75b0aa2977"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDQ4NjE1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODoxOTo1NFrOHithWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODoxOTo1NFrOHithWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE1OTQ0OA==", "bodyText": "When will this happen?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506159448", "createdAt": "2020-10-16T08:19:54Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDU2NDY3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODozNDowMFrOHiuU4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODozNDowMFrOHiuU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3MjY0MQ==", "bodyText": "Why do we need to use this subscriber if the autoRenewLock is false?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506172641", "createdAt": "2020-10-16T08:34:00Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDU3MjcwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODozNToyOFrOHiuZ9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODozNToyOFrOHiuZ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mzk0MQ==", "bodyText": "Log the exception as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506173941", "createdAt": "2020-10-16T08:35:28Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDYxOTM4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODo0NTozM1rOHiu2xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODoyNzowOVrOHkDMHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTMxOA==", "bodyText": "This else block is not required.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506181318", "createdAt": "2020-10-16T08:45:33Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2MzAzNw==", "bodyText": "This should not be called, but this is for debugging  only, I have added a log point to help in production log error.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507563037", "createdAt": "2020-10-19T08:27:09Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTMxOA=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDYyMTgwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODo0NjowOVrOHiu4ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODo0NjowOVrOHiu4ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTczMw==", "bodyText": "Remove this printStackTrace.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506181733", "createdAt": "2020-10-16T08:46:09Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDYyNTYzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODo0Njo1OFrOHiu66w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODoyNjoxM1rOHkDJxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MjM3OQ==", "bodyText": "Will this also call hookOnError()?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506182379", "createdAt": "2020-10-16T08:46:58Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2MjQzNw==", "bodyText": "yes", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507562437", "createdAt": "2020-10-19T08:26:13Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MjM3OQ=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDYzNjQwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODo0OTozNlrOHivBeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0MDowOFrOHksxWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4NDA1Ng==", "bodyText": "Will this propagate the subscriber context?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506184056", "createdAt": "2020-10-16T08:49:36Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NDMxMg==", "bodyText": "yes I wrote test", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508244312", "createdAt": "2020-10-20T06:40:08Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4NDA1Ng=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDczNDc0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOTowODo0MFrOHiwChw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo0NDowNVrOHks4xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ==", "bodyText": "It's odd that creating an instance of LockRenewalOperation also starts renewing the locks immediately. Also, if the lock renewal fails, how is the user notified of it?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506200711", "createdAt": "2020-10-16T09:08:40Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTU4NA==", "bodyText": "There is logic logic inside to delay the lock renewal based on given OffsetDateTime tokenLockedUntil", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508245584", "createdAt": "2020-10-20T06:42:48Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjIxNA==", "bodyText": "The lock renewal is running in background and we do not call user in this case, we will log the error.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508246214", "createdAt": "2020-10-20T06:44:05Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDc1OTk1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToxMjoxNFrOHiwTdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxODoyNjo1OFrOHjLlrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTA0NA==", "bodyText": "If the message has null lockedUntil and lockToken values, should that be considered an invalid message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506205044", "createdAt": "2020-10-16T09:12:14Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1MjA3OA==", "bodyText": "We should never be in this situation, In RECEIVE_DELETE mode, we will always have these values. But I have put these checks as caution.\nMay be we can log it as warning", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506652078", "createdAt": "2020-10-16T18:26:58Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTA0NA=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDc2NDA1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToxMjo1MFrOHiwWBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToxMjo1MFrOHiwWBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTcwMg==", "bodyText": "When the lock is renewed, will message.getLockedUntil() return the renewed time? If yes, where is the update to lockedUntil property happening for this message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506205702", "createdAt": "2020-10-16T09:12:50Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDc3MjM5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToxNTowM1rOHiwbaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODoyODoxM1rOHkDO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNzA4MQ==", "bodyText": "What happens if this operation throws an exception? This can throw if the lockContainer is disposed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506207081", "createdAt": "2020-10-16T09:15:03Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2MzczMQ==", "bodyText": "the error is thrown in this case.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507563731", "createdAt": "2020-10-19T08:28:13Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNzA4MQ=="}, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDc4MDg5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToxNjo0N1rOHiwg3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToxNjo0N1rOHiwg3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwODQ3OA==", "bodyText": "Typo in method name max. Also, include Lock after Auto in the name and update the javadocs too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506208478", "createdAt": "2020-10-16T09:16:47Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,25 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDc5Njk0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyMDoyOFrOHiwqxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyMDoyOFrOHiwqxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxMTAxMg==", "bodyText": "maxAutoLockRenewDuration.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506211012", "createdAt": "2020-10-16T09:20:28Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +844,25 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO} or\n+         * {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoRenewDuration(Duration maxAutoRenewDuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDgxMDA5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyMzoyNVrOHiwzBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyMzoyNVrOHiwzBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxMzEyNw==", "bodyText": "Since this operator is created only when autoLockRenewal is true, do we need the 2nd param?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506213127", "createdAt": "2020-10-16T09:23:25Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor\n             .map(message -> this.messageSerializer.deserialize(message, ServiceBusReceivedMessage.class))\n             .publish(prefetch)\n             .autoConnect(1);\n+\n+        if (autoLockRenewal) {\n+            this.messageSource = new ServiceBusMessageRenewOperator(source,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDgxOTM1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyNToxNVrOHiw4dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwOToyNToxNVrOHiw4dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxNDUxOQ==", "bodyText": "If only one subscription is allowed, this should return from here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506214519", "createdAt": "2020-10-16T09:25:15Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, isAutoRenewLock,\n+            maxAutoLockRenewal, messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {\n+            newLockRenewSubscriber.dispose();\n+            logger.error(\"Already subscribed once.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzUxNzkzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTowMDowNFrOHjMiog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTowMDowNFrOHjMiog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY2NzY4Mg==", "bodyText": "Why are you keeping a reference to this? BaseSubscriber holds most of this logic. I don't see a call to the base class either.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506667682", "createdAt": "2020-10-16T19:00:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzUzNjEzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTowNjoyNVrOHjMuGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTowNjoyNVrOHjMuGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MDYxOQ==", "bodyText": "nit: unneeded new line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506670619", "createdAt": "2020-10-16T19:06:25Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiver.java", "diffHunk": "@@ -182,6 +183,7 @@ void setSessionLockedUntil(OffsetDateTime lockedUntil) {\n     }\n \n     Mono<Void> updateDisposition(String lockToken, DeliveryState deliveryState) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU0OTQxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReceiveLinkProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxMToxMFrOHjM2IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMTo1NDoyN1rOHjQ0Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjY3Mw==", "bodyText": "When is this used?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506672673", "createdAt": "2020-10-16T19:11:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReceiveLinkProcessor.java", "diffHunk": "@@ -129,6 +135,15 @@ public String getLinkName() {\n             }));\n     }\n \n+    /**\n+     * Gets the error context associated with this link.\n+     *\n+     * @return the error context associated with this link.\n+     */\n+    public AmqpErrorContext getErrorContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczNzY4Mw==", "bodyText": "I was using earlier, but not now. So removing it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506737683", "createdAt": "2020-10-16T21:54:27Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReceiveLinkProcessor.java", "diffHunk": "@@ -129,6 +135,15 @@ public String getLinkName() {\n             }));\n     }\n \n+    /**\n+     * Gets the error context associated with this link.\n+     *\n+     * @return the error context associated with this link.\n+     */\n+    public AmqpErrorContext getErrorContext() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjY3Mw=="}, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU1MjgyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxMjozMlrOHjM4PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxMjozMlrOHjM4PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MzIxMw==", "bodyText": "consistent use of final.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506673213", "createdAt": "2020-10-16T19:12:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});\n+\n+        ServiceBusMessageRenewOperator renewOperator = new ServiceBusMessageRenewOperator(messageSource,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU2MDQ1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNTowOVrOHjM8yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODowMDoyM1rOHkCMfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw==", "bodyText": "Use TestPublisher because we should test multiple renewals.\nWe should also test that cancellation from downstream.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506674377", "createdAt": "2020-10-16T19:15:09Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4NDczMw==", "bodyText": "I think we need more tests about the behaviour of this. has many more cases: https://github.com/reactor/reactor-core/blob/master/reactor-core/src/test/java/reactor/core/publisher/FluxMapTest.java", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506684733", "createdAt": "2020-10-16T19:39:00Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw=="}, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0Njc0OA==", "bodyText": "added more test", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507546748", "createdAt": "2020-10-19T08:00:23Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw=="}, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU2NzcxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNzozMlrOHjNBGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNzozMlrOHjNBGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTQ4MQ==", "bodyText": "same comment about moving validation not to build method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506675481", "createdAt": "2020-10-16T19:17:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -927,20 +956,23 @@ public ServiceBusReceiverClientBuilder topicName(String topicName) {\n          *     #topicName(String) topicName} is set, but {@link #subscriptionName(String) subscriptionName} is not.\n          * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n+         * @throws IllegalArgumentException {#code maxAutoLockRenewDuration} is negative.\n          */\n         public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final MessagingEntityType entityType = validateEntityPaths(logger, connectionStringEntityName, topicName,\n                 queueName);\n             final String entityPath = getEntityPath(logger, entityType, queueName, topicName, subscriptionName,\n                 subQueue);\n             validateAndThrow(prefetchCount);\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU3MDMzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxODoyOVrOHjNCwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxODoyOVrOHjNCwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTkwNQ==", "bodyText": "Should move validation to the maxAutoLockRenewDuration setter.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506675905", "createdAt": "2020-10-16T19:18:29Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -758,24 +777,19 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n                 SubQueue.NONE);\n \n             validateAndThrow(prefetchCount);\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU4Njc0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyNDozOVrOHjNNJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMDozODoxM1rOHjS82Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw==", "bodyText": "Can we keep this to ReceiveOptions? it seems like we're bloating this constructor", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506678567", "createdAt": "2020-10-16T19:24:39Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTA3NA==", "bodyText": "I'm also adding another parameter from ReceiveOptions.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506679074", "createdAt": "2020-10-16T19:25:48Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw=="}, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MjY5Nw==", "bodyText": "Okay but I think we should not add messageLockContainer since that is not related to ReceiveOptions.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506772697", "createdAt": "2020-10-17T00:38:13Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw=="}, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU5MjQxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyNjo0MVrOHjNQew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyNjo0MVrOHjNQew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTQxOQ==", "bodyText": "Same with this one. I'm not sure if Yijun fixed this too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506679419", "createdAt": "2020-10-16T19:26:41Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -758,24 +777,19 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n                 SubQueue.NONE);\n \n             validateAndThrow(prefetchCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzU5NjEyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyODowNFrOHjNSxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyODowNFrOHjNSxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MDAwNQ==", "bodyText": "Can we dump this in receive options.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506680005", "createdAt": "2020-10-16T19:28:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -142,13 +147,13 @@\n             renewal.close();\n         });\n \n-        this.unnamedSessionManager = null;\n+        this.sessionManager = null;\n     }\n \n     ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType,\n         ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, Duration cleanupInterval,\n         TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose,\n-        UnnamedSessionManager unnamedSessionManager) {\n+        Duration maxAutoRenewLockDuration, ServiceBusSessionManager sessionManager) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjczOTQwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNzoyM1rOHkkHtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNzoyM1rOHkkHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMjU4MQ==", "bodyText": "receiverOptions also has an sessionId. Can we just use that one?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508102581", "createdAt": "2020-10-19T22:37:23Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,47 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {\n     // Time to delay before trying to accept another session.\n     private static final Duration SLEEP_DURATION_ON_ACCEPT_SESSION_EXCEPTION = Duration.ofMinutes(1);\n \n-    private final ClientLogger logger = new ClientLogger(UnnamedSessionManager.class);\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionManager.class);\n     private final String entityPath;\n     private final MessagingEntityType entityType;\n     private final ReceiverOptions receiverOptions;\n     private final ServiceBusConnectionProcessor connectionProcessor;\n     private final Duration operationTimeout;\n     private final TracerProvider tracerProvider;\n     private final MessageSerializer messageSerializer;\n+    private final String userProvidedSessionId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Mzc4ODU2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoxMDo0OFrOHktr-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTo1MzowM1rOHlOkKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTMyMQ==", "bodyText": "Wouldn't this call user's onError handler? I thought we were not going to notify the user of any error if auto lock renewal fails.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508259321", "createdAt": "2020-10-20T07:10:48Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5Nzk5Mg==", "bodyText": "Okay, for now I will not call onError, log it only.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508797992", "createdAt": "2020-10-20T19:53:03Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTMyMQ=="}, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Mzc5MTgxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoxMTo0M1rOHktt5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyMjo1N1rOHlGptA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTgxNQ==", "bodyText": "When will the message have null lock token and lockedUntil?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508259815", "createdAt": "2020-10-20T07:11:43Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODM0MA==", "bodyText": "That's true. We should probably log it and return early.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508668340", "createdAt": "2020-10-20T16:22:57Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTgxNQ=="}, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzgzOTc4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyNDoyMVrOHkuKHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyNDoyMVrOHkuKHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NzAzOA==", "bodyText": "Maybe we should just mark this as info as we don't surface any errors to users. Logging an error could alarm the user.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508267038", "createdAt": "2020-10-20T07:24:21Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Mzg0NjgwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyNjoxMlrOHkuOhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyNjoxMlrOHkuOhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2ODE2Ng==", "bodyText": "When the renewOperation is closed, should we also remove this from messageLockContainer?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508268166", "createdAt": "2020-10-20T07:26:12Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);\n+            }\n+        } else {\n+            logger.warning(\"Unexpected, LockToken [{}] or lockedUntil [{}] is not present for message [{}].\",\n+                lockToken, lockedUntil, message.getSequenceNumber());\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);\n+        } finally {\n+            renewOperation.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Mzk3NDU4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzo1ODozM1rOHkvcjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTo1MDo0OFrOHlbOqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4ODE0MA==", "bodyText": "Why do we restrict this to a single subscriber? Are multiple calls to receive() not allowed?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508288140", "createdAt": "2020-10-20T07:58:33Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwNTQ4MA==", "bodyText": "changed it to be able to make multiple receive () calls.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509005480", "createdAt": "2020-10-21T05:50:48Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4ODE0MA=="}, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjMzODI2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyMDoxN1rOHlGiPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDowNDo1OFrOHlO-mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjQzMQ==", "bodyText": "Why OffsetDateTime.now()? This variable is only used once.\nI'm not sure why we don't just have a LockRenewalOperation.DONE it just returns empty.\nclass LockRenewalOperation {\n    static final LockRenewalOperation COMPLETED = new LockRenewalOperation(null, null, null, null);\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508666431", "createdAt": "2020-10-20T16:20:17Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgwNDc2Mg==", "bodyText": "Removed it totally based on other comments.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508804762", "createdAt": "2020-10-20T20:04:58Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjQzMQ=="}, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM3NzE3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyOTozMVrOHlG6tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoyOTozMVrOHlG6tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjY5NQ==", "bodyText": "Do we need all these overloads? I'm not entirely sure why we need this consumer... Can't we map the renewalOperation.map(update -> {});?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508672695", "createdAt": "2020-10-20T16:29:31Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -49,6 +53,34 @@\n         this(lockToken, maxLockRenewalDuration, isSession, renewalOperation, OffsetDateTime.now());\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM4OTU5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozMjozMFrOHlHCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozMjozMFrOHlHCpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NDcyNg==", "bodyText": "Can we move that LockRenewSubscriber class into this one? It only exists to be used in this class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508674726", "createdAt": "2020-10-20T16:32:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {\n+            newLockRenewSubscriber.dispose();\n+            logger.error(\"Already subscribed once.\");\n+            return;\n+        }\n+        source.subscribe(lockRenewSubscriber.get());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM5MjA2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozMzoxMFrOHlHEPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozMzoxMFrOHlHEPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NTEzNQ==", "bodyText": "nit: FluxAutoRenew to follow the same vein as the existing ones.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508675135", "createdAt": "2020-10-20T16:33:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjM5ODkxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozNTowMlrOHlHIqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozNTowMlrOHlHIqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NjI2Nw==", "bodyText": "Can we move this duration logic into a receiver option?\nboolean isAutoRenewEnabled() { return maxAutoLockRenewDuration != null ...; }", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508676267", "createdAt": "2020-10-20T16:35:02Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,32 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor\n             .map(message -> this.messageSerializer.deserialize(message, ServiceBusReceivedMessage.class))\n-            .publish(prefetch)\n+            .publish(receiverOptions.getPrefetchCount())\n             .autoConnect(1);\n+\n+        final Duration maxAutoLockRenewDuration = receiverOptions.getMaxLockRenewDuration();\n+\n+        final boolean isAutoLockRenewal = maxAutoLockRenewDuration != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzUzMjE3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozNjoyMVrOHlSCjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozNjoyMVrOHlSCjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDkyNw==", "bodyText": "FluxAutoLockRenew", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508854927", "createdAt": "2020-10-20T21:36:21Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU0MjYyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozOTo0MFrOHlSI3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozOTo0MFrOHlSI3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjU0MA==", "bodyText": "Don't use error level here as we are not reporting these errors to the user. It will show up in their log and can alert them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508856540", "createdAt": "2020-10-20T21:39:40Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            } else if (Objects.isNull(lockedUntil)) {\n+                logger.info(\"Unexpected, lockedUntil is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            }\n+\n+            final Function<String, Mono<OffsetDateTime>> onRenewLockUpdateMessage = onRenewLock.andThen(updated ->\n+                updated.map(newLockedUntil -> {\n+                    message.setLockedUntil(newLockedUntil);\n+                    return newLockedUntil;\n+                }));\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false,\n+                onRenewLockUpdateMessage, lockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU0NDIxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0MDoxMFrOHlSJ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0MDoxMFrOHlSJ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Njc5Ng==", "bodyText": "onError() shouldn't be called here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508856796", "createdAt": "2020-10-20T21:40:10Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            } else if (Objects.isNull(lockedUntil)) {\n+                logger.info(\"Unexpected, lockedUntil is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            }\n+\n+            final Function<String, Mono<OffsetDateTime>> onRenewLockUpdateMessage = onRenewLock.andThen(updated ->\n+                updated.map(newLockedUntil -> {\n+                    message.setLockedUntil(newLockedUntil);\n+                    return newLockedUntil;\n+                }));\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false,\n+                onRenewLockUpdateMessage, lockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+            }\n+\n+            try {\n+                actual.onNext(message);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+                onError(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU1NDE5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ReceiverOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0MzozMFrOHlSP-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0MzozMFrOHlSP-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODM2MQ==", "bodyText": "We should use AutoLockRenew terminology consistently.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858361", "createdAt": "2020-10-20T21:43:30Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ReceiverOptions.java", "diffHunk": "@@ -62,6 +75,15 @@ int getPrefetchCount() {\n         return prefetchCount;\n     }\n \n+    /**\n+     * Determine if client have enabled auto renew of message or session lock.\n+     *\n+     * @return true if  autoRenew is enabled; false otherwise.\n+     */\n+    boolean isAutoRenewEnabled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU1NDcyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Mzo0MlrOHlSQTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Mzo0MlrOHlSQTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODQ0NQ==", "bodyText": "can this be static", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858445", "createdAt": "2020-10-20T21:43:42Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU1NTMwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Mzo1NVrOHlSQrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Mzo1NVrOHlSQrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODU0Mw==", "bodyText": "consistent null checks?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858543", "createdAt": "2020-10-20T21:43:55Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU1NjA2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NDoxMlrOHlSRLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NDoxMlrOHlSRLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODY3MA==", "bodyText": "you can do the assignment on the same line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858670", "createdAt": "2020-10-20T21:44:12Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU1Njc1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NDoyNVrOHlSRlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NDoyNVrOHlSRlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODc3Mg==", "bodyText": "This can be verbose.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858772", "createdAt": "2020-10-20T21:44:25Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU1ODA3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NDo1N1rOHlSSfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NDo1N1rOHlSSfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTAwNA==", "bodyText": "Informational?\nAlso, the underlying CoreSubscriber should do the dispose already. Do you need to explicitly do it?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508859004", "createdAt": "2020-10-20T21:44:57Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU2MDUwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NTo0NlrOHlSUAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NTo0NlrOHlSUAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTM5Mw==", "bodyText": "This should be a warning other than an info?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508859393", "createdAt": "2020-10-20T21:45:46Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU2NTg0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NzoyMFrOHlSXEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NzoyMFrOHlSXEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDE3OA==", "bodyText": "javadocs is incorrect. Same with the one on 654.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860178", "createdAt": "2020-10-20T21:47:20Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -669,8 +688,10 @@ public ServiceBusSessionReceiverClientBuilder maxConcurrentSessions(int maxConcu\n          * @param prefetchCount The prefetch count.\n          *\n          * @return The modified {@link ServiceBusSessionReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code prefetchCount} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU2NjgxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NzozN1rOHlSXrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0NzozN1rOHlSXrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDMzMg==", "bodyText": "Incorrect javadocs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860332", "createdAt": "2020-10-20T21:47:37Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU2NzIwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Nzo0NFrOHlSX6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0Nzo0NFrOHlSX6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDM5Mg==", "bodyText": "Incorrect javadocs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860392", "createdAt": "2020-10-20T21:47:44Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -845,8 +874,10 @@ private ServiceBusReceiverClientBuilder() {\n          * @param prefetchCount The prefetch count.\n          *\n          * @return The modified {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code prefetchCount} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU2ODY1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0ODoxNVrOHlSY1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTo1MDowOVrOHlbN0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDYzMA==", "bodyText": "This method is only used once. It can be pulled in here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860630", "createdAt": "2020-10-20T21:48:15Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoLockRenewDuration(Duration maxAutoLockRenewDuration) {\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwNTI2Ng==", "bodyText": "validateAndThrow(maxAutoLockRenewDuration) is used in  ServiceBusSessionReceiverClientBuilder and in ServiceBusReceiverClientBuilder, two places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509005266", "createdAt": "2020-10-21T05:50:09Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoLockRenewDuration(Duration maxAutoLockRenewDuration) {\n+            validateAndThrow(maxAutoLockRenewDuration);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDYzMA=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU2OTcxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0ODozOFrOHlSZiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0ODozOFrOHlSZiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDgwOA==", "bodyText": "Don't think we need to log this as it's not very informative.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860808", "createdAt": "2020-10-20T21:48:38Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU3MDYyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0ODo1NVrOHlSaFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0ODo1NVrOHlSaFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDk1MQ==", "bodyText": "final?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860951", "createdAt": "2020-10-20T21:48:55Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -1068,8 +1084,9 @@ private ServiceBusAsyncConsumer getOrCreateConsumer() {\n         final ServiceBusReceiveLinkProcessor linkMessageProcessor = receiveLink.subscribeWith(\n             new ServiceBusReceiveLinkProcessor(receiverOptions.getPrefetchCount(), retryPolicy,\n                 receiverOptions.getReceiveMode()));\n-        final ServiceBusAsyncConsumer newConsumer = new ServiceBusAsyncConsumer(linkName, linkMessageProcessor,\n-            messageSerializer, receiverOptions.getPrefetchCount());\n+\n+        ServiceBusAsyncConsumer newConsumer = new ServiceBusAsyncConsumer(linkName, linkMessageProcessor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU3NDE2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0OTo1OFrOHlScKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo0OTo1OFrOHlScKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTQ4MQ==", "bodyText": "As discussed, we should categorize these errors into different error sources.\nhttps://github.com/Azure/azure-sdk-for-net/blob/master/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ServiceBusErrorSource.cs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508861481", "createdAt": "2020-10-20T21:49:58Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU3ODE1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1MToyMlrOHlSemw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1MTozMFrOHlSe4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjEwNw==", "bodyText": "Should be consistent about adding ( around your lambdas. there are several down there that don't have it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862107", "createdAt": "2020-10-20T21:51:22Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjE3Ng==", "bodyText": "Same with other instances.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862176", "createdAt": "2020-10-20T21:51:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjEwNw=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU4MTk3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1MjozMlrOHlSg9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzo1Nzo0M1rOHle-tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjcwOQ==", "bodyText": "Is there any way to check that your renewal operations are cancelled on these messages?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862709", "createdAt": "2020-10-20T21:52:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA2NjkzNA==", "bodyText": "added it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509066934", "createdAt": "2020-10-21T07:57:43Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjcwOQ=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU4NDAwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1MzoxMlrOHlSiLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODowNTozNlrOHlfSbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzAyMw==", "bodyText": "The test above tests the same scenario. I'm not sure how Map makes a difference here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863023", "createdAt": "2020-10-20T21:53:12Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3MTk4MQ==", "bodyText": "I will remove it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509071981", "createdAt": "2020-10-21T08:05:36Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzAyMw=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU4NjQ2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1NDoxMVrOHlSjvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODowMzo0OVrOHlfN5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA==", "bodyText": "If you  mock this function, you can verify invocations it rather than keeping track.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863420", "createdAt": "2020-10-20T21:54:11Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator.map(serviceBusReceivedMessage -> expectedMappedValue))\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(expectedMappedValue, actual))\n+            .thenCancel()\n+            .verify();\n+    }\n+\n+    /**\n+     * Check that illegal values are not allowed in constructor.\n+     */\n+    @Test\n+    void illegalValueConstructor() {\n+        // Arrange, Act & Assert\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(null,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, null, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, null));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FluxAutoRenew(messageSource,\n+            DISABLE_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked. It will verify\n+     * 1. The renew lock function is invoked multiple times.\n+     * 2. The updated new lockedUntil is reflected on ServiceBusReceivedMessage object.\n+     */\n+    @Test\n+    void lockRenewedMultipleTimes() {\n+        // Arrange\n+        final int renewedForAtLeast = 3;\n+        final int totalProcessingTimeSeconds = 5;\n+        final AtomicInteger actualTokenRenewCalledTimes = new AtomicInteger();\n+        final Function<String, Mono<OffsetDateTime>> lockTokenRenewFunction = (lockToken) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzYyNQ==", "bodyText": "Also, you could have mocked the function in general instead of providing a concrete implementation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863625", "createdAt": "2020-10-20T21:54:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator.map(serviceBusReceivedMessage -> expectedMappedValue))\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(expectedMappedValue, actual))\n+            .thenCancel()\n+            .verify();\n+    }\n+\n+    /**\n+     * Check that illegal values are not allowed in constructor.\n+     */\n+    @Test\n+    void illegalValueConstructor() {\n+        // Arrange, Act & Assert\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(null,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, null, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, null));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FluxAutoRenew(messageSource,\n+            DISABLE_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked. It will verify\n+     * 1. The renew lock function is invoked multiple times.\n+     * 2. The updated new lockedUntil is reflected on ServiceBusReceivedMessage object.\n+     */\n+    @Test\n+    void lockRenewedMultipleTimes() {\n+        // Arrange\n+        final int renewedForAtLeast = 3;\n+        final int totalProcessingTimeSeconds = 5;\n+        final AtomicInteger actualTokenRenewCalledTimes = new AtomicInteger();\n+        final Function<String, Mono<OffsetDateTime>> lockTokenRenewFunction = (lockToken) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3MDgyMw==", "bodyText": "I could not find a way to mock onRenewLock.**andThen**(...), So for now I am using concrete implementation for renewLock.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509070823", "createdAt": "2020-10-21T08:03:49Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator.map(serviceBusReceivedMessage -> expectedMappedValue))\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(expectedMappedValue, actual))\n+            .thenCancel()\n+            .verify();\n+    }\n+\n+    /**\n+     * Check that illegal values are not allowed in constructor.\n+     */\n+    @Test\n+    void illegalValueConstructor() {\n+        // Arrange, Act & Assert\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(null,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, null, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, null));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FluxAutoRenew(messageSource,\n+            DISABLE_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked. It will verify\n+     * 1. The renew lock function is invoked multiple times.\n+     * 2. The updated new lockedUntil is reflected on ServiceBusReceivedMessage object.\n+     */\n+    @Test\n+    void lockRenewedMultipleTimes() {\n+        // Arrange\n+        final int renewedForAtLeast = 3;\n+        final int totalProcessingTimeSeconds = 5;\n+        final AtomicInteger actualTokenRenewCalledTimes = new AtomicInteger();\n+        final Function<String, Mono<OffsetDateTime>> lockTokenRenewFunction = (lockToken) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA=="}, "originalCommit": {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjkyNjI4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTo0MzoxN1rOHmHJrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTo0MzoxN1rOHmHJrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyNTEwMQ==", "bodyText": "Do you need this reference?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509725101", "createdAt": "2020-10-21T21:43:17Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI0MDI2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MjoyNlrOHmKdEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MjoyNlrOHmKdEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTIxOQ==", "bodyText": "the parameter name is 'actual'", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779219", "createdAt": "2020-10-21T22:52:26Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI0MTA0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MjozNlrOHmKdng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MjozNlrOHmKdng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTM1OA==", "bodyText": "nit: add new line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779358", "createdAt": "2020-10-21T22:52:36Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");\n+\n+        final LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    static final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = Objects.requireNonNull(actual, \"'downstream' cannot be null.\");\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+                \"'maxAutoLockRenewDuration' cannot be null.\");\n+        }\n+        /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI0MTcxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1Mjo0NVrOHmKeFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1Mjo0NVrOHmKeFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTQ3Nw==", "bodyText": "nit: remove empty line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779477", "createdAt": "2020-10-21T22:52:45Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");\n+\n+        final LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1NTk1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NjoyNFrOHmKnSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjo1NzowOFrOHmOxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTgzMw==", "bodyText": "My PR has this one level higher in ReceiverClient. Is there a constraining reason why? If we map this to one level higher, the onRenewLock doesn't have to be passed into the constructor for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509781833", "createdAt": "2020-10-21T22:56:24Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +29,27 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0OTkwOA==", "bodyText": "Okay moved it higher.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509849908", "createdAt": "2020-10-22T02:57:08Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +29,27 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTgzMw=="}, "originalCommit": {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mzg1MTkwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDoxNzozM1rOHmP_zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjowMzowMVrOHmRxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg3MDAyOA==", "bodyText": "We should still append a random string to the name of the session to get a unique link name.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509870028", "createdAt": "2020-10-22T04:17:33Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -224,16 +224,21 @@ private AmqpErrorContext getErrorContext() {\n     }\n \n     /**\n-     * Creates an unnamed session receive link.\n+     * Creates an session receive link.\n      *\n-     * @return A Mono that completes with an unnamed session receive link.\n+     * @return A Mono that completes with an session receive link.\n      */\n     private Mono<ServiceBusReceiveLink> createSessionReceiveLink() {\n-        final String linkName = StringUtil.getRandomString(\"session-\");\n+        final String sessionId = receiverOptions.getSessionId();\n \n+        final String linkName = (sessionId != null)\n+            ? sessionId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39689042daf7ebaaa177004bc700cdc583313dd"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg5OTA2MA==", "bodyText": "If  we make linkName random for same Named SessionId, It will try to create a new Link for same session (Example SessionId= GREEN). And if  a Link already exists for GREEN, we will not be able to get the lock.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509899060", "createdAt": "2020-10-22T06:03:01Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -224,16 +224,21 @@ private AmqpErrorContext getErrorContext() {\n     }\n \n     /**\n-     * Creates an unnamed session receive link.\n+     * Creates an session receive link.\n      *\n-     * @return A Mono that completes with an unnamed session receive link.\n+     * @return A Mono that completes with an session receive link.\n      */\n     private Mono<ServiceBusReceiveLink> createSessionReceiveLink() {\n-        final String linkName = StringUtil.getRandomString(\"session-\");\n+        final String sessionId = receiverOptions.getSessionId();\n \n+        final String linkName = (sessionId != null)\n+            ? sessionId", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg3MDAyOA=="}, "originalCommit": {"oid": "c39689042daf7ebaaa177004bc700cdc583313dd"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4149, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}