{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MjU3ODEy", "number": 14585, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo0NDoxMFrOEee9Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0OTozM1rOEorXcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzk5OTExOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo0NDoxMFrOHKKSOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzozMzowMVrOHKNvCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNjMxNQ==", "bodyText": "This should be OffsetDateTime or it will conflict with @YijunXieMS 's changes.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r480416315", "createdAt": "2020-08-31T21:44:10Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -326,6 +327,38 @@ public String getEntityPath() {\n         return scheduleMessageInternal(message, scheduledEnqueueTime, null);\n     }\n \n+    /**\n+     * Sends a scheduled messages to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time.\n+     *\n+     * @param messages Message to be sent to the Service Bus Queue.\n+     * @param scheduledEnqueueTime Instant at which the message should appear in the Service Bus queue or topic.\n+     *\n+     * @return The sequence number of the scheduled message which can be used to cancel the scheduling of the message.\n+     *\n+     * @throws NullPointerException if {@code messages} or {@code scheduledEnqueueTime} is {@code null}.\n+     */\n+    public Flux<Long> scheduleMessages(Iterable<ServiceBusMessage> messages, Instant scheduledEnqueueTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68649729177553398d64d6928d8ad6ad77b5627"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3Mjg0Mw==", "bodyText": "I will wait for Yijun's change and merge it in my branch. Since it effect downstream methods.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r480472843", "createdAt": "2020-08-31T23:33:01Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -326,6 +327,38 @@ public String getEntityPath() {\n         return scheduleMessageInternal(message, scheduledEnqueueTime, null);\n     }\n \n+    /**\n+     * Sends a scheduled messages to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time.\n+     *\n+     * @param messages Message to be sent to the Service Bus Queue.\n+     * @param scheduledEnqueueTime Instant at which the message should appear in the Service Bus queue or topic.\n+     *\n+     * @return The sequence number of the scheduled message which can be used to cancel the scheduling of the message.\n+     *\n+     * @throws NullPointerException if {@code messages} or {@code scheduledEnqueueTime} is {@code null}.\n+     */\n+    public Flux<Long> scheduleMessages(Iterable<ServiceBusMessage> messages, Instant scheduledEnqueueTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNjMxNQ=="}, "originalCommit": {"oid": "d68649729177553398d64d6928d8ad6ad77b5627"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDAwMjQwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo0NToxM1rOHKKUGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoyNDoxNFrOHKNkKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNjc5NA==", "bodyText": "IIRC you said that your tests were failing for this? If that's the case, we should remove this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r480416794", "createdAt": "2020-08-31T21:45:13Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -342,7 +375,83 @@ public String getEntityPath() {\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n-            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get()));\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get(),\n+                null));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumber of the scheduled message to cancel.\n+     * @param transactionContext to be set on batch message before scheduling them on Service Bus.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws IllegalArgumentException if {@code sequenceNumber} is negative.\n+     */\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber, ServiceBusTransactionContext transactionContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68649729177553398d64d6928d8ad6ad77b5627"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MDA1OA==", "bodyText": "removing", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r480470058", "createdAt": "2020-08-31T23:24:14Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -342,7 +375,83 @@ public String getEntityPath() {\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n-            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get()));\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get(),\n+                null));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumber of the scheduled message to cancel.\n+     * @param transactionContext to be set on batch message before scheduling them on Service Bus.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws IllegalArgumentException if {@code sequenceNumber} is negative.\n+     */\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber, ServiceBusTransactionContext transactionContext) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNjc5NA=="}, "originalCommit": {"oid": "d68649729177553398d64d6928d8ad6ad77b5627"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDAwMzkyOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo0NTo0NFrOHKKU7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoyMzozNFrOHKNjXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNzAwNg==", "bodyText": "I don't remember. Did cancelling work with a transaction?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r480417006", "createdAt": "2020-08-31T21:45:44Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -342,7 +375,83 @@ public String getEntityPath() {\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n-            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get()));\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get(),\n+                null));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumber of the scheduled message to cancel.\n+     * @param transactionContext to be set on batch message before scheduling them on Service Bus.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws IllegalArgumentException if {@code sequenceNumber} is negative.\n+     */\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber, ServiceBusTransactionContext transactionContext) {\n+        if (sequenceNumber < 0) {\n+            return monoError(logger, new IllegalArgumentException(\"'sequenceNumber' cannot be negative.\"));\n+        }\n+\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get(),\n+                transactionContext));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumbers of the scheduled messages to cancel.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws NullPointerException if {@code sequenceNumbers} is null.\n+     */\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers) {\n+\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"cancelScheduledMessages\")));\n+        }\n+\n+        if (Objects.isNull(sequenceNumbers)) {\n+            return monoError(logger, new NullPointerException(\"'messages' cannot be null.\"));\n+        }\n+\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessages(sequenceNumbers, linkName.get(),\n+                null));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumbers of the scheduled messages to cancel.\n+     * @param transactionContext to be set on batch sequence numbers for this operation on Service Bus.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws NullPointerException if {@code sequenceNumbers} is null.\n+     */\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68649729177553398d64d6928d8ad6ad77b5627"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2OTg1NA==", "bodyText": "I tested with cancelScheduledMessages  with rollback and it worked.  Now when I test withy commit, it is not giving me expected result.  Since we have doubt about this API, I will remove it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r480469854", "createdAt": "2020-08-31T23:23:34Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -342,7 +375,83 @@ public String getEntityPath() {\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n-            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get()));\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get(),\n+                null));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumber of the scheduled message to cancel.\n+     * @param transactionContext to be set on batch message before scheduling them on Service Bus.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws IllegalArgumentException if {@code sequenceNumber} is negative.\n+     */\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber, ServiceBusTransactionContext transactionContext) {\n+        if (sequenceNumber < 0) {\n+            return monoError(logger, new IllegalArgumentException(\"'sequenceNumber' cannot be negative.\"));\n+        }\n+\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessage(sequenceNumber, linkName.get(),\n+                transactionContext));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumbers of the scheduled messages to cancel.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws NullPointerException if {@code sequenceNumbers} is null.\n+     */\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers) {\n+\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"cancelScheduledMessages\")));\n+        }\n+\n+        if (Objects.isNull(sequenceNumbers)) {\n+            return monoError(logger, new NullPointerException(\"'messages' cannot be null.\"));\n+        }\n+\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityName, entityType))\n+            .flatMap(managementNode -> managementNode.cancelScheduledMessages(sequenceNumbers, linkName.get(),\n+                null));\n+    }\n+\n+    /**\n+     * Cancels the enqueuing of an already scheduled message, if it was not already enqueued.\n+     *\n+     * @param sequenceNumbers of the scheduled messages to cancel.\n+     * @param transactionContext to be set on batch sequence numbers for this operation on Service Bus.\n+     *\n+     * @return The {@link Mono} that finishes this operation on service bus resource.\n+     *\n+     * @throws NullPointerException if {@code sequenceNumbers} is null.\n+     */\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNzAwNg=="}, "originalCommit": {"oid": "d68649729177553398d64d6928d8ad6ad77b5627"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTUxMTk0OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzozMDo1MVrOHLBGXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzozMDo1MVrOHLBGXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNDM5OQ==", "bodyText": "we don't need this transactioncontext anymore.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r481314399", "createdAt": "2020-09-01T17:30:51Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -96,7 +98,40 @@\n                 requestMessage.setBody(new AmqpValue(Collections.singletonMap(ManagementConstants.SEQUENCE_NUMBERS,\n                     new Long[]{sequenceNumber})));\n \n-                return sendWithVerify(channel, requestMessage, null);\n+                TransactionalState transactionalState = null;\n+                if (transactionContext != null && transactionContext.getTransactionId() != null) {\n+                    transactionalState = new TransactionalState();\n+                    transactionalState.setTxnId(new Binary(transactionContext.getTransactionId().array()));\n+                }\n+\n+                return sendWithVerify(channel, requestMessage, transactionalState);\n+            })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers, String associatedLinkName,\n+        ServiceBusTransactionContext transactionContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf9763f12398950efbaa1237a1c4980330f62f4"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTUxNDUzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzozMTozN1rOHLBIBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMDowNzo0NVrOHYYtgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNDgyMg==", "bodyText": "Can we condense this? It is a copy of all the logic from the single send. same with cancel.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r481314822", "createdAt": "2020-09-01T17:31:37Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -282,6 +317,87 @@\n         });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<Long> schedule(final List<ServiceBusMessage> messages, Instant scheduledEnqueueTime, int maxLinkSize,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf9763f12398950efbaa1237a1c4980330f62f4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMjczOQ==", "bodyText": "merged two into one", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r495332739", "createdAt": "2020-09-26T00:07:45Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -282,6 +317,87 @@\n         });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<Long> schedule(final List<ServiceBusMessage> messages, Instant scheduledEnqueueTime, int maxLinkSize,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNDgyMg=="}, "originalCommit": {"oid": "acf9763f12398950efbaa1237a1c4980330f62f4"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTU0MTM2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzozOTo0N1rOHLBZjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzozOTo0N1rOHLBZjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxOTMxMQ==", "bodyText": "Can you run all the live tests? I'm afraid we'll run into dirty tests and conflicts like what Yijun experienced", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r481319311", "createdAt": "2020-09-01T17:39:47Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientTest.java", "diffHunk": "@@ -301,6 +303,89 @@ void scheduleMessageWithTransaction() {\n         verify(asyncSender).scheduleMessage(testData, scheduledEnqueueTime, transactionContext);\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf9763f12398950efbaa1237a1c4980330f62f4"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjE3MDM4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyNjoyNlrOHZMg2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyNjoyNlrOHZMg2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4MTQ2Nw==", "bodyText": "final Long[] longs to be consistent.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496181467", "createdAt": "2020-09-28T19:26:26Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -97,6 +99,32 @@\n                 requestMessage.setBody(new AmqpValue(Collections.singletonMap(ManagementConstants.SEQUENCE_NUMBERS,\n                     new Long[]{sequenceNumber})));\n \n+                TransactionalState transactionalState = null;\n+                if (transactionContext != null && transactionContext.getTransactionId() != null) {\n+                    transactionalState = new TransactionalState();\n+                    transactionalState.setTxnId(new Binary(transactionContext.getTransactionId().array()));\n+                }\n+\n+                return sendWithVerify(channel, requestMessage, transactionalState);\n+            })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers, String associatedLinkName) {\n+        return isAuthorized(ManagementConstants.OPERATION_CANCEL_SCHEDULED_MESSAGE)\n+            .then(createChannel.flatMap(channel -> {\n+                final Message requestMessage = createManagementMessage(\n+                    ManagementConstants.OPERATION_CANCEL_SCHEDULED_MESSAGE, associatedLinkName);\n+\n+                final List<Long> numbers = new ArrayList<>();\n+                sequenceNumbers.forEach(s -> numbers.add(s));\n+                Long[] longs = numbers.toArray(new Long[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2bd166d718480256dbdfba677446889983e1969"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjE3Mzg5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyNzozN1rOHZMjGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyNzozN1rOHZMjGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4MjA0MA==", "bodyText": "Why duplicate logic, the logic in cancel and with iterable and single item are exactly the same.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496182040", "createdAt": "2020-09-28T19:27:37Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -97,6 +99,32 @@\n                 requestMessage.setBody(new AmqpValue(Collections.singletonMap(ManagementConstants.SEQUENCE_NUMBERS,\n                     new Long[]{sequenceNumber})));\n \n+                TransactionalState transactionalState = null;\n+                if (transactionContext != null && transactionContext.getTransactionId() != null) {\n+                    transactionalState = new TransactionalState();\n+                    transactionalState.setTxnId(new Binary(transactionContext.getTransactionId().array()));\n+                }\n+\n+                return sendWithVerify(channel, requestMessage, transactionalState);\n+            })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessages(Iterable<Long> sequenceNumbers, String associatedLinkName) {\n+        return isAuthorized(ManagementConstants.OPERATION_CANCEL_SCHEDULED_MESSAGE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2bd166d718480256dbdfba677446889983e1969"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjE3ODA3OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyODo1MlrOHZMllQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyODo1MlrOHZMllQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4MjY3Nw==", "bodyText": "Consistent use of final.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496182677", "createdAt": "2020-09-28T19:28:52Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -287,53 +315,57 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<Long> schedule(ServiceBusMessage message, OffsetDateTime scheduledEnqueueTime, int maxLinkSize,\n-        String associatedLinkName, ServiceBusTransactionContext transactionContext) {\n-        message.setScheduledEnqueueTime(scheduledEnqueueTime);\n-\n-        return isAuthorized(OPERATION_SCHEDULE_MESSAGE).then(createChannel.flatMap(channel -> {\n-            // Serialize the request.\n-            final Message amqpMessage = messageSerializer.serialize(message);\n-\n-            // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n-            final int payloadSize = messageSerializer.getSize(amqpMessage);\n-            final int allocationSize =\n-                Math.min(payloadSize + ManagementConstants.MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxLinkSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = amqpMessage.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage = String.format(\n-                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\", maxLinkSize / 1024);\n-                final AmqpErrorContext errorContext = channel.getErrorContext();\n-\n-                return monoError(logger, Exceptions.propagate(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, errorContext)));\n-            }\n+    public Flux<Long> schedule(final List<ServiceBusMessage> messages, OffsetDateTime scheduledEnqueueTime,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2bd166d718480256dbdfba677446889983e1969"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDg2NzI2OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0Mzo0M1rOHZ52fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0Mzo0M1rOHZ52fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI4Ng==", "bodyText": "You don't need this internal method at all. The overload on top can call this method with transaction context as null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496924286", "createdAt": "2020-09-29T17:43:43Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -326,6 +328,38 @@ public String getEntityPath() {\n         return scheduleMessageInternal(message, scheduledEnqueueTime, null);\n     }\n \n+    /**\n+     * Sends a scheduled messages to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time.\n+     *\n+     * @param messages Message to be sent to the Service Bus Queue.\n+     * @param scheduledEnqueueTime OffsetDateTime at which the message should appear in the Service Bus queue or topic.\n+     *\n+     * @return The sequence number of the scheduled message which can be used to cancel the scheduling of the message.\n+     *\n+     * @throws NullPointerException if {@code messages} or {@code scheduledEnqueueTime} is {@code null}.\n+     */\n+    public Flux<Long> scheduleMessages(Iterable<ServiceBusMessage> messages, OffsetDateTime scheduledEnqueueTime) {\n+        return scheduleMessagesInternal(messages, scheduledEnqueueTime, null);\n+    }\n+\n+    /**\n+     * Sends a scheduled messages to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time.\n+     *\n+     * @param messages Message to be sent to the Service Bus Queue.\n+     * @param scheduledEnqueueTime Instant at which the message should appear in the Service Bus queue or topic.\n+     * @param transactionContext to be set on batch message before scheduling them on Service Bus.\n+     *\n+     * @return The sequence number of the scheduled message which can be used to cancel the scheduling of the message.\n+     *\n+     * @throws NullPointerException if {@code message} or {@code scheduledEnqueueTime} is {@code null}.\n+     */\n+    public Flux<Long> scheduleMessages(Iterable<ServiceBusMessage> messages, OffsetDateTime scheduledEnqueueTime,\n+        ServiceBusTransactionContext transactionContext) {\n+        return scheduleMessagesInternal(messages, scheduledEnqueueTime, transactionContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3770950a6735547199a42cb5671a129fdf493a96"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDg3Nzc4OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0NjoyM1rOHZ589w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0NjoyM1rOHZ589w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNTk0Mw==", "bodyText": "This method is only used once.. why not roll it up into one?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496925943", "createdAt": "2020-09-29T17:46:23Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -426,6 +486,46 @@ public void close() {\n         });\n     }\n \n+\n+    private Flux<Long> scheduleMessagesInternal(Iterable<ServiceBusMessage> messages,\n+        OffsetDateTime scheduledEnqueueTime, ServiceBusTransactionContext transaction) {\n+        if (Objects.isNull(messages)) {\n+            return fluxError(logger, new NullPointerException(\"'messages' cannot be null.\"));\n+        }\n+\n+        if (Objects.isNull(scheduledEnqueueTime)) {\n+            return fluxError(logger, new NullPointerException(\"'scheduledEnqueueTime' cannot be null.\"));\n+        }\n+\n+        return createBatch().flatMapMany(messageBatch -> {\n+            messages.forEach(message -> messageBatch.tryAdd(message));\n+            return scheduleMessagesInternal(messageBatch, scheduledEnqueueTime, transaction);\n+        });\n+    }\n+\n+    private Flux<Long> scheduleMessagesInternal(ServiceBusMessageBatch message, OffsetDateTime scheduledEnqueueTime,\n+        ServiceBusTransactionContext transactionContext) {\n+        if (Objects.isNull(message)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3770950a6735547199a42cb5671a129fdf493a96"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDg4MDIzOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0Njo1N1rOHZ5-Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0Njo1N1rOHZ5-Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNjMwMw==", "bodyText": "Why are we getting link size again instead of just using the batch's max size???", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496926303", "createdAt": "2020-09-29T17:46:57Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -426,6 +486,46 @@ public void close() {\n         });\n     }\n \n+\n+    private Flux<Long> scheduleMessagesInternal(Iterable<ServiceBusMessage> messages,\n+        OffsetDateTime scheduledEnqueueTime, ServiceBusTransactionContext transaction) {\n+        if (Objects.isNull(messages)) {\n+            return fluxError(logger, new NullPointerException(\"'messages' cannot be null.\"));\n+        }\n+\n+        if (Objects.isNull(scheduledEnqueueTime)) {\n+            return fluxError(logger, new NullPointerException(\"'scheduledEnqueueTime' cannot be null.\"));\n+        }\n+\n+        return createBatch().flatMapMany(messageBatch -> {\n+            messages.forEach(message -> messageBatch.tryAdd(message));\n+            return scheduleMessagesInternal(messageBatch, scheduledEnqueueTime, transaction);\n+        });\n+    }\n+\n+    private Flux<Long> scheduleMessagesInternal(ServiceBusMessageBatch message, OffsetDateTime scheduledEnqueueTime,\n+        ServiceBusTransactionContext transactionContext) {\n+        if (Objects.isNull(message)) {\n+            return fluxError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        }\n+\n+        if (Objects.isNull(scheduledEnqueueTime)) {\n+            return fluxError(logger, new NullPointerException(\"'scheduledEnqueueTime' cannot be null.\"));\n+        }\n+\n+        return getSendLink()\n+            .flatMapMany(link -> link.getLinkSize().flatMapMany(size -> {\n+                int maxSize =  size > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3770950a6735547199a42cb5671a129fdf493a96"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDg5MDEwOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0OTozM1rOHZ6Esg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjowNzoyMVrOHak7Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzkyMg==", "bodyText": "We're basically creating our own message batch here. Why not just have a schedule that takes MessageBatch? Then we don't need the maxLinkSize anymore.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r496927922", "createdAt": "2020-09-29T17:49:33Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -287,53 +291,57 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<Long> schedule(ServiceBusMessage message, OffsetDateTime scheduledEnqueueTime, int maxLinkSize,\n-        String associatedLinkName, ServiceBusTransactionContext transactionContext) {\n-        message.setScheduledEnqueueTime(scheduledEnqueueTime);\n-\n-        return isAuthorized(OPERATION_SCHEDULE_MESSAGE).then(createChannel.flatMap(channel -> {\n-            // Serialize the request.\n-            final Message amqpMessage = messageSerializer.serialize(message);\n-\n-            // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n-            final int payloadSize = messageSerializer.getSize(amqpMessage);\n-            final int allocationSize =\n-                Math.min(payloadSize + ManagementConstants.MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxLinkSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = amqpMessage.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage = String.format(\n-                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\", maxLinkSize / 1024);\n-                final AmqpErrorContext errorContext = channel.getErrorContext();\n-\n-                return monoError(logger, Exceptions.propagate(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, errorContext)));\n-            }\n+    public Flux<Long> schedule(List<ServiceBusMessage> messages, OffsetDateTime scheduledEnqueueTime,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3770950a6735547199a42cb5671a129fdf493a96"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0NTc3MA==", "bodyText": "messageBatch.getMessages() is package private and not accessible to ManagementChannel . And I did not want to make it public, Thus I am not sending MessageBatch here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r497045770", "createdAt": "2020-09-29T20:51:58Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -287,53 +291,57 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<Long> schedule(ServiceBusMessage message, OffsetDateTime scheduledEnqueueTime, int maxLinkSize,\n-        String associatedLinkName, ServiceBusTransactionContext transactionContext) {\n-        message.setScheduledEnqueueTime(scheduledEnqueueTime);\n-\n-        return isAuthorized(OPERATION_SCHEDULE_MESSAGE).then(createChannel.flatMap(channel -> {\n-            // Serialize the request.\n-            final Message amqpMessage = messageSerializer.serialize(message);\n-\n-            // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n-            final int payloadSize = messageSerializer.getSize(amqpMessage);\n-            final int allocationSize =\n-                Math.min(payloadSize + ManagementConstants.MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxLinkSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = amqpMessage.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage = String.format(\n-                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\", maxLinkSize / 1024);\n-                final AmqpErrorContext errorContext = channel.getErrorContext();\n-\n-                return monoError(logger, Exceptions.propagate(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, errorContext)));\n-            }\n+    public Flux<Long> schedule(List<ServiceBusMessage> messages, OffsetDateTime scheduledEnqueueTime,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzkyMg=="}, "originalCommit": {"oid": "3770950a6735547199a42cb5671a129fdf493a96"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMDA1NA==", "bodyText": "I'd use an EntityHelper in this case because we're duplicating unnecessary mandatory logic here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14585#discussion_r497630054", "createdAt": "2020-09-30T16:07:21Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -287,53 +291,57 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<Long> schedule(ServiceBusMessage message, OffsetDateTime scheduledEnqueueTime, int maxLinkSize,\n-        String associatedLinkName, ServiceBusTransactionContext transactionContext) {\n-        message.setScheduledEnqueueTime(scheduledEnqueueTime);\n-\n-        return isAuthorized(OPERATION_SCHEDULE_MESSAGE).then(createChannel.flatMap(channel -> {\n-            // Serialize the request.\n-            final Message amqpMessage = messageSerializer.serialize(message);\n-\n-            // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n-            final int payloadSize = messageSerializer.getSize(amqpMessage);\n-            final int allocationSize =\n-                Math.min(payloadSize + ManagementConstants.MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxLinkSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = amqpMessage.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage = String.format(\n-                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\", maxLinkSize / 1024);\n-                final AmqpErrorContext errorContext = channel.getErrorContext();\n-\n-                return monoError(logger, Exceptions.propagate(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, errorContext)));\n-            }\n+    public Flux<Long> schedule(List<ServiceBusMessage> messages, OffsetDateTime scheduledEnqueueTime,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzkyMg=="}, "originalCommit": {"oid": "3770950a6735547199a42cb5671a129fdf493a96"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1462, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}