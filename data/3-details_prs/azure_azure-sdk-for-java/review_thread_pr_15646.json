{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNzQwNDQ0", "number": 15646, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyNjowN1rOEnk8ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1Mzo0OFrOEpjw5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM1MjY3OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedFluxCore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyNjowN1rOHYP6Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo1NTo0NVrOHZ6TPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODU0Mw==", "bodyText": "I think the latch.await() is something we have to be cautious about.\nOur \"drain + subscribe + latch.await\" could gets executes in the context of a non-blocking Thread. As an example, say app is running in a single thread, thread_0:\nthe drain() is executing in thread_0.\nsubscribe() results in queueing a n/w call and return.\nlatch.await() executed in thread_0, blocking it for the result.\nscheduled n/w call cannot be completed as thread_0 is waiting it\u2019s a deadlock.\nReactor marks some threads as non-blocking https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/NonBlocking.html.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r495188543", "createdAt": "2020-09-25T19:26:07Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedFluxCore.java", "diffHunk": "@@ -228,4 +230,179 @@ boolean isDone() {\n             return this.isDone;\n         }\n     }\n+\n+    private static abstract class BaseSubscription<C, T, P extends ContinuablePage<C, T>, U, V>\n+        implements Subscription {\n+        private final Subscriber<? super U> subscriber;\n+        private final ContinuationState<C> continuationState;\n+        private final PageRetriever<C, P> pageRetriever;\n+        private final Integer defaultPageSize;\n+\n+        volatile boolean done;\n+        volatile V next;\n+        private Throwable error;\n+        private volatile boolean cancelled;\n+\n+        volatile int wip;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicIntegerFieldUpdater<BaseSubscription> WIP =\n+            AtomicIntegerFieldUpdater.newUpdater(BaseSubscription.class, \"wip\");\n+\n+        volatile long requested;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicLongFieldUpdater<BaseSubscription> REQUESTED =\n+            AtomicLongFieldUpdater.newUpdater(BaseSubscription.class, \"requested\");\n+\n+        BaseSubscription(Subscriber<? super U> subscriber, ContinuationState<C> continuationState,\n+            PageRetriever<C, P> pageRetriever, Integer defaultPageSize) {\n+            this.subscriber = subscriber;\n+            this.continuationState = continuationState;\n+            this.pageRetriever = pageRetriever;\n+            this.defaultPageSize = defaultPageSize;\n+        }\n+\n+        @Override\n+        public void request(long l) {\n+            if (Operators.validate(l)) {\n+                Operators.addCap(REQUESTED, this, l);\n+                drain();\n+            }\n+        }\n+\n+        private void drain() {\n+            if (WIP.getAndIncrement(this) != 0) {\n+                return;\n+            }\n+\n+            // On the first request or once the iterator is consumed request a page.\n+            if (needToRequestPage()) {\n+                requestPage();\n+            }\n+\n+            int missed = 1;\n+            while (true) {\n+                if (cancelled) {\n+                    return;\n+                }\n+\n+                if (REQUESTED.get(this) > 0) {\n+                    boolean emitted = false;\n+                    // read d before next to avoid race\n+                    boolean d = done;\n+                    if (hasNext()) {\n+                        subscriber.onNext(getNext());\n+                        emitted = true;\n+                    }\n+\n+                    if (d) {\n+                        if (error != null) {\n+                            subscriber.onError(error);\n+                        } else {\n+                            subscriber.onComplete();\n+                        }\n+\n+                        // exit without reducing wip so that further drains will be NOOP\n+                        return;\n+                    }\n+\n+                    if (emitted) {\n+                        // do this after checking d to avoid calling read\n+                        // when done\n+                        Operators.produced(REQUESTED, this, 1);\n+                    }\n+                }\n+\n+                missed = WIP.addAndGet(this, -missed);\n+                if (missed == 0) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        abstract boolean needToRequestPage();\n+        abstract boolean hasNext();\n+        abstract U getNext();\n+\n+        private void requestPage() {\n+            CountDownLatch countDownLatch = new CountDownLatch(1);\n+            pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+                .singleOrEmpty()\n+                .subscribe(this::setNext, this::setError, countDownLatch::countDown);\n+\n+            try {\n+                countDownLatch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7839f44350b8b6a9e1de79b43d3357759aca4dd1"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTY0Ng==", "bodyText": "Made it so only PagedIterable instances will use the blocking calling.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r496931646", "createdAt": "2020-09-29T17:55:45Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedFluxCore.java", "diffHunk": "@@ -228,4 +230,179 @@ boolean isDone() {\n             return this.isDone;\n         }\n     }\n+\n+    private static abstract class BaseSubscription<C, T, P extends ContinuablePage<C, T>, U, V>\n+        implements Subscription {\n+        private final Subscriber<? super U> subscriber;\n+        private final ContinuationState<C> continuationState;\n+        private final PageRetriever<C, P> pageRetriever;\n+        private final Integer defaultPageSize;\n+\n+        volatile boolean done;\n+        volatile V next;\n+        private Throwable error;\n+        private volatile boolean cancelled;\n+\n+        volatile int wip;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicIntegerFieldUpdater<BaseSubscription> WIP =\n+            AtomicIntegerFieldUpdater.newUpdater(BaseSubscription.class, \"wip\");\n+\n+        volatile long requested;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicLongFieldUpdater<BaseSubscription> REQUESTED =\n+            AtomicLongFieldUpdater.newUpdater(BaseSubscription.class, \"requested\");\n+\n+        BaseSubscription(Subscriber<? super U> subscriber, ContinuationState<C> continuationState,\n+            PageRetriever<C, P> pageRetriever, Integer defaultPageSize) {\n+            this.subscriber = subscriber;\n+            this.continuationState = continuationState;\n+            this.pageRetriever = pageRetriever;\n+            this.defaultPageSize = defaultPageSize;\n+        }\n+\n+        @Override\n+        public void request(long l) {\n+            if (Operators.validate(l)) {\n+                Operators.addCap(REQUESTED, this, l);\n+                drain();\n+            }\n+        }\n+\n+        private void drain() {\n+            if (WIP.getAndIncrement(this) != 0) {\n+                return;\n+            }\n+\n+            // On the first request or once the iterator is consumed request a page.\n+            if (needToRequestPage()) {\n+                requestPage();\n+            }\n+\n+            int missed = 1;\n+            while (true) {\n+                if (cancelled) {\n+                    return;\n+                }\n+\n+                if (REQUESTED.get(this) > 0) {\n+                    boolean emitted = false;\n+                    // read d before next to avoid race\n+                    boolean d = done;\n+                    if (hasNext()) {\n+                        subscriber.onNext(getNext());\n+                        emitted = true;\n+                    }\n+\n+                    if (d) {\n+                        if (error != null) {\n+                            subscriber.onError(error);\n+                        } else {\n+                            subscriber.onComplete();\n+                        }\n+\n+                        // exit without reducing wip so that further drains will be NOOP\n+                        return;\n+                    }\n+\n+                    if (emitted) {\n+                        // do this after checking d to avoid calling read\n+                        // when done\n+                        Operators.produced(REQUESTED, this, 1);\n+                    }\n+                }\n+\n+                missed = WIP.addAndGet(this, -missed);\n+                if (missed == 0) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        abstract boolean needToRequestPage();\n+        abstract boolean hasNext();\n+        abstract U getNext();\n+\n+        private void requestPage() {\n+            CountDownLatch countDownLatch = new CountDownLatch(1);\n+            pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+                .singleOrEmpty()\n+                .subscribe(this::setNext, this::setError, countDownLatch::countDown);\n+\n+            try {\n+                countDownLatch.await();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODU0Mw=="}, "originalCommit": {"oid": "7839f44350b8b6a9e1de79b43d3357759aca4dd1"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjIyMzIwOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedFluxTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDowOToyNlrOHathTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDoyNzo1NlrOHauGyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MDgyOA==", "bodyText": "I would add some guard/assertion to all these new tests that makes sure that there's actually more than one page in the underlying data source. Otherwise it's easy to make this test worthless if someone changes underlying data source to have just one page. (btw. it's not that easy for me to trace data flow in these tests so I can't tell whether source has one or more pages... some check would be great.)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r497770828", "createdAt": "2020-09-30T20:09:26Z", "author": {"login": "kasobol-msft"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedFluxTest.java", "diffHunk": "@@ -284,15 +284,63 @@ public void testPagedFluxWithContext() throws Exception {\n             return Mono.empty();\n         }\n \n-        return Mono.just(pagedResponses.get(Integer.valueOf(continuationToken)));\n+        int parsedToken = Integer.parseInt(continuationToken);\n+        if (parsedToken >= pagedResponses.size()) {\n+            return Mono.empty();\n+        }\n+\n+        return Mono.just(pagedResponses.get(parsedToken));\n     }\n \n     private List<Integer> getItems(Integer i) {\n         return IntStream.range(i * 3, i * 3 + 3).boxed().collect(Collectors.toList());\n     }\n \n     private List<String> getStringItems(Integer i) {\n-        return IntStream.range(i * 3, i * 3 + 3).boxed().map(val -> String.valueOf(val)).collect(Collectors.toList());\n+        return IntStream.range(i * 3, i * 3 + 3).boxed().map(String::valueOf).collect(Collectors.toList());\n     }\n \n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        Integer next = new OnlyOnePagedFlux(() -> pageRetriever).blockFirst();\n+\n+        Thread.sleep(2000);\n+\n+        assertEquals(1, pageRetriever.getGetCount());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4c054f6d50f60edf52715059f2a486d9547e5c1"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MDQyNQ==", "bodyText": "OnlyOnePageRetriever should return 5 pages when consumed to completion. In each of the new tests I'll add an initial verification that OnlyOnePagedFlux/OnlyOnePagedIterable using collect toList is greater than one element.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r497780425", "createdAt": "2020-09-30T20:27:56Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedFluxTest.java", "diffHunk": "@@ -284,15 +284,63 @@ public void testPagedFluxWithContext() throws Exception {\n             return Mono.empty();\n         }\n \n-        return Mono.just(pagedResponses.get(Integer.valueOf(continuationToken)));\n+        int parsedToken = Integer.parseInt(continuationToken);\n+        if (parsedToken >= pagedResponses.size()) {\n+            return Mono.empty();\n+        }\n+\n+        return Mono.just(pagedResponses.get(parsedToken));\n     }\n \n     private List<Integer> getItems(Integer i) {\n         return IntStream.range(i * 3, i * 3 + 3).boxed().collect(Collectors.toList());\n     }\n \n     private List<String> getStringItems(Integer i) {\n-        return IntStream.range(i * 3, i * 3 + 3).boxed().map(val -> String.valueOf(val)).collect(Collectors.toList());\n+        return IntStream.range(i * 3, i * 3 + 3).boxed().map(String::valueOf).collect(Collectors.toList());\n     }\n \n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        Integer next = new OnlyOnePagedFlux(() -> pageRetriever).blockFirst();\n+\n+        Thread.sleep(2000);\n+\n+        assertEquals(1, pageRetriever.getGetCount());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MDgyOA=="}, "originalCommit": {"oid": "a4c054f6d50f60edf52715059f2a486d9547e5c1"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDA3NjQwOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedIterableTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjozNzoxOVrOHbSk4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1NToyN1rOHbTL-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3Nzk1NA==", "bodyText": "should we add a test for using pagedIterable.stream().parallel() and iteration on output of parallel? just double confirming our iterable impl is stream safe.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498377954", "createdAt": "2020-10-01T16:37:19Z", "author": {"login": "anuchandy"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedIterableTest.java", "diffHunk": "@@ -250,4 +256,90 @@ int getNextPageRetrievals() {\n             return nextPageRetrievals;\n         }\n     }\n+\n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        OnlyOnePagedIterable pagedIterable = new OnlyOnePagedIterable(new OnlyOnePagedFlux(() -> pageRetriever));\n+\n+        // Validation that there is more than one paged in the full return.\n+        pagedIterable.stream().count();\n+        int fullPageCount = pageRetriever.getGetCount();\n+        assertTrue(fullPageCount > 1);\n+\n+        Integer next = pagedIterable.stream().findFirst().get();\n+\n+        Thread.sleep(2000);\n+\n+        /*\n+         * Given that each page contains more than one element we are able to only retrieve a single page.\n+         */\n+        assertEquals(1, pageRetriever.getGetCount() - fullPageCount);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4Nzk2MQ==", "bodyText": "Will add tests for these", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498387961", "createdAt": "2020-10-01T16:55:27Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedIterableTest.java", "diffHunk": "@@ -250,4 +256,90 @@ int getNextPageRetrievals() {\n             return nextPageRetrievals;\n         }\n     }\n+\n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        OnlyOnePagedIterable pagedIterable = new OnlyOnePagedIterable(new OnlyOnePagedFlux(() -> pageRetriever));\n+\n+        // Validation that there is more than one paged in the full return.\n+        pagedIterable.stream().count();\n+        int fullPageCount = pageRetriever.getGetCount();\n+        assertTrue(fullPageCount > 1);\n+\n+        Integer next = pagedIterable.stream().findFirst().get();\n+\n+        Thread.sleep(2000);\n+\n+        /*\n+         * Given that each page contains more than one element we are able to only retrieve a single page.\n+         */\n+        assertEquals(1, pageRetriever.getGetCount() - fullPageCount);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3Nzk1NA=="}, "originalCommit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDEzMDI5OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedByIteratorBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1Mzo0OFrOHbTIdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyNDoyMFrOHbX9Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzA2MA==", "bodyText": "Is then() required here since you have a block() after this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498387060", "createdAt": "2020-10-01T16:53:48Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedByIteratorBase.java", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.util.paging;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Internal class that is a blocking iterator base class.\n+ * <p>\n+ * This class manages retrieving and maintaining previously retrieve page/pages in a synchronous fashion. It will ensure\n+ * the minimum number of pages are retrieved from a service by checking if any additional items/pages could be emitted\n+ * before requesting additional ones from the service.\n+ *\n+ * @param <C> The continuation token type.\n+ * @param <T> The item type.\n+ * @param <P> The page type.\n+ * @param <E> The type that the {@link ContinuablePagedIterable} will emit.\n+ */\n+abstract class ContinuablePagedByIteratorBase<C, T, P extends ContinuablePage<C, T>, E> implements Iterator<E> {\n+    private final PageRetriever<C, P> pageRetriever;\n+    private final ContinuationState<C> continuationState;\n+    private final Integer defaultPageSize;\n+    private final ClientLogger logger;\n+\n+    private volatile boolean done;\n+\n+    ContinuablePagedByIteratorBase(PageRetriever<C, P> pageRetriever, ContinuationState<C> continuationState,\n+        Integer defaultPageSize, ClientLogger logger) {\n+        this.continuationState = continuationState;\n+        this.pageRetriever = pageRetriever;\n+        this.defaultPageSize = defaultPageSize;\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public E next() {\n+        if (!hasNext()) {\n+            throw logger.logExceptionAsError(new NoSuchElementException(\"Iterator contains no more elements.\"));\n+        }\n+\n+        return getNext();\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        // Request next pages in a loop in case we are returned empty pages for the by item implementation.\n+        while (!done && needToRequestPage()) {\n+            requestPage();\n+        }\n+\n+        return isNextAvailable();\n+    }\n+\n+    /*\n+     * Indicates if a page needs to be requested.\n+     */\n+    abstract boolean needToRequestPage();\n+\n+    /*\n+     * Indicates if another element is available.\n+     */\n+    abstract boolean isNextAvailable();\n+\n+    /*\n+     * Gets the next element to be emitted.\n+     */\n+    abstract E getNext();\n+\n+    synchronized void requestPage() {\n+        AtomicBoolean receivedPages = new AtomicBoolean(false);\n+        pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+            .map(page -> {\n+                receivedPages.set(true);\n+                addPage(page);\n+\n+                continuationState.setLastContinuationToken(page.getContinuationToken());\n+                this.done = continuationState.isDone();\n+\n+                return page;\n+            })\n+            .then()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjA2Mw==", "bodyText": "Will change this toblockLast()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498466063", "createdAt": "2020-10-01T19:24:20Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedByIteratorBase.java", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.util.paging;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Internal class that is a blocking iterator base class.\n+ * <p>\n+ * This class manages retrieving and maintaining previously retrieve page/pages in a synchronous fashion. It will ensure\n+ * the minimum number of pages are retrieved from a service by checking if any additional items/pages could be emitted\n+ * before requesting additional ones from the service.\n+ *\n+ * @param <C> The continuation token type.\n+ * @param <T> The item type.\n+ * @param <P> The page type.\n+ * @param <E> The type that the {@link ContinuablePagedIterable} will emit.\n+ */\n+abstract class ContinuablePagedByIteratorBase<C, T, P extends ContinuablePage<C, T>, E> implements Iterator<E> {\n+    private final PageRetriever<C, P> pageRetriever;\n+    private final ContinuationState<C> continuationState;\n+    private final Integer defaultPageSize;\n+    private final ClientLogger logger;\n+\n+    private volatile boolean done;\n+\n+    ContinuablePagedByIteratorBase(PageRetriever<C, P> pageRetriever, ContinuationState<C> continuationState,\n+        Integer defaultPageSize, ClientLogger logger) {\n+        this.continuationState = continuationState;\n+        this.pageRetriever = pageRetriever;\n+        this.defaultPageSize = defaultPageSize;\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public E next() {\n+        if (!hasNext()) {\n+            throw logger.logExceptionAsError(new NoSuchElementException(\"Iterator contains no more elements.\"));\n+        }\n+\n+        return getNext();\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        // Request next pages in a loop in case we are returned empty pages for the by item implementation.\n+        while (!done && needToRequestPage()) {\n+            requestPage();\n+        }\n+\n+        return isNextAvailable();\n+    }\n+\n+    /*\n+     * Indicates if a page needs to be requested.\n+     */\n+    abstract boolean needToRequestPage();\n+\n+    /*\n+     * Indicates if another element is available.\n+     */\n+    abstract boolean isNextAvailable();\n+\n+    /*\n+     * Gets the next element to be emitted.\n+     */\n+    abstract E getNext();\n+\n+    synchronized void requestPage() {\n+        AtomicBoolean receivedPages = new AtomicBoolean(false);\n+        pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+            .map(page -> {\n+                receivedPages.set(true);\n+                addPage(page);\n+\n+                continuationState.setLastContinuationToken(page.getContinuationToken());\n+                this.done = continuationState.isDone();\n+\n+                return page;\n+            })\n+            .then()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzA2MA=="}, "originalCommit": {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 876, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}