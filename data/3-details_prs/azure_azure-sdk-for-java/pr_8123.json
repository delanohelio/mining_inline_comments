{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MDY1MjI2", "number": 8123, "title": "Adding readMany api that reads many documents at once based on id and\u2026", "bodyText": "Adding readMany api that reads many documents at once based on id and partitionkey\nThis avoids queryplan round trip, and does query only required partitions for required elements.", "createdAt": "2020-02-12T02:48:28Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123", "merged": true, "mergeCommit": {"oid": "6c11cca309cc00b9e51fab566e0cdf9ba00a0381"}, "closed": true, "closedAt": "2020-02-13T17:26:17Z", "author": {"login": "mbhaskar"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDdLVegH2gAyMzc0MDY1MjI2OjljMzFjOGVlNThlNmY3Yjc1MWYwY2UzNDQ1NmZhZWQ4ZjdlNzU0ZGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcD22Q8AH2gAyMzc0MDY1MjI2OjdiY2RhZGMyNDlhZmFiODIyNzRlOGMzM2FiMzI5MDE4NmVkODlhNTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "committedDate": "2020-02-12T02:47:29Z", "message": "Adding readMany api that reads many documents at once based on id and partitionkey.\nThis avoids queryplan round trip, and does query only required partitions for required elements."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTYxNzc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357161776", "createdAt": "2020-02-12T03:01:31Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMzowMTozMVrOFogYSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMzowNjowMVrOFogb9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNzg2NQ==", "bodyText": "does this actually read the collection? or uses collection cache.\nReading collection is expensive and we should be using CollectionCache.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378017865", "createdAt": "2020-02-12T03:01:31Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxODU5MQ==", "bodyText": "shouldn't this be concurrentHashMap as it is modified on a flatMap?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378018591", "createdAt": "2020-02-12T03:05:01Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())\n+            .flatMap(documentCollectionResourceResponse -> {\n+                         Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                             new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxODgwNw==", "bodyText": "same about this one too. shouldn't this be thread-safe?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378018807", "createdAt": "2020-02-12T03:06:01Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/ParallelDocumentQueryExecutionContext.java", "diffHunk": "@@ -96,6 +100,36 @@ private ParallelDocumentQueryExecutionContext(\n         }\n     }\n \n+    public static <T extends Resource> Flux<IDocumentQueryExecutionComponent<T>> createReadManyQueryAsync(\n+        IDocumentQueryClient queryClient,\n+        String collectionResourceId, SqlQuerySpec sqlQuery,\n+        Map<PartitionKeyRange, String> rangeQueryMap,\n+        FeedOptions feedOptions, String collectionRid, String collectionLink, UUID activityId, Class<T> klass,\n+        ResourceType resourceTypeEnum) {\n+        \n+        List<PartitionKeyRange> ranges = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTg5MTg0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357189184", "createdAt": "2020-02-12T04:57:06Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1NzowN1rOFohyAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1NzowN1rOFohyAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MDgzNQ==", "bodyText": "String, PartitionKey [](start = 63, length = 20)\n\nParameter order consistency w.r.t. other API's", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378040835", "createdAt": "2020-02-12T04:57:07Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -489,4 +491,12 @@ public static void setFeedOptionsMaxItemCount(FeedOptions feedOptions, Integer m\n     public static <T> CosmosContinuablePagedFlux<T> createCosmosContinuablePagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n         return new CosmosContinuablePagedFlux<>(pagedFluxOptionsFluxFunction);\n     }\n+\n+    public static Mono<FeedResponse<Document>> readMany(CosmosAsyncContainer container, \n+                                                     List<Pair<String, PartitionKey>> itemKeyList){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTg5NDc1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357189475", "createdAt": "2020-02-12T04:58:22Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1ODoyMlrOFohy4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1ODoyMlrOFohy4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTA1OQ==", "bodyText": "Is a sync version of this contract also needed?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378041059", "createdAt": "2020-02-12T04:58:22Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -489,4 +491,12 @@ public static void setFeedOptionsMaxItemCount(FeedOptions feedOptions, Integer m\n     public static <T> CosmosContinuablePagedFlux<T> createCosmosContinuablePagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n         return new CosmosContinuablePagedFlux<>(pagedFluxOptionsFluxFunction);\n     }\n+\n+    public static Mono<FeedResponse<Document>> readMany(CosmosAsyncContainer container, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTg5NzQ4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357189748", "createdAt": "2020-02-12T04:59:28Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1OToyOFrOFohzsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1OToyOFrOFohzsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTI2Nw==", "bodyText": "Is BridgeInernal right place? May be a new targetted contract\nBridgeInternal has lot of other contracts which might get attention.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378041267", "createdAt": "2020-02-12T04:59:28Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -489,4 +491,12 @@ public static void setFeedOptionsMaxItemCount(FeedOptions feedOptions, Integer m\n     public static <T> CosmosContinuablePagedFlux<T> createCosmosContinuablePagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n         return new CosmosContinuablePagedFlux<>(pagedFluxOptionsFluxFunction);\n     }\n+\n+    public static Mono<FeedResponse<Document>> readMany(CosmosAsyncContainer container, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTkwNDEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357190411", "createdAt": "2020-02-12T05:02:32Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowMjozMlrOFoh19Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowMjozMlrOFoh19Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTg0NQ==", "bodyText": "can we create the template of query using StringBuilder,  and use SqlQuerySpec and SqlParameter for passing id and pk values?\nthat way you don't have to worry about serializing the query and also it is safe against sql query injection attack?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378041845", "createdAt": "2020-02-12T05:02:32Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())\n+            .flatMap(documentCollectionResourceResponse -> {\n+                         Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                             new HashMap<>();\n+                         Mono<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = partitionKeyRangeCache\n+                                                                                             .tryLookupAsync(collection\n+                                                                                                                 .getResourceId(),\n+                                                                                                             null,\n+                                                                                                             null);\n+                         return valueHolderMono.flatMap(collectionRoutingMapValueHolder ->{\n+                             CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                             itemKeyList\n+                                 .forEach(stringPartitionKeyPair -> {\n+\n+                                     String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                                                                              .getEffectivePartitionKeyString(BridgeInternal\n+                                                                                                                  .getPartitionKeyInternal(stringPartitionKeyPair\n+                                                                                                                                               .getRight()),\n+                                                                                                              collection\n+                                                                                                                  .getPartitionKey());\n+\n+                                     //use routing map to find the partitionKeyRangeId of each effectivePartitionKey\n+\n+\n+                                     PartitionKeyRange range =\n+                                         routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+\n+                                     //group the itemKeyList based on partitionKeyRangeId\n+                                     if (partitionRangeItemKeyMap.get(range) == null) {\n+                                         List<Pair<String, PartitionKey>> list = new ArrayList<>();\n+                                         list.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, list);\n+                                     } else {\n+                                         List<Pair<String, PartitionKey>> pairs = partitionRangeItemKeyMap.get(range);\n+                                         pairs.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, pairs);\n+                                     }\n+\n+                                 });\n+\n+                             Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n+                             List<PartitionKeyRange> ranges = new ArrayList<>();\n+                             ranges.addAll(partitionKeyRanges);\n+\n+                             //Create the range query map that contains the query to be run for that partitionkeyrange\n+                             Map<PartitionKeyRange, String> rangeQueryMap;\n+                             rangeQueryMap = getRangeQueryMap(partitionRangeItemKeyMap, collection.getPartitionKey());\n+\n+                             String sqlQuery = \"this is dummy and only used for creating \" +\n+                                                   \"ParallelDocumentQueryExecutioncontext, but not used\";\n+\n+                             return createReadManyQuery(collectionLink, new SqlQuerySpec(sqlQuery), new FeedOptions(), Document.class,\n+                                                        ResourceType.Document, collection, rangeQueryMap)\n+                                        .collectList() // aggregating the result construct a FeedResponse and aggregate RUs.\n+                                        .map(feedList -> {\n+                                            List<Document> finalList = new ArrayList<>();\n+                                            HashMap<String, String> headers = new HashMap<>();\n+                                            double requestCharge = 0;\n+                                            for (FeedResponse<Document> page : feedList) {\n+                                                requestCharge += page.getRequestCharge();\n+                                                finalList.addAll(page.getResults());\n+                                            }\n+                                            headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n+                                            FeedResponse<Document> frp = BridgeInternal.createFeedResponse(finalList, headers);\n+                                            return frp;\n+                                        });\n+                         });\n+                     }\n+            );\n+      \n+    }\n+\n+    // TODO: This needs refactoring and optimization and betterment and everything\n+    private Map<PartitionKeyRange, String> getRangeQueryMap(\n+        Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap,\n+        PartitionKeyDefinition partitionKeyDefinition) {\n+        //TODO: Optimise this\n+        String partitionKeyPathString = partitionKeyDefinition.getPaths().get(0);\n+        String partitionKeyPath = (new StringBuilder(partitionKeyPathString)).deleteCharAt(0).toString();\n+        \n+        Map<PartitionKeyRange, String> rangeQueryMap = new HashMap<>();\n+        \n+        for (PartitionKeyRange range : partitionRangeItemKeyMap.keySet()) {\n+            StringBuilder queryStringBuilder = new StringBuilder();\n+            queryStringBuilder.append(\"select * from c where \");\n+            List<Pair<String, PartitionKey>> pairsList = partitionRangeItemKeyMap.get(range);\n+            for (Pair p : pairsList) {\n+                queryStringBuilder.append(\"(c.id = \\\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTkxMDM0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357191034", "createdAt": "2020-02-12T05:05:17Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowNToxN1rOFoh3-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowNToxN1rOFoh3-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MjM2Mg==", "bodyText": "is this some leftover code? is this needed?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378042362", "createdAt": "2020-02-12T05:05:17Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTk1OTg5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357195989", "createdAt": "2020-02-12T05:25:35Z", "commit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToyNTozNVrOFoiGrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToyNTozNVrOFoiGrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NjEyNQ==", "bodyText": "Split handling: Do query layer take care?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378046125", "createdAt": "2020-02-12T05:25:35Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())\n+            .flatMap(documentCollectionResourceResponse -> {\n+                         Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                             new HashMap<>();\n+                         Mono<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = partitionKeyRangeCache\n+                                                                                             .tryLookupAsync(collection\n+                                                                                                                 .getResourceId(),\n+                                                                                                             null,\n+                                                                                                             null);\n+                         return valueHolderMono.flatMap(collectionRoutingMapValueHolder ->{\n+                             CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                             itemKeyList\n+                                 .forEach(stringPartitionKeyPair -> {\n+\n+                                     String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                                                                              .getEffectivePartitionKeyString(BridgeInternal\n+                                                                                                                  .getPartitionKeyInternal(stringPartitionKeyPair\n+                                                                                                                                               .getRight()),\n+                                                                                                              collection\n+                                                                                                                  .getPartitionKey());\n+\n+                                     //use routing map to find the partitionKeyRangeId of each effectivePartitionKey\n+\n+\n+                                     PartitionKeyRange range =\n+                                         routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+\n+                                     //group the itemKeyList based on partitionKeyRangeId\n+                                     if (partitionRangeItemKeyMap.get(range) == null) {\n+                                         List<Pair<String, PartitionKey>> list = new ArrayList<>();\n+                                         list.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, list);\n+                                     } else {\n+                                         List<Pair<String, PartitionKey>> pairs = partitionRangeItemKeyMap.get(range);\n+                                         pairs.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, pairs);\n+                                     }\n+\n+                                 });\n+\n+                             Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n+                             List<PartitionKeyRange> ranges = new ArrayList<>();\n+                             ranges.addAll(partitionKeyRanges);\n+\n+                             //Create the range query map that contains the query to be run for that partitionkeyrange\n+                             Map<PartitionKeyRange, String> rangeQueryMap;\n+                             rangeQueryMap = getRangeQueryMap(partitionRangeItemKeyMap, collection.getPartitionKey());\n+\n+                             String sqlQuery = \"this is dummy and only used for creating \" +\n+                                                   \"ParallelDocumentQueryExecutioncontext, but not used\";\n+\n+                             return createReadManyQuery(collectionLink, new SqlQuerySpec(sqlQuery), new FeedOptions(), Document.class,\n+                                                        ResourceType.Document, collection, rangeQueryMap)\n+                                        .collectList() // aggregating the result construct a FeedResponse and aggregate RUs.\n+                                        .map(feedList -> {\n+                                            List<Document> finalList = new ArrayList<>();\n+                                            HashMap<String, String> headers = new HashMap<>();\n+                                            double requestCharge = 0;\n+                                            for (FeedResponse<Document> page : feedList) {\n+                                                requestCharge += page.getRequestCharge();\n+                                                finalList.addAll(page.getResults());\n+                                            }\n+                                            headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n+                                            FeedResponse<Document> frp = BridgeInternal.createFeedResponse(finalList, headers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fce2e2d44869faff18df4cb6a7e5272b4635b80d", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fce2e2d44869faff18df4cb6a7e5272b4635b80d", "committedDate": "2020-02-13T00:31:20Z", "message": "Addressing PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0619c734b908500547e62f6af859daf6edeeecc1", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0619c734b908500547e62f6af859daf6edeeecc1", "committedDate": "2020-02-13T02:25:02Z", "message": "Merge branch 'feature/cosmos/upstream-v4' into mbhaskar/v4/readmany-internalapi\n\n# Conflicts:\n#\tsdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java\n#\tsdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\n#\tsdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ParallelDocumentQueryTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7055cff91d00143b3b18f31b7a22aaf748fd09ad", "author": {"user": {"login": "mbhaskar", "name": "Bhaskar Mallapragada"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7055cff91d00143b3b18f31b7a22aaf748fd09ad", "committedDate": "2020-02-13T02:47:21Z", "message": "Skipping readMany test in gateway mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "696d0d5274a91ee699ab8ec4876bdec126b83a52", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/696d0d5274a91ee699ab8ec4876bdec126b83a52", "committedDate": "2020-02-13T05:08:38Z", "message": "added support for pk = '/id', and added support for nested partition-key path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1e1ee4dfc0aafe2c2c8717c479eee19c8a3a68f", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1e1ee4dfc0aafe2c2c8717c479eee19c8a3a68f", "committedDate": "2020-02-13T05:31:30Z", "message": "added support for typed based translation to readmany"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ee589b285036ed42b1494819ddba2e23818f3af", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ee589b285036ed42b1494819ddba2e23818f3af", "committedDate": "2020-02-13T05:39:57Z", "message": "moved readmany to ItemOperation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTE1OTUw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357915950", "createdAt": "2020-02-13T02:16:44Z", "commit": {"oid": "fce2e2d44869faff18df4cb6a7e5272b4635b80d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMjoxNjo0NFrOFpFBJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMjoxNjo0NFrOFpFBJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxODE0OQ==", "bodyText": "this only works on simple partition-key-path. I will improve this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378618149", "createdAt": "2020-02-13T02:16:44Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1334,182 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink, FeedOptions options) {\n+\n+        RxDocumentServiceRequest request = RxDocumentServiceRequest.create(\n+            OperationType.Query,\n+            ResourceType.Document,\n+            collectionLink, null\n+        ); // This should not got to backend\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionObs = collectionCache.resolveCollectionAsync(request);\n+\n+        return collectionObs\n+                   .flatMap(documentCollectionResourceResponse -> {\n+                                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                                if (collection == null) {\n+                                    throw new IllegalStateException(\"Collection cannot be null\");\n+                                }\n+\n+                                Mono<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = partitionKeyRangeCache\n+                                                                                                    .tryLookupAsync(collection\n+                                                                                                                        .getResourceId(),\n+                                                                                                                    null,\n+                                                                                                                    null);\n+                                return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n+                                    Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                                        new HashMap<>();\n+                                    CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                                    if (routingMap == null) {\n+                                        throw new IllegalStateException(\"Failed to get routing map.\");\n+                                    }\n+                                    itemKeyList\n+                                        .forEach(stringPartitionKeyPair -> {\n+\n+                                            String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                                                                                     .getEffectivePartitionKeyString(BridgeInternal\n+                                                                                                                         .getPartitionKeyInternal(stringPartitionKeyPair\n+                                                                                                                                                      .getRight()),\n+                                                                                                                     collection\n+                                                                                                                         .getPartitionKey());\n+\n+                                            //use routing map to find the partitionKeyRangeId of each \n+                                            // effectivePartitionKey\n+                                            PartitionKeyRange range =\n+                                                routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+                                            //group the itemKeyList based on partitionKeyRangeId\n+                                            if (partitionRangeItemKeyMap.get(range) == null) {\n+                                                List<Pair<String, PartitionKey>> list = new ArrayList<>();\n+                                                list.add(stringPartitionKeyPair);\n+                                                partitionRangeItemKeyMap.put(range, list);\n+                                            } else {\n+                                                List<Pair<String, PartitionKey>> pairs =\n+                                                    partitionRangeItemKeyMap.get(range);\n+                                                pairs.add(stringPartitionKeyPair);\n+                                                partitionRangeItemKeyMap.put(range, pairs);\n+                                            }\n+\n+                                        });\n+\n+                                    Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n+                                    List<PartitionKeyRange> ranges = new ArrayList<>();\n+                                    ranges.addAll(partitionKeyRanges);\n+\n+                                    //Create the range query map that contains the query to be run for that \n+                                    // partitionkeyrange\n+                                    Map<PartitionKeyRange, SqlQuerySpec> rangeQueryMap;\n+                                    rangeQueryMap = getRangeQueryMap(partitionRangeItemKeyMap,\n+                                                                     collection.getPartitionKey());\n+\n+                                    String sqlQuery = \"this is dummy and only used in creating \" +\n+                                                          \"ParallelDocumentQueryExecutioncontext, but not used\";\n+\n+                                    // create the executable query\n+                                    return createReadManyQuery(collectionLink,\n+                                                               new SqlQuerySpec(sqlQuery),\n+                                                               new FeedOptions(),\n+                                                               Document.class,\n+                                                               ResourceType.Document,\n+                                                               collection,\n+                                                               Collections.unmodifiableMap(rangeQueryMap))\n+                                               .collectList() // aggregating the result construct a FeedResponse and \n+                                               // aggregate RUs.\n+                                               .map(feedList -> {\n+                                                   List<Document> finalList = new ArrayList<>();\n+                                                   HashMap<String, String> headers = new HashMap<>();\n+                                                   double requestCharge = 0;\n+                                                   for (FeedResponse<Document> page : feedList) {\n+                                                       requestCharge += page.getRequestCharge();\n+                                                       finalList.addAll(page.getResults());\n+                                                   }\n+                                                   headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double\n+                                                                                                             .toString(requestCharge));\n+                                                   FeedResponse<Document> frp = BridgeInternal\n+                                                                                    .createFeedResponse(finalList, headers);\n+                                                   return frp;\n+                                               });\n+                                });\n+                            }\n+                   );\n+\n+    }\n+\n+    // TODO: This needs refactoring and optimization and betterment and everything\n+    private Map<PartitionKeyRange, SqlQuerySpec> getRangeQueryMap(\n+        Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap,\n+        PartitionKeyDefinition partitionKeyDefinition) {\n+        //TODO: Optimise this to include all types of partitionkeydefinitions. ex: c[\"prop1./ab\"][\"key1\"]\n+        String partitionKeyPathString = partitionKeyDefinition.getPaths().get(0);\n+        String partitionKeyPath = (new StringBuilder(partitionKeyPathString)).deleteCharAt(0).toString();\n+\n+        SqlParameterList parameters = new SqlParameterList();\n+        int paramCnt = 0;\n+        Map<PartitionKeyRange, SqlQuerySpec> rangeQueryMap = new HashMap<>();\n+        \n+        for (PartitionKeyRange range : partitionRangeItemKeyMap.keySet()) {\n+            StringBuilder queryStringBuilder = new StringBuilder();\n+            queryStringBuilder.append(\"select * from c where \");\n+            List<Pair<String, PartitionKey>> pairsList = partitionRangeItemKeyMap.get(range);\n+            for (Pair p : pairsList) {\n+                paramCnt++;\n+                queryStringBuilder.append(\"(c.id = \");\n+                queryStringBuilder.append(getCurentParamName(paramCnt));\n+                parameters.add(new SqlParameter(getCurentParamName(paramCnt), p.getLeft()));\n+                paramCnt++;\n+                queryStringBuilder.append(\" and \");\n+                queryStringBuilder.append(\" c.\");\n+                // partition key def\n+                queryStringBuilder.append(partitionKeyPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fce2e2d44869faff18df4cb6a7e5272b4635b80d"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6746cc67f7df9f51b2b12ae002629d097e93bcf", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b6746cc67f7df9f51b2b12ae002629d097e93bcf", "committedDate": "2020-02-13T05:58:27Z", "message": "added a sync method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTg1OTcz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#pullrequestreview-357985973", "createdAt": "2020-02-13T06:47:33Z", "commit": {"oid": "b6746cc67f7df9f51b2b12ae002629d097e93bcf"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNjo0NzozM1rOFpIotQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNjo1MDo1OFrOFpIsqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3NzQyOQ==", "bodyText": "Nit: No need for this import.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378677429", "createdAt": "2020-02-13T06:47:33Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -26,7 +26,9 @@\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.tuple.Pair;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6746cc67f7df9f51b2b12ae002629d097e93bcf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3ODQ0MQ==", "bodyText": "Do we still need to fix this for gateway ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378678441", "createdAt": "2020-02-13T06:50:58Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ParallelDocumentQueryTest.java", "diffHunk": "@@ -539,4 +547,44 @@ private void queryWithContinuationTokensAndPageSizes(String query, int[] pageSiz\n \n         return receivedDocuments;\n     }\n+\n+    //TODO: Fix the test for GW mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6746cc67f7df9f51b2b12ae002629d097e93bcf"}, "originalPosition": 453}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bcdadc249afab82274e8c33ab3290186ed89a54", "author": {"user": {"login": "moderakh", "name": "Mohammad Derakhshani"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7bcdadc249afab82274e8c33ab3290186ed89a54", "committedDate": "2020-02-13T08:42:00Z", "message": "fixed parallelism in readMany"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2460, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}