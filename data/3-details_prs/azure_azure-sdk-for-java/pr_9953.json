{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNjQ0OTA4", "number": 9953, "title": "[FR] implements auto-content-detection method getContentType() ", "bodyText": "fixes: #9248", "createdAt": "2020-04-08T05:58:13Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953", "merged": true, "mergeCommit": {"oid": "b3069ae8f34f06ff90fe87e6c618dac837402d8c"}, "closed": true, "closedAt": "2020-04-21T21:51:56Z", "author": {"login": "mssfang"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVgU3tgH2gAyNDAwNjQ0OTA4OmYyYTUyMjEzMDM1M2Y1NGFkMDQzOWM2MDBjMWY0ZGQyMWViNDcxMDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZ65EYgFqTM5NzcwMTk3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f2a522130353f54ad0439c600c1f4dd21eb47105", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2a522130353f54ad0439c600c1f4dd21eb47105", "committedDate": "2020-04-08T04:38:15Z", "message": "getContentType implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "committedDate": "2020-04-08T05:54:00Z", "message": "getContentType impl"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDMwNDA0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-390030404", "createdAt": "2020-04-08T14:30:08Z", "commit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDozMDowOFrOGCx--w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDozNDo0OVrOGCyMww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2OTI3NQ==", "bodyText": "It could be nice to pull out the Byte.toUnsignedInt((byte)) into a separate function", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405569275", "createdAt": "2020-04-08T14:30:08Z", "author": {"login": "iscai-msft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\");\n+        }\n+\n+        final int byte0 = Byte.toUnsignedInt(bytes[0]);\n+        final int byte1 = Byte.toUnsignedInt(bytes[1]);\n+        final int byte2 = Byte.toUnsignedInt(bytes[2]);\n+        final int byte3 = Byte.toUnsignedInt(bytes[3]);\n+\n+        if (byte0 == Byte.toUnsignedInt((byte) 0x25) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDI5NQ==", "bodyText": "For Jpeg, I think you also need to check the last two bytes are 0xFF and 0xD9", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405570295", "createdAt": "2020-04-08T14:31:32Z", "author": {"login": "iscai-msft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\");\n+        }\n+\n+        final int byte0 = Byte.toUnsignedInt(bytes[0]);\n+        final int byte1 = Byte.toUnsignedInt(bytes[1]);\n+        final int byte2 = Byte.toUnsignedInt(bytes[2]);\n+        final int byte3 = Byte.toUnsignedInt(bytes[3]);\n+\n+        if (byte0 == Byte.toUnsignedInt((byte) 0x25) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&\n+            byte2 == Byte.toUnsignedInt((byte) 0x44) && byte3 == Byte.toUnsignedInt((byte) 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (byte0 == Byte.toUnsignedInt((byte) 0xff) && byte1 == Byte.toUnsignedInt((byte) 0xd8)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MjgwMw==", "bodyText": "Just making sure that this little edit is all that needs to be changed in the key credential transition", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405572803", "createdAt": "2020-04-08T14:34:49Z", "author": {"login": "iscai-msft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/FormRecognizerClientTestBase.java", "diffHunk": "@@ -218,7 +218,7 @@ private static void validatePageMetadata(PageMetadata expectedPageInfo, PageMeta\n      * Create a client builder with endpoint and API key credential.\n      *\n      * @param endpoint the given endpoint\n-     * @param credential the given {@link FormRecognizerApiKeyCredential} credential\n+     * @param credential the given {@link AzureKeyCredential} credential", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTI2MzEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-390126311", "createdAt": "2020-04-08T16:14:32Z", "commit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxNDozMlrOGC2oVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxNDozMlrOGC2oVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NTM5OQ==", "bodyText": "If content type cannot be auto-detected we still need to let the user pass content type themselves. Perhaps include that in this exception message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405645399", "createdAt": "2020-04-08T16:14:32Z", "author": {"login": "kristapratico"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\");\n+        }\n+\n+        final int byte0 = Byte.toUnsignedInt(bytes[0]);\n+        final int byte1 = Byte.toUnsignedInt(bytes[1]);\n+        final int byte2 = Byte.toUnsignedInt(bytes[2]);\n+        final int byte3 = Byte.toUnsignedInt(bytes[3]);\n+\n+        if (byte0 == Byte.toUnsignedInt((byte) 0x25) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&\n+            byte2 == Byte.toUnsignedInt((byte) 0x44) && byte3 == Byte.toUnsignedInt((byte) 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (byte0 == Byte.toUnsignedInt((byte) 0xff) && byte1 == Byte.toUnsignedInt((byte) 0xd8)) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (byte0 == Byte.toUnsignedInt((byte) 0x89) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&\n+            byte2 == Byte.toUnsignedInt((byte) 0x4e) && byte3 == Byte.toUnsignedInt((byte) 0x47)) {\n+            return ContentType.IMAGE_PNG;\n+        } else if ((byte0 == Byte.toUnsignedInt((byte) 0x49) && byte1 == Byte.toUnsignedInt((byte) 0x49) &&\n+                byte2 == Byte.toUnsignedInt((byte) 0x2a) && byte3 == Byte.toUnsignedInt((byte) 0x0)) || // little-endian\n+            (byte0 == Byte.toUnsignedInt((byte) 0x4d) && byte1 == Byte.toUnsignedInt((byte) 0x4d) &&\n+                byte2 == Byte.toUnsignedInt((byte) 0x0) && byte3 == Byte.toUnsignedInt((byte) 0x2a))) {  // big-endian\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw new IllegalArgumentException (\"content type could not be detected\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTI5ODg1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-390129885", "createdAt": "2020-04-08T16:18:53Z", "commit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxODo1M1rOGC2zsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyMTowMFrOGC25CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODMwNQ==", "bodyText": "Should this be logger throw?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405648305", "createdAt": "2020-04-08T16:18:53Z", "author": {"login": "samvaity"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +16,61 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n-     *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        Pair pair = new Pair();\n+        return Flux.just(true)\n+            .repeat()\n+            .map(ignore -> {\n+                byte[] buffer = new byte[BYTE_BUFFER_CHUNK_SIZE];\n+                try {\n+                    int numBytes = inputStream.read(buffer);\n+                    if (numBytes > 0) {\n+                        return pair.buffer(ByteBuffer.wrap(buffer, 0, numBytes)).readBytes(numBytes);\n+                    } else {\n+                        return pair.buffer(null).readBytes(numBytes);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw Exceptions.propagate(ioe);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODczMg==", "bodyText": "Should we consider moving this to core?\ncc: @srnagar", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405648732", "createdAt": "2020-04-08T16:19:32Z", "author": {"login": "samvaity"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +16,61 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n-     *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0OTY3Mg==", "bodyText": "Need tests?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405649672", "createdAt": "2020-04-08T16:21:00Z", "author": {"login": "samvaity"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTQ1NjI5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-390145629", "createdAt": "2020-04-08T16:38:56Z", "commit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozODo1NlrOGC3nBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozODo1NlrOGC3nBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MTQ0NA==", "bodyText": "Feels like it shouldn't belong to Trasnform?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405661444", "createdAt": "2020-04-08T16:38:56Z", "author": {"login": "jeremymeng"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -30,6 +29,7 @@\n import java.util.UUID;\n import java.util.function.Function;\n \n+import static com.azure.ai.formrecognizer.Transforms.getContentType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c8b2f54620a69ca479280b9422f295419c25dafe", "committedDate": "2020-04-10T06:20:11Z", "message": "add tests and address feedbacks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDc5NzQ1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-391479745", "createdAt": "2020-04-10T14:43:53Z", "commit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNDo0Mzo1M1rOGD8cPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNDo0NTowM1rOGD8eNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4OTE4Mw==", "bodyText": "nitpick (feel free to ignore)\nYou could make the function isEqual take in a list of bytes and what they should be, so the code could be more like\nisEqual(bytes.subList(0, 4), [0x25, 0x50, 0x44, 0x46])", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406789183", "createdAt": "2020-04-10T14:43:53Z", "author": {"login": "iscai-msft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -22,6 +23,41 @@\n     private Utility() {\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4OTY4NQ==", "bodyText": "Consider adding a test where the user passes in the content type", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406789685", "createdAt": "2020-04-10T14:45:03Z", "author": {"login": "iscai-msft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/ContentTypeDetectionTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.Utility;\n+import com.azure.ai.formrecognizer.implementation.models.ContentType;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+/**\n+ * Unit tests for automatically detection of content type.\n+ */\n+public class ContentTypeDetectionTest {\n+\n+    /**\n+     * Test for JPG file content type detection.\n+     *\n+     * @throws  IOException if an I/O error occurs reading from the stream\n+     */\n+    @Test\n+    public void jpgContentDetectionTest() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNTI5MTMx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-391529131", "createdAt": "2020-04-10T16:19:25Z", "commit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoxOToyNVrOGD--5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjozMjoxOVrOGD_Tvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMDgyMw==", "bodyText": "We generally don't want to block in Reactive code as this could cause a RuntimeException for blocking in a non-blocking thread. We have some control on whether non-blocking threads are being used but not complete control.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406830823", "createdAt": "2020-04-10T16:19:25Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -173,11 +170,11 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     }\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n-        Flux<ByteBuffer> buffer, long length, FormContentType formContentType, boolean includeTextDetails) {\n+        Flux<ByteBuffer> buffer, long length, boolean includeTextDetails) {\n         return (pollingContext) -> {\n             try {\n                 return service.analyzeReceiptAsyncWithResponseAsync(includeTextDetails,\n-                    ContentType.fromString(formContentType.toString()), buffer, length)\n+                    getContentType(buffer.blockFirst()), buffer, length)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTQ1MA==", "bodyText": "This is something we'll want to add into FluxUtil eventually, mind filing an issue for this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406831450", "createdAt": "2020-04-10T16:21:05Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +16,61 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n-     *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODczMg=="}, "originalCommit": {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMzA3Nw==", "bodyText": "Instead of casting the byte to an int we could just use the following checks:\nbytes[0] == (byte) 0x25...", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406833077", "createdAt": "2020-04-10T16:24:45Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTI0MQ==", "bodyText": "If we do want to end up keeping this we shouldn't cast and re-cast the hex value.\nbyteValue == (byte) hexValue should be sufficient.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406835241", "createdAt": "2020-04-10T16:29:57Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (isEqual(bytes[0], 0xff) && isEqual(bytes[1], 0xd8)) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (\n+            isEqual(bytes[0], 0x89) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x4e) && isEqual(bytes[3], 0x47)) {\n+            return ContentType.IMAGE_PNG;\n+        } else if (\n+            // little-endian\n+            (isEqual(bytes[0], 0x49) && isEqual(bytes[1], 0x49) && isEqual(bytes[2], 0x2a) && isEqual(bytes[3], 0x0))\n+            // big-endian\n+            || (isEqual(bytes[0], 0x4d) && isEqual(bytes[1], 0x4d) && isEqual(bytes[2], 0x0)\n+                && isEqual(bytes[3], 0x2a))) {\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw new IllegalArgumentException(\n+                \"Content type could not be detected. Should use other overload API that takes content type.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n+     *\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        Pair pair = new Pair();\n+        return Flux.just(true)\n+            .repeat()\n+            .map(ignore -> {\n+                byte[] buffer = new byte[BYTE_BUFFER_CHUNK_SIZE];\n+                try {\n+                    int numBytes = inputStream.read(buffer);\n+                    if (numBytes > 0) {\n+                        return pair.buffer(ByteBuffer.wrap(buffer, 0, numBytes)).readBytes(numBytes);\n+                    } else {\n+                        return pair.buffer(null).readBytes(numBytes);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw LOGGER.logExceptionAsError(new RuntimeException(ioe));\n+                }\n+            })\n+            .takeUntil(p -> p.readBytes() == -1)\n+            .filter(p -> p.readBytes() > 0)\n+            .map(Pair::buffer);\n     }\n \n-    private static ByteBuffer toByteArray(InputStream in) {\n-        try {\n-            ByteArrayOutputStream os = new ByteArrayOutputStream();\n-            byte[] buffer = new byte[1024];\n-            int len;\n-\n-            // read bytes from the input stream and store them in buffer\n-            while ((len = in.read(buffer)) != -1) {\n-                // write bytes from the buffer into output stream\n-                os.write(buffer, 0, len);\n-            }\n-            return ByteBuffer.wrap(os.toByteArray());\n-        } catch (IOException e) {\n-            throw LOGGER.logExceptionAsError(new RuntimeException(e));\n+    private static class Pair {\n+        private ByteBuffer byteBuffer;\n+        private int readBytes;\n+\n+        ByteBuffer buffer() {\n+            return this.byteBuffer;\n+        }\n+\n+        int readBytes() {\n+            return this.readBytes;\n+        }\n+\n+        Pair buffer(ByteBuffer byteBuffer) {\n+            this.byteBuffer = byteBuffer;\n+            return this;\n+        }\n+\n+        Pair readBytes(int cnt) {\n+            this.readBytes = cnt;\n+            return this;\n         }\n     }\n+\n+    /**\n+     * Compare if a byte value equals to a hex type value.\n+     *\n+     * @param byteValue the byte type value\n+     * @param hexValue the hex type value\n+     * @return true if two type's values are equal in unsigned int comparision.\n+     */\n+    private static boolean isEqual(byte byteValue, int hexValue) {\n+        return Byte.toUnsignedInt(byteValue) == Byte.toUnsignedInt((byte) hexValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTU5OQ==", "bodyText": "Since we have the static logger we should log this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406835599", "createdAt": "2020-04-10T16:30:48Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (isEqual(bytes[0], 0xff) && isEqual(bytes[1], 0xd8)) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (\n+            isEqual(bytes[0], 0x89) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x4e) && isEqual(bytes[3], 0x47)) {\n+            return ContentType.IMAGE_PNG;\n+        } else if (\n+            // little-endian\n+            (isEqual(bytes[0], 0x49) && isEqual(bytes[1], 0x49) && isEqual(bytes[2], 0x2a) && isEqual(bytes[3], 0x0))\n+            // big-endian\n+            || (isEqual(bytes[0], 0x4d) && isEqual(bytes[1], 0x4d) && isEqual(bytes[2], 0x0)\n+                && isEqual(bytes[3], 0x2a))) {\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNjE1OQ==", "bodyText": "Since we are only checking the first ByteBuffer what would happen if the first buffer is empty due to a disk or networking latency but then the next one contains the byte marking which would properly determine the file type.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406836159", "createdAt": "2020-04-10T16:32:19Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "646c6a21e87820ee0684bd09ce2dbd523cfe3f34", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/646c6a21e87820ee0684bd09ce2dbd523cfe3f34", "committedDate": "2020-04-17T23:19:01Z", "message": "resolve conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcbb1cbcaca0b42e8111048e14895500f63871b6", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dcbb1cbcaca0b42e8111048e14895500f63871b6", "committedDate": "2020-04-17T23:35:26Z", "message": "refactor without blocking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e68e9a1a6d2fa5352e213dc476884f27172a6b12", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e68e9a1a6d2fa5352e213dc476884f27172a6b12", "committedDate": "2020-04-17T23:46:31Z", "message": "remove unused method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0962f82ce2824eb8d0f1fbaba20a9036517675c", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0962f82ce2824eb8d0f1fbaba20a9036517675c", "committedDate": "2020-04-20T04:12:11Z", "message": "working solution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3858916ced70778c1c6e5b112c1da51b56c5c007", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3858916ced70778c1c6e5b112c1da51b56c5c007", "committedDate": "2020-04-20T05:33:57Z", "message": "add recorded file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41d15d6b6a5d80725453abee1c079b6821b6f631", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/41d15d6b6a5d80725453abee1c079b6821b6f631", "committedDate": "2020-04-20T06:01:51Z", "message": "remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/859c5a05d42735995a9a97fdca305c44d880f0e0", "committedDate": "2020-04-20T06:22:49Z", "message": "added sync tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjA3MTM2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-396607136", "createdAt": "2020-04-20T16:16:23Z", "commit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoxNjoyM1rOGIckaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoyODowOVrOGIdF9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwOTg2NA==", "bodyText": "If Content-Type is given we can skip trying to guess the type.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411509864", "createdAt": "2020-04-20T16:16:23Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }\n+                return false;\n+            }, true, Integer.MAX_VALUE)\n+            .next()\n+            .flatMap(newData -> {\n+                // if content type is not given, do guessing the content type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxMTAyMQ==", "bodyText": "I don't feel this abstraction is really worth the overhead, both in maintenance and performance.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411511021", "createdAt": "2020-04-20T16:18:00Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -17,37 +17,121 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n+\n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 2) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 2 bytes of data\"));\n+        }\n+\n+        final byte[] firstFourBytesArray = new byte[] {bytes[0], bytes[1], bytes[2], bytes[3]};\n+\n+        if (isEqual(firstFourBytesArray, new int[] {0x25, 0x50, 0x44, 0x46})) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xd8) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (isEqual(firstFourBytesArray, new int[] {0x89, 0x50, 0x4e, 0x47})) {\n+            return ContentType.IMAGE_PNG;\n+        } else if (\n+            // little-endian\n+            (isEqual(firstFourBytesArray, new int[] {0x49, 0x49, 0x2a, 0x0}))\n+                // big-endian\n+                || (isEqual(firstFourBytesArray, new int[] {0x4d, 0x4d, 0x0, 0x2a}))) {\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\n+                \"Content type could not be detected. Should use other overload API that takes content type.\"));\n+        }\n     }\n \n-    private static ByteBuffer toByteArray(InputStream in) {\n-        try {\n-            ByteArrayOutputStream os = new ByteArrayOutputStream();\n-            byte[] buffer = new byte[1024];\n-            int len;\n+    /**\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n+     *\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        Pair pair = new Pair();\n+        return Flux.just(true)\n+            .repeat()\n+            .map(ignore -> {\n+                byte[] buffer = new byte[BYTE_BUFFER_CHUNK_SIZE];\n+                try {\n+                    int numBytes = inputStream.read(buffer);\n+                    if (numBytes > 0) {\n+                        return pair.buffer(ByteBuffer.wrap(buffer, 0, numBytes)).readBytes(numBytes);\n+                    } else {\n+                        return pair.buffer(null).readBytes(numBytes);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw LOGGER.logExceptionAsError(new RuntimeException(ioe));\n+                }\n+            })\n+            .takeUntil(p -> p.readBytes() == -1)\n+            .filter(p -> p.readBytes() > 0)\n+            .map(Pair::buffer);\n+    }\n+\n+    private static class Pair {\n+        private ByteBuffer byteBuffer;\n+        private int readBytes;\n \n-            // read bytes from the input stream and store them in buffer\n-            while ((len = in.read(buffer)) != -1) {\n-                // write bytes from the buffer into output stream\n-                os.write(buffer, 0, len);\n+        ByteBuffer buffer() {\n+            return this.byteBuffer;\n+        }\n+\n+        int readBytes() {\n+            return this.readBytes;\n+        }\n+\n+        Pair buffer(ByteBuffer byteBuffer) {\n+            this.byteBuffer = byteBuffer;\n+            return this;\n+        }\n+\n+        Pair readBytes(int cnt) {\n+            this.readBytes = cnt;\n+            return this;\n+        }\n+    }\n+\n+    /**\n+     * Compare if a byte value equals to a hex type value.\n+     *\n+     * @param byteValueList An array of byte type values.\n+     * @param hexValueList An array of hex type values.\n+     * @return true if two type's values are equal in unsigned int comparision, otherwise return false.\n+     */\n+    private static boolean isEqual(byte[] byteValueList, int[] hexValueList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxNDMxNw==", "bodyText": "This logic appears to be duplicated three times, any chance this could be abstracted? Possibly a method that takes Flux<ByteBuffer> and returns Mono<Tuple2<ContentType, Flux<ByteBuffer>>.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411514317", "createdAt": "2020-04-20T16:22:36Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -556,19 +623,53 @@ private void throwIfAnalyzeStatusInvalid(SimpleResponse<AnalyzeOperationResult>\n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> analyzeFormStreamActivationOperation(\n         Flux<ByteBuffer> data, String modelId, long length,\n         FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+        Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxODQ1Mw==", "bodyText": "The logic here is close, but a little off. Right now this will cache the entire data stream, this could be modified to cache until we get the number of bytes required to determine the content type, then join the cached buffers with the remaining buffers.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411518453", "createdAt": "2020-04-20T16:28:09Z", "author": {"login": "alzimmermsft"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -442,18 +476,51 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> contentStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeLayoutAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjU5MTM3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-396659137", "createdAt": "2020-04-20T17:22:41Z", "commit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyMjo0MVrOGIfWjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyMjo0MVrOGIfWjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NTQ3MQ==", "bodyText": "If I understand it correctly - there are two cases:\nuser input -> { data = contentTypeHeader+content }\nuser input -> { data = contentTypeHeader+content, contentType=pdf }\ni.e. user can optionally provide contentType as input.\nWe've this windowUntil here to detect the content-type but that comes with a cost i.e. we need to allocate a new ByteBuffer (or multiple ByteBuffers if data emits byte-by-byte), we do that even if user provide us the contentType as an argument. I think when contentType is given we can call the underlying API and give it data as it is, if contentType is not given then apply the windowUntil path.  This way we can also simplify the logic, we don't the var  isGuessed or check like formContentType == null\nComing to the current windowUntil path - I think it may not work correctly if data comes as chunks i.e.\ndata = ByteBuffer_chunk1 (containing contentType and some data),  ByteBuffer_chunk2, ByteBuffer_chunk3\n\nLooks like by doing next() after windowUntil, the newData will be just ByteBuffer_chunk1. Good to double check.\nYou might want to apply buffer operator after windowUntil\n.buffer(2)\n.next()\n.flatMap(fluxes -> {\n    var contentType = getContentType(cachedBuffers);\n    if (fluxes.size() == 1) {\n        return callAPI(Flux.fromIterable(cachedBuffers));\n    } else {\n        return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1)));\n    }\n})", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411555471", "createdAt": "2020-04-20T17:22:41Z", "author": {"login": "anuchandy"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }\n+                return false;\n+            }, true, Integer.MAX_VALUE)\n+            .next()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2Njg2NDMx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-396686431", "createdAt": "2020-04-20T17:59:59Z", "commit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzo1OTo1OVrOGIg2ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODoyMjo0MVrOGIhsoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MDA2Nw==", "bodyText": "These public async APIs shouldn't throw exceptions. It should be returned as an error.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411580067", "createdAt": "2020-04-20T17:59:59Z", "author": {"login": "srnagar"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -355,16 +357,16 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     public PollerFlux<OperationResult, IterableStream<RecognizedReceipt>> beginRecognizeReceipts(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails,\n         Duration pollInterval) {\n-        final Duration interval = pollInterval != null ? pollInterval : DEFAULT_DURATION;\n-        return new PollerFlux<OperationResult, IterableStream<RecognizedReceipt>>(interval,\n+\n+        return new PollerFlux<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NjcyNQ==", "bodyText": "Why do you need an array? This can just be AtomicBoolean.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411586725", "createdAt": "2020-04-20T18:10:45Z", "author": {"login": "srnagar"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4OTcwMA==", "bodyText": "Is this done to support hot fluxes? I thought this API only supported cold fluxes. If we only support cold fluxes, this can be simplified.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411589700", "createdAt": "2020-04-20T18:15:33Z", "author": {"login": "srnagar"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }\n+                return false;\n+            }, true, Integer.MAX_VALUE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5MjUwMQ==", "bodyText": "The byte array length is checked for < 2 but the first four bytes are accessed. Should the length check be < 4?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411592501", "createdAt": "2020-04-20T18:20:16Z", "author": {"login": "srnagar"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -17,37 +17,121 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n+\n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 2) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 2 bytes of data\"));\n+        }\n+\n+        final byte[] firstFourBytesArray = new byte[] {bytes[0], bytes[1], bytes[2], bytes[3]};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5Mzg4OQ==", "bodyText": "If the buffer data is greater than length, we should stop and throw an exception as the length provided by user is incorrect.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411593889", "createdAt": "2020-04-20T18:22:41Z", "author": {"login": "srnagar"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cc991f099d0e5ad296f3585456c68f3fd776162", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1cc991f099d0e5ad296f3585456c68f3fd776162", "committedDate": "2020-04-21T01:23:32Z", "message": "working solution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3c630720accabc26ddc155c67c3119c6cb70274", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c3c630720accabc26ddc155c67c3119c6cb70274", "committedDate": "2020-04-21T01:27:22Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8ff667d898746aae5195beac5a4f8cd0b918c06", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f8ff667d898746aae5195beac5a4f8cd0b918c06", "committedDate": "2020-04-21T02:01:54Z", "message": "simplicy the imple"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDM5ODY2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-397439866", "createdAt": "2020-04-21T15:21:35Z", "commit": {"oid": "f8ff667d898746aae5195beac5a4f8cd0b918c06"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyMTozNVrOGJLoIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyMTozNVrOGJLoIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA==", "bodyText": "Thanks, Shawn, for simplifying this.\nThis looks better, but it assumes that the first ByteBuffer from data is at least 2 or 4 bytes, which may not always the case. For example, if the data arrives in following structure, then next() operator is not sufficient:\nFlux<ByteBuffer> data = Flux.fromArray(new ByteBuffer [] {\n    ByteBuffer.wrap(new byte[]{(byte) 0xff}),\n    ByteBuffer.wrap(new byte[]{(byte) 0xd8}),\n    ByteBuffer.wrap(new byte[]{3}),\n    ByteBuffer.wrap(new byte[]{4})\n});\nmay be something like below which looks for header even if the header bytes are split across chunks, (please test it, also return type should be ContentType)\nprivate static Mono<String> detectContentType(Flux<ByteBuffer> data) {\n    byte[] header = new byte[4];\n    int[] written = new int[] {0};\n    String[] contentType = new String[] {null};\n    return data.map(chunk -> {\n        final int len = chunk.remaining();\n        for (int i = 0 ;i < len; i++) {\n            header[written[0]] = chunk.get(i);\n            written[0]++;\n            if (written[0] == 2) {\n                if (isJpeg(header)) {\n                    contentType[0] = \"IMAGE_JPEG\";\n                    // Got a matching two bytes, return false so that takeWhile\n                    // can cut the subscription on data\n                    return false;\n                } else {\n                    // two bytes didn't match, continue to read next byte\n                    continue;\n                }\n            }\n            if (written[0] == 4) {\n                if (isPdf(header)) {\n                    contentType[0] = \"APPLICATION_PDF\";\n                } else if (isPng(header)) {\n                    contentType[0] = \"IMAGE_PNG\";\n                } else if (isTiff(header)) {\n                    contentType[0] = \"IMAGE_TIFF\";\n                }\n                // Got a four bytes matching or not, either way no need to read more byte return false \n               // so that takeWhile can cut the subscription on data\n                return false;\n            }\n        }\n        // current chunk don't have enough bytes so return true to get next Chunk if there is one.\n        return true;\n    })\n    .takeWhile(doContinue -> doContinue == true)\n    .then(Mono.defer(() -> {\n        if (contentType[0] != null) {\n            return Mono.just(contentType[0]);\n        } else {\n            return Mono.error(new RuntimeException(\"Content type could not be detected. \" +\n                \"Should use other overload API that takes content type.\"));\n        }\n    }));\n}\n\nprivate static boolean isJpeg(byte[] header) {\n    return (header[0] == (byte) 0xff && header[1] == (byte) 0xd8);\n}\n\nprivate static boolean isPdf(byte[] header) {\n    return header[0] == (byte) 0x25\n        && header[1] == (byte) 0x50\n        && header[2] == (byte) 0x44\n        && header[3] == (byte) 0x46;\n}\n\nprivate static boolean isPng(byte[] header) {\n   return header[0] == (byte) 0x89\n        &&  header[1] == (byte) 0x50\n        && header[2] == (byte) 0x4e\n        && header[3] == (byte) 0x47;\n}\n\nprivate static boolean isTiff(byte[] header) {\n    return (header[0] == (byte) 0x49\n        && header[1] == (byte) 0x49\n        && header[2] == (byte) 0x2a\n        && header[3] == (byte) 0x0)\n        // big-endian\n        || (header[0] == (byte) 0x4d\n        && header[1] == (byte) 0x4d\n        && header[2] == (byte) 0x0\n        && header[3] == (byte) 0x2a);\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412280864", "createdAt": "2020-04-21T15:21:35Z", "author": {"login": "anuchandy"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,14 +381,16 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        return pollingContext -> {\n             try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n-                        parseModelId(response.getDeserializedHeaders().getOperationLocation())));\n+                return data.next()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ff667d898746aae5195beac5a4f8cd0b918c06"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21da927a288bcb47cc817bc6cc23ee05fc2ce675", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21da927a288bcb47cc817bc6cc23ee05fc2ce675", "committedDate": "2020-04-21T17:22:05Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into FR-ContentType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eb1daa8001ad9a2ef47bf68439ebe458bfcdefc", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3eb1daa8001ad9a2ef47bf68439ebe458bfcdefc", "committedDate": "2020-04-21T18:04:20Z", "message": "changes method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236", "author": {"user": {"login": "mssfang", "name": "Shawn Fang"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236", "committedDate": "2020-04-21T19:25:03Z", "message": "final version"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjA4ODQ1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-397608845", "createdAt": "2020-04-21T19:27:00Z", "commit": {"oid": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Njk1NDQ1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-397695445", "createdAt": "2020-04-21T21:39:01Z", "commit": {"oid": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTozOTowMlrOGJZnKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTozOTowMlrOGJZnKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTk5NQ==", "bodyText": "This will throw an error that will cause the public async API to also throw an error. As per reactive guidelines, you should instead catch this exception in the public API method and return an error. See PagedFlux APIs for reference. You will have to do something similar for PollerFlux too.\nFile an issue for this and can be fixed post preview release.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412509995", "createdAt": "2020-04-21T21:39:02Z", "author": {"login": "srnagar"}, "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,16 +382,23 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n-                        parseModelId(response.getDeserializedHeaders().getOperationLocation())));\n-            } catch (RuntimeException ex) {\n-                return monoError(logger, ex);\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzAxOTc4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#pullrequestreview-397701978", "createdAt": "2020-04-21T21:51:01Z", "commit": {"oid": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1261, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}