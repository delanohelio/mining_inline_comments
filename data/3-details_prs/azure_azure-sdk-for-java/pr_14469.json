{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczNjUxODA4", "number": 14469, "title": "mgmt add azure-resourcemanager-eventhubs", "bodyText": "", "createdAt": "2020-08-26T05:17:20Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469", "merged": true, "mergeCommit": {"oid": "8880b04b0dea7f5d52fc5d6e7482d7fe7ef220d0"}, "closed": true, "closedAt": "2020-08-31T04:01:35Z", "author": {"login": "xseeseesee"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCP4hmAH2gAyNDczNjUxODA4OjljZWVlY2IwMTE5NmVlMzE4NTEyOGYxNzNmZGQ4NzNhYjFjNDg0MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdEJU7MAFqTQ3ODI3MTg2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9ceeecb01196ee3185128f173fdd873ab1c48426", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9ceeecb01196ee3185128f173fdd873ab1c48426", "committedDate": "2020-08-25T04:55:24Z", "message": "copy eventhubs code from azure-libraries-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12049a117a1b454542634162186510d6f759c0f2", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/12049a117a1b454542634162186510d6f759c0f2", "committedDate": "2020-08-25T05:08:41Z", "message": "rename package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dbf307e78b162c842bae370c6aedd38cac9c69c", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0dbf307e78b162c842bae370c6aedd38cac9c69c", "committedDate": "2020-08-25T05:13:07Z", "message": "update api-spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f17004b9af80af6ad7fdd362efeac5670f276fbc", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f17004b9af80af6ad7fdd362efeac5670f276fbc", "committedDate": "2020-08-25T05:15:48Z", "message": "generate eventhubs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/09dc56d15c874464185c45bb7ac306edf3457ed7", "committedDate": "2020-08-25T10:33:25Z", "message": "fix compile errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a16ab26a0e9a8f7986516f1d3b5d82ac62465a7", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4a16ab26a0e9a8f7986516f1d3b5d82ac62465a7", "committedDate": "2020-08-26T02:39:38Z", "message": "update session records"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1aa4ecd8f290faa8ec0cd111a47a9f6a63ba3a8", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f1aa4ecd8f290faa8ec0cd111a47a9f6a63ba3a8", "committedDate": "2020-08-26T03:31:06Z", "message": "update for storage changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caf0bacb859a20348cb3afe82f59d179de9090a5", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/caf0bacb859a20348cb3afe82f59d179de9090a5", "committedDate": "2020-08-26T03:31:49Z", "message": "update eventhubs in azure client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8", "committedDate": "2020-08-26T05:16:25Z", "message": "add samples for eventhubs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MTU4NjA0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-475158604", "createdAt": "2020-08-26T05:23:14Z", "commit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNToyMzoxNFrOHG8RHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNToyMzoxNFrOHG8RHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MDkyNg==", "bodyText": "Here we adopt com.microsoft.azure: azure-storage to com.azure: azure-storage-blob, comparing to previous code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477040926", "createdAt": "2020-08-26T05:23:14Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                    final String containerName) {\n+            return getBlobClientAsync(storageAccount)\n+                .flatMap(blobServiceAsyncClient -> blobServiceAsyncClient\n+                    .getBlobContainerAsyncClient(containerName)\n+                    .exists()\n+                    .flatMap(aBoolean -> {\n+                        if (aBoolean) {\n+                            return Mono.empty();\n+                        }\n+                        return blobServiceAsyncClient.getBlobContainerAsyncClient(containerName).create();\n+                    }));\n+        }\n+\n+        private Mono<BlobServiceAsyncClient> getBlobClientAsync(final StorageAccount storageAccount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "originalPosition": 497}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e7d6ba14af0bcbcaa302a189d0a16b41b354984", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e7d6ba14af0bcbcaa302a189d0a16b41b354984", "committedDate": "2020-08-26T05:43:26Z", "message": "update credcheck and session records"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0356ee79c0d6fad3cc12b4467a477d65f07e63f6", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0356ee79c0d6fad3cc12b4467a477d65f07e63f6", "committedDate": "2020-08-26T05:49:55Z", "message": "rename and reformat"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MTY3ODUz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-475167853", "createdAt": "2020-08-26T05:49:10Z", "commit": {"oid": "5e7d6ba14af0bcbcaa302a189d0a16b41b354984"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNTo0OToxMFrOHG8wGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjoxNToyMlrOHG9TkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0ODg1OA==", "bodyText": "Please copy another latest readme, which contains  For documentation on how to use this package, please see [Azure Management Libraries for Java](https://aka.ms/azure-sdk-java-mgmt).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477048858", "createdAt": "2020-08-26T05:49:10Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/README.md", "diffHunk": "@@ -0,0 +1,40 @@\n+# Azure Resource Manager EventHubs client library for Java\n+\n+Azure Resource Manager EventHubs client library for Java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7d6ba14af0bcbcaa302a189d0a16b41b354984"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzkzNg==", "bodyText": "Mgmt should be able to create a storage blob container?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477057936", "createdAt": "2020-08-26T06:15:22Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8"}, "originalPosition": 483}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33141d8d2fa25b031eb0a22481b65db069064316", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/33141d8d2fa25b031eb0a22481b65db069064316", "committedDate": "2020-08-26T07:12:23Z", "message": "rename EventHubManager to EventHubsManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/846bff2ed7a7ad2d7d77c92629586bd8ff048db4", "committedDate": "2020-08-26T08:01:10Z", "message": "remove azure-storage-blob"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MzA3NDgy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-475307482", "createdAt": "2020-08-26T09:19:12Z", "commit": {"oid": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOToxOToxMlrOHHDhqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOToxOToxMlrOHHDhqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1OTg1MA==", "bodyText": "blobContainer is a indexable, don't flatmap to void", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477159850", "createdAt": "2020-08-26T09:19:12Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -383,7 +383,7 @@ public CaptureSettings withNewStorageAccountForCapturedData(\n                     StorageAccount storageAccount = (StorageAccount) indexable;\n                     ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n                     return createContainerIfNotExistsAsync(storageAccount, containerName)\n-                        .flatMap(aVoid -> context.voidMono());\n+                        .flatMap(blobContainer -> context.voidMono());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ac97ba2bffe000bf59720c12f5b6dfb9d45fdf0", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ac97ba2bffe000bf59720c12f5b6dfb9d45fdf0", "committedDate": "2020-08-26T09:44:15Z", "message": "update indexable cast"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MzMyMzg4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-476332388", "createdAt": "2020-08-27T01:56:35Z", "commit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1NjozNVrOHHxNoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo1NzozOVrOHHxTbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwODM4NA==", "bodyText": "I think it better throws exception when else, due to it need such properties in request.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477908384", "createdAt": "2020-08-27T01:56:35Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "diffHunk": "@@ -70,10 +66,13 @@ public ProvisioningStateDR provisioningState() {\n     }\n \n     @Override\n-    public EventHubDisasterRecoveryPairingImpl withNewPrimaryNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+    public EventHubDisasterRecoveryPairingImpl withNewPrimaryNamespace(\n+        Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwODYwOQ==", "bodyText": "same as above", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477908609", "createdAt": "2020-08-27T01:56:45Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "diffHunk": "@@ -96,10 +96,13 @@ public EventHubDisasterRecoveryPairingImpl withExistingPrimaryNamespaceId(String\n     }\n \n     @Override\n-    public EventHubDisasterRecoveryPairingImpl withNewSecondaryNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+    public EventHubDisasterRecoveryPairingImpl withNewSecondaryNamespace(\n+        Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.inner().withPartnerNamespace(namespace.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.inner().withPartnerNamespace(namespace.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwOTg2OA==", "bodyText": "same as above", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477909868", "createdAt": "2020-08-27T01:57:39Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -153,8 +139,10 @@ public int messageRetentionPeriodInDays() {\n     @Override\n     public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0f0ac4106c27d4f8265b211c9c2df2761957fe98", "committedDate": "2020-08-27T04:38:09Z", "message": "throw illegal argument exception when casting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Mzg1MTI1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-476385125", "createdAt": "2020-08-27T04:57:20Z", "commit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNDo1NzoyMVrOHH-B8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNDo1NzoyMVrOHH-B8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODExODM4NA==", "bodyText": "@weidongxu-microsoft This is the main changes after migration. I apply azure-resourcemanager-storage for the scenario to create a container if not exists instead of using azure-storage/azure-storage-blob. The rest part keeps as it is.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478118384", "createdAt": "2020-08-27T04:57:21Z", "author": {"login": "xseeseesee"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName);\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName);\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Indexable> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                final String containerName) {\n+            return storageManager.blobContainers()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 483}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MzkxOTU5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-476391959", "createdAt": "2020-08-27T05:18:44Z", "commit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNToxODo0NFrOHH-3Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNToxODo0NFrOHH-3Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw==", "bodyText": "Please try test case which do both (NewSend and NewListen) in one Create/Update. I remember service not able to handle concurrent requests under eventhub, so these had to be done in sequence.\nAzure/azure-libraries-for-net#891", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478132043", "createdAt": "2020-08-27T05:18:44Z", "author": {"login": "weidongxu-microsoft"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98"}, "originalPosition": 245}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f62436201ae005669094c9a48c1a607a6d206eef", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f62436201ae005669094c9a48c1a607a6d206eef", "committedDate": "2020-08-27T06:13:04Z", "message": "support add both send and listen access"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/025514c54e6d2c4af3753e48063a5f9b46c6704f", "committedDate": "2020-08-28T06:42:05Z", "message": "concatenate post run tasks in eventhubs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1910ece9fcd65144d6eb98250d5d0c1c62a215b3", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1910ece9fcd65144d6eb98250d5d0c1c62a215b3", "committedDate": "2020-08-28T06:44:03Z", "message": "update credcheck and session records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MzcxMTE3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-477371117", "createdAt": "2020-08-28T07:20:35Z", "commit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMDozNVrOHIsbUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMDozNVrOHIsbUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3ODU0NA==", "bodyText": "postRunTasks = null;\nreturn Mono.empty();", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478878544", "createdAt": "2020-08-28T07:20:35Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -333,6 +340,15 @@ public void beforeGroupCreateOrUpdate() {\n                 .map(innerToFluentMap(this));\n     }\n \n+    @Override\n+    public Mono<Void> afterPostRunAsync(boolean isGroupFaulted) {\n+        return Mono.just(true)\n+            .map(aBoolean -> {\n+                postRunTasks = null;\n+                return aBoolean;\n+            }).then();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Mzc3Mzcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-477377372", "createdAt": "2020-08-28T07:22:21Z", "commit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMjoyMVrOHIseYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoyMjoyMVrOHIseYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3OTMzMQ==", "bodyText": "same above", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478879331", "createdAt": "2020-08-28T07:22:21Z", "author": {"login": "ChenTanyi"}, "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubNamespaceImpl.java", "diffHunk": "@@ -204,13 +210,29 @@ public EventHubNamespaceImpl withThroughputUnitsUpperLimit(int units) {\n         return this;\n     }\n \n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        if (postRunTasks != null) {\n+            addPostRunDependent(context -> postRunTasks.last());\n+        }\n+    }\n+\n     @Override\n     public Mono<EventHubNamespace> createResourceAsync() {\n         return this.manager().inner().getNamespaces()\n                 .createOrUpdateAsync(resourceGroupName(), name(), this.inner())\n                 .map(innerToFluentMap(this));\n     }\n \n+    @Override\n+    public Mono<Void> afterPostRunAsync(boolean isGroupFaulted) {\n+        return Mono.just(true)\n+            .map(aBoolean -> {\n+                postRunTasks = null;\n+                return aBoolean;\n+            }).then();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f"}, "originalPosition": 130}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a7c01b8ca1726588e2b4a9c78b22ce65d6fbc76", "author": {"user": {"login": "xseeseesee", "name": null}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a7c01b8ca1726588e2b4a9c78b22ce65d6fbc76", "committedDate": "2020-08-28T07:49:40Z", "message": "update test case after running credcheck"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MjcxODY1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#pullrequestreview-478271865", "createdAt": "2020-08-31T02:24:56Z", "commit": {"oid": "9a7c01b8ca1726588e2b4a9c78b22ce65d6fbc76"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 273, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}