{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1ODExNTk2", "number": 9689, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTozNDo1NFrODs3MDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjo0NzowOFrODs4apQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzY4MTQwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTozNDo1NVrOF99GDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTozNDo1NVrOF99GDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwODQzMA==", "bodyText": "should these comments actually be bufferedNext? I'm assuming you just renamed the variable and forgot to change the comments", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400508430", "createdAt": "2020-03-30T21:34:55Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {\n+                        this.bufferedNext = nextPath;\n+                        return true;\n+                    }\n+                } catch (IOException e) {\n+                    throw LoggingUtility.logError(logger, new DirectoryIteratorException(e));\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Path next() {\n+            if (this.bufferedNext == null) {\n+                if (!this.hasNext()) { // This will populate cachedNext in the process.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzcxMjMyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo0NDo0OFrOF99ZDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoyNjo1MFrOF_IqYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxMzI5Mg==", "bodyText": "is there a reason we can't just do this +next 3 lines once in the constructor for AzureDirectoryIterator?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400513292", "createdAt": "2020-03-30T21:44:48Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {\n+                        this.bufferedNext = nextPath;\n+                        return true;\n+                    }\n+                } catch (IOException e) {\n+                    throw LoggingUtility.logError(logger, new DirectoryIteratorException(e));\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Path next() {\n+            if (this.bufferedNext == null) {\n+                if (!this.hasNext()) { // This will populate cachedNext in the process.\n+                    throw LoggingUtility.logError(logger, new NoSuchElementException());\n+                }\n+            }\n+            Path next = this.bufferedNext; // cachedNext will have been populated by hasNext()\n+            this.bufferedNext = null;\n+            return next;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        private Path getNextListResult(BlobItem blobItem) {\n+            // Strip the root if it is present so we can relativize the list result, which never has a root.\n+            Path withoutRoot = this.path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NjUzMQ==", "bodyText": "Ooo probably. Save doing it every time. Good thought!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r401746531", "createdAt": "2020-04-01T16:26:50Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {\n+                        this.bufferedNext = nextPath;\n+                        return true;\n+                    }\n+                } catch (IOException e) {\n+                    throw LoggingUtility.logError(logger, new DirectoryIteratorException(e));\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Path next() {\n+            if (this.bufferedNext == null) {\n+                if (!this.hasNext()) { // This will populate cachedNext in the process.\n+                    throw LoggingUtility.logError(logger, new NoSuchElementException());\n+                }\n+            }\n+            Path next = this.bufferedNext; // cachedNext will have been populated by hasNext()\n+            this.bufferedNext = null;\n+            return next;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        private Path getNextListResult(BlobItem blobItem) {\n+            // Strip the root if it is present so we can relativize the list result, which never has a root.\n+            Path withoutRoot = this.path;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxMzI5Mg=="}, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzcyMzA4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo0ODozMlrOF99fvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoyNzowOVrOF_IrKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNTAwNA==", "bodyText": "Can we possibly swap all instances of NIOs DIR_METADATA_MARKER for the one in common? I just merged a PR today that added the constant for a datalake feature", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400515004", "createdAt": "2020-03-30T21:48:32Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureResource.java", "diffHunk": "@@ -34,10 +34,10 @@\n  * It also serves as the interface to Storage clients. Any operation that needs to use a client should first build an\n  * AzureResource using a path and then use the getter to access the client.\n  */\n-class AzureResource {\n+final class AzureResource {\n     private final ClientLogger logger = new ClientLogger(AzureResource.class);\n \n-    static final String DIR_METADATA_MARKER = \"is_hdi_folder\";\n+    static final String DIR_METADATA_MARKER = \"hdi_isfolder\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NjcyOQ==", "bodyText": "Definitely will do that.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r401746729", "createdAt": "2020-04-01T16:27:09Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureResource.java", "diffHunk": "@@ -34,10 +34,10 @@\n  * It also serves as the interface to Storage clients. Any operation that needs to use a client should first build an\n  * AzureResource using a path and then use the getter to access the client.\n  */\n-class AzureResource {\n+final class AzureResource {\n     private final ClientLogger logger = new ClientLogger(AzureResource.class);\n \n-    static final String DIR_METADATA_MARKER = \"is_hdi_folder\";\n+    static final String DIR_METADATA_MARKER = \"hdi_isfolder\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNTAwNA=="}, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzgzNzE1OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyOToyNFrOF9-luA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyOToyNFrOF9-luA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjkyMA==", "bodyText": "nit: an object is an instantiated class. I believe this comment describes class.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400532920", "createdAt": "2020-03-30T22:29:24Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Mzg1NDM2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjozNTo0M1rOF9-wJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoyODo0NlrOF_IvlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzNTU5MA==", "bodyText": "Files.newDirectoryStream throws NotDirectoryException if the file could not otherwise be opened because it is not a directory . Should we be consistent with that?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400535590", "createdAt": "2020-03-30T22:35:43Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0Nzg2MQ==", "bodyText": "It's listed as an optional specific exception, so I was going to save checking the status, but can make a call to ensure it's a directory.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r401747861", "createdAt": "2020-04-01T16:28:46Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzNTU5MA=="}, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Mzg3MjI0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjo0MzowMVrOF9-7VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjo0MzowMVrOF9-7VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzODQ1Mg==", "bodyText": "nit. should this be called !isDuplicate ? or something like that", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400538452", "createdAt": "2020-03-30T22:43:01Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureDirectoryStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.nio;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.models.BlobItem;\n+import com.azure.storage.blob.models.BlobListDetails;\n+import com.azure.storage.blob.models.ListBlobsOptions;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * An object for iterating the contents of a directory.\n+ *\n+ * This type does not validate that the given path is a directory; a listing call will be made against the given\n+ * resource in either case, and if the resource is a file, it will simply return 0 results (assuming there are no\n+ * other files that {@link AzurePath#startsWith(String) start with} the given path.\n+ *\n+ * This type is asynchronously closeable, i.e. closing the stream from any thread will cause the stream to stop\n+ * returning elements at that point.\n+ *\n+ * {@inheritDoc}\n+ */\n+public class AzureDirectoryStream implements DirectoryStream<Path> {\n+    private final ClientLogger logger = new ClientLogger(AzureDirectoryStream.class);\n+\n+    private final AzurePath path;\n+    private final DirectoryStream.Filter<? super Path> filter;\n+    private boolean iteratorRequested = false;\n+    private final AzureDirectoryIterator iterator;\n+    boolean closed = false;\n+\n+    AzureDirectoryStream(AzurePath path, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        this.path = path;\n+        this.filter = filter;\n+        this.iterator = new AzureDirectoryIterator(this, this.path, this.filter);\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        if (this.iteratorRequested) {\n+            throw LoggingUtility.logError(logger,\n+                new IllegalStateException(\"Only one iterator may be requested from a given directory stream\"));\n+        }\n+        this.iteratorRequested = true;\n+        return this.iterator;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.closed = true;\n+    }\n+\n+    private static class AzureDirectoryIterator implements Iterator<Path> {\n+        private final ClientLogger logger = new ClientLogger(AzureDirectoryIterator.class);\n+\n+        private final AzureDirectoryStream parentStream;\n+        private final DirectoryStream.Filter<? super Path> filter;\n+        private final Iterator<BlobItem> blobIterator;\n+        private final AzurePath path;\n+        private Path bufferedNext = null;\n+        private final Set<String> directoryPaths;\n+\n+        AzureDirectoryIterator(AzureDirectoryStream parentStream, AzurePath path,\n+            DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            this.parentStream = parentStream;\n+            this.filter = filter;\n+            this.path = path;\n+            directoryPaths = new HashSet<>();\n+\n+            BlobContainerClient containerClient;\n+            ListBlobsOptions listOptions = new ListBlobsOptions()\n+                .setDetails(new BlobListDetails().setRetrieveMetadata(true));\n+            if (path.isRoot()) {\n+                String containerName = path.toString().substring(0, path.toString().length() - 1);\n+                containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n+                    .getBlobContainerClient(containerName);\n+            } else {\n+                AzureResource azureResource = new AzureResource(path);\n+                listOptions.setPrefix(azureResource.getBlobClient().getBlobName() + AzureFileSystem.PATH_SEPARATOR);\n+                containerClient = azureResource.getContainerClient();\n+            }\n+            this.blobIterator = containerClient\n+                .listBlobsByHierarchy(AzureFileSystem.PATH_SEPARATOR, listOptions, null).iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            // Closing the parent stream halts iteration.\n+            if (parentStream.closed) {\n+                return false;\n+            }\n+\n+            // In case a customer calls hasNext multiple times in a row. If we've buffered an element, we have a next.\n+            if (this.bufferedNext != null) {\n+                return true;\n+            }\n+\n+            /*\n+            Search for a new element that passes the filter and buffer it when found. If no such element is found,\n+            return false.\n+             */\n+            while (this.blobIterator.hasNext()) {\n+                BlobItem nextBlob = this.blobIterator.next();\n+                Path nextPath = getNextListResult(nextBlob);\n+                try {\n+                    if (this.filter.accept(nextPath) && passesDirectoryDuplicateFilter(nextPath, nextBlob)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Mzg4MjYxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjo0NzowOFrOF9_B1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjo0NToyNlrOF_JaGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MDExOQ==", "bodyText": "limitation on path type should be mentioned in javadoc I think and what is expected if somebody passes something other than AzurePath.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r400540119", "createdAt": "2020-03-30T22:47:08Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -194,12 +193,18 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * Returns an {@link AzureDirectoryStream} for iterating over the contents of a directory.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public DirectoryStream<Path> newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)\n         throws IOException {\n-        return null;\n+        if (!(path instanceof AzurePath)) {\n+            throw LoggingUtility.logError(logger, new IllegalArgumentException(\"This provider cannot operate on \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1MzM4NA==", "bodyText": "So I've been doing this defensively just to be safe, but I don't think under normal circumstances paths usually get passed to providers other than their own. People usually work through the Files type, which gets the appropriate provider for the given path and then passes it to the method on the provider internally. To screw this up, someone would have to query for the provider themselves and make an explicit all.\nThe docs also aren't super clear to me on what the behavior should be if a path is used with a provider that is not its own. I suppose instead of asserting the right type, I could always just get the string representation of the path and construct an AzurePath from that. Thoughts?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r401753384", "createdAt": "2020-04-01T16:37:01Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -194,12 +193,18 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * Returns an {@link AzureDirectoryStream} for iterating over the contents of a directory.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public DirectoryStream<Path> newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)\n         throws IOException {\n-        return null;\n+        if (!(path instanceof AzurePath)) {\n+            throw LoggingUtility.logError(logger, new IllegalArgumentException(\"This provider cannot operate on \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MDExOQ=="}, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1ODc0Nw==", "bodyText": "I'm NOT questioning that validation. I'm just saying that we should have @throws section in javadoc for this method explaining that behavior - which is not obvious by just reading method signature (it promises to take any Path).\nWhether to keep validation or try to convert other Paths. I think going with validation is good start. It's easier to loosen it later than make it strict, so let's be strict and wait for feedback.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9689#discussion_r401758747", "createdAt": "2020-04-01T16:45:26Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -194,12 +193,18 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * Returns an {@link AzureDirectoryStream} for iterating over the contents of a directory.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public DirectoryStream<Path> newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)\n         throws IOException {\n-        return null;\n+        if (!(path instanceof AzurePath)) {\n+            throw LoggingUtility.logError(logger, new IllegalArgumentException(\"This provider cannot operate on \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MDExOQ=="}, "originalCommit": {"oid": "5c4c5dc9b2ea6e5307a773ed693be4fe9bd4684b"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2151, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}