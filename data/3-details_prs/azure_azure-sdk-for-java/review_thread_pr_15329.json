{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4ODM4NjAw", "number": 15329, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODowNDo0MlrOEkqaCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODozODoxN1rOEpl0yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODc4OTg0OnYy", "diffSide": "RIGHT", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchIndexingBufferedAsyncSender.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODowNDo0MlrOHTvETA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoxNDoyOFrOHbVy0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NjE0MA==", "bodyText": "Need to figure out how to pass generic information here cleanly. Currently, this has the issue where the type is erased at this point where T resolved to Object. .NET uses FieldBuilder functionality or retrieving the index from the Search service to generate an implicit documentKeyRetriever instead of explicitly requiring it to be configured all the time. So, either a Class<T> will need to be passed somewhere or Java will need to require explicit configuration of the documentKeyRetriever.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15329#discussion_r490456140", "createdAt": "2020-09-17T18:04:42Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchIndexingBufferedAsyncSender.java", "diffHunk": "@@ -15,66 +14,93 @@\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n+import java.lang.reflect.Type;\n import java.net.HttpURLConnection;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Timer;\n import java.util.TimerTask;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import static com.azure.core.util.FluxUtil.withContext;\n \n /**\n- * This class provides a client that contains operations for conveniently indexing documents to an Azure Search index.\n- *\n- * @see SearchBatchClientBuilder\n+ * This class provides a buffered sender that contains operations for conveniently indexing documents to an Azure Search\n+ * index.\n  */\n-public final class SearchBatchAsyncClient {\n-    private static final int DEFAULT_BATCH_SIZE = 1000;\n-    private static final long DEFAULT_FLUSH_WINDOW = TimeUnit.SECONDS.toMillis(60);\n-    private static final int TRY_LIMIT = 10;\n-\n+public final class SearchIndexingBufferedAsyncSender<T> {\n     private final SearchAsyncClient client;\n     private final boolean autoFlush;\n     private final long flushWindowMillis;\n     private final int batchSize;\n-    private final IndexingHook indexingHook;\n+    private final int documentTryLimit;\n+\n+    private final Consumer<IndexAction<T>> onActionAddedConsumer;\n+    private final Consumer<IndexAction<T>> onActionSucceededConsumer;\n+    private final BiConsumer<IndexAction<T>, Throwable> onActionErrorBiConsumer;\n+    private final Consumer<IndexAction<T>> onActionRemovedConsumer;\n+\n+    private final Function<T, String> documentKeyRetriever;\n+\n     private final Timer autoFlushTimer;\n \n-    private final Object actionsMutex = 0;\n-    private List<TryTrackingIndexAction> actions = new ArrayList<>();\n+    private final Object actionsMutex = new Object();\n+    private List<TryTrackingIndexAction<T>> actions = new ArrayList<>();\n \n     private final AtomicReference<TimerTask> flushTask = new AtomicReference<>();\n \n-    SearchBatchAsyncClient(SearchAsyncClient client, Boolean autoFlush, Duration flushWindow,\n-        Integer batchSize, IndexingHook indexingHook) {\n-        ClientLogger logger = new ClientLogger(SearchBatchAsyncClient.class);\n-\n-        if (batchSize != null && batchSize < 1) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"'batchSize' cannot be less than one.\"));\n-        }\n+    SearchIndexingBufferedAsyncSender(SearchAsyncClient client, SearchIndexingBufferedSenderOptions<T> options) {\n+        SearchIndexingBufferedSenderOptions<T> buildOptions = (options == null)\n+            ? new SearchIndexingBufferedSenderOptions<>()\n+            : options;\n \n         this.client = client;\n-        this.autoFlush = autoFlush == null || autoFlush;\n-\n-        if (flushWindow == null) {\n-            this.flushWindowMillis = DEFAULT_FLUSH_WINDOW;\n-        } else if (flushWindow.isZero() || flushWindow.isNegative()) {\n-            this.flushWindowMillis = 0;\n-        } else {\n-            this.flushWindowMillis = flushWindow.toMillis();\n-        }\n+        this.autoFlush = buildOptions.getAutoFlush();\n+        this.flushWindowMillis = Math.max(0, buildOptions.getFlushWindow().toMillis());\n+        this.batchSize = buildOptions.getBatchSize();\n+        this.documentTryLimit = buildOptions.getDocumentTryLimit();\n+\n+        this.onActionAddedConsumer = (action) -> {\n+            if (buildOptions.getOnActionAdded() != null) {\n+                buildOptions.getOnActionAdded().accept(action);\n+            }\n+        };\n+\n+        this.onActionSucceededConsumer = (action) -> {\n+            if (buildOptions.getOnActionSucceeded() != null) {\n+                buildOptions.getOnActionSucceeded().accept(action);\n+            }\n+        };\n+\n+        this.onActionErrorBiConsumer = (action, throwable) -> {\n+            if (buildOptions.getOnActionError() != null) {\n+                buildOptions.getOnActionError().accept(action, throwable);\n+            }\n+        };\n+\n+        this.onActionRemovedConsumer = (action) -> {\n+            if (buildOptions.getOnActionRemoved() != null) {\n+                buildOptions.getOnActionRemoved().accept(action);\n+            }\n+        };\n+\n+        this.documentKeyRetriever = (buildOptions.getDocumentKeyRetriever() != null)\n+            ? buildOptions.getDocumentKeyRetriever()\n+            : buildDocumentKeyRetriever(buildOptions.getClass().getGenericSuperclass());\n \n-        this.batchSize = (batchSize == null) ? DEFAULT_BATCH_SIZE : batchSize;\n-        this.indexingHook = indexingHook;\n         this.autoFlushTimer = (this.autoFlush) ? new Timer(true) : null;\n     }\n \n+    private Function<T, String> buildDocumentKeyRetriever(Type clazz) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e19dca240f3222238769328345178bfc8f86af"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1ODIxNA==", "bodyText": "@JonathanGiles @srnagar @tg-msft what are your thoughts on this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15329#discussion_r490458214", "createdAt": "2020-09-17T18:08:20Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchIndexingBufferedAsyncSender.java", "diffHunk": "@@ -15,66 +14,93 @@\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n+import java.lang.reflect.Type;\n import java.net.HttpURLConnection;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Timer;\n import java.util.TimerTask;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import static com.azure.core.util.FluxUtil.withContext;\n \n /**\n- * This class provides a client that contains operations for conveniently indexing documents to an Azure Search index.\n- *\n- * @see SearchBatchClientBuilder\n+ * This class provides a buffered sender that contains operations for conveniently indexing documents to an Azure Search\n+ * index.\n  */\n-public final class SearchBatchAsyncClient {\n-    private static final int DEFAULT_BATCH_SIZE = 1000;\n-    private static final long DEFAULT_FLUSH_WINDOW = TimeUnit.SECONDS.toMillis(60);\n-    private static final int TRY_LIMIT = 10;\n-\n+public final class SearchIndexingBufferedAsyncSender<T> {\n     private final SearchAsyncClient client;\n     private final boolean autoFlush;\n     private final long flushWindowMillis;\n     private final int batchSize;\n-    private final IndexingHook indexingHook;\n+    private final int documentTryLimit;\n+\n+    private final Consumer<IndexAction<T>> onActionAddedConsumer;\n+    private final Consumer<IndexAction<T>> onActionSucceededConsumer;\n+    private final BiConsumer<IndexAction<T>, Throwable> onActionErrorBiConsumer;\n+    private final Consumer<IndexAction<T>> onActionRemovedConsumer;\n+\n+    private final Function<T, String> documentKeyRetriever;\n+\n     private final Timer autoFlushTimer;\n \n-    private final Object actionsMutex = 0;\n-    private List<TryTrackingIndexAction> actions = new ArrayList<>();\n+    private final Object actionsMutex = new Object();\n+    private List<TryTrackingIndexAction<T>> actions = new ArrayList<>();\n \n     private final AtomicReference<TimerTask> flushTask = new AtomicReference<>();\n \n-    SearchBatchAsyncClient(SearchAsyncClient client, Boolean autoFlush, Duration flushWindow,\n-        Integer batchSize, IndexingHook indexingHook) {\n-        ClientLogger logger = new ClientLogger(SearchBatchAsyncClient.class);\n-\n-        if (batchSize != null && batchSize < 1) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"'batchSize' cannot be less than one.\"));\n-        }\n+    SearchIndexingBufferedAsyncSender(SearchAsyncClient client, SearchIndexingBufferedSenderOptions<T> options) {\n+        SearchIndexingBufferedSenderOptions<T> buildOptions = (options == null)\n+            ? new SearchIndexingBufferedSenderOptions<>()\n+            : options;\n \n         this.client = client;\n-        this.autoFlush = autoFlush == null || autoFlush;\n-\n-        if (flushWindow == null) {\n-            this.flushWindowMillis = DEFAULT_FLUSH_WINDOW;\n-        } else if (flushWindow.isZero() || flushWindow.isNegative()) {\n-            this.flushWindowMillis = 0;\n-        } else {\n-            this.flushWindowMillis = flushWindow.toMillis();\n-        }\n+        this.autoFlush = buildOptions.getAutoFlush();\n+        this.flushWindowMillis = Math.max(0, buildOptions.getFlushWindow().toMillis());\n+        this.batchSize = buildOptions.getBatchSize();\n+        this.documentTryLimit = buildOptions.getDocumentTryLimit();\n+\n+        this.onActionAddedConsumer = (action) -> {\n+            if (buildOptions.getOnActionAdded() != null) {\n+                buildOptions.getOnActionAdded().accept(action);\n+            }\n+        };\n+\n+        this.onActionSucceededConsumer = (action) -> {\n+            if (buildOptions.getOnActionSucceeded() != null) {\n+                buildOptions.getOnActionSucceeded().accept(action);\n+            }\n+        };\n+\n+        this.onActionErrorBiConsumer = (action, throwable) -> {\n+            if (buildOptions.getOnActionError() != null) {\n+                buildOptions.getOnActionError().accept(action, throwable);\n+            }\n+        };\n+\n+        this.onActionRemovedConsumer = (action) -> {\n+            if (buildOptions.getOnActionRemoved() != null) {\n+                buildOptions.getOnActionRemoved().accept(action);\n+            }\n+        };\n+\n+        this.documentKeyRetriever = (buildOptions.getDocumentKeyRetriever() != null)\n+            ? buildOptions.getDocumentKeyRetriever()\n+            : buildDocumentKeyRetriever(buildOptions.getClass().getGenericSuperclass());\n \n-        this.batchSize = (batchSize == null) ? DEFAULT_BATCH_SIZE : batchSize;\n-        this.indexingHook = indexingHook;\n         this.autoFlushTimer = (this.autoFlush) ? new Timer(true) : null;\n     }\n \n+    private Function<T, String> buildDocumentKeyRetriever(Type clazz) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NjE0MA=="}, "originalCommit": {"oid": "09e19dca240f3222238769328345178bfc8f86af"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMDY3NA==", "bodyText": "Given this will go out for another preview Java will be making this a required configuration.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15329#discussion_r498430674", "createdAt": "2020-10-01T18:14:28Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchIndexingBufferedAsyncSender.java", "diffHunk": "@@ -15,66 +14,93 @@\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n+import java.lang.reflect.Type;\n import java.net.HttpURLConnection;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Timer;\n import java.util.TimerTask;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import static com.azure.core.util.FluxUtil.withContext;\n \n /**\n- * This class provides a client that contains operations for conveniently indexing documents to an Azure Search index.\n- *\n- * @see SearchBatchClientBuilder\n+ * This class provides a buffered sender that contains operations for conveniently indexing documents to an Azure Search\n+ * index.\n  */\n-public final class SearchBatchAsyncClient {\n-    private static final int DEFAULT_BATCH_SIZE = 1000;\n-    private static final long DEFAULT_FLUSH_WINDOW = TimeUnit.SECONDS.toMillis(60);\n-    private static final int TRY_LIMIT = 10;\n-\n+public final class SearchIndexingBufferedAsyncSender<T> {\n     private final SearchAsyncClient client;\n     private final boolean autoFlush;\n     private final long flushWindowMillis;\n     private final int batchSize;\n-    private final IndexingHook indexingHook;\n+    private final int documentTryLimit;\n+\n+    private final Consumer<IndexAction<T>> onActionAddedConsumer;\n+    private final Consumer<IndexAction<T>> onActionSucceededConsumer;\n+    private final BiConsumer<IndexAction<T>, Throwable> onActionErrorBiConsumer;\n+    private final Consumer<IndexAction<T>> onActionRemovedConsumer;\n+\n+    private final Function<T, String> documentKeyRetriever;\n+\n     private final Timer autoFlushTimer;\n \n-    private final Object actionsMutex = 0;\n-    private List<TryTrackingIndexAction> actions = new ArrayList<>();\n+    private final Object actionsMutex = new Object();\n+    private List<TryTrackingIndexAction<T>> actions = new ArrayList<>();\n \n     private final AtomicReference<TimerTask> flushTask = new AtomicReference<>();\n \n-    SearchBatchAsyncClient(SearchAsyncClient client, Boolean autoFlush, Duration flushWindow,\n-        Integer batchSize, IndexingHook indexingHook) {\n-        ClientLogger logger = new ClientLogger(SearchBatchAsyncClient.class);\n-\n-        if (batchSize != null && batchSize < 1) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"'batchSize' cannot be less than one.\"));\n-        }\n+    SearchIndexingBufferedAsyncSender(SearchAsyncClient client, SearchIndexingBufferedSenderOptions<T> options) {\n+        SearchIndexingBufferedSenderOptions<T> buildOptions = (options == null)\n+            ? new SearchIndexingBufferedSenderOptions<>()\n+            : options;\n \n         this.client = client;\n-        this.autoFlush = autoFlush == null || autoFlush;\n-\n-        if (flushWindow == null) {\n-            this.flushWindowMillis = DEFAULT_FLUSH_WINDOW;\n-        } else if (flushWindow.isZero() || flushWindow.isNegative()) {\n-            this.flushWindowMillis = 0;\n-        } else {\n-            this.flushWindowMillis = flushWindow.toMillis();\n-        }\n+        this.autoFlush = buildOptions.getAutoFlush();\n+        this.flushWindowMillis = Math.max(0, buildOptions.getFlushWindow().toMillis());\n+        this.batchSize = buildOptions.getBatchSize();\n+        this.documentTryLimit = buildOptions.getDocumentTryLimit();\n+\n+        this.onActionAddedConsumer = (action) -> {\n+            if (buildOptions.getOnActionAdded() != null) {\n+                buildOptions.getOnActionAdded().accept(action);\n+            }\n+        };\n+\n+        this.onActionSucceededConsumer = (action) -> {\n+            if (buildOptions.getOnActionSucceeded() != null) {\n+                buildOptions.getOnActionSucceeded().accept(action);\n+            }\n+        };\n+\n+        this.onActionErrorBiConsumer = (action, throwable) -> {\n+            if (buildOptions.getOnActionError() != null) {\n+                buildOptions.getOnActionError().accept(action, throwable);\n+            }\n+        };\n+\n+        this.onActionRemovedConsumer = (action) -> {\n+            if (buildOptions.getOnActionRemoved() != null) {\n+                buildOptions.getOnActionRemoved().accept(action);\n+            }\n+        };\n+\n+        this.documentKeyRetriever = (buildOptions.getDocumentKeyRetriever() != null)\n+            ? buildOptions.getDocumentKeyRetriever()\n+            : buildDocumentKeyRetriever(buildOptions.getClass().getGenericSuperclass());\n \n-        this.batchSize = (batchSize == null) ? DEFAULT_BATCH_SIZE : batchSize;\n-        this.indexingHook = indexingHook;\n         this.autoFlushTimer = (this.autoFlush) ? new Timer(true) : null;\n     }\n \n+    private Function<T, String> buildDocumentKeyRetriever(Type clazz) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NjE0MA=="}, "originalCommit": {"oid": "09e19dca240f3222238769328345178bfc8f86af"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDQ2Nzk0OnYy", "diffSide": "RIGHT", "path": "sdk/search/azure-search-documents/src/test/resources/session-records/closingTwiceDoesNotThrow.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODozODoxN1rOHbWj_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOTowMjozN1rOHbXUFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ0MzI2MQ==", "bodyText": "NIT: do we need this record file?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15329#discussion_r498443261", "createdAt": "2020-10-01T18:38:17Z", "author": {"login": "mssfang"}, "path": "sdk/search/azure-search-documents/src/test/resources/session-records/closingTwiceDoesNotThrow.json", "diffHunk": "@@ -0,0 +1,4 @@\n+{\n+  \"networkCallRecords\" : [ ],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed88ae508f6611dadbdb93b1e189dc6b90e31a6"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1NTU3Mg==", "bodyText": "At this time, yes. This is an area we need to improve on for test recording. Without this empty data playback file the test will fail because its recorded data will be null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15329#discussion_r498455572", "createdAt": "2020-10-01T19:02:37Z", "author": {"login": "alzimmermsft"}, "path": "sdk/search/azure-search-documents/src/test/resources/session-records/closingTwiceDoesNotThrow.json", "diffHunk": "@@ -0,0 +1,4 @@\n+{\n+  \"networkCallRecords\" : [ ],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ0MzI2MQ=="}, "originalCommit": {"oid": "eed88ae508f6611dadbdb93b1e189dc6b90e31a6"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 935, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}