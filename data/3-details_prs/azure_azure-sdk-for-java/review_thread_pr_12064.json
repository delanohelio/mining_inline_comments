{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzcwODA5", "number": 12064, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzowMzoyMlrOEFITvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzowMzoyMlrOEFITvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODE0NDYwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzowMzoyMlrOGjLXgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzowNTo1NFrOGjLcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTU4NQ==", "bodyText": "blockSize is long now right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12064#discussion_r439539585", "createdAt": "2020-06-12T17:03:22Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -221,10 +228,111 @@ public InputStream newInputStream(Path path, OpenOption... options) throws IOExc\n                 + \"Path must point to a file. Path: \" + path.toString()));\n         }\n \n-        // Note that methods on BlobInputSTream are already synchronized.\n+        // Note that methods on BlobInputStream are already synchronized.\n         return new NioBlobInputStream(resource.getBlobClient().openInputStream());\n     }\n \n+    /**\n+     * Opens an {@link OutputStream} to the given path. The resulting file will be stored as a block blob.\n+     * <p>\n+     * The only supported options are {@link StandardOpenOption#CREATE}, {@link StandardOpenOption#CREATE_NEW},\n+     * {@link StandardOpenOption#WRITE}, {@link StandardOpenOption#TRUNCATE_EXISTING}. Any other options will throw an\n+     * {@link UnsupportedOperationException}. {@code WRITE} and {@code TRUNCATE_EXISTING} must be specified or an\n+     * {@link IllegalArgumentException} will be thrown. Hence, files cannot be updated, only overwritten completely.\n+     * <p>\n+     * This stream will not attempt to buffer the entire file, however some buffering will be done for potential\n+     * optimizations and to avoid network thrashing. Specifically, up to\n+     * {@link AzureFileSystem#AZURE_STORAGE_PUT_BLOB_THRESHOLD} bytes will be buffered initially. If that threshold is\n+     * exceeded, the data will be broken into chunks and sent in blocks, and writes will be buffered into sizes of\n+     * {@link AzureFileSystem#AZURE_STORAGE_UPLOAD_BLOCK_SIZE}. The maximum number of buffers of this size to be\n+     * allocated is defined by {@link AzureFileSystem#AZURE_STORAGE_MAX_CONCURRENCY_PER_REQUEST}, which also configures\n+     * the level of parallelism with which we may write and thus may affect write speeds as well.\n+     * <p>\n+     * The data is only committed when the steam is closed. Hence data cannot be read from the destination until the\n+     * stream is closed. When the close method returns, it is guaranteed that, barring any errors, the data is finalized\n+     * and available for reading.\n+     * <p>\n+     * Writing happens asynchronously. Bytes passed for writing are stored until either the threshold or block size are\n+     * met at which time they are sent to the service. When the write method returns, there is no guarantee about which\n+     * phase of this process the data is in other than it has been accepted and will be written. Again, closing will\n+     * guarantee that the data is written and available.\n+     * <p>\n+     * Flush is a no-op as regards data transfers, but it can be used to check the state of the stream for errors.\n+     * This can be a useful tool because writing happens asynchronously, and therefore an error from a previous write\n+     * may not otherwise be thrown unless the stream is flushed, closed, or written to again.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+        // If options are empty, add Create, Write, TruncateExisting as defaults per nio docs.\n+        if (options == null || options.length == 0) {\n+            options = new OpenOption[] {\n+                StandardOpenOption.CREATE,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.TRUNCATE_EXISTING };\n+        }\n+        List<OpenOption> optionsList = Arrays.asList(options);\n+\n+        // Check for unsupported options.\n+        List<OpenOption> supportedOptions = Arrays.asList(\n+            StandardOpenOption.CREATE_NEW,\n+            StandardOpenOption.CREATE,\n+            StandardOpenOption.WRITE,\n+            // Though we don't actually truncate, the same result is achieved by overwriting the destination.\n+            StandardOpenOption.TRUNCATE_EXISTING);\n+        for (OpenOption option : optionsList) {\n+            if (!supportedOptions.contains(option)) {\n+                throw new UnsupportedOperationException(\"Unsupported option: \" + option.toString());\n+            }\n+        }\n+\n+        // Write and truncate must be specified\n+        if (!optionsList.contains(StandardOpenOption.WRITE)\n+            || !optionsList.contains(StandardOpenOption.TRUNCATE_EXISTING)) {\n+            throw new IllegalArgumentException(\"Write and TruncateExisting must be specified to open an OutputStream\");\n+        }\n+\n+        AzureResource resource = new AzureResource(path);\n+        DirectoryStatus status = resource.checkDirStatus();\n+\n+        // Cannot write to a directory.\n+        if (DirectoryStatus.isDirectory(status)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Cannot open an OutputStream to a directory. Path: \"\n+                + path.toString()));\n+        }\n+\n+        // Writing to an empty location requires a create option.\n+        if (status.equals(DirectoryStatus.DOES_NOT_EXIST)\n+            && !(optionsList.contains(StandardOpenOption.CREATE)\n+            || optionsList.contains(StandardOpenOption.CREATE_NEW))) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Writing to an empty location requires a create \"\n+                + \"option. Path: \" + path.toString()));\n+        }\n+\n+        // Cannot write to an existing file if create new was specified.\n+        if (status.equals(DirectoryStatus.NOT_A_DIRECTORY) && optionsList.contains(StandardOpenOption.CREATE_NEW)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"A file already exists at this location and \"\n+                + \"CREATE_NEW was specified. Path: \" + path.toString()));\n+        }\n+\n+        // Create options based on file system config\n+        AzureFileSystem fs = (AzureFileSystem) (path.getFileSystem());\n+        Integer blockSize = fs.getBlockSize() == null ? null : fs.getBlockSize().intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c89b68727cc773a2f81ad6214e7b57f79c415686"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTk2Ng==", "bodyText": "Or is this on purpose due to constraints below?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12064#discussion_r439539966", "createdAt": "2020-06-12T17:04:02Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -221,10 +228,111 @@ public InputStream newInputStream(Path path, OpenOption... options) throws IOExc\n                 + \"Path must point to a file. Path: \" + path.toString()));\n         }\n \n-        // Note that methods on BlobInputSTream are already synchronized.\n+        // Note that methods on BlobInputStream are already synchronized.\n         return new NioBlobInputStream(resource.getBlobClient().openInputStream());\n     }\n \n+    /**\n+     * Opens an {@link OutputStream} to the given path. The resulting file will be stored as a block blob.\n+     * <p>\n+     * The only supported options are {@link StandardOpenOption#CREATE}, {@link StandardOpenOption#CREATE_NEW},\n+     * {@link StandardOpenOption#WRITE}, {@link StandardOpenOption#TRUNCATE_EXISTING}. Any other options will throw an\n+     * {@link UnsupportedOperationException}. {@code WRITE} and {@code TRUNCATE_EXISTING} must be specified or an\n+     * {@link IllegalArgumentException} will be thrown. Hence, files cannot be updated, only overwritten completely.\n+     * <p>\n+     * This stream will not attempt to buffer the entire file, however some buffering will be done for potential\n+     * optimizations and to avoid network thrashing. Specifically, up to\n+     * {@link AzureFileSystem#AZURE_STORAGE_PUT_BLOB_THRESHOLD} bytes will be buffered initially. If that threshold is\n+     * exceeded, the data will be broken into chunks and sent in blocks, and writes will be buffered into sizes of\n+     * {@link AzureFileSystem#AZURE_STORAGE_UPLOAD_BLOCK_SIZE}. The maximum number of buffers of this size to be\n+     * allocated is defined by {@link AzureFileSystem#AZURE_STORAGE_MAX_CONCURRENCY_PER_REQUEST}, which also configures\n+     * the level of parallelism with which we may write and thus may affect write speeds as well.\n+     * <p>\n+     * The data is only committed when the steam is closed. Hence data cannot be read from the destination until the\n+     * stream is closed. When the close method returns, it is guaranteed that, barring any errors, the data is finalized\n+     * and available for reading.\n+     * <p>\n+     * Writing happens asynchronously. Bytes passed for writing are stored until either the threshold or block size are\n+     * met at which time they are sent to the service. When the write method returns, there is no guarantee about which\n+     * phase of this process the data is in other than it has been accepted and will be written. Again, closing will\n+     * guarantee that the data is written and available.\n+     * <p>\n+     * Flush is a no-op as regards data transfers, but it can be used to check the state of the stream for errors.\n+     * This can be a useful tool because writing happens asynchronously, and therefore an error from a previous write\n+     * may not otherwise be thrown unless the stream is flushed, closed, or written to again.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+        // If options are empty, add Create, Write, TruncateExisting as defaults per nio docs.\n+        if (options == null || options.length == 0) {\n+            options = new OpenOption[] {\n+                StandardOpenOption.CREATE,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.TRUNCATE_EXISTING };\n+        }\n+        List<OpenOption> optionsList = Arrays.asList(options);\n+\n+        // Check for unsupported options.\n+        List<OpenOption> supportedOptions = Arrays.asList(\n+            StandardOpenOption.CREATE_NEW,\n+            StandardOpenOption.CREATE,\n+            StandardOpenOption.WRITE,\n+            // Though we don't actually truncate, the same result is achieved by overwriting the destination.\n+            StandardOpenOption.TRUNCATE_EXISTING);\n+        for (OpenOption option : optionsList) {\n+            if (!supportedOptions.contains(option)) {\n+                throw new UnsupportedOperationException(\"Unsupported option: \" + option.toString());\n+            }\n+        }\n+\n+        // Write and truncate must be specified\n+        if (!optionsList.contains(StandardOpenOption.WRITE)\n+            || !optionsList.contains(StandardOpenOption.TRUNCATE_EXISTING)) {\n+            throw new IllegalArgumentException(\"Write and TruncateExisting must be specified to open an OutputStream\");\n+        }\n+\n+        AzureResource resource = new AzureResource(path);\n+        DirectoryStatus status = resource.checkDirStatus();\n+\n+        // Cannot write to a directory.\n+        if (DirectoryStatus.isDirectory(status)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Cannot open an OutputStream to a directory. Path: \"\n+                + path.toString()));\n+        }\n+\n+        // Writing to an empty location requires a create option.\n+        if (status.equals(DirectoryStatus.DOES_NOT_EXIST)\n+            && !(optionsList.contains(StandardOpenOption.CREATE)\n+            || optionsList.contains(StandardOpenOption.CREATE_NEW))) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Writing to an empty location requires a create \"\n+                + \"option. Path: \" + path.toString()));\n+        }\n+\n+        // Cannot write to an existing file if create new was specified.\n+        if (status.equals(DirectoryStatus.NOT_A_DIRECTORY) && optionsList.contains(StandardOpenOption.CREATE_NEW)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"A file already exists at this location and \"\n+                + \"CREATE_NEW was specified. Path: \" + path.toString()));\n+        }\n+\n+        // Create options based on file system config\n+        AzureFileSystem fs = (AzureFileSystem) (path.getFileSystem());\n+        Integer blockSize = fs.getBlockSize() == null ? null : fs.getBlockSize().intValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTU4NQ=="}, "originalCommit": {"oid": "c89b68727cc773a2f81ad6214e7b57f79c415686"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MDgzMw==", "bodyText": "It's long in 73, which is why I made the config value a long in anticipation of that, but this branch doesn't have those updates yet, so I'll strike these conversions to int once all that gets merged in.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12064#discussion_r439540833", "createdAt": "2020-06-12T17:05:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -221,10 +228,111 @@ public InputStream newInputStream(Path path, OpenOption... options) throws IOExc\n                 + \"Path must point to a file. Path: \" + path.toString()));\n         }\n \n-        // Note that methods on BlobInputSTream are already synchronized.\n+        // Note that methods on BlobInputStream are already synchronized.\n         return new NioBlobInputStream(resource.getBlobClient().openInputStream());\n     }\n \n+    /**\n+     * Opens an {@link OutputStream} to the given path. The resulting file will be stored as a block blob.\n+     * <p>\n+     * The only supported options are {@link StandardOpenOption#CREATE}, {@link StandardOpenOption#CREATE_NEW},\n+     * {@link StandardOpenOption#WRITE}, {@link StandardOpenOption#TRUNCATE_EXISTING}. Any other options will throw an\n+     * {@link UnsupportedOperationException}. {@code WRITE} and {@code TRUNCATE_EXISTING} must be specified or an\n+     * {@link IllegalArgumentException} will be thrown. Hence, files cannot be updated, only overwritten completely.\n+     * <p>\n+     * This stream will not attempt to buffer the entire file, however some buffering will be done for potential\n+     * optimizations and to avoid network thrashing. Specifically, up to\n+     * {@link AzureFileSystem#AZURE_STORAGE_PUT_BLOB_THRESHOLD} bytes will be buffered initially. If that threshold is\n+     * exceeded, the data will be broken into chunks and sent in blocks, and writes will be buffered into sizes of\n+     * {@link AzureFileSystem#AZURE_STORAGE_UPLOAD_BLOCK_SIZE}. The maximum number of buffers of this size to be\n+     * allocated is defined by {@link AzureFileSystem#AZURE_STORAGE_MAX_CONCURRENCY_PER_REQUEST}, which also configures\n+     * the level of parallelism with which we may write and thus may affect write speeds as well.\n+     * <p>\n+     * The data is only committed when the steam is closed. Hence data cannot be read from the destination until the\n+     * stream is closed. When the close method returns, it is guaranteed that, barring any errors, the data is finalized\n+     * and available for reading.\n+     * <p>\n+     * Writing happens asynchronously. Bytes passed for writing are stored until either the threshold or block size are\n+     * met at which time they are sent to the service. When the write method returns, there is no guarantee about which\n+     * phase of this process the data is in other than it has been accepted and will be written. Again, closing will\n+     * guarantee that the data is written and available.\n+     * <p>\n+     * Flush is a no-op as regards data transfers, but it can be used to check the state of the stream for errors.\n+     * This can be a useful tool because writing happens asynchronously, and therefore an error from a previous write\n+     * may not otherwise be thrown unless the stream is flushed, closed, or written to again.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+        // If options are empty, add Create, Write, TruncateExisting as defaults per nio docs.\n+        if (options == null || options.length == 0) {\n+            options = new OpenOption[] {\n+                StandardOpenOption.CREATE,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.TRUNCATE_EXISTING };\n+        }\n+        List<OpenOption> optionsList = Arrays.asList(options);\n+\n+        // Check for unsupported options.\n+        List<OpenOption> supportedOptions = Arrays.asList(\n+            StandardOpenOption.CREATE_NEW,\n+            StandardOpenOption.CREATE,\n+            StandardOpenOption.WRITE,\n+            // Though we don't actually truncate, the same result is achieved by overwriting the destination.\n+            StandardOpenOption.TRUNCATE_EXISTING);\n+        for (OpenOption option : optionsList) {\n+            if (!supportedOptions.contains(option)) {\n+                throw new UnsupportedOperationException(\"Unsupported option: \" + option.toString());\n+            }\n+        }\n+\n+        // Write and truncate must be specified\n+        if (!optionsList.contains(StandardOpenOption.WRITE)\n+            || !optionsList.contains(StandardOpenOption.TRUNCATE_EXISTING)) {\n+            throw new IllegalArgumentException(\"Write and TruncateExisting must be specified to open an OutputStream\");\n+        }\n+\n+        AzureResource resource = new AzureResource(path);\n+        DirectoryStatus status = resource.checkDirStatus();\n+\n+        // Cannot write to a directory.\n+        if (DirectoryStatus.isDirectory(status)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Cannot open an OutputStream to a directory. Path: \"\n+                + path.toString()));\n+        }\n+\n+        // Writing to an empty location requires a create option.\n+        if (status.equals(DirectoryStatus.DOES_NOT_EXIST)\n+            && !(optionsList.contains(StandardOpenOption.CREATE)\n+            || optionsList.contains(StandardOpenOption.CREATE_NEW))) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Writing to an empty location requires a create \"\n+                + \"option. Path: \" + path.toString()));\n+        }\n+\n+        // Cannot write to an existing file if create new was specified.\n+        if (status.equals(DirectoryStatus.NOT_A_DIRECTORY) && optionsList.contains(StandardOpenOption.CREATE_NEW)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"A file already exists at this location and \"\n+                + \"CREATE_NEW was specified. Path: \" + path.toString()));\n+        }\n+\n+        // Create options based on file system config\n+        AzureFileSystem fs = (AzureFileSystem) (path.getFileSystem());\n+        Integer blockSize = fs.getBlockSize() == null ? null : fs.getBlockSize().intValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTU4NQ=="}, "originalCommit": {"oid": "c89b68727cc773a2f81ad6214e7b57f79c415686"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3943, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}