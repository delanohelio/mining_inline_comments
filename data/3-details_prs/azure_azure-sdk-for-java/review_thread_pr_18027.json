{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NzY3NDQw", "number": 18027, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoyNjo0NVrOFCoHVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMTowOTowM1rOFUUPBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Mjk4NzA4OnYy", "diffSide": "RIGHT", "path": "eng/versioning/version_client.txt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoyNjo0NVrOIB5FTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoyOTozNFrOIB5LuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NDczNA==", "bodyText": "can we remove this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538854734", "createdAt": "2020-12-08T22:26:45Z", "author": {"login": "conniey"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -177,6 +177,7 @@ com.microsoft:microsoft-opentelemetry-exporter-azuremonitor;1.0.0-beta.1;1.0.0-b\n # unreleased_<groupId>:<artifactId>;dependency-version\n # note: The unreleased dependencies will not be manipulated with the automatic PR creation code.\n unreleased_com.azure:azure-messaging-servicebus;7.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NjM3Nw==", "bodyText": "We should as this has been released", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538856377", "createdAt": "2020-12-08T22:29:34Z", "author": {"login": "alzimmermsft"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -177,6 +177,7 @@ com.microsoft:microsoft-opentelemetry-exporter-azuremonitor;1.0.0-beta.1;1.0.0-b\n # unreleased_<groupId>:<artifactId>;dependency-version\n # note: The unreleased dependencies will not be manipulated with the automatic PR creation code.\n unreleased_com.azure:azure-messaging-servicebus;7.0.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NDczNA=="}, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzAxNTc3OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozNDowNFrOIB5VOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzo1OTo0OVrOICiD4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1ODgwOA==", "bodyText": "This change is happening because we want to run the connectionMono and activeEndpointState publishers concurrently?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538858808", "createdAt": "2020-12-08T22:34:04Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -138,12 +138,11 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n                 \"connectionId[%s]: Connection is disposed. Cannot get CBS node.\", connectionId))));\n         }\n \n-        final Mono<ClaimsBasedSecurityNode> cbsNodeMono =\n-            RetryUtil.withRetry(getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE),\n-                connectionOptions.getRetry().getTryTimeout(), retryPolicy)\n-            .then(Mono.fromCallable(this::getOrCreateCBSNode));\n+        final Flux<AmqpEndpointState> activeEndpointState = RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE), connectionOptions.getRetry(),\n+            \"ReactorConnection: Retries exhausted waiting for ACTIVE endpoint state on CBS node.\");\n \n-        return connectionMono.then(cbsNodeMono);\n+        return Mono.when(connectionMono, activeEndpointState).then(Mono.fromCallable(() -> getOrCreateCBSNode()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjExMg==", "bodyText": "Yes. It is. When I first wrote this code, I thought it had to sequential but it doesn't. :)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r539526112", "createdAt": "2020-12-09T17:59:49Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -138,12 +138,11 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n                 \"connectionId[%s]: Connection is disposed. Cannot get CBS node.\", connectionId))));\n         }\n \n-        final Mono<ClaimsBasedSecurityNode> cbsNodeMono =\n-            RetryUtil.withRetry(getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE),\n-                connectionOptions.getRetry().getTryTimeout(), retryPolicy)\n-            .then(Mono.fromCallable(this::getOrCreateCBSNode));\n+        final Flux<AmqpEndpointState> activeEndpointState = RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE), connectionOptions.getRetry(),\n+            \"ReactorConnection: Retries exhausted waiting for ACTIVE endpoint state on CBS node.\");\n \n-        return connectionMono.then(cbsNodeMono);\n+        return Mono.when(connectionMono, activeEndpointState).then(Mono.fromCallable(() -> getOrCreateCBSNode()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1ODgwOA=="}, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzAzMTk4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozODoxMFrOIB5d1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozODoxMFrOIB5d1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MTAxNA==", "bodyText": "Is this needed? Looks like we are just assigning a constant to a local constant", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538861014", "createdAt": "2020-12-08T22:38:10Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -228,108 +228,25 @@ public boolean removeLink(String linkName) {\n             return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n                 \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n         }\n-        TransactionCoordinator existing = transactionCoordinator.get();\n+\n+        final TransactionCoordinator existing = transactionCoordinator.get();\n         if (existing != null) {\n             logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n             return Mono.just(existing);\n         }\n \n-        return createCoordinatorSendLink(openTimeout, retryPolicy)\n-            .map(sendLink -> {\n-                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+        final String linkName = TRANSACTION_LINK_NAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzA0Njg0OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0MjoyN1rOIB5mOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODowMDowOVrOICiExA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzE2Mg==", "bodyText": "I've been seeing this pattern in a lot of locations, do we want to centralize it anywhere?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538863162", "createdAt": "2020-12-08T22:42:27Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -563,6 +507,30 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n         return new LinkSubscription<>(reactorReceiver, subscription);\n     }\n \n+    /**\n+     * Asynchronously waits for the session's active endpoint state.\n+     *\n+     * @return A mono that completes when the session is active.\n+     */\n+    private Mono<Void> onActiveEndpoint() {\n+        return RetryUtil.withRetry(getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjM0MA==", "bodyText": "I don't think this is required to be centralised.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r539526340", "createdAt": "2020-12-09T18:00:09Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -563,6 +507,30 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n         return new LinkSubscription<>(reactorReceiver, subscription);\n     }\n \n+    /**\n+     * Asynchronously waits for the session's active endpoint state.\n+     *\n+     * @return A mono that completes when the session is active.\n+     */\n+    private Mono<Void> onActiveEndpoint() {\n+        return RetryUtil.withRetry(getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzE2Mg=="}, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzA1NDI1OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0NDozMlrOIB5qQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTozMzozNVrOIanUzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NDE5NA==", "bodyText": "Does the AMQP response contain any information on backoff when the server is busy and this is a best approximation default?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538864194", "createdAt": "2020-12-08T22:44:32Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -22,6 +22,10 @@\n  * Helper class to help with retry policies.\n  */\n public class RetryUtil {\n+    private static final double JITTER_FACTOR = 0.08;\n+    // Base sleep wait time.\n+    private static final Duration SERVER_BUSY_WAIT_TIME = Duration.ofSeconds(4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc3ODE4OQ==", "bodyText": "Yes", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564778189", "createdAt": "2021-01-26T19:33:35Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -22,6 +22,10 @@\n  * Helper class to help with retry policies.\n  */\n public class RetryUtil {\n+    private static final double JITTER_FACTOR = 0.08;\n+    // Base sleep wait time.\n+    private static final Duration SERVER_BUSY_WAIT_TIME = Duration.ofSeconds(4);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NDE5NA=="}, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzA2MTAyOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0NjoyOVrOIB5uDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo0NzoxMVrOICowIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NTE2Nw==", "bodyText": "When there is no delay we won't attempt retries? Would we want this instead?\nreturn Retry.max(options.getMaxRetries());", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538865167", "createdAt": "2020-12-08T22:46:29Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNTc0NA==", "bodyText": "Yes, that is already covered in general. But part of the existing logic was if the Duration was 0, we'd also not try again.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r539635744", "createdAt": "2020-12-09T20:47:11Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NTE2Nw=="}, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzA3MDY2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0OTowNVrOIB5zlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0OTowNVrOIB5zlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NjU4MQ==", "bodyText": "nit: Mind adding parentheses around the && block for easier reading", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538866581", "createdAt": "2020-12-08T22:49:05Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);\n+        }\n \n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else {\n-                    LOGGER.warning(\"Error is not a TimeoutException nor is it a retryable AMQP exception.\", error);\n+        final Duration delay = options.getDelay().plus(SERVER_BUSY_WAIT_TIME);\n+        final RetryBackoffSpec retrySpec;\n+        switch (options.getMode()) {\n+            case FIXED:\n+                retrySpec = Retry.fixedDelay(options.getMaxRetries(), delay);\n+                break;\n+            case EXPONENTIAL:\n+                retrySpec = Retry.backoff(options.getMaxRetries(), delay);\n+                break;\n+            default:\n+                LOGGER.warning(\"Unknown: '{}'. Using exponential delay. Delay: {}. Max Delay: {}. Max Retries: {}.\",\n+                    options.getMode(), options.getDelay(), options.getMaxDelay(), options.getMaxRetries());\n+                retrySpec = Retry.backoff(options.getMaxRetries(), delay);\n+                break;\n+        }\n \n-                    throw Exceptions.propagate(error);\n-                }\n-            })\n-            .flatMap(Mono::delay);\n+        return retrySpec.jitter(JITTER_FACTOR)\n+            .maxBackoff(options.getMaxDelay())\n+            .filter(error -> error instanceof TimeoutException\n+                || error instanceof AmqpException && ((AmqpException) error).isTransient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NzMwNjUwOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTozODo1N1rOIani0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQyMDo0Mzo0M1rOIap3kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4MTc3Ng==", "bodyText": "Would changing this to a Mono.error return be a breaking change? Or does something further up the stack handle converting this into a Mono.error?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564781776", "createdAt": "2021-01-26T19:38:57Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "diffHunk": "@@ -155,7 +162,8 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n                 receiveLink.open();\n             });\n         } catch (IOException e) {\n-            throw logger.logExceptionAsError(new RuntimeException(\"Unable to open send and receive link.\", e));\n+            throw logger.logExceptionAsError(new RuntimeException(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxOTg1OQ==", "bodyText": "This occurs in the constructor for RequestResponseChannel. It wouldn't be able to return a Mono.error.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564819859", "createdAt": "2021-01-26T20:43:43Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "diffHunk": "@@ -155,7 +162,8 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n                 receiveLink.open();\n             });\n         } catch (IOException e) {\n-            throw logger.logExceptionAsError(new RuntimeException(\"Unable to open send and receive link.\", e));\n+            throw logger.logExceptionAsError(new RuntimeException(String.format(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4MTc3Ng=="}, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NzM0Nzk4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTo0OTo1MFrOIan73g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQyMDo1MzozNVrOIaqNcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA==", "bodyText": "This is for a larger discussion\nShould we guard timeouts on timeout periods that are zero or negative? Timeout schedules a task on the parallel scheduler by default to propagate an exception if it runs before an emission is made from the reactive stream. From this could an instantly scheduled exception operation result in side affect/unexpected behavior?\ncc: @srnagar @JonathanGiles", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564788190", "createdAt": "2021-01-26T19:49:50Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgwNzYwMw==", "bodyText": "Timeout periods that are zero or negative are invalid inputs and should be validated when it's set. If the timeout is null then we should use a default (if applicable) or never timeout.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564807603", "createdAt": "2021-01-26T20:22:10Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA=="}, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyNTQ1Nw==", "bodyText": "In our existing logic for AmqpRetryOptions, if the duration is zero, then we don't retry at all. But negative is invalid.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564825457", "createdAt": "2021-01-26T20:53:35Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA=="}, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NzM1MzE1OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTo1MTowN1rOIan-6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTo1MTowN1rOIan-6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODk2OA==", "bodyText": "Based on the previous topic of no delay or zero delay resulting in no retrying, should we also check if the delay is negative?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564788968", "createdAt": "2021-01-26T19:51:07Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())\n+            .retryWhen(createRetry(retryOptions))\n+            .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())\n+            .retryWhen(createRetry(retryOptions))\n+            .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2ODI5MzQzOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMzo1MzowNVrOIcPm0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMzo1MzowNVrOIcPm0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ4NjczOQ==", "bodyText": "Removing duplicated code for creating a transaction link.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566486739", "createdAt": "2021-01-28T23:53:05Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -228,108 +228,25 @@ public boolean removeLink(String linkName) {\n             return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n                 \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n         }\n-        TransactionCoordinator existing = transactionCoordinator.get();\n+\n+        final TransactionCoordinator existing = transactionCoordinator.get();\n         if (existing != null) {\n             logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n             return Mono.just(existing);\n         }\n \n-        return createCoordinatorSendLink(openTimeout, retryPolicy)\n-            .map(sendLink -> {\n-                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+        return createProducer(TRANSACTION_LINK_NAME, TRANSACTION_LINK_NAME, new Coordinator(), retryOptions, null,\n+            false)\n+            .map(link -> {\n+                final TransactionCoordinator newCoordinator = new TransactionCoordinator(link, messageSerializer);\n                 if (transactionCoordinator.compareAndSet(null, newCoordinator)) {\n-                    logger.info(\"Coordinator[{}]: Created transaction coordinator.\", TRANSACTION_LINK_NAME);\n+                    return newCoordinator;\n                 } else {\n-                    logger.info(\"linkName[{}]: Another transaction coordinator exists.\", TRANSACTION_LINK_NAME);\n+                    return transactionCoordinator.get();\n                 }\n-                return transactionCoordinator.get();\n             });\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2595a4bebdbac99d4d0fa47d55d4280707a37495"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2ODQyMjUwOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMDo0NzowN1rOIcQxMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMDo0NzowN1rOIcQxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUwNTc3Nw==", "bodyText": "Check for isZero() as well and update the javadoc, error message.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566505777", "createdAt": "2021-01-29T00:47:07Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "diffHunk": "@@ -72,8 +82,15 @@ public AmqpRetryOptions setMaxRetries(int numberOfRetries) {\n      *\n      * @param delay The delay between retry attempts.\n      * @return The updated {@link AmqpRetryOptions} object.\n+     * @throws NullPointerException When {@code delay} is null.\n+     * @throws IllegalArgumentException When {@code delay} is negative.\n      */\n     public AmqpRetryOptions setDelay(Duration delay) {\n+        Objects.requireNonNull(delay, \"'delay' cannot be null.\");\n+        if (delay.isNegative()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2ODQyMzM2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMDo0NzozMFrOIcQxtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMDo0NzozMFrOIcQxtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUwNTkwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IllegalArgumentException When {@code maximumDelay} is negative.\n          \n          \n            \n                 * @throws IllegalArgumentException When {@code maximumDelay} is negative or zero.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566505908", "createdAt": "2021-01-29T00:47:30Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "diffHunk": "@@ -94,8 +119,16 @@ public AmqpRetryOptions setMaxDelay(Duration maximumDelay) {\n      *\n      * @param tryTimeout The maximum duration to wait for completion.\n      * @return The updated {@link AmqpRetryOptions} object.\n+     *\n+     * @throws NullPointerException When {@code maximumDelay} is null.\n+     * @throws IllegalArgumentException When {@code maximumDelay} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2ODQ1NTQ4OnYy", "diffSide": "LEFT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AzureTokenManagerProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMTowMToxNVrOIcREUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMTowMToxNVrOIcREUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMDY3NQ==", "bodyText": "Log at debug level instead of deleting this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566510675", "createdAt": "2021-01-29T01:01:15Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AzureTokenManagerProvider.java", "diffHunk": "@@ -46,8 +46,6 @@ public AzureTokenManagerProvider(CbsAuthorizationType authorizationType, String\n     public TokenManager getTokenManager(Mono<ClaimsBasedSecurityNode> cbsNodeMono, String resource) {\n         final String scopes = getScopesFromResource(resource);\n         final String tokenAudience = String.format(Locale.US, TOKEN_AUDIENCE_FORMAT, fullyQualifiedNamespace, resource);\n-\n-        logger.info(\"Creating new token manager for audience[{}], resource[{}]\", tokenAudience, resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2ODQ3MzY0OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMTowOTowM1rOIcROxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxOToxMjozNlrOIdwduw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMzM1MQ==", "bodyText": "So, we no longer need retries for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566513351", "createdAt": "2021-01-29T01:09:03Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -368,34 +285,32 @@ public boolean removeLink(String linkName) {\n         }\n \n         final TokenManager tokenManager = tokenManagerProvider.getTokenManager(cbsNodeSupplier, entityPath);\n-        return RetryUtil.withRetry(\n-            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE), timeout, retry)\n-            .then(tokenManager.authorize().then(Mono.create(sink -> {\n-                try {\n-                    // This has to be executed using reactor dispatcher because it's possible to run into race\n-                    // conditions with proton-j.\n-                    provider.getReactorDispatcher().invoke(() -> {\n-                        final LinkSubscription<AmqpReceiveLink> computed = openReceiveLinks.compute(linkName,\n-                            (linkNameKey, existing) -> {\n-                                if (existing != null) {\n-                                    logger.info(\"linkName[{}]: Another receive link exists. Disposing of new one.\",\n-                                        linkName);\n-                                    tokenManager.close();\n-\n-                                    return existing;\n-                                }\n-\n-                                logger.info(\"Creating a new receiver link with linkName {}\", linkName);\n-                                return getSubscription(linkNameKey, entityPath, sourceFilters, receiverProperties,\n-                                    receiverDesiredCapabilities, senderSettleMode, receiverSettleMode, tokenManager);\n-                            });\n-\n-                        sink.success(computed.getLink());\n-                    });\n-                } catch (IOException e) {\n-                    sink.error(e);\n-                }\n-            })));\n+        return Mono.when(onActiveEndpoint(), tokenManager.authorize()).then(Mono.create(sink -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODA3MzY1OQ==", "bodyText": "The onActiveEndpoint() method uses retries.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r568073659", "createdAt": "2021-02-01T19:12:36Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -368,34 +285,32 @@ public boolean removeLink(String linkName) {\n         }\n \n         final TokenManager tokenManager = tokenManagerProvider.getTokenManager(cbsNodeSupplier, entityPath);\n-        return RetryUtil.withRetry(\n-            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE), timeout, retry)\n-            .then(tokenManager.authorize().then(Mono.create(sink -> {\n-                try {\n-                    // This has to be executed using reactor dispatcher because it's possible to run into race\n-                    // conditions with proton-j.\n-                    provider.getReactorDispatcher().invoke(() -> {\n-                        final LinkSubscription<AmqpReceiveLink> computed = openReceiveLinks.compute(linkName,\n-                            (linkNameKey, existing) -> {\n-                                if (existing != null) {\n-                                    logger.info(\"linkName[{}]: Another receive link exists. Disposing of new one.\",\n-                                        linkName);\n-                                    tokenManager.close();\n-\n-                                    return existing;\n-                                }\n-\n-                                logger.info(\"Creating a new receiver link with linkName {}\", linkName);\n-                                return getSubscription(linkNameKey, entityPath, sourceFilters, receiverProperties,\n-                                    receiverDesiredCapabilities, senderSettleMode, receiverSettleMode, tokenManager);\n-                            });\n-\n-                        sink.success(computed.getLink());\n-                    });\n-                } catch (IOException e) {\n-                    sink.error(e);\n-                }\n-            })));\n+        return Mono.when(onActiveEndpoint(), tokenManager.authorize()).then(Mono.create(sink -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMzM1MQ=="}, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 224}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2672, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}