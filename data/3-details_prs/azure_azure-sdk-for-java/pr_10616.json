{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMDkzMzE2", "number": 10616, "title": "Direct TCP | Address socket leak", "bodyText": "PR is ready for review with these TODOs before we merge.\n\n\nGet a pass or address test failures documented below.\nSee analysis of current test failures.\n\n\nComplete customer ready JMH test runs on 4 and 8 proc containers.\nComparative JMH test runs were completed here were run on a Standard F16s_v2 (16 vcpus, 32 GiB memory) VM.\n\n\nTable of contents\n\nAzure:master vs David-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization\n\nConcurrency: 16\nConcurrency: 32\nConcurrency: 64\nConcurrency: 128\nConcurrency: 256\nConcurrency: 512\nConcurrency: 1024\nConcurrency: 2048\n\n\nPerformance\n\nThroughput\nLatency\n\n\n\n\nSocket utilization in development environments with this change in place\n\nmacOS\nWindows\n\n\nOther issues addressed while creating this PR\nAnalysis of current test failures\n\nAzure:master vs. David-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak #\nAnecdotal evidence had suggested that socket leaks were more likely to occur in development environments than production environments. The systematic study presented here shows that socket leaks will occur in a production environments like this one as well:\n{\n    \"client\": \"Linux appserver-lin-3 5.0.0-1036-azure #38-Ubuntu SMP Sun Mar 22 21:27:21 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\",\n    \"vmSize\": \"Standard F16s_v2 (16 vcpus, 32 GiB memory)\",\n    \"javaVersion\": \"openjdk version 1.8.0_252 (Zulu)\",\n    \"benchmark\": \"ReadLatency\",\n    \"consistencyLevel\": \"Eventual\",\n    \"concurrency\": [16, 32, 64, 128, 256, 1024, 2048],\n    \"documentCount\": [1, 100000],\n    \"operationCount\": \"50,000,000\"\n}\nThis PR corrects this issue. Here we show that at concurrencies between 16 and 2048 the value of maxChannels is respected and--consequently--there are no socket leaks. At concurrency levels at or above 256 we observe some performance degradation. Reviewers will see that performance differences could be the result of maxing out on channels. At a concurrency of 2048, for example, reviewers will note that channel utilization is at 100% with 10 channels allocated for each endpoint. The result is a difference in performance of around 5-6% as well as an increase in average latency. Warmup times might also have increased a little, though we did not specifically measure it. (Hypothesis: Additional connections are now guaranteed to be opened one at a time and this increases our warmup time.)\nAll of this indicates that performance tuning using RntbdTransportClient.Options may be a fruitful next step in RntbdTransportClient performance work. We might specifically run a set of experiments designed to measure the performance/latency curves for select values of:\n\nmaxChannels\nmaxRequestsPerChannel\nthreadCount, a new option doubled from its fixed value to 2 * processor-count in this PR.\n\nSuch experiments would be a good segue into work on developing option profiles suited to specific workloads (e.g., read, write, query, or mixed at specific concurrency levels). Customers could then make tradeoffs between Cosmos client performance and Cosmos client resource consumption (CPU, Memory, and Sockets).\nSocket utilization : Concurrency : 16 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization : Concurrency : 32 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\n#####Socket utilization : Concurrency : 64 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization : Concurrency : 128 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization : Concurrency : 256 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization : Concurrency : 512 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization : Concurrency : 1024 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nSocket utilization : Concurrency : 2048 #\nAzure:master\n\nDavid-Noble-at-work:isssue/cosmos-4.X/direct-tcp/socket-leak\n\nPerformance #\nWe utilized two performance test programs in these runs:\n\nJava SDK benchmark tool for measuring asynchronous ReadLatency performance.\nOur internal JMH-based benchmark tool for measuring blocking ReadLatency performance.\n\nThroughput #\n\n\nLatency #\n\n\nSocket utilization in development environments #\nReadLatency : macOS development environment, documentCount = [1, 100,000] #\n\n{\n    \"client\": \"Danoble-MBP-6.thenobles.us, Darwin Kernel Version 19.4.0 x86_64 i386 MacBookPro16,1\",\n    \"javaVersion\": \"openjdk version 1.8.0_252 (AdoptOpenJDK)\",\n    \"benchmark\": \"ReadLatency\",\n    \"concurrency\": 2048,\n    \"documentCount\": [\n        1,\n        100000\n    ]\n}\nReadLatency : Windows development environment, documentCount = [1, 100,000] #\n\n{\n    \"client\": \"Danoble-WS19-1, Microsoft Windows Server 2019 Datacenter Version 10.0.17763\",\n    \"javaVersion\": \"openjdk version 11.0.3 2019-04-16 LTS (Zulu)\",\n    \"benchmark\": \"ReadLatency\",\n    \"concurrency\": 2048,\n    \"documentCount\": [\n        1,\n        100000\n    ]\n}\nOther issues addressed while creating this PR #\n\n\nRntbdRequestTimer now never prevents program termination.\nI discovered that by default that Netty's HashedWheelTimer creates a user thread by default and that this user thread is not guaranteed to stop running when the HashedWheelTimer is stopped. RntbdRequestTimer now creates a daemon thread using a custom thread factory: RntbdThreadFactory. Our custom thread factory is now also used in RntbdClientChannelPool to allocate a static daemon thread for closing a channel pool.\n\n\nRntbdReporter now always produces a useful stack trace\n\n\nRntbdTransportClient.Options now includes:\nconnectionAcquisitionTimeout\nIf a channel cannot be acquired within this time interval, it is failed. The default value is Duration.ZERO and specifies that there is no connection acquisition timeout.\nthreadCount\nThe number of IO threads to allocate to the RntbdTransportClient event loop group. The default value is 2 * Runtime.getRuntime().availableProcessors(). This is a two-fold increase over the previous value which was not configurable. The new default value (which is the default value used by Netty) was found to consistently produce a small (<5%) performance boost.\n\n\nAdded benchmark configuration option: -reportingDirectory\nThis option causes a CSV reporter to be created instead of a console reporter. I would like to rethink the option name on another PR. Reviewers: Is this good enough for now?\n\n\nRemoved a few low-value debug-level logger messages.\n\n\nAnalysis of current test failures #\nAll but one build failure are for the result of failures in one or more of these tests:\n\nConsistencyTests2::validateSessionTokenAsync\nConsistencyTests2::validateSessionTokenWithDocumentNotFound\nConsistencyTests2::validateSessionTokenWithPreConditionFailure\n\nOne build failed due to this test failure:\n\nUniqueIndexTest.insertWithUniqueIndex\n\nCI Task Insights reports that these failures have occurred \"[multiple] times across 15 pipeline runs in the last 14 days.\"\nSingle_Region_Strong_Tcp:Strong_Tcp_Direct, MultiMaster_Single_Region:Direct\n2020-05-03T16:44:54.9731158Z [ERROR] Tests run: 79, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 870.012 s <<< FAILURE! - in TestSuite\n2020-05-03T16:44:54.9764800Z [ERROR] ConsistencyTests2::validateSessionTokenAsync(com.azure.cosmos.implementation.ConsistencyTests2)  Time elapsed: 480.014 s  <<< FAILURE!\n2020-05-03T16:44:54.9774100Z org.testng.internal.thread.ThreadTimeoutException: Method com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenAsync() didn't finish within the time-out 480000\n2020-05-03T16:44:54.9775987Z \tat app//com.azure.cosmos.implementation.ConsistencyTests2.lambda$validateSessionTokenAsync$0(ConsistencyTests2.java:235)\n2020-05-03T16:44:54.9788238Z \tat app//com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenAsync(ConsistencyTests2.java:272)\n\nSingle_Region_Session:Single Region Direct, Single_Region_Session_2:Multimaster Single Region Direct\n2020-05-03T16:44:21.4096557Z [ERROR] Tests run: 79, Failures: 2, Errors: 0, Skipped: 6, Time elapsed: 803.098 s <<< FAILURE! - in TestSuite\n2020-05-03T16:44:21.4131385Z [ERROR] ConsistencyTests2::validateSessionTokenAsync(com.azure.cosmos.implementation.ConsistencyTests2)  Time elapsed: 480.009 s  <<< FAILURE!\n2020-05-03T16:44:21.4133834Z org.testng.internal.thread.ThreadTimeoutException: Method com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenAsync() didn't finish within the time-out 480000\n2020-05-03T16:44:21.4144820Z \tat app//com.azure.cosmos.implementation.ConsistencyTests2.lambda$validateSessionTokenAsync$0(ConsistencyTests2.java:235)\n2020-05-03T16:44:21.4146499Z \tat app//com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenAsync(ConsistencyTests2.java:272)\n2020-05-03T16:44:21.4147349Z \n2020-05-03T16:44:21.4150290Z [ERROR] ConsistencyTests2::validateSessionTokenWithDocumentNotFound(com.azure.cosmos.implementation.ConsistencyTests2)  Time elapsed: 20.558 s  <<< FAILURE!\n2020-05-03T16:44:21.4154098Z java.lang.AssertionError: \n2020-05-03T16:44:21.4154735Z \n2020-05-03T16:44:21.4155411Z Expecting:\n2020-05-03T16:44:21.4156076Z  <false>\n2020-05-03T16:44:21.4156764Z to be equal to:\n2020-05-03T16:44:21.4157435Z  <true>\n2020-05-03T16:44:21.4158094Z but was not.\n2020-05-03T16:44:21.4167664Z \tat com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenWithDocumentNotFound(ConsistencyTests2.java:114)\n2020-05-03T16:44:21.4168735Z \n\nMultiMaster_Multi_Region:Direct\n2020-05-03T18:06:39.2863867Z [ERROR] Tests run: 79, Failures: 2, Errors: 0, Skipped: 6, Time elapsed: 773.709 s <<< FAILURE! - in TestSuite\n2020-05-03T18:06:39.2914217Z [ERROR] ConsistencyTests2::validateSessionTokenAsync(com.azure.cosmos.implementation.ConsistencyTests2)  Time elapsed: 480.014 s  <<< FAILURE!\n2020-05-03T18:06:39.2916257Z org.testng.internal.thread.ThreadTimeoutException: Method com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenAsync() didn't finish within the time-out 480000\n2020-05-03T18:06:39.2924420Z \tat app//com.azure.cosmos.implementation.ConsistencyTests2.lambda$validateSessionTokenAsync$0(ConsistencyTests2.java:235)\n2020-05-03T18:06:39.2931550Z \tat app//com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenAsync(ConsistencyTests2.java:272)\n2020-05-03T18:06:39.2932367Z \n2020-05-03T18:06:39.2933305Z [ERROR] ConsistencyTests2::validateSessionTokenWithPreConditionFailure(com.azure.cosmos.implementation.ConsistencyTests2)  Time elapsed: 30.395 s  <<< FAILURE!\n2020-05-03T18:06:39.2938156Z java.lang.AssertionError: \n2020-05-03T18:06:39.2938709Z \n2020-05-03T18:06:39.2942431Z Expecting:\n2020-05-03T18:06:39.2952499Z  <false>\n2020-05-03T18:06:39.2953245Z to be equal to:\n2020-05-03T18:06:39.2953913Z  <true>\n2020-05-03T18:06:39.2954390Z but was not.\n2020-05-03T18:06:39.2964162Z \tat com.azure.cosmos.implementation.ConsistencyTests2.validateSessionTokenWithPreConditionFailure(ConsistencyTests2.java:105)\n20\n\nSingle_Region_Session_2 Single_Region_Long:Long Integration Tests\n2020-05-03T17:44:30.4500562Z [ERROR] UniqueIndexTest::insertWithUniqueIndex(com.azure.cosmos.rx.UniqueIndexTest)  Time elapsed: 30.067 s  <<< FAILURE!\n2020-05-03T17:44:30.4502230Z org.testng.internal.thread.ThreadTimeoutException: Method com.azure.cosmos.rx.UniqueIndexTest.insertWithUniqueIndex() didn't finish within the time-out 30000\n2020-05-03T17:44:30.4503311Z \tat app//com.azure.cosmos.rx.UniqueIndexTest.insertWithUniqueIndex(UniqueIndexTest.java:116)\n2020-05-03T17:44:30.4503993Z", "createdAt": "2020-04-30T02:57:25Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616", "merged": true, "mergeCommit": {"oid": "66775f878ea692b28c4183b05fb94f8fc3ca8696"}, "closed": true, "closedAt": "2020-05-15T17:00:49Z", "author": {"login": "David-Noble-at-work"}, "timelineItems": {"totalCount": 58, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABbkQmrkAH2gAyNDExMDkzMzE2Ojg0YTM3YWIzMjk1MjVhZTUyZDdjMWFkYzZlN2JhM2MzMzYyNWM1Yzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchNVcJAFqTQxMTc5MzMwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "84a37ab329525ae52d7c1adc6e7ba3c33625c5c7", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/84a37ab329525ae52d7c1adc6e7ba3c33625c5c7", "committedDate": "2019-11-07T04:36:56Z", "message": "Port from v4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d218925e1dff21266697a27e4271d34dfcc3b6a7", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d218925e1dff21266697a27e4271d34dfcc3b6a7", "committedDate": "2019-11-08T01:46:09Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11cbbf37bf63bf50e94f67fe30300ac39c72ed4f", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/11cbbf37bf63bf50e94f67fe30300ac39c72ed4f", "committedDate": "2019-11-08T03:20:35Z", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05c7e0551ffb6fd1ed80c15d1068cb32e734007e", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/05c7e0551ffb6fd1ed80c15d1068cb32e734007e", "committedDate": "2019-11-09T00:07:30Z", "message": "Corrected package misspelling in log4j.properties and removed System.exit from Main.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dfa3dbf03ae2addeddcb34ffc67c362670a164c", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8dfa3dbf03ae2addeddcb34ffc67c362670a164c", "committedDate": "2019-11-09T00:07:47Z", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6e71f5e6b292cac17b6a9687d04ad858f02a8a1", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e6e71f5e6b292cac17b6a9687d04ad858f02a8a1", "committedDate": "2019-11-09T18:42:20Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e082d817a13d64ed57e5243cbc1da5b4ef0ab58e", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e082d817a13d64ed57e5243cbc1da5b4ef0ab58e", "committedDate": "2019-11-17T00:51:11Z", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "069c822e997087f384cf1a1864e7efec331e69f8", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/069c822e997087f384cf1a1864e7efec331e69f8", "committedDate": "2019-11-23T22:36:47Z", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ead1cca230e56b61e5376e73bd1481f7a7b81e6", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ead1cca230e56b61e5376e73bd1481f7a7b81e6", "committedDate": "2019-12-03T18:58:37Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "669ba8b28ed6ae321fda445e0e167ff027cc6481", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/669ba8b28ed6ae321fda445e0e167ff027cc6481", "committedDate": "2019-12-04T19:34:26Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "735f57269d45a3497a66d47d594b7efac88179ff", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/735f57269d45a3497a66d47d594b7efac88179ff", "committedDate": "2019-12-04T19:36:31Z", "message": "Responded to code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6db330d843c4cdbb80b90c6f734f69a59afb9183", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6db330d843c4cdbb80b90c6f734f69a59afb9183", "committedDate": "2020-01-04T00:31:23Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48855b55564f6f216ee6a156f7a64ff5991ee2e6", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/48855b55564f6f216ee6a156f7a64ff5991ee2e6", "committedDate": "2020-01-04T02:07:38Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2367f50dd69e8f4d1ba123c3b42ad4388caeaa66", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2367f50dd69e8f4d1ba123c3b42ad4388caeaa66", "committedDate": "2020-01-17T20:51:14Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb9cac0c12e21f09e3c45580bf324bef7733b8c1", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb9cac0c12e21f09e3c45580bf324bef7733b8c1", "committedDate": "2020-01-23T01:18:46Z", "message": "Updated sdk/cosmos/README.md with info on using system properties to modify default Direct TCP options"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dd708ef9e753607040a6bb1f2b69c863dda8a0a", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1dd708ef9e753607040a6bb1f2b69c863dda8a0a", "committedDate": "2020-01-23T01:21:11Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203507a249705593b04dec3e36566537d15da4e2", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/203507a249705593b04dec3e36566537d15da4e2", "committedDate": "2020-03-16T00:12:48Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "368b10f9893cdf49e95545e8ae4ec5ff03450f60", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/368b10f9893cdf49e95545e8ae4ec5ff03450f60", "committedDate": "2020-03-16T17:10:04Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7544aa31e210fe20d9939c26b17c9dbb4d7d72f", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f7544aa31e210fe20d9939c26b17c9dbb4d7d72f", "committedDate": "2020-03-17T01:24:39Z", "message": "Ported memory leak from v2.6.X and bumped version number."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cd3a139255f258d20b3c56ce9d00462add02b2b", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4cd3a139255f258d20b3c56ce9d00462add02b2b", "committedDate": "2020-03-18T01:32:58Z", "message": "Removed a file that was mistakenly committed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f58a9c7b813cc0f1d39071c8dd64e667681e2ec", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8f58a9c7b813cc0f1d39071c8dd64e667681e2ec", "committedDate": "2020-03-18T05:41:03Z", "message": "Space adjustments for readability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49baa6abd3e5ee01571b05c776ef43ff6efe7620", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/49baa6abd3e5ee01571b05c776ef43ff6efe7620", "committedDate": "2020-03-19T00:30:26Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/memory-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f70e844575c77ef9906cc109a44c06e1366a3ad5", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f70e844575c77ef9906cc109a44c06e1366a3ad5", "committedDate": "2020-03-24T00:46:33Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163c66d1a858ade5c179488ee9b7fb9798147e03", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/163c66d1a858ade5c179488ee9b7fb9798147e03", "committedDate": "2020-03-26T02:47:43Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01a3661f189abc1cf6f582083bbba44126aa8719", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/01a3661f189abc1cf6f582083bbba44126aa8719", "committedDate": "2020-04-05T01:57:34Z", "message": "DCDocumentCrudTest passes. Performance, reliability, and scalability tuning/testing work remains."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be7b3d88e28d214ed79d686bcd4349f00d0b3c7a", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/be7b3d88e28d214ed79d686bcd4349f00d0b3c7a", "committedDate": "2020-04-07T04:54:30Z", "message": "Enabled channel acquisition timeout interval default: 100 ms\n\nVerified: direct tests pass modulo a mockito issue that breaks a number of direct tests. Root cause analysis on the mockito break is TBD."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7446c7aa03a788401d61900188ebfb357c0fea00", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7446c7aa03a788401d61900188ebfb357c0fea00", "committedDate": "2020-04-08T00:34:05Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f263570653c07bc9f077cae2307061ad0d286ac", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5f263570653c07bc9f077cae2307061ad0d286ac", "committedDate": "2020-04-08T22:37:00Z", "message": "Removed some newlines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfb2ba4826880e5152658bab479b34f5f490a5bd", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dfb2ba4826880e5152658bab479b34f5f490a5bd", "committedDate": "2020-04-08T22:37:31Z", "message": "Added a newline at the end of file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34baf33d1a8a05c4f04091b8ef963209f1ed949f", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/34baf33d1a8a05c4f04091b8ef963209f1ed949f", "committedDate": "2020-04-08T22:37:58Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d7bf22c9ec045ec56683dc94f5879de003fdf40", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5d7bf22c9ec045ec56683dc94f5879de003fdf40", "committedDate": "2020-04-11T20:56:20Z", "message": "Ensured that RntbdClientChannelPool.release never throws and never releases a channel prematurely. This change addresses occassional point read failures (~0.0015% of the time in local testing) when slamming a partition with read requests. This change also ensures that unhandled exceptions during release do not cause thread deaths."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5a8e7b75b7ff126eac016d28738f937951aa4a1", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c5a8e7b75b7ff126eac016d28738f937951aa4a1", "committedDate": "2020-04-15T16:20:21Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05f141039211010d76a20a070dc864df979759b6", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/05f141039211010d76a20a070dc864df979759b6", "committedDate": "2020-04-16T00:26:34Z", "message": "Revised channel acquisition algorithm such that no timer acquisition task timeout is used by default and we allow maxRequestsPerChannel to go above limit when maxChannels are allocated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e767404f56822dab79896d35ff73e584b3e018f1", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e767404f56822dab79896d35ff73e584b3e018f1", "committedDate": "2020-04-18T20:26:30Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3425d0b8e13d32afcb8684f0d9d344509cd90007", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3425d0b8e13d32afcb8684f0d9d344509cd90007", "committedDate": "2020-04-18T20:58:40Z", "message": "Attempt to resolve scalability issue that causes performance degradation about about 500 concurrent requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7a6cdad8597ff80a6209ecc37b093f4934eb2b2", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f7a6cdad8597ff80a6209ecc37b093f4934eb2b2", "committedDate": "2020-04-19T19:56:19Z", "message": "Code/documentation tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a04ad8bc10d8ad3a809ff52e7aac120147620a9", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a04ad8bc10d8ad3a809ff52e7aac120147620a9", "committedDate": "2020-04-20T04:03:27Z", "message": "Idle endpoint timeout task now detects idleEndpointTimeout and\u2014unless the endpoint is found to be idle\u2014runs tasks in the pendingAcquisitionQueue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb81f3e7458759d7fadb237c71c2db4b0ae7f19d", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb81f3e7458759d7fadb237c71c2db4b0ae7f19d", "committedDate": "2020-04-20T04:09:56Z", "message": "Updated a comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f23efd6299bf6989eecc5dcbc1b9b14276e83ca", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7f23efd6299bf6989eecc5dcbc1b9b14276e83ca", "committedDate": "2020-04-20T05:57:42Z", "message": "Code tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78f0e55d2001b90ba72450b6854c83ac3baba8e6", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/78f0e55d2001b90ba72450b6854c83ac3baba8e6", "committedDate": "2020-04-21T04:27:48Z", "message": "Switch to HashedWheelTimer implementation for RntbdClientChannelPool.acquisitionAndIdleEndpointDetectionTimeout and revised RntbdClientChannelPool.acquireChannel. Local testing indicates that this significatnly reduces P95-P99.9 latencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12b5981b89ec39d52b45117e29835401358a5ba5", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/12b5981b89ec39d52b45117e29835401358a5ba5", "committedDate": "2020-04-22T18:04:19Z", "message": "Tweaked log message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5ff54c36b6cc35e63cecaccc287abff95b202e0", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5ff54c36b6cc35e63cecaccc287abff95b202e0", "committedDate": "2020-04-24T00:22:21Z", "message": "Addressed a number of threading-related issues in RntbdClientChannelPool; tweaked the RntbdReporter; and added a CsvReporter feature to the benchmark tool. They latter may be a temporary addition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc7637be1cebb5f6a8b4df3395600996c9b50ca4", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc7637be1cebb5f6a8b4df3395600996c9b50ca4", "committedDate": "2020-04-25T20:23:13Z", "message": "Streamlined RntbdServiceEndpoint.write for performance/readability. In local testing this change resulted in a significant performance gain in these configurations:\n* concurrency=2048.documentCount=000001.operation=ReadLatency.operation-count=1000000\n* concurrency=2048.documentCount=100000.operation=ReadLatency.operation-count=1000000\nSpecificallly, the P99 values moved to P99.9 and throughput increased by at least 11% as measured by (lowest[with-change] - highest[sans-change]) / highest[sans-change])"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "488291ed705a9cc6552b2326c794268e1785442f", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/488291ed705a9cc6552b2326c794268e1785442f", "committedDate": "2020-04-28T15:11:38Z", "message": "Tweaks tested extensively--full test suite plus point read benchmarks (1 and 10,0000 documents with 2,048 concurrent requests) locally in prep for PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02293fc5c0952a9615a29a1992e08d87b461567a", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/02293fc5c0952a9615a29a1992e08d87b461567a", "committedDate": "2020-04-28T15:15:58Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2375baab4d6b8dc533a38405294ed21fa247f648", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2375baab4d6b8dc533a38405294ed21fa247f648", "committedDate": "2020-04-28T21:53:39Z", "message": "Tweaked AsyncBenchmark for verifying the direct tcp \u201cconnection timeout\u201d issue raised by T-Mobile."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46f5dd1bd9ebfac572044b3f2a104c6b37267103", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/46f5dd1bd9ebfac572044b3f2a104c6b37267103", "committedDate": "2020-04-29T20:59:51Z", "message": "Moved a misplaced statement in AsyncBenchmark that produced a lot of logger noise."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d0c00772d1c79f4b3ba82add514132660d5ae31", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d0c00772d1c79f4b3ba82add514132660d5ae31", "committedDate": "2020-04-30T03:52:52Z", "message": "Updated version numbers in an attempt to get past CI version checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb7273bd375723f5a065eb0a511c8df935201245", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb7273bd375723f5a065eb0a511c8df935201245", "committedDate": "2020-04-30T03:54:21Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02d7ed00304e953d15119c35358bc2497e162a0a", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/02d7ed00304e953d15119c35358bc2497e162a0a", "committedDate": "2020-04-30T04:06:27Z", "message": "Tweaked RntbdRequestTimer.close for readability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44c7ea7ded34c1141e28fc8866326c296639d2b7", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/44c7ea7ded34c1141e28fc8866326c296639d2b7", "committedDate": "2020-04-30T05:32:22Z", "message": "Removed README.md which seems to have been removed from master after being edited by me"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/350db568ea82a310993c3d9f4860d7897ad50afc", "committedDate": "2020-04-30T06:09:49Z", "message": "Fixed a build issue that CI complains about."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MDQ5MDQ4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#pullrequestreview-405049048", "createdAt": "2020-05-04T14:36:40Z", "commit": {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNjo0MFrOGQDVLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNjo0MFrOGQDVLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg==", "bodyText": "@kushagraThapar\ncom.azure:azure-cosmos-examples and azure-cosmos-benchmark are in the process is being removed as libraries. Further, they're intentionally not part of the Artifacts cosmos' ci.yml which makes them incapable of being released (this was intentional as these are never supposed to be released). There is no version change necessary here and it should be reverted.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419484972", "createdAt": "2020-05-04T14:36:40Z", "author": {"login": "JimSuplizio"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -17,8 +17,8 @@ com.azure:azure-core-serializer-json-jackson;1.0.0-beta.1;1.0.0-beta.1\n com.azure:azure-core-test;1.2.0;1.3.0-beta.1\n com.azure:azure-core-tracing-opentelemetry;1.0.0-beta.4;1.0.0-beta.5\n com.azure:azure-cosmos;4.0.1-beta.2;4.0.1-beta.3\n-com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.1\n-com.azure:azure-cosmos-benchmark;4.0.1-beta.1;4.0.1-beta.1\n+com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "committedDate": "2020-05-04T22:17:10Z", "message": "Reverting version bump for benchmark and examples as these are in the process of being removed as libraries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjYyNjU0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#pullrequestreview-406262654", "createdAt": "2020-05-06T01:51:39Z", "commit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMTo1MTozOVrOGRBlvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjowMTo0NVrOGRBu8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA==", "bodyText": "Nit : Though the error message should say \"Collection {} creation failed due to ... \" instead of Database :)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420505020", "createdAt": "2020-05-06T01:51:39Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -83,11 +88,18 @@\n         }\n \n         try {\n-            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(this.configuration.getCollectionId()).read().block().getContainer();\n+            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(\n+                this.configuration.getCollectionId()\n+            ).read().doOnError(error ->\n+                logger.error(\"Database {} creation failed due to \", this.configuration.getDatabaseId(), error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjA4NA==", "bodyText": "Some dead code ?\nOr do you need it later ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506084", "createdAt": "2020-05-06T01:55:57Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -27,172 +34,253 @@\n import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n import java.time.Duration;\n-import java.util.ArrayDeque;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdReporter.reportIssueUnless;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+import static com.azure.cosmos.implementation.guava27.Strings.lenientFormat;\n \n /**\n- * {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections\n+ * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n  */\n @JsonSerialize(using = RntbdClientChannelPool.JsonSerializer.class)\n-public final class RntbdClientChannelPool extends SimpleChannelPool {\n+public final class RntbdClientChannelPool implements ChannelPool {\n \n     private static final TimeoutException ACQUISITION_TIMEOUT = ThrowableUtil.unknownStackTrace(\n-        new TimeoutException(\"Acquisition took longer than the configured maximum time\"),\n+        new TimeoutException(\"acquisition took longer than the configured maximum time\"),\n         RntbdClientChannelPool.class, \"<init>\");\n \n     private static final ClosedChannelException CHANNEL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire0(...)\");\n+        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_RELEASE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n         RntbdClientChannelPool.class, \"release\");\n \n+    private static final AttributeKey<RntbdClientChannelPool> POOL_KEY = AttributeKey.newInstance(\n+        RntbdClientChannelPool.class.getName());\n+\n     private static final IllegalStateException TOO_MANY_PENDING_ACQUISITIONS = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"Too many outstanding acquire operations\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"too many outstanding acquire operations\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n+\n+    private static final EventExecutor closer = new DefaultEventExecutor(new RntbdThreadFactory(\n+        \"channel-pool-closer\",\n+        true,\n+        Thread.NORM_PRIORITY));\n+\n+    private static final HashedWheelTimer acquisitionAndIdleEndpointDetectionTimer =\n+        new HashedWheelTimer(new RntbdThreadFactory(\n+            \"channel-acquisition-timer\",\n+            true,\n+            Thread.NORM_PRIORITY));\n \n     private static final Logger logger = LoggerFactory.getLogger(RntbdClientChannelPool.class);\n \n-    private final long acquisitionTimeoutNanos;\n+    private final long acquisitionTimeoutInNanos;\n+    private final Runnable acquisitionTimeoutTask;\n     private final PooledByteBufAllocatorMetric allocatorMetric;\n+    private final Bootstrap bootstrap;\n     private final EventExecutor executor;\n-    private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n+    private final ChannelHealthChecker healthChecker;\n+    // private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n     private final int maxChannels;\n     private final int maxPendingAcquisitions;\n     private final int maxRequestsPerChannel;\n+    private final ChannelPoolHandler poolHandler;\n+    private final boolean releaseHealthCheck;\n \n-    // No need to worry about synchronization as everything that modified the queue or counts is done by this.executor\n-\n-    private final Queue<AcquireTask> pendingAcquisitionQueue = new ArrayDeque<AcquireTask>();\n-    private final Runnable acquisitionTimeoutTask;\n-\n-    // Because these values can be requested on any thread...\n+    // Because state from these fields can be requested on any thread...\n \n-    private final AtomicInteger acquiredChannelCount = new AtomicInteger();\n-    private final AtomicInteger availableChannelCount = new AtomicInteger();\n+    private final AtomicReference<Timeout> acquisitionAndIdleEndpointDetectionTimeout = new AtomicReference<>();\n+    private final ConcurrentHashMap<Channel, Channel> acquiredChannels = new ConcurrentHashMap<>();\n+    private final Deque<Channel> availableChannels = new ConcurrentLinkedDeque<>();\n     private final AtomicBoolean closed = new AtomicBoolean();\n+    private final AtomicBoolean connecting = new AtomicBoolean();\n+    private final Queue<AcquireTask> pendingAcquisitions = new ConcurrentLinkedQueue<>();\n \n     /**\n-     * Initializes a newly created {@link RntbdClientChannelPool} object\n-     *  @param bootstrap the\u00a0{@link Bootstrap} that is used for connections\n-     * @param config    the {@link Config} that is used for the channel pool instance created\n+     * Initializes a newly created {@link RntbdClientChannelPool} instance.\n+     *\n+     * @param bootstrap the\u00a0{@link Bootstrap} that is used for connections.\n+     * @param config the {@link Config} that is used for the channel pool instance created.\n      */\n     RntbdClientChannelPool(final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config) {\n         this(endpoint, bootstrap, config, new RntbdClientChannelHealthChecker(config));\n     }\n \n     private RntbdClientChannelPool(\n-        final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config,\n-        final RntbdClientChannelHealthChecker healthChecker\n-    ) {\n+        final RntbdServiceEndpoint endpoint,\n+        final Bootstrap bootstrap,\n+        final Config config,\n+        final RntbdClientChannelHealthChecker healthChecker) {\n \n-        super(bootstrap, new RntbdClientChannelHandler(config, healthChecker), healthChecker, true, true);\n+        checkNotNull(endpoint, \"expected non-null endpoint\");\n+        checkNotNull(bootstrap, \"expected non-null bootstrap\");\n+        checkNotNull(config, \"expected non-null config\");\n+        checkNotNull(healthChecker, \"expected non-null healthChecker\");\n \n-        this.allocatorMetric = config.allocator().metric();\n+        this.poolHandler = new RntbdClientChannelHandler(config, healthChecker);\n         this.executor = bootstrap.config().group().next();\n-        this.maxChannels = config.maxChannelsPerEndpoint();\n-        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n-        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n-\n-        // TODO: DANOBLE: Add RntbdEndpoint.Config settings for acquisition timeout and acquisition timeout action\n-        //  Alternatively: drop acquisition timeout and acquisition timeout action\n-        //  Decision should be based on performance, reliability, and usability considerations\n+        this.healthChecker = healthChecker;\n \n-        final AcquisitionTimeoutAction acquisitionTimeoutAction = null;\n-        final long acquisitionTimeoutNanos = -1L;\n-\n-        if (acquisitionTimeoutAction == null) {\n-\n-            this.acquisitionTimeoutNanos = -1L;\n-            this.acquisitionTimeoutTask = null;\n-\n-        } else {\n-\n-            this.acquisitionTimeoutNanos = acquisitionTimeoutNanos;\n-\n-            switch (acquisitionTimeoutAction) {\n-                case FAIL:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            task.promise.setFailure(ACQUISITION_TIMEOUT);\n-                        }\n-                    };\n-                    break;\n-                case NEW:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            // Increment the acquire count and get a new Channel by delegating to super.acquire\n-                            task.acquired();\n-                            RntbdClientChannelPool.super.acquire(task.promise);\n-                        }\n-                    };\n-                    break;\n-                default:\n-                    throw new Error();\n+        this.bootstrap = bootstrap.clone().handler(new ChannelInitializer<Channel>() {\n+            @Override\n+            protected void initChannel(final Channel channel) throws Exception {\n+            checkState(channel.eventLoop().inEventLoop());\n+            RntbdClientChannelPool.this.poolHandler.channelCreated(channel);\n             }\n-        }\n-\n-        final long idleEndpointTimeout = config.idleEndpointTimeoutInNanos();\n-\n-        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n-            () -> {\n-\n-                final long currentTime = System.nanoTime();\n-                final long lastRequestTime = endpoint.lastRequestTime();\n-                final long elapsedTime = currentTime - lastRequestTime;\n-\n-                if (elapsedTime > idleEndpointTimeout) {\n+        });\n \n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\n-                            \"{} closing due to inactivity (time elapsed since last request: {} > idleEndpointTimeout: {})\",\n-                            endpoint, Duration.ofNanos(elapsedTime), Duration.ofNanos(idleEndpointTimeout));\n-                    }\n+        // TODO (DANOBLE) Consider moving or removing this.allocatorMetric\n+        //  This metric is redundant in the scope of this class and should be pulled up to RntbdServiceEndpoint or\n+        //  entirely removed.\n \n-                    endpoint.close();\n-                }\n+        this.acquisitionTimeoutInNanos = config.connectionAcquisitionTimeoutInNanos();\n+        this.allocatorMetric = config.allocator().metric();\n+        this.maxChannels = config.maxChannelsPerEndpoint();\n+        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n \n-            }, idleEndpointTimeout, idleEndpointTimeout, TimeUnit.NANOSECONDS);\n+        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n+        this.releaseHealthCheck = true;\n+\n+        this.acquisitionTimeoutTask = acquisitionTimeoutInNanos <= 0 ? null : new AcquireTimeoutTask(this) {\n+            /**\n+             * Fails a request due to a channel acquisition timeout.\n+             *\n+             * @param task a {@link AcquireTask channel acquisition task} that has timed out.\n+             */\n+            @Override\n+            public void onTimeout(AcquireTask task) {\n+                task.promise.setFailure(ACQUISITION_TIMEOUT);\n+            }\n+        };\n+\n+        newTimeout(endpoint, config.idleEndpointTimeoutInNanos(), config.requestTimerResolutionInNanos());\n+\n+//        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n+//            () -> {\n+//                final long elapsedTimeInNanos = System.nanoTime() - endpoint.lastRequestNanoTime();\n+//\n+//                if (idleEndpointTimeoutInNanos - elapsedTimeInNanos <= 0) {\n+//                    if (logger.isDebugEnabled()) {\n+//                        logger.debug(\n+//                            \"{} closing endpoint due to inactivity (elapsedTime: {} > idleEndpointTimeout: {})\",\n+//                            endpoint,\n+//                            Duration.ofNanos(elapsedTimeInNanos),\n+//                            Duration.ofNanos(idleEndpointTimeoutInNanos));\n+//                    }\n+//                    endpoint.close();\n+//                    return;\n+//                }\n+//\n+//                this.runTasksInPendingAcquisitionQueue();\n+//\n+//            }, requestTimerResolutionInNanos, requestTimerResolutionInNanos, TimeUnit.NANOSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ==", "bodyText": "Explanation required ?\nIf not, remove the check as per the comment :)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506599", "createdAt": "2020-05-06T01:58:23Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -233,45 +349,87 @@ public boolean isClosed() {\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n             if (this.executor.inEventLoop()) {\n-                this.close0();\n+                this.doClose();\n             } else {\n-                this.executor.submit(this::close0).awaitUninterruptibly();\n+                this.executor.submit(this::doClose).awaitUninterruptibly(); // block until complete\n             }\n         }\n     }\n \n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     *\n+     * @return asynchronous result of the operation. If the operation fails, {@code channel} will be closed\n+     * automatically.\n+     */\n+    @Override\n+    public Future<Void> release(final Channel channel) {\n+        return this.release(channel, channel.eventLoop().newPromise());\n+    }\n+\n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     * @param promise a {@link Promise promise} to be notified once the release is successful; failed otherwise.\n+     *\n+     * @return a reference to {@code promise}. If the operation fails, {@code channel} will be closed automatically.\n+     */\n     @Override\n     public Future<Void> release(final Channel channel, final Promise<Void> promise) {\n \n         // We do not call this.throwIfClosed because a channel may be released back to the pool during close\n \n-        super.release(channel, this.executor.<Void>newPromise().addListener((FutureListener<Void>)future -> {\n+        checkNotNull(channel, \"expected non-null channel\");\n+        checkNotNull(promise, \"expected non-null promise\");\n \n-            checkState(this.executor.inEventLoop());\n+        Promise<Void> anotherPromise = this.executor.newPromise(); // ensures we finish in our executor's event loop\n+\n+        try {\n+            final EventLoop loop = channel.eventLoop();\n+            if (loop.inEventLoop()) {\n+                this.releaseChannel(channel, anotherPromise);\n+            } else {\n+                loop.execute(() -> this.releaseChannel(channel, anotherPromise));\n+            }\n+        } catch (Throwable cause) {\n+            if (this.executor.inEventLoop()) {\n+                this.closeChannelAndFail(channel, cause, anotherPromise);\n+            } else {\n+                this.executor.submit(() -> this.closeChannelAndFail(channel, cause, anotherPromise));\n+            }\n+        }\n+\n+        anotherPromise.addListener((FutureListener<Void>) future -> {\n+\n+            this.ensureValidRunState();\n \n             if (this.isClosed()) {\n-                // Since the pool is closed, we have no choice but to close the channel\n+                // We have no choice but to close the channel\n                 promise.setFailure(POOL_CLOSED_ON_RELEASE);\n-                channel.close();\n+                this.closeChannel(channel);\n                 return;\n             }\n \n             if (future.isSuccess()) {\n-\n-                this.decrementAndRunTaskQueue();\n+                this.runTasksInPendingAcquisitionQueue();\n                 promise.setSuccess(null);\n-\n             } else {\n-\n+                // TODO (DANOBLE) Is this check for an IllegalArgumentException required?\n+                //  Explain here, if so; otherwise remove the check.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjc1NA==", "bodyText": "Is this intended to have no message and only params / values ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506754", "createdAt": "2020-05-06T01:59:00Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -281,126 +439,286 @@ public String toString() {\n         return RntbdObjectMapper.toString(this);\n     }\n \n+    // endregion\n+\n+    // region Privates\n+\n     /**\n-     * Offer a {@link Channel} back to the internal storage\n+     * Acquires a serviceable channel from the {@link RntbdClientChannelPool pool}.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe.\n+     * This method acquires the first channel that's both available and serviceable in LIFO order. A new channel is\n+     * created and added to the pool if and only if:\n+     * <ul>\n+     * <li>fewer than {@link #maxChannels} channels have been created ({@link #channels} < {@link #maxChannels()}))\n+     * and</li>\n+     * <li>there are no acquired channels pending release ({@link #channelsAcquired} == 0).</li>\n+     * </ul>\n+     * Under load it is possible that:\n+     * <ul>\n+     * <li>no available channels are serviceable ({@link RntbdRequestManager#pendingRequestCount()} ==\n+     * {@link #maxChannels()})</li>\n+     * <li>there are acquired channels pending release, and</li>\n+     * <li>{@link #maxChannels} channels have been created.</li>\n+     * </ul>\n+     * Under these circumstances a request to acquire a channel will be satisfied by the\n+     * {@link #acquisitionTimeoutTask} which will:\n+     * <ul>\n+     * <li>process items in the {@link #pendingAcquisitions} on each call to {@link #acquire} or {@link #release},\n+     * and</li>\n+     * <li>each {@link #acquisitionTimeoutInNanos} nanoseconds\n+     * </ul>\n+     * until a channel is acquired.\n+     *\n+     * @param promise the promise of a {@link Channel channel}.\n      *\n-     * @param channel the {@link Channel} to return to internal storage\n-     * @return {@code true}, if the {@link Channel} could be added to internal storage; otherwise {@code false}\n+     * @see #isChannelServiceable(Channel)\n+     * @see AcquireTimeoutTask\n      */\n-    @Override\n-    protected boolean offerChannel(final Channel channel) {\n-        if (super.offerChannel(channel)) {\n-            this.availableChannelCount.incrementAndGet();\n-            return true;\n+    private void acquireChannel(final Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (this.isClosed()) {\n+            promise.setFailure(POOL_CLOSED_ON_ACQUIRE);\n+            return;\n+        }\n+\n+        try {\n+            Channel candidate = this.pollChannel();\n+\n+            if (candidate != null) {\n+\n+                // Fulfill this request with our candidate, assuming it's healthy\n+                // If our candidate is unhealthy, notifyChannelHealthCheck will call us again\n+\n+                doAcquireChannel(promise, candidate);\n+                return;\n+            }\n+\n+            final int channelCount = this.channels();\n+\n+            if (channelCount < this.maxChannels) {\n+\n+                if (this.connecting.compareAndSet(false, true)) {\n+\n+                    // Fulfill this request with a new channel, assuming we can connect one\n+                    // If our connection attempt fails, notifyChannelConnect will call us again\n+\n+                    final Promise<Channel> anotherPromise = this.newChannelPromise(promise);\n+                    final ChannelFuture future = this.bootstrap.clone().attr(POOL_KEY, this).connect();\n+\n+                    if (future.isDone()) {\n+                        this.notifyChannelConnect(future, anotherPromise);\n+                    } else {\n+                        future.addListener(ignored -> this.notifyChannelConnect(future, anotherPromise));\n+                    }\n+\n+                    return;\n+                }\n+\n+            } else if (this.computeLoadFactor() > 0.90D) {\n+\n+                // All channels are swamped and we'll pick the one with the lowest pending request count\n+\n+                long pendingRequestCountMin = Long.MAX_VALUE;\n+\n+                for (Channel channel : this.availableChannels) {\n+\n+                    final RntbdRequestManager manager = channel.pipeline().get(RntbdRequestManager.class);\n+                    final long pendingRequestCount = manager.pendingRequestCount();\n+\n+                    if (pendingRequestCount < pendingRequestCountMin) {\n+                        pendingRequestCountMin = pendingRequestCount;\n+                        candidate = channel;\n+                    }\n+                }\n+\n+                assert candidate != null;\n+\n+                this.availableChannels.remove(candidate);\n+                doAcquireChannel(promise, candidate);\n+\n+                return;\n+            }\n+\n+            this.addTaskToPendingAcquisitionQueue(promise);\n+\n+        } catch (Throwable cause) {\n+            promise.tryFailure(cause);\n         }\n-        return false;\n     }\n \n     /**\n-     * Poll a {@link Channel} out of internal storage to reuse it\n+     * Add a task to the pending acquisition queue to fulfill the request for a {@link Channel channel} later.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe and this type ensures thread safety by calling\n-     * this method serially on a single-threaded EventExecutor. As a result this method need not (and should not) be\n-     * synchronized.\n+     * Tasks in the pending acquisition queue are run whenever a channel is released. This ensures that pending requests\n+     * for channels are fulfilled as soon as possible.\n      *\n-     * @return a value of {@code null}, if no {@link Channel} is ready to be reused\n-     * @see #acquire(Promise)\n+     * @param promise a {@link Promise promise} that will be completed when a {@link Channel channel} is acquired or an\n+     * error is encountered.\n+     *\n+     * @see #runTasksInPendingAcquisitionQueue\n      */\n-    @Override\n-    protected Channel pollChannel() {\n-\n-        final Channel first = super.pollChannel();\n-\n-        if (first == null) {\n-            return null;\n+    private void addTaskToPendingAcquisitionQueue(Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"{}, {}, {}, {}, {}, {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA3NA==", "bodyText": "Another TODO. Stale code ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420507074", "createdAt": "2020-05-06T02:00:15Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -411,48 +729,389 @@ private void close0() {\n             task.promise.setFailure(new ClosedChannelException());\n         }\n \n-        // Ensure we dispatch this on another Thread as close0 will be called from the EventExecutor and we need\n-        // to ensure we will not block in an EventExecutor\n+        // NOTE: we must dispatch this request on another thread--the closer thread--as this.doClose is called on\n+        // this.executor and we need to ensure we will not block it.\n+\n+        closer.submit(() -> {\n+\n+            this.availableChannels.addAll(this.acquiredChannels.values());\n+            this.acquiredChannels.clear();\n+\n+            for (; ; ) {\n+                final Channel channel = this.pollChannel();\n+                if (channel == null) {\n+                    break;\n+                }\n+                channel.close().awaitUninterruptibly(); // block and ignore errors reported back from channel.close\n+            }\n+\n+            assert this.acquiredChannels.isEmpty() && this.availableChannels.isEmpty();\n+\n+        }).addListener(closed -> {\n+            if (!closed.isSuccess()) {\n+                logger.error(\"[{}] close failed due to \", this, closed.cause());\n+            } else {\n+                logger.debug(\"[{}] closed\", this);\n+            }\n+        });\n+    }\n+\n+    private void ensureInEventLoop() {\n+        reportIssueUnless(logger, this.executor.inEventLoop(), this,\n+            \"expected to be in event loop {}, not thread {}\",\n+            this.executor,\n+            Thread.currentThread());\n+    }\n \n-        GlobalEventExecutor.INSTANCE.execute(RntbdClientChannelPool.super::close);\n+    /**\n+     * Checks that the state of this {@link RntbdClientChannelPool pool} is a valid run state and returns the {@link\n+     * #availableChannels} available channel count.\n+     * <p>\n+     * This method reports an issue to be addressed if the state is invalid. It does not throw.\n+     */\n+    private void ensureValidRunState() {\n+\n+        this.ensureInEventLoop();\n+// TODO (DANOBLE) remove or restore this code:\n+//        final int channelsAvailable = this.channelsAvailable();\n+//        final int channelsAcquired = this.channelsAcquired();\n+//        final int channelCount = this.channels();\n+//\n+//        reportIssueUnless(logger, 0 <= channelCount && channelCount <= this.maxChannels, this,\n+//            \"expected channelCount in range [0, {}], not {}\",\n+//            this.maxChannels,\n+//            channelCount,\n+//            channelsAcquired);\n+//\n+//        return channelsAvailable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 943}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM3Nw==", "bodyText": "Love this. \u2764\ufe0f", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420507377", "createdAt": "2020-05-06T02:01:45Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -667,12 +1329,24 @@ public void serialize(final RntbdClientChannelPool value, final JsonGenerator ge\n             generator.writeNumberField(\"channelsAcquired\", value.channelsAcquired());\n             generator.writeNumberField(\"channelsAvailable\", value.channelsAvailable());\n             generator.writeNumberField(\"requestQueueLength\", value.requestQueueLength());\n-            generator.writeNumberField(\"usedDirectMemory\", value.usedDirectMemory());\n-            generator.writeNumberField(\"usedHeapMemory\", value.usedHeapMemory());\n             generator.writeEndObject();\n             generator.writeEndObject();\n         }\n     }\n \n+    private static class StacklessIllegalStateException extends IllegalStateException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 1544}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzkwNzI1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#pullrequestreview-405390725", "createdAt": "2020-05-04T22:25:49Z", "commit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjoyNTo0OVrOGQUcTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjoyNTo0OVrOGQUcTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2NTMyNA==", "bodyText": "nice addition. thank you", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419765324", "createdAt": "2020-05-04T22:25:49Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -11,6 +11,7 @@\n import com.azure.cosmos.CosmosClientException;\n import com.azure.cosmos.implementation.HttpConstants;\n import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a747ce328164ae53f261958300d23f3f7eea42b", "author": {"user": {"login": "David-Noble-at-work", "name": "David Noble"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a747ce328164ae53f261958300d23f3f7eea42b", "committedDate": "2020-05-14T00:11:00Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNzkzMzAz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#pullrequestreview-411793303", "createdAt": "2020-05-14T13:17:46Z", "commit": {"oid": "2a747ce328164ae53f261958300d23f3f7eea42b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4672, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}