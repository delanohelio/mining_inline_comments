{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjE1MDQ2", "number": 9194, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToxMzoyNFrODpPrqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToxNzowM1rODpPwAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTc1MTQ2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/test/java/com/azure/core/util/logging/ClientLoggerTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToxMzoyNFrOF4TUdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToyNDoxN1rOF4Tq6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTExMA==", "bodyText": "Can this be changed to catch IOException instead?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394581110", "createdAt": "2020-03-18T19:13:24Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/util/logging/ClientLoggerTests.java", "diffHunk": "@@ -57,233 +58,167 @@ public void revertLoggingConfiguration() throws Exception {\n         logCaptureStream.close();\n     }\n \n-    private void setPropertyToOriginalOrClear(String propertyName, String originalValue) {\n-        if (CoreUtils.isNullOrEmpty(originalValue)) {\n-            System.clearProperty(propertyName);\n-        } else {\n-            System.setProperty(propertyName, originalValue);\n-        }\n-    }\n-\n     /**\n-     * Tests that logging at the same level as the environment logging level will log.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether the logger supports a given log level based on its configured log level.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3, 4 })\n-    public void logAtSupportedLevel(int logLevel) {\n-        String logMessage = \"This is a test\";\n-\n-        String originalLogLevel = setupLogLevel(logLevel);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void canLogAtLevel(LogLevel logLevelToConfigure, LogLevel logLevelToValidate, boolean expected) {\n+        setupLogLevel(logLevelToConfigure.getLogLevel());\n+        assertEquals(expected, new ClientLogger(ClientLoggerTests.class).canLogAtLevel(logLevelToValidate));\n     }\n \n     /**\n-     * Tests that logging at a level that is less than the environment logging level doesn't log anything.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether a log will be captured when the ClientLogger and message are configured to the passed log levels.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3 })\n-    public void logAtUnsupportedLevel(int logLevel) {\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void log(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage) {\n         String logMessage = \"This is a test\";\n \n-        String originalLogLevel = setupLogLevel(logLevel + 1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertFalse(logValues.contains(logMessage));\n-    }\n-\n-    /**\n-     * Tests that logging when the environment log level is disabled nothing is logged.\n-     */\n-    @Test\n-    public void logWhenLoggingNotSet() {\n-        assertEquals(LogLevel.NOT_SET, LogLevel.fromString(null));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level isn't VERBOSE only log the exception message.\n-     */\n-    @Test\n-    public void onlyLogExceptionMessage() {\n-        String logMessage = \"This is an exception\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n-\n-        String originalLogLevel = setupLogLevel(2);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level is VERBOSE the stack trace is logged.\n-     */\n-    @Test\n-    public void logExceptionStackTrace() {\n-        String logMessage = \"This is an exception fdsafdafdomcklamfd fdsafdafmlkdfmalsf fdsafdcacdalmd\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests whether a log will contain the exception message when the ClientLogger and message are configured to the\n+     * passed log levels.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithErrorLevel() {\n+    @ParameterizedTest\n+    @MethodSource(\"multiLevelCheckSupplier\")\n+    public void logException(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String logMessage = \"This is an exception\";\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        RuntimeException runtimeException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 4, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage, runtimeException);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n+        assertEquals(logContainsStackTrace, logValues.contains(runtimeException.getStackTrace()[0].toString()));\n     }\n \n-\n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a RuntimeException as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithNoLogLevel() {\n-        String logMessage = \"This is an exception\";\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 5, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.isEmpty());\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a Throwable as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionWithInvalidLogLevel() {\n-        String logMessage = \"This is an exception\";\n-        Object runtimeException = new Object();\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logCheckedExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n+        String exceptionMessage = \"An exception message\";\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsWarning(ioException);\n+        } catch (Throwable throwable) {\n+            assertTrue(throwable instanceof IOException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(ioException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning won't include the stack trace when the environment log level isn't\n-     * VERBOSE. Additionally, this tests that the exception message isn't logged twice as logging an exception uses\n-     * the exception message as the format string.\n+     * Tests that logging a RuntimeException as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningOnlyExceptionMessage() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(2);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsError(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(exceptionMessage + System.lineSeparator()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning will include the stack trace when the environment log level is set to\n-     * VERBOSE.\n+     * Tests that logging a Throwable as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningStackTrace() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logCheckedExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsError(ioException);\n+        } catch (Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Njg1OQ==", "bodyText": "I was looking to catch the generic type to ensure that instanceof it would be what is expected.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394586859", "createdAt": "2020-03-18T19:24:17Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/test/java/com/azure/core/util/logging/ClientLoggerTests.java", "diffHunk": "@@ -57,233 +58,167 @@ public void revertLoggingConfiguration() throws Exception {\n         logCaptureStream.close();\n     }\n \n-    private void setPropertyToOriginalOrClear(String propertyName, String originalValue) {\n-        if (CoreUtils.isNullOrEmpty(originalValue)) {\n-            System.clearProperty(propertyName);\n-        } else {\n-            System.setProperty(propertyName, originalValue);\n-        }\n-    }\n-\n     /**\n-     * Tests that logging at the same level as the environment logging level will log.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether the logger supports a given log level based on its configured log level.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3, 4 })\n-    public void logAtSupportedLevel(int logLevel) {\n-        String logMessage = \"This is a test\";\n-\n-        String originalLogLevel = setupLogLevel(logLevel);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void canLogAtLevel(LogLevel logLevelToConfigure, LogLevel logLevelToValidate, boolean expected) {\n+        setupLogLevel(logLevelToConfigure.getLogLevel());\n+        assertEquals(expected, new ClientLogger(ClientLoggerTests.class).canLogAtLevel(logLevelToValidate));\n     }\n \n     /**\n-     * Tests that logging at a level that is less than the environment logging level doesn't log anything.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether a log will be captured when the ClientLogger and message are configured to the passed log levels.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3 })\n-    public void logAtUnsupportedLevel(int logLevel) {\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void log(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage) {\n         String logMessage = \"This is a test\";\n \n-        String originalLogLevel = setupLogLevel(logLevel + 1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertFalse(logValues.contains(logMessage));\n-    }\n-\n-    /**\n-     * Tests that logging when the environment log level is disabled nothing is logged.\n-     */\n-    @Test\n-    public void logWhenLoggingNotSet() {\n-        assertEquals(LogLevel.NOT_SET, LogLevel.fromString(null));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level isn't VERBOSE only log the exception message.\n-     */\n-    @Test\n-    public void onlyLogExceptionMessage() {\n-        String logMessage = \"This is an exception\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n-\n-        String originalLogLevel = setupLogLevel(2);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level is VERBOSE the stack trace is logged.\n-     */\n-    @Test\n-    public void logExceptionStackTrace() {\n-        String logMessage = \"This is an exception fdsafdafdomcklamfd fdsafdafmlkdfmalsf fdsafdcacdalmd\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests whether a log will contain the exception message when the ClientLogger and message are configured to the\n+     * passed log levels.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithErrorLevel() {\n+    @ParameterizedTest\n+    @MethodSource(\"multiLevelCheckSupplier\")\n+    public void logException(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String logMessage = \"This is an exception\";\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        RuntimeException runtimeException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 4, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage, runtimeException);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n+        assertEquals(logContainsStackTrace, logValues.contains(runtimeException.getStackTrace()[0].toString()));\n     }\n \n-\n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a RuntimeException as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithNoLogLevel() {\n-        String logMessage = \"This is an exception\";\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 5, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.isEmpty());\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a Throwable as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionWithInvalidLogLevel() {\n-        String logMessage = \"This is an exception\";\n-        Object runtimeException = new Object();\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logCheckedExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n+        String exceptionMessage = \"An exception message\";\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsWarning(ioException);\n+        } catch (Throwable throwable) {\n+            assertTrue(throwable instanceof IOException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(ioException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning won't include the stack trace when the environment log level isn't\n-     * VERBOSE. Additionally, this tests that the exception message isn't logged twice as logging an exception uses\n-     * the exception message as the format string.\n+     * Tests that logging a RuntimeException as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningOnlyExceptionMessage() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(2);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsError(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(exceptionMessage + System.lineSeparator()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning will include the stack trace when the environment log level is set to\n-     * VERBOSE.\n+     * Tests that logging a Throwable as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningStackTrace() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logCheckedExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsError(ioException);\n+        } catch (Throwable throwable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTExMA=="}, "originalCommit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTc2MjU4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOToxNzowM1rOF4Tbuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOTo0MDo1N1rOF4UMfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Mjk3MQ==", "bodyText": "Since this applies to all throwables, we can name this logThrowableAsError", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394582971", "createdAt": "2020-03-18T19:17:03Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -134,37 +135,76 @@ public void error(String format, Object... args) {\n \n     /**\n      * Logs the {@link RuntimeException} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsWarning(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n-     * @return The passed {@code RuntimeException}.\n+     * @return The passed {@link RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsWarning(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsWarning(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsWarning(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsWarning(T checkedException) {\n+        Objects.requireNonNull(checkedException, \"'checkedException' cannot be null.\");\n         if (!logger.isWarnEnabled()) {\n-            return runtimeException;\n+            return checkedException;\n         }\n \n-        performLogging(LogLevel.WARNING, true, runtimeException.getMessage(), runtimeException);\n-        return runtimeException;\n+        performLogging(LogLevel.WARNING, true, checkedException.getMessage(), checkedException);\n+        return checkedException;\n     }\n \n     /**\n      * Logs the {@link RuntimeException} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsError(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n      * @return The passed {@code RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsError(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsError(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsError(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsError(T checkedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5NTQ1Mg==", "bodyText": "Renamed", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394595452", "createdAt": "2020-03-18T19:40:57Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -134,37 +135,76 @@ public void error(String format, Object... args) {\n \n     /**\n      * Logs the {@link RuntimeException} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsWarning(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n-     * @return The passed {@code RuntimeException}.\n+     * @return The passed {@link RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsWarning(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsWarning(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsWarning(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsWarning(T checkedException) {\n+        Objects.requireNonNull(checkedException, \"'checkedException' cannot be null.\");\n         if (!logger.isWarnEnabled()) {\n-            return runtimeException;\n+            return checkedException;\n         }\n \n-        performLogging(LogLevel.WARNING, true, runtimeException.getMessage(), runtimeException);\n-        return runtimeException;\n+        performLogging(LogLevel.WARNING, true, checkedException.getMessage(), checkedException);\n+        return checkedException;\n     }\n \n     /**\n      * Logs the {@link RuntimeException} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsError(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n      * @return The passed {@code RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsError(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsError(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsError(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsError(T checkedException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Mjk3MQ=="}, "originalCommit": {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 138, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}