{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NDYyMjY5", "number": 10430, "title": "ServiceBusReceiverClient : Setting up Integration test", "bodyText": "ServiceBusReceiverClient : Setting up Integration test", "createdAt": "2020-04-22T18:28:10Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430", "merged": true, "mergeCommit": {"oid": "1375e21cd0a267d46f71f57d6ac09c42d226735f"}, "closed": true, "closedAt": "2020-04-24T23:52:57Z", "author": {"login": "hemanttanwar"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaMkeigH2gAyNDA3NDYyMjY5OjFkMzEyNjVmYzk0MGU5OTAxZmIzMWM2NzFmNzIyMjNkZGYxZWRhMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABca5s82AH2gAyNDA3NDYyMjY5Ojk5N2QyNDI3NDYzMGViMDM5OTc3OWRiNWZmNDc2MWE0ODljZDBmMDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1d31265fc940e9901fb31c671f72223ddf1eda14", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d31265fc940e9901fb31c671f72223ddf1eda14", "committedDate": "2020-04-22T18:26:49Z", "message": "Setting up sync receiver client integration test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NDY2OTcz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#pullrequestreview-398466973", "createdAt": "2020-04-22T18:31:40Z", "commit": {"oid": "1d31265fc940e9901fb31c671f72223ddf1eda14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODozMTo0MVrOGKFB0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODozMTo0MVrOGKFB0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMTMyOQ==", "bodyText": "I am moving common ,between sync and async client,   part in IntegrationTestBase", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r413221329", "createdAt": "2020-04-22T18:31:41Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -224,4 +238,38 @@ protected void dispose(AutoCloseable... closeables) {\n             }\n         }\n     }\n+\n+    static Stream<Arguments> messagingEntityProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d31265fc940e9901fb31c671f72223ddf1eda14"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5237322db8dfba09cc12d0f7fa90d91b42c3165", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5237322db8dfba09cc12d0f7fa90d91b42c3165", "committedDate": "2020-04-23T21:49:05Z", "message": "adding sync test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/865d04f007027162a75429a3ef6f35cc6ad35302", "committedDate": "2020-04-23T21:55:19Z", "message": "adding sync test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTI1ODUw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#pullrequestreview-399525850", "createdAt": "2020-04-23T22:39:16Z", "commit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjozOToxNlrOGK-9vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjo0NjoxNlrOGK_JiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MDU1OA==", "bodyText": "private modifier for both.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414170558", "createdAt": "2020-04-23T22:39:16Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -50,6 +62,9 @@\n     private String testName;\n     private final Scheduler scheduler = Schedulers.parallel();\n \n+    static final byte[] CONTENTS_BYTES = \"Some-contents\".getBytes(StandardCharsets.UTF_8);\n+    String sessionId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MTk0Mw==", "bodyText": "You could probably move this BeforeAll and AfterAll setup into the base class because we want there to be a timeout.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414171943", "createdAt": "2020-04-23T22:42:29Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveAsyncOptions;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    ServiceBusReceiverClient receiver;\n+    ServiceBusSenderClient sender;\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MTk5Mg==", "bodyText": "private", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414171992", "createdAt": "2020-04-23T22:42:36Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveAsyncOptions;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    ServiceBusReceiverClient receiver;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MjcxOA==", "bodyText": "This would be Act. And the line after would be Assert.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414172718", "createdAt": "2020-04-23T22:44:17Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveAsyncOptions;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    ServiceBusReceiverClient receiver;\n+    ServiceBusSenderClient sender;\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        dispose(sender);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        for(ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        for(ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MjgwNQ==", "bodyText": "It's Act and then Assert. For all the other ones.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414172805", "createdAt": "2020-04-23T22:44:31Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveAsyncOptions;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    ServiceBusReceiverClient receiver;\n+    ServiceBusSenderClient sender;\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        dispose(sender);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        for(ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        for(ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MjcxOA=="}, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MzE5Mg==", "bodyText": "Indent 4 spaces rather than matching it with the method name.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414173192", "createdAt": "2020-04-23T22:45:26Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveAsyncOptions;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    ServiceBusReceiverClient receiver;\n+    ServiceBusSenderClient sender;\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        dispose(sender);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        for(ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        for(ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());\n+        assertMessageEquals(receivedPeekMessage, messageId, isSessionEnabled);\n+\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekBatchMessages(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+        final int maxMessages = 2;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatch(maxMessages);\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void peekBatchMessagesFromSequence(MessagingEntityType entityType) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, false);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, false);\n+        final int maxMessages = 2;\n+        final int fromSequenceNumber = 1;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Assert & Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatchAt(maxMessages, fromSequenceNumber);\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can dead-letter a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void deadLetterMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        receiver.deadLetter(receivedMessage);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveAndComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        receiver.complete(receivedMessage);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can renew message lock.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void receiveAndRenewLock(MessagingEntityType entityType) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, false);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, false);\n+\n+        // Blocking here because it is not part of the scenario we want to test.\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+        Assertions.assertNotNull(receivedMessage);\n+\n+        assertNotNull(receivedMessage);\n+        assertNotNull(receivedMessage.getLockedUntil());\n+\n+        final Instant initialLock = receivedMessage.getLockedUntil();\n+        logger.info(\"Received message. Seq: {}. lockedUntil: {}\", receivedMessage.getSequenceNumber(), initialLock);\n+\n+        // Assert & Act\n+        try {\n+            Instant lockedUntil = receiver.renewMessageLock(receivedMessage);\n+            assertTrue(lockedUntil.isAfter(initialLock),\n+                String.format(\"Updated lock is not after the initial Lock. updated: [%s]. initial:[%s]\",\n+                    lockedUntil, initialLock));\n+        } finally {\n+            logger.info(\"Completing message. Seq: {}.\", receivedMessage.getSequenceNumber());\n+            receiver.complete(receivedMessage);\n+            messagesPending.decrementAndGet();\n+        }\n+    }\n+\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveAndAbandon(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+        Assertions.assertNotNull(receivedMessage);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        receiver.abandon(receivedMessage);\n+    }\n+\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveAndDefer(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+        Assertions.assertNotNull(receivedMessage);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Act & Assert\n+        receiver.defer(receivedMessage);\n+\n+    }\n+\n+\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void sendReceiveMessageWithVariousPropertyTypes(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage messageToSend = getMessage(messageId, isSessionEnabled);\n+\n+        Map<String, Object> sentProperties = messageToSend.getProperties();\n+        sentProperties.put(\"NullProperty\", null);\n+        sentProperties.put(\"BooleanProperty\", true);\n+        sentProperties.put(\"ByteProperty\", (byte) 1);\n+        sentProperties.put(\"ShortProperty\", (short) 2);\n+        sentProperties.put(\"IntProperty\", 3);\n+        sentProperties.put(\"LongProperty\", 4L);\n+        sentProperties.put(\"FloatProperty\", 5.5f);\n+        sentProperties.put(\"DoubleProperty\", 6.6f);\n+        sentProperties.put(\"CharProperty\", 'z');\n+        sentProperties.put(\"UUIDProperty\", UUID.randomUUID());\n+        sentProperties.put(\"StringProperty\", \"string\");\n+\n+        sendMessage(messageToSend);\n+\n+        // Assert & Act\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiveAndDeleteReceiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+        Assertions.assertNotNull(receivedMessage);\n+\n+        messagesPending.decrementAndGet();\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+\n+        final Map<String, Object> received = receivedMessage.getProperties();\n+\n+        assertEquals(sentProperties.size(), received.size());\n+\n+        for (Map.Entry<String, Object> sentEntry : sentProperties.entrySet()) {\n+            if (sentEntry.getValue() != null && sentEntry.getValue().getClass().isArray()) {\n+                assertArrayEquals((Object[]) sentEntry.getValue(), (Object[]) received.get(sentEntry.getKey()));\n+            } else {\n+                final Object expected = sentEntry.getValue();\n+                final Object actual = received.get(sentEntry.getKey());\n+\n+                assertEquals(expected, actual, String.format(\n+                    \"Key '%s' does not match. Expected: '%s'. Actual: '%s'\", sentEntry.getKey(), expected,\n+                    actual));\n+            }\n+        }\n+    }\n+\n+    private void setSenderAndReceiver(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        setSenderAndReceiver(entityType, isSessionEnabled, Function.identity());\n+    }\n+\n+    private void setSenderAndReceiver(MessagingEntityType entityType, boolean isSessionEnabled,\n+                                      Function<ServiceBusClientBuilder.ServiceBusReceiverClientBuilder, ServiceBusClientBuilder.ServiceBusReceiverClientBuilder> onReceiverCreate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MzU3Nw==", "bodyText": "What about cases where no messages are received in that time out period? Or if you try to receive two batches, one after the other?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414173577", "createdAt": "2020-04-23T22:46:16Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9a3e79c795fa68acb77d8b7f454a66592d3af32", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9a3e79c795fa68acb77d8b7f454a66592d3af32", "committedDate": "2020-04-24T00:30:50Z", "message": "adding sync test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5baa5c8f404338c74eb60221ade25116dadaed4", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5baa5c8f404338c74eb60221ade25116dadaed4", "committedDate": "2020-04-24T03:21:19Z", "message": "Fixing space and formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b05b86eceedbfdad509f249d2eefc0dfdcf67e3", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7b05b86eceedbfdad509f249d2eefc0dfdcf67e3", "committedDate": "2020-04-24T06:46:12Z", "message": "Added test for no message received"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b5851babfff4c6e7d3b351e70b1898a65dfa697", "committedDate": "2020-04-24T06:57:34Z", "message": " checkstyle changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDIwMjg2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#pullrequestreview-400020286", "createdAt": "2020-04-24T14:54:20Z", "commit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDo1NDoyMVrOGLblGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNToxMDozMlrOGLcVQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzOTM4NQ==", "bodyText": "nit: remove extra line", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414639385", "createdAt": "2020-04-24T14:54:21Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -68,6 +82,17 @@ public void setupTest(TestInfo testInfo) {\n         beforeTest();\n     }\n \n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MDUxNw==", "bodyText": "The visibility is confusing because many of the methods are protected but these ones, and the methods (Stream) you've moved in here are package-private. I'd change the visibility to all protected, then.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414640517", "createdAt": "2020-04-24T14:55:50Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -50,6 +62,9 @@\n     private String testName;\n     private final Scheduler scheduler = Schedulers.parallel();\n \n+    static final byte[] CONTENTS_BYTES = \"Some-contents\".getBytes(StandardCharsets.UTF_8);\n+    String sessionId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MDU1OA=="}, "originalCommit": {"oid": "865d04f007027162a75429a3ef6f35cc6ad35302"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MDkyOA==", "bodyText": "Format this document. There are two spaces here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414640928", "createdAt": "2020-04-24T14:56:20Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -59,6 +71,8 @@ public void setupTest(TestInfo testInfo) {\n         logger.info(\"========= SET-UP [{}] =========\", testInfo.getDisplayName());\n \n         testName = testInfo.getDisplayName();\n+        TestMode mode = getTestMode();\n+        boolean isRecord =  getTestMode() == TestMode.RECORD;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MTMzMQ==", "bodyText": "Test classes don't need to be public.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414641331", "createdAt": "2020-04-24T14:56:49Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MTkzNw==", "bodyText": "These can be private final and group your member variables together. private finals, privates together, static variables together.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414641937", "createdAt": "2020-04-24T14:57:35Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MzI4Nw==", "bodyText": "Format this document. There should be a space before the colon.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414643287", "createdAt": "2020-04-24T14:59:16Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0Mzg1OA==", "bodyText": "You didn't assert that you had two messages. If there were 0 messages, this would still pass.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414643858", "createdAt": "2020-04-24T15:00:03Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NDQxMA==", "bodyText": "Auto-complete is not supported in the synchronous scenario. I would expect you to be completing these manually.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414644410", "createdAt": "2020-04-24T15:00:42Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NjU1OA==", "bodyText": "https://www.jetbrains.com/help/idea/reformat-and-rearrange-code.html", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414646558", "createdAt": "2020-04-24T15:03:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MTkzNw=="}, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzIyNw==", "bodyText": "This would still pass with 0 items in the collection.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414647227", "createdAt": "2020-04-24T15:04:26Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzM0Mg==", "bodyText": "There should be a space before the colon.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414647342", "createdAt": "2020-04-24T15:04:34Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzU1OQ==", "bodyText": "You only received one message and sent one message, this should be decremented once.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414647559", "createdAt": "2020-04-24T15:04:52Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0ODIzMg==", "bodyText": "The reason this is here is that when we successfully receive a message, we don't need to clean it up in after test case scenario. This should be in the foreach block. Same with any uses below.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414648232", "createdAt": "2020-04-24T15:05:49Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0ODc4OQ==", "bodyText": "This should be in the foreach loop as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414648789", "createdAt": "2020-04-24T15:06:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzU1OQ=="}, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0OTM0NA==", "bodyText": "nit: variable name: Ite?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414649344", "createdAt": "2020-04-24T15:07:11Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+\n+        // Assert\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MDI2Nw==", "bodyText": "Is this assertion necessary? If the list was empty, the .get(0) would fail with an out of range exception. The assertion is probably Assertions.assertEquals(1, asList.size()) before you get the first item.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414650267", "createdAt": "2020-04-24T15:08:28Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+\n+        // Assert\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MDkwOA==", "bodyText": "You should be asserting that the messages also start from that sequence number.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414650908", "createdAt": "2020-04-24T15:09:20Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+\n+        // Assert\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());\n+\n+        // Assert\n+        assertMessageEquals(receivedPeekMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekBatchMessages(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+        final int maxMessages = 2;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatch(maxMessages);\n+\n+        // Assert\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void peekBatchMessagesFromSequence(MessagingEntityType entityType) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, false);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, false);\n+        final int maxMessages = 2;\n+        final int fromSequenceNumber = 1;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatchAt(maxMessages, fromSequenceNumber);\n+\n+        // Assert\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MTIyNg==", "bodyText": "You should also assert that the message is from that sequence number.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414651226", "createdAt": "2020-04-24T15:09:49Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+\n+        // Assert\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());\n+\n+        // Assert\n+        assertMessageEquals(receivedPeekMessage, messageId, isSessionEnabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MTU0Nw==", "bodyText": "Same with the comment above. If you did .get(0) and the list was empty, it would throw. This check is incorrect.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414651547", "createdAt": "2020-04-24T15:10:18Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+\n+        // Assert\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());\n+\n+        // Assert\n+        assertMessageEquals(receivedPeekMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekBatchMessages(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+        final int maxMessages = 2;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatch(maxMessages);\n+\n+        // Assert\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void peekBatchMessagesFromSequence(MessagingEntityType entityType) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, false);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, false);\n+        final int maxMessages = 2;\n+        final int fromSequenceNumber = 1;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatchAt(maxMessages, fromSequenceNumber);\n+\n+        // Assert\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can dead-letter a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void deadLetterMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MTcxNA==", "bodyText": "And all other instances of it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414651714", "createdAt": "2020-04-24T15:10:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+public class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    final AtomicInteger messagesPending = new AtomicInteger();\n+    final AtomicReference<List<Long>>  messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" +  receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages =  messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we do not receive any message in given timeout.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 2;\n+        int noMessages = 0;\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, Duration.ofSeconds(15));\n+\n+        // Assert\n+        final int receivedMessages = iterableMessages.stream().collect(Collectors.toList()).size();\n+        assertEquals(noMessages, receivedMessages);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive one messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int howManyMessage = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        Iterable<ServiceBusReceivedMessage> iterableMessages = receiver.receive(howManyMessage, TIMEOUT);\n+\n+        // Assert\n+        for (ServiceBusReceivedMessage receivedMessage: iterableMessages) {\n+            assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+        }\n+\n+        messagesPending.decrementAndGet();\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedMessage = receiver.peek();\n+\n+        // Assert\n+        assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekFromSequenceNumberMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);\n+\n+        // Act\n+        ServiceBusReceivedMessage receivedPeekMessage = receiver.peekAt(receivedMessage.getSequenceNumber());\n+\n+        // Assert\n+        assertMessageEquals(receivedPeekMessage, messageId, isSessionEnabled);\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void peekBatchMessages(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+        final int maxMessages = 2;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatch(maxMessages);\n+\n+        // Assert\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can send and peek a batch of messages.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void peekBatchMessagesFromSequence(MessagingEntityType entityType) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, false);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, false);\n+        final int maxMessages = 2;\n+        final int fromSequenceNumber = 1;\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> iterableMessages = receiver.peekBatchAt(maxMessages, fromSequenceNumber);\n+\n+        // Assert\n+        Assertions.assertEquals(maxMessages, iterableMessages.stream().collect(Collectors.toList()).size());\n+    }\n+\n+    /**\n+     * Verifies that we can dead-letter a message.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void deadLetterMessage(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        final IterableStream<ServiceBusReceivedMessage> messageIte = receiver.receive(1, TIMEOUT);\n+        Assertions.assertNotNull(messageIte);\n+\n+        final List<ServiceBusReceivedMessage> asList = messageIte.stream().collect(Collectors.toList());\n+        ServiceBusReceivedMessage receivedMessage = asList.get(0);\n+\n+        assertNotNull(receivedMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MTU0Nw=="}, "originalCommit": {"oid": "1b5851babfff4c6e7d3b351e70b1898a65dfa697"}, "originalPosition": 291}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21a8f72f3d234886688defc556ad97c29171ee69", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21a8f72f3d234886688defc556ad97c29171ee69", "committedDate": "2020-04-24T16:55:08Z", "message": "more test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4879609a78ed369f03b76d6e685fb9a99874f046", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4879609a78ed369f03b76d6e685fb9a99874f046", "committedDate": "2020-04-24T16:55:38Z", "message": "more test fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTE4ODEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#pullrequestreview-400118811", "createdAt": "2020-04-24T17:00:03Z", "commit": {"oid": "4879609a78ed369f03b76d6e685fb9a99874f046"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzowMDowNFrOGLg0eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzowMjoxMlrOGLg54Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNTI0MQ==", "bodyText": "nit: extra line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414725241", "createdAt": "2020-04-24T17:00:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,590 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+    private final AtomicReference<List<Long>> messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4879609a78ed369f03b76d6e685fb9a99874f046"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNTQ5Mw==", "bodyText": "Use logger.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414725493", "createdAt": "2020-04-24T17:00:28Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,590 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+    private final AtomicReference<List<Long>> messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" + receivedMessage.getSequenceNumber());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4879609a78ed369f03b76d6e685fb9a99874f046"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNjYyNQ==", "bodyText": "Should use placeholders so it can be lazily evaluated.\nhttp://www.slf4j.org/faq.html#logging_performance", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414726625", "createdAt": "2020-04-24T17:02:12Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,590 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+    private final AtomicReference<List<Long>> messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    System.out.println(\"Removed Message sequence : \" + receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages = messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity : \" + receiver.getEntityPath(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4879609a78ed369f03b76d6e685fb9a99874f046"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ae1cc9997585554964f90c0ce2c3bd1a899bb76", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ae1cc9997585554964f90c0ce2c3bd1a899bb76", "committedDate": "2020-04-24T18:10:44Z", "message": "more test fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjI0MzIy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#pullrequestreview-400224322", "createdAt": "2020-04-24T19:44:04Z", "commit": {"oid": "3ae1cc9997585554964f90c0ce2c3bd1a899bb76"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTo0NDowNFrOGLmoWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTo0OToxOVrOGLmy9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMDQ0MQ==", "bodyText": "Do we need the empty set? This is done during clean up. The class will be recreated after every method.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414820441", "createdAt": "2020-04-24T19:44:04Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,595 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+    private final AtomicReference<List<Long>> messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    logger.info(\"Removed Message Seq: {} \", receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages = messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity: {} \", receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae1cc9997585554964f90c0ce2c3bd1a899bb76"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMTgyNA==", "bodyText": "A better way is to count the number of time you go into the loop and assert at the end rather than creating the list eagerly.\nint count = 0;\nfor (Message m : messages) {\n    count++;\n}\nassertEquals(2, count);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414821824", "createdAt": "2020-04-24T19:46:36Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,595 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+    private final AtomicReference<List<Long>> messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    logger.info(\"Removed Message Seq: {} \", receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages = messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity: {} \", receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAndComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int maxMessages = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> messages = receiver.receive(maxMessages, TIMEOUT);\n+\n+        // Assert\n+        final List<ServiceBusReceivedMessage> asList = messages.stream().collect(Collectors.toList());\n+        assertEquals(maxMessages, asList.size());\n+\n+        for (ServiceBusReceivedMessage receivedMessage : asList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae1cc9997585554964f90c0ce2c3bd1a899bb76"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMjI5Mg==", "bodyText": "Same with other instances.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414822292", "createdAt": "2020-04-24T19:47:35Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,595 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {\n+\n+    /* Sometime not all the messages are cleaned-up. This is buffer to ensure all the messages are cleaned-up.*/\n+    private static final int BUFFER_MESSAGES_TO_REMOVE = 10;\n+\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+    private final AtomicReference<List<Long>> messagesDeferred = new AtomicReference<>(new ArrayList<>());\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClientIntegrationTest.class);\n+\n+    private ServiceBusReceiverClient receiver;\n+    private ServiceBusSenderClient sender;\n+\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverClient receiveAndDeleteReceiver;\n+\n+    protected ServiceBusReceiverClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusReceiverClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        final int pending = messagesPending.get();\n+        if (pending < 1 && messagesDeferred.get().size() < 1) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        if (pending > 0) {\n+            try {\n+                IterableStream<ServiceBusReceivedMessage> removedMessage = receiveAndDeleteReceiver.receive(\n+                    pending + BUFFER_MESSAGES_TO_REMOVE);\n+                removedMessage.stream().forEach(receivedMessage -> {\n+                    logger.info(\"Removed Message Seq: {} \", receivedMessage.getSequenceNumber());\n+                });\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining queue.\", e);\n+            }\n+        }\n+\n+        if (messagesDeferred.get().size() > 0) {\n+            try {\n+                List<Long> listOfDeferredMessages = messagesDeferred.get();\n+                for (Long seqNumber : listOfDeferredMessages) {\n+                    ServiceBusReceivedMessage deferredMessages = receiver.receiveDeferredMessage(seqNumber);\n+                    receiver.complete(deferredMessages);\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Error occurred when draining deferred messages Entity: {} \", receiver.getEntityPath(), e);\n+            }\n+\n+            // set empty list\n+            messagesDeferred.set(new ArrayList<>());\n+        }\n+\n+        dispose(receiver, sender, receiveAndDeleteReceiver);\n+    }\n+\n+    /**\n+     * Verifies that we can send and receive two messages.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAndComplete(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int maxMessages = 2;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+        sendMessage(message);\n+\n+        // Act\n+        IterableStream<ServiceBusReceivedMessage> messages = receiver.receive(maxMessages, TIMEOUT);\n+\n+        // Assert\n+        final List<ServiceBusReceivedMessage> asList = messages.stream().collect(Collectors.toList());\n+        assertEquals(maxMessages, asList.size());\n+\n+        for (ServiceBusReceivedMessage receivedMessage : asList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMTgyNA=="}, "originalCommit": {"oid": "3ae1cc9997585554964f90c0ce2c3bd1a899bb76"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMzE1OA==", "bodyText": "One test case you're missing is what happens if we receive() twice. Customers would probably try this in a loop several times rather than once.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10430#discussion_r414823158", "createdAt": "2020-04-24T19:49:19Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,595 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.DispositionStatus;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Integration tests for {@link ServiceBusReceiverClient} from queues or subscriptions.\n+ */\n+class ServiceBusReceiverClientIntegrationTest extends IntegrationTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae1cc9997585554964f90c0ce2c3bd1a899bb76"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "997d24274630eb0399779db5ff4761a489cd0f08", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/997d24274630eb0399779db5ff4761a489cd0f08", "committedDate": "2020-04-24T23:01:48Z", "message": "Adding test for two receive() calls"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4778, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}