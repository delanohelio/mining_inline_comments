{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzU4MjYz", "number": 14781, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0NjoxOVrOEgEy7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMTowOFrOEgJWdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDY4NDYyOnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0NjoxOVrOHMvMYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0NjoxOVrOHMvMYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExODE3Nw==", "bodyText": ".map(Response::getValue) returns null, which is not a valid return item from a Mono. So we need to map it to Mono.empty() instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483118177", "createdAt": "2020-09-03T16:46:19Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "diffHunk": "@@ -909,7 +909,7 @@ public HttpPipeline getHttpPipeline() {\n     @ServiceMethod(returns = ReturnType.SINGLE)\n     public Mono<Void> deleteModel(String modelId) {\n         return deleteModelWithResponse(modelId)\n-            .map(Response::getValue);\n+            .flatMap(voidResponse -> Mono.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDY5MTI0OnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0ODowOFrOHMvQQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo0ODowOFrOHMvQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExOTE2OQ==", "bodyText": "This implementation is very long and verbose. I am trying to see how I could chain the list and delete operations together, I'll put up an update in the next PR.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483119169", "createdAt": "2020-09-03T16:48:08Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +98,250 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDcxNTQ5OnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo1NDo1MlrOHMvf2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjo1NDo1MlrOHMvf2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyMzE2Mg==", "bodyText": "We should have been able to schedule the async API on a single thread, and forced them to run sequentially; however, I didn't have success with that.\nI am blocking the async API call for now, until I figure that out.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483123162", "createdAt": "2020-09-03T16:54:52Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +98,249 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(throwable -> {\n+                    if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"List relationships error: \" + throwable);\n+                    }\n+                })\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(throwable -> {\n+                    if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"List incoming relationships error: \" + throwable);\n+                    }\n+                })\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(throwable -> {\n+                            if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                                System.err.println(\"List relationships error: \" + throwable);\n+                            }\n+                        })\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n                     .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n+                        if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                            System.err.println(\"Delete twin error: \" + throwable);\n                         }\n                     })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.\n+                deleteTwinsLatch.await(MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+    }\n \n+    /**\n+     * Delete models created by FullLifecycleSample for the ADT service instance.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n+     */\n+    public static void deleteAllModels() throws InterruptedException {\n+        System.out.println(\"DELETING MODELS\");\n+\n+        // This is to ensure models are deleted in an order such that no other models are referencing it.\n+        List<String> models = asList(RoomModelId, WifiModelId, BuildingModelId, FloorModelId, HvacModelId);\n+\n+        // Call APIs to delete the models.\n+        // Note that we are blocking the async API call. This is to ensure models are deleted in an order such that no other models are referencing it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f48f680a71b1923b7773bb1092fc2672e571519"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTMyNzExOnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo1OTo0MFrOHM1fUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo1OTo0MFrOHM1fUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyMTMzMQ==", "bodyText": "Oops", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483221331", "createdAt": "2020-09-03T19:59:40Z", "author": {"login": "azabbasi"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "diffHunk": "@@ -788,7 +788,7 @@ public HttpPipeline getHttpPipeline() {\n                         objectPagedResponse.getHeaders(),\n                         convertedList,\n                         null,\n-                        ((PagedResponseBase) objectPagedResponse).getDeserializedHeaders());\n+                        ((ResponseBase) objectPagedResponse).getDeserializedHeaders());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTM5NDE5OnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyMDoxNFrOHM2IUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMDoyOVrOHM2eRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA==", "bodyText": "For each async delete? Can you elaborate what you mean here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483231824", "createdAt": "2020-09-03T20:20:14Z", "author": {"login": "bikamani"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNDI2Ng==", "bodyText": "What is a latch?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483234266", "createdAt": "2020-09-03T20:24:03Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA=="}, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTc5Ng==", "bodyText": "Appears to be some kind of threadsafe counter, eh?\nI'd reword this to be \"Wait until the latch count reaches zero...\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483235796", "createdAt": "2020-09-03T20:27:06Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA=="}, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzQ0NA==", "bodyText": "A countdown latch is a mechanism to block the calling thread until other threads that are running in parallel have completed (counted down). The .countdown() essentially decrements a thread-safe counter.\nFrom this article online: https://www.baeldung.com/java-countdown-latch\nSimply put, a CountDownLatch has a counter field, which you can decrement as we require. We can then use it to block a calling thread until it's been counted down to zero.\nIf we were doing some parallel processing, we could instantiate the CountDownLatch with the same value for the counter as a number of threads we want to work across. Then, we could just call countdown() after each thread finishes, guaranteeing that a dependent thread calling await() will block until the worker threads are finished.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237444", "createdAt": "2020-09-03T20:30:29Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA=="}, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTQxNDQ1OnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyNTo0M1rOHM2VHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMzo0N1rOHM2j5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTEwMw==", "bodyText": "Does Java support string interpolation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483235103", "createdAt": "2020-09-03T20:25:43Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzODg4NA==", "bodyText": "We can use String.format() to specify a template, but nothing as handy as $ in C#.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483238884", "createdAt": "2020-09-03T20:33:47Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTEwMw=="}, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTQyNzEzOnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyOTo0NlrOHM2c6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDo0MDoyNFrOHM2vpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzA5OA==", "bodyText": "Unfortunate that you have to know ahead of time how many items you are counting down. This presents a \"magic\" number, which can be confusing to someone else reviewing the code who doesn't realize the significance (this will be used to asynchronously delete 1 dt).\nAlso, in C# we have a general rule of not declaring a variable until it is needed (so it is more contextual). Does Java have a different standard of all variables at the top?\nFWIW, I think this could at least use a comment.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237098", "createdAt": "2020-09-03T20:29:46Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI0MTg5NQ==", "bodyText": "We need to initialize these latches and semaphore within the scope that they are referenced in; but yes, I agree, the count can be confusing to understand.\nI'll add some more comments around this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483241895", "createdAt": "2020-09-03T20:40:24Z", "author": {"login": "abhipsaMisra"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzA5OA=="}, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTQzMDk0OnYy", "diffSide": "RIGHT", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMTowOFrOHM2fUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDozMTowOFrOHM2fUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzcxMw==", "bodyText": "If Java doesn't have string interpolation, I'd think this would be much more readable as a string format (like below).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237713", "createdAt": "2020-09-03T20:31:08Z", "author": {"login": "drwill-ms"}, "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.\n+                deleteTwinsLatch.await(MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Delete models created by FullLifecycleSample for the ADT service instance.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n+     */\n+    public static void deleteAllModels() throws InterruptedException {\n+        System.out.println(\"DELETING MODELS\");\n+\n+        // This is to ensure models are deleted in an order such that no other models are referencing it.\n+        List<String> models = asList(RoomModelId, WifiModelId, BuildingModelId, FloorModelId, HvacModelId);\n \n+        // Call APIs to delete the models.\n+        // Note that we are blocking the async API call. This is to ensure models are deleted in an order such that no other models are referencing it.\n+        models\n+            .forEach(modelId -> {\n                 try {\n-                    // Verify that the list relationships and list incoming relationships async operations have completed.\n-                    if (deleteRelationshipsSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n-                        // Now the digital twin should be safe to delete\n-\n-                        // Call APIs to delete the twins.\n-                        client.deleteDigitalTwin(twinId)\n-                            .doOnSuccess(aVoid -> {\n-                                System.out.println(\"Deleted digital twin: \" + twinId);\n-                                deleteTwinsSemaphore.release();\n-                            })\n-                            .doOnError(throwable -> {\n-                                if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                                    deleteTwinsSemaphore.release();\n-                                } else {\n-                                    System.err.println(\"Could not delete digital twin \" + twinId + \" due to \" + throwable);\n-                                }\n-                            })\n-                            .subscribe();\n+                    client.deleteModel(modelId).block();\n+                    System.out.println(\"Deleted model: \" + modelId);\n+                } catch (ErrorResponseException ex) {\n+                    if (ex.getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"Could not delete model \" + modelId + \" due to \" + ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f"}, "originalPosition": 211}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1257, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}