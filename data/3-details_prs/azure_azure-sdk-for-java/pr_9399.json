{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNDcxMzU5", "number": 9399, "title": "Adding throughput /latency workload for multi client", "bodyText": "Idea is to create workload to test throughput and latency of the SDK with multiple clients with sharing transport layer.\nClients host and key will be fetch from clientHostAndKey.txt.\nData will be created before the test starts in all accounts and then it will do random read across them.\nTwo extra program arguments are added\n1.int throughPutForMultiClient - for collection create (default is 100000)\n2.boolean deleteCollections - if this set, it will just delete the existing containers with container id  provided in argument -collectionId in all the accounts , help in running the test fresh.", "createdAt": "2020-03-23T15:53:26Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399", "merged": true, "mergeCommit": {"oid": "4bbe4ee89a8cfec5572282c96471b6ba4ac73523"}, "closed": true, "closedAt": "2020-03-27T19:01:21Z", "author": {"login": "simplynaveen20"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPoYakgH2gAyMzkyNDcxMzU5OjQ5MDZhNjVjMjkyODBkOWQ5YjJmNGU2YmIwNDc3NzU2Y2M3YmJhNGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcR0tAYgFqTM4MzA5MDc2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4906a65c29280d9d9b2f4e6bb0477756cc7bba4e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4906a65c29280d9d9b2f4e6bb0477756cc7bba4e", "committedDate": "2020-03-20T22:37:49Z", "message": "adding test for multi client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/189a4797ee947fe43282900eb8fb05e007f6955e", "committedDate": "2020-03-23T15:43:09Z", "message": "Update README.md\n\nupdating read me"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTk0MzI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-379594327", "createdAt": "2020-03-23T16:22:08Z", "commit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjoyMjowOFrOF6NSwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjo0MTowMFrOF6OJJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3OTUyMQ==", "bodyText": "please use logger, not System.out/err.\nPlease do everywhere.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396579521", "createdAt": "2020-03-23T16:22:08Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MDI4NQ==", "bodyText": "please don't use System.out/err.\nuse logger here and elsewhere.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396580285", "createdAt": "2020-03-23T16:23:07Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+\n+                        registry = configuration.getGraphiteMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+                        System.out.println(\"Client have been initialized with data created for host \" + hostAndKey[0]);\n+                    } else {\n+                        System.out.println(\"Client have been initialized with host \" + hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            System.out.println(\"Total number of client created for ReadThroughputWithMultipleClient \" + clientDocsMap.size());\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MTk4Nw==", "bodyText": "we should be using logger everywhere. Please replace System.out with logger here and elsewhere.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396581987", "createdAt": "2020-03-23T16:25:23Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+\n+                        registry = configuration.getGraphiteMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+                        System.out.println(\"Client have been initialized with data created for host \" + hostAndKey[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NDMwNg==", "bodyText": "please use try-with-resources to simplify the try/catch pattern:\nhttps://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396584306", "createdAt": "2020-03-23T16:28:25Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NjIzOQ==", "bodyText": "fix code style.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396586239", "createdAt": "2020-03-23T16:31:04Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -359,6 +375,10 @@ void tryGetValuesFromSystem() {\n         String numberOfOperationsValue = StringUtils.defaultString(\n                 Strings.emptyToNull(System.getenv().get(\"NUMBER_OF_OPERATIONS\")), Integer.toString(numberOfOperations));\n         numberOfOperations = Integer.parseInt(numberOfOperationsValue);\n+\n+        String  throughPutForMultiClientValue = StringUtils.defaultString(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4ODg5NA==", "bodyText": "could you please change format to the pattern that portal provides for connection string:\nAccountEndpoint=https://xyz.documents.azure.com:443/;AccountKey=abc;\n\nThis makes it easier to construct this file copy/pasting from portal", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396588894", "createdAt": "2020-03-23T16:34:41Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/clientHostAndKey.txt", "diffHunk": "@@ -0,0 +1,2 @@\n+<host1>,<key1>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MDkwMQ==", "bodyText": "it seems you are using isDeleteCollections for not only deleting collections but also for creating collection?\nis that right? the config seems to be overloaded.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396590901", "createdAt": "2020-03-23T16:37:25Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTEwNQ==", "bodyText": "it seems you are using deleteCollections for not only deleting collections but also for creating collection?\nis that right? the config seems to be overloaded.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396591105", "createdAt": "2020-03-23T16:37:44Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -76,8 +76,15 @@\n     @Parameter(names = \"-enableJvmStats\", description = \"Enables JVM Stats\")\n     private boolean enableJvmStats;\n \n+    @Parameter(names = \"-throughPutForMultiClientTest\", description = \"throughput on each container for multi client test\")\n+    private int throughPutForMultiClient = 100000;\n+\n+    @Parameter(names = \"-deleteCollections\", description = \"Delete collections on all client with collectionId mentioned in the tool\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5Mjk1Ng==", "bodyText": "meterRegistry is a static setting, why do we need to set it \"inside\" the for loop? shouldn't this be outside?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396592956", "createdAt": "2020-03-23T16:40:21Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MzQ0NQ==", "bodyText": "meterRegistry is a static setting, why do we need to set it \"inside\" the for loop? shouldn't this be outside?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396593445", "createdAt": "2020-03-23T16:41:00Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+\n+                        registry = configuration.getGraphiteMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e"}, "originalPosition": 258}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5168bca395ecd951be6374f3dc5e453c080622da", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5168bca395ecd951be6374f3dc5e453c080622da", "committedDate": "2020-03-23T18:10:55Z", "message": "Merge branch 'latest-master' into users/nakumars/customeBenchMarkFOrMultiAccount"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88b54c96ef3cd9f184ad95aff91a8beace7487b8", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/88b54c96ef3cd9f184ad95aff91a8beace7487b8", "committedDate": "2020-03-23T20:19:45Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/82d075b7ce5202803f1ca01837131a77de01b558", "committedDate": "2020-03-23T20:20:14Z", "message": "Merge branch 'users/nakumars/customeBenchMarkFOrMultiAccount' of https://github.com/simplynaveen20/azure-sdk-for-java into users/nakumars/customeBenchMarkFOrMultiAccount"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTk0Njgy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-382994682", "createdAt": "2020-03-27T16:04:24Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNDoyNFrOF83z5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNDoyNFrOF83z5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MzI4NQ==", "bodyText": "ditto, we should be using logger.error", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373285", "createdAt": "2020-03-27T16:04:24Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            registry = configuration.getGraphiteMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            logger.info(\"Total number of client created for ReadThroughputWithMultipleClient {}\",clientDocsMap.size());\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 275}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTk1MDEw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-382995010", "createdAt": "2020-03-27T16:04:48Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNDo0OFrOF8300Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNDo0OFrOF8300Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MzUyMQ==", "bodyText": "please fix indentation to be consistent with the rest", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373521", "createdAt": "2020-03-27T16:04:48Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -76,8 +76,15 @@\n     @Parameter(names = \"-enableJvmStats\", description = \"Enables JVM Stats\")\n     private boolean enableJvmStats;\n \n+    @Parameter(names = \"-throughputForMultiClientTest\", description = \"throughput on each container for multi client test\")\n+    private int throughputForMultiClient = 100000;\n+\n+    @Parameter(names = \"-deleteCollections\", description = \"Delete collections on all client with collectionId mentioned in the tool\")\n+    private boolean deleteCollections = false;\n+\n     @Parameter(names = \"-operation\", description = \"Type of Workload:\\n\"\n             + \"\\tReadThroughput- run a READ workload that prints only throughput *\\n\"\n+\t\t\t+ \"\\tReadThroughputWithMultipleClients - run a READ workload that prints throughput and latency for multiple client read.*\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTk1NTcw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-382995570", "createdAt": "2020-03-27T16:05:29Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNToyOVrOF832jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNToyOVrOF832jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Mzk2NA==", "bodyText": "code style: you have multiple spaces String  throughputForMultiClientValue -> String throughputForMultiClientValue", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373964", "createdAt": "2020-03-27T16:05:29Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -359,6 +375,10 @@ void tryGetValuesFromSystem() {\n         String numberOfOperationsValue = StringUtils.defaultString(\n                 Strings.emptyToNull(System.getenv().get(\"NUMBER_OF_OPERATIONS\")), Integer.toString(numberOfOperations));\n         numberOfOperations = Integer.parseInt(numberOfOperationsValue);\n+\n+        String  throughputForMultiClientValue = StringUtils.defaultString(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTk1Nzc3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-382995777", "createdAt": "2020-03-27T16:05:43Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNTo0M1rOF833Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNTo0M1rOF833Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NDEyMg==", "bodyText": "code style: space after comma", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399374122", "createdAt": "2020-03-27T16:05:43Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -359,6 +375,10 @@ void tryGetValuesFromSystem() {\n         String numberOfOperationsValue = StringUtils.defaultString(\n                 Strings.emptyToNull(System.getenv().get(\"NUMBER_OF_OPERATIONS\")), Integer.toString(numberOfOperations));\n         numberOfOperations = Integer.parseInt(numberOfOperationsValue);\n+\n+        String  throughputForMultiClientValue = StringUtils.defaultString(\n+                Strings.emptyToNull(System.getenv().get(\"THROUGHPUT_MULTICLIENT\")),Integer.toString(throughputForMultiClient));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTk5Nzg2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-382999786", "createdAt": "2020-03-27T16:10:22Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMDoyMlrOF84DcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMDoyMlrOF84DcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzI2NQ==", "bodyText": "this will print the key as well. can we just print the endpoint. ideally we should not log key anywhere in the log.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399377265", "createdAt": "2020-03-27T16:10:22Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTk5OTQx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-382999941", "createdAt": "2020-03-27T16:10:32Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMDozM1rOF84D7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMDozM1rOF84D7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzM5MQ==", "bodyText": "ditto. we should not log the key", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399377391", "createdAt": "2020-03-27T16:10:33Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 254}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDAwNDYx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-383000461", "createdAt": "2020-03-27T16:11:07Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMTowOFrOF84FYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMTowOFrOF84FYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Nzc2Mg==", "bodyText": "codestyle: space after comma\nplease use intellij autoformatting on this new file.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399377762", "createdAt": "2020-03-27T16:11:08Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            registry = configuration.getGraphiteMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            logger.info(\"Total number of client created for ReadThroughputWithMultipleClient {}\",clientDocsMap.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDAxNTcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-383001572", "createdAt": "2020-03-27T16:12:32Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMjozMlrOF84I8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMjozMlrOF84I8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODY3Mg==", "bodyText": "setting metrics registery should be outside of try/catch block. not related to connection string parsing.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399378672", "createdAt": "2020-03-27T16:12:32Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 259}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDAzOTg1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-383003985", "createdAt": "2020-03-27T16:15:24Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxNToyNFrOF84QkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxNToyNFrOF84QkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MDYyNA==", "bodyText": "if we are creating the collection, we should allow the throughput to be configurable similar to collectionId and databaseId.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399380624", "createdAt": "2020-03-27T16:15:24Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDA5MDcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-383009072", "createdAt": "2020-03-27T16:21:27Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43acc71a0477db1baa2c1a90cdc34183ee5b63e9", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/43acc71a0477db1baa2c1a90cdc34183ee5b63e9", "committedDate": "2020-03-27T16:47:35Z", "message": "Merge branch 'latest-master' into users/nakumars/customeBenchMarkFOrMultiAccount"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDc1NDIy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-383075422", "createdAt": "2020-03-27T17:45:48Z", "commit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNzo0NTo0OFrOF87wdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNzo0NTo0OFrOF87wdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzNzk0Mw==", "bodyText": "we should either make this configurable or fail if the existing collection partition key path is not /pk", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399437943", "createdAt": "2020-03-27T17:45:48Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d075b7ce5202803f1ca01837131a77de01b558"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2648b1d2dd29d27f9f7087755a9238f7b0180600", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2648b1d2dd29d27f9f7087755a9238f7b0180600", "committedDate": "2020-03-27T17:55:10Z", "message": "resolving comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDkwNzYz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#pullrequestreview-383090763", "createdAt": "2020-03-27T18:07:01Z", "commit": {"oid": "2648b1d2dd29d27f9f7087755a9238f7b0180600"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1492, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}