{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNjIwNzg5", "number": 17908, "title": "Added support to lock on version in BlobInputStream", "bodyText": "Resolves #16882\nHere is a gist of this code.\nAdded ConsistentReadControl enum - NONE, E_TAG, VERSION_ID - Documentation for each is on the Enum.\nDefault value - E_TAG\nWe allow for setting etag and versionid at same time.\nIf E_TAG or VERSION_ID specified, we will lock on latest if not specified by user.", "createdAt": "2020-12-01T22:44:10Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908", "merged": true, "mergeCommit": {"oid": "4fcc2094f8336775f6f0f92c22bb89324e899a6f"}, "closed": true, "closedAt": "2021-01-22T21:18:52Z", "author": {"login": "gapra-msft"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiB5W-gH2gAyNTMwNjIwNzg5OjhkYTEzMmNkOTA3NTE1NmE4YjhhMTY2MWQ5OGUxN2I1NDQzYWE5Mjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyurSnAH2gAyNTMwNjIwNzg5OmJjYTA3OTk2NzE1OWM1NTNhOTNhNGEzZDExYmQ1NDRmODQ3NTA4YjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8da132cd9075156a8b8a1661d98e17b5443aa927", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8da132cd9075156a8b8a1661d98e17b5443aa927", "committedDate": "2020-12-01T22:43:13Z", "message": "Added support to lock on version in BlobInputStream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5391e4e4e4ad90f0d395afa5132e2823318f7dd0", "committedDate": "2020-12-01T23:08:26Z", "message": "Removed imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMzc4ODk2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-542378896", "createdAt": "2020-12-01T23:20:21Z", "commit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMDoyMlrOH9D3LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMDoyMlrOH9D3LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ==", "bodyText": "E_TAG or ETAG? In other locations in Storage we already use constants where it doesn't have the _ such as https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/storage/azure-storage-common/src/main/java/com/azure/storage/common/implementation/Constants.java#L221", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533788461", "createdAt": "2020-12-01T23:20:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMzc5NDcx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-542379471", "createdAt": "2020-12-01T23:21:26Z", "commit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMToyNlrOH9D49Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyNDozOVrOH9D-DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODkxNw==", "bodyText": "Do we want to log an informational or warning message here instead of throwing?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533788917", "createdAt": "2020-12-01T23:21:26Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTc1MA==", "bodyText": "Should we make this into two constants as we only have two cases we need to cover and that will eliminate a string format.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533789750", "createdAt": "2020-12-01T23:23:33Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));\n         }\n \n         return new BlobInputStream(client, range.getOffset(), range.getCount(), chunkSize,\n             requestConditions, properties);\n     }\n \n+    private UnsupportedOperationException generateNoneException(String wrongValue, String toSet) {\n+        return new UnsupportedOperationException(String.format(\"'%s' can not be set when 'concurrencyControl'\"\n+            + \" is set to NONE. Set 'concurrencyControl' to %s.\", wrongValue, toSet));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDIyMA==", "bodyText": "Should the error types being thrown here be IllegalStateException instead of UnsupportedOperationException? They feel more like bad states and not like operations that can't be perfromed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533790220", "createdAt": "2020-12-01T23:24:39Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMzkyOTcw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-542392970", "createdAt": "2020-12-01T23:53:26Z", "commit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1MzoyNlrOH9Em8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1MzoyNlrOH9Em8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMDY4OA==", "bodyText": "I think we should be using the customer's requestConditions for this call and THEN locking on the resulting etag.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533800688", "createdAt": "2020-12-01T23:53:26Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMzkzODA4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-542393808", "createdAt": "2020-12-01T23:55:26Z", "commit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1NToyNlrOH9Ep4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1NToyNlrOH9Ep4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTQ0Mw==", "bodyText": "I think we want to throw here if etag is specified and throw above if version is specified", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533801443", "createdAt": "2020-12-01T23:55:26Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMzk1NDc4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-542395478", "createdAt": "2020-12-01T23:59:25Z", "commit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1OToyNVrOH9Ev0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1OToyNVrOH9Ev0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ==", "bodyText": "I don't love the name concurrency control. I think it's technically correct, but it sounds to me more like it's intended to manage like number of threads or something. And etags are for optimistic concurrency, but I don't think versions fits in that linguistic space. That might just be me. It's more about like ensuring a consistent view of the blob for the whole download. It's also weird because they behave differently. Etag will throw if it changes, but version id will never throw as long as the version is not deleted.\n... I don't have any suggestions here though.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533802961", "createdAt": "2020-12-01T23:59:25Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09e4eb52057532f3972a86665d4d3c3548a9ea39", "author": {"user": {"login": "gapra-msft", "name": "Gauri Prasad"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/09e4eb52057532f3972a86665d4d3c3548a9ea39", "committedDate": "2020-12-02T17:28:27Z", "message": "Merge branch 'master' into storage/inputStreamOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe4699c480aa71aeb9d7a89359722493b6fa9f54", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe4699c480aa71aeb9d7a89359722493b6fa9f54", "committedDate": "2020-12-02T17:53:23Z", "message": "Updated based off review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTMyMzQz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-544132343", "createdAt": "2020-12-03T16:17:50Z", "commit": {"oid": "fe4699c480aa71aeb9d7a89359722493b6fa9f54"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoxNzo1MFrOH-k1Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoxNzo1MFrOH-k1Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzI1MQ==", "bodyText": "How about other requestConditions?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535377251", "createdAt": "2020-12-03T16:17:50Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.ETAG\n+            : options.getConcurrencyControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.ETAG.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.VERSION_ID.toString(), ConcurrencyControl.ETAG.toString()));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe4699c480aa71aeb9d7a89359722493b6fa9f54"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf5d119b830ca3486aff335d068a78e487f33a84", "committedDate": "2020-12-03T18:32:11Z", "message": "renamed enum"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjYyODM0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-544262834", "createdAt": "2020-12-03T18:36:35Z", "commit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODozNjozNVrOH-ra3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODozNjozNVrOH-ra3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NTE0OA==", "bodyText": "Rewrite these docs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535485148", "createdAt": "2020-12-03T18:36:35Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjgzMjIw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-544283220", "createdAt": "2020-12-03T19:00:23Z", "commit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowMDoyM1rOH-sZ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowMDoyM1rOH-sZ2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTI3Mg==", "bodyText": "If someone is using both versionid and ifmatch condition this is going to break them.\nMaybe we shouldn't default to \"ETAG\" few lines above but rather apply this switch block only if consistency controll was explicitly set. Otherwise use old logic?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535501272", "createdAt": "2020-12-03T19:00:23Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConsistentReadControl consistentReadControl = options.getConsistentReadControl() == null ? ConsistentReadControl.ETAG\n+            : options.getConsistentReadControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (consistentReadControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"requestConditions.ifMatch\",\n+                        ConsistentReadControl.NONE.toString(), ConsistentReadControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"client.versionId\",\n+                        ConsistentReadControl.NONE.toString(), ConsistentReadControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"client.versionId\",\n+                        ConsistentReadControl.ETAG.toString(), ConsistentReadControl.VERSION_ID.toString()));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cb28fc7374c60a52de919f2de91bd7b76f3748e9", "committedDate": "2020-12-03T20:19:12Z", "message": "Line length"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTYyNDE0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-548562414", "createdAt": "2020-12-09T20:03:47Z", "commit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowMzo0OFrOICnDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowMzo0OFrOICnDlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzk1OQ==", "bodyText": "I think we should also have a case where readControl.ETAG is set, but no request conditions are passed to ensure we will pick the latest etag if none is specified.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539607959", "createdAt": "2020-12-09T20:03:48Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTY0MTQ5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-548564149", "createdAt": "2020-12-09T20:06:08Z", "commit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowNjowOFrOICnJiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowNjowOFrOICnJiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwOTQ4MQ==", "bodyText": "why is this necessary?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539609481", "createdAt": "2020-12-09T20:06:08Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTY1NDUy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-548565452", "createdAt": "2020-12-09T20:07:56Z", "commit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowNzo1NlrOICnN3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowNzo1NlrOICnN3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMDU5MA==", "bodyText": "Why do these have to be live mode?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539610590", "createdAt": "2020-12-09T20:07:56Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b3de8cad8c35b54f54e74bec7ffd79851e8792d", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b3de8cad8c35b54f54e74bec7ffd79851e8792d", "committedDate": "2020-12-09T21:55:31Z", "message": "Merge branch 'master' into storage/inputStreamOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f892e19e39d71b8b71c0e9d307ab62945824fd4", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0f892e19e39d71b8b71c0e9d307ab62945824fd4", "committedDate": "2020-12-09T22:55:00Z", "message": "Made tests not live mode only and recorded them"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9ed862e3efde0c614f8431ffc0ed61cf2eadc05", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c9ed862e3efde0c614f8431ffc0ed61cf2eadc05", "committedDate": "2020-12-09T23:10:18Z", "message": "Updated test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efb61f59733b2c78523d787dfdfb314bc257e334", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/efb61f59733b2c78523d787dfdfb314bc257e334", "committedDate": "2020-12-10T17:45:36Z", "message": "Added more docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "683c50df4ed465b98319ea66bef9e79e3cf51b55", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/683c50df4ed465b98319ea66bef9e79e3cf51b55", "committedDate": "2020-12-10T17:45:59Z", "message": "Redmoved doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6d2a355f08668b34658b2ec8811f7533daf6c6", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8a6d2a355f08668b34658b2ec8811f7533daf6c6", "committedDate": "2020-12-11T22:38:26Z", "message": "Added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7e6a404e7250922e8b81c6f0333830a5d8f9fc31", "committedDate": "2020-12-14T17:36:59Z", "message": "Added version test recorx"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNjY3MjEy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-573667212", "createdAt": "2021-01-21T19:30:09Z", "commit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMDowOVrOIYGhYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMDowOVrOIYGhYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0MzU4Ng==", "bodyText": "locking on etag means we will throw if it changes in the meantime", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562143586", "createdAt": "2021-01-21T19:30:09Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNjY4Njkw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-573668690", "createdAt": "2021-01-21T19:32:09Z", "commit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMjowOVrOIYGlxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMjowOVrOIYGlxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0NDcxMQ==", "bodyText": "locking on version means you get a consisten read on blob without throwing if it vhanges in the meantime", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562144711", "createdAt": "2021-01-21T19:32:09Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    ETAG,\n+\n+    /**\n+     * Consistent control based on versionId. Note: Versioning must be supported by the account to use this value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcb7c652330c8e9d6c96b7bbe216886e41cce67f", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bcb7c652330c8e9d6c96b7bbe216886e41cce67f", "committedDate": "2021-01-21T20:12:05Z", "message": "Merge branch 'master' into storage/inputStreamOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fff06c1c940056706a5a5c185788e0190f171dab", "committedDate": "2021-01-21T22:26:57Z", "message": "Updaed tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NDg0NDg3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574484487", "createdAt": "2021-01-22T17:50:43Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzo1MDo0NFrOIYuspQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzo1MDo0NFrOIYuspQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwMTgyOQ==", "bodyText": "nit: Should we call out specific exception type that will be thrown?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562801829", "createdAt": "2021-01-22T17:50:44Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. The client will honor user provided {@link BlobRequestConditions#getIfMatch()} and\n+     * {@link BlobClient#getVersionId()}.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     * Note: Modification of the base blob will result in an {@code Exception} if eTag is the only form of consistent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTA0MDEz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574504013", "createdAt": "2021-01-22T18:14:47Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNDo0N1rOIYvvXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNDo0N1rOIYvvXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxODkwOQ==", "bodyText": "I think we should add a bit more here: \"Defines values to indicate what strategy the sdk should use when reading from a blob to ensure the view of the data is consistent and not changed during the read.\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562818909", "createdAt": "2021-01-22T18:14:47Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTA1MDQy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574505042", "createdAt": "2021-01-22T18:16:08Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNjowOFrOIYvyhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNjowOFrOIYvyhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxOTcxOA==", "bodyText": "\"... but it may no longer be the latest data.\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562819718", "createdAt": "2021-01-22T18:16:08Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. The client will honor user provided {@link BlobRequestConditions#getIfMatch()} and\n+     * {@link BlobClient#getVersionId()}.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     * Note: Modification of the base blob will result in an {@code Exception} if eTag is the only form of consistent\n+     * read control being employed.\n+     */\n+    ETAG,\n+\n+    /**\n+     * Consistent control based on versionId. Note: Versioning must be supported by the account to use this value.\n+     * If {@link BlobClient#getVersionId()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobClient#getVersionId()} is set to the latest versionId.\n+     * Note: Modification of the base blob will not result in an {@code Exception} and allow you to continue reading the\n+     * entirety of the appropriate version of the blob determined at the time of opening the {@code InputStream}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTIyODQ5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574522849", "createdAt": "2021-01-22T18:41:25Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0MToyNVrOIYwpXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0MToyNVrOIYwpXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMzc1Ng==", "bodyText": "I think we should try modifying and check for failure on these after we get success to make sure that it's actually getting set.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562833756", "createdAt": "2021-01-22T18:41:25Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTI0MDky", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574524092", "createdAt": "2021-01-22T18:43:07Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0MzowN1rOIYws3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0MzowN1rOIYws3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNDY1NQ==", "bodyText": "Is this true if the specify etag? Or does the etag on the version also get locked so they'll always match?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562834655", "createdAt": "2021-01-22T18:43:07Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version and etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+        // When a versioned client is used it should still succeed if the blob has been modified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTI4ODUy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574528852", "createdAt": "2021-01-22T18:49:54Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0OTo1NFrOIYw7_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0OTo1NFrOIYw7_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzODUyNQ==", "bodyText": "Can we do another upload after we get the properties to force this version to be different from the latest at the time of constructing the stream?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562838525", "createdAt": "2021-01-22T18:49:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version and etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+        // When a versioned client is used it should still succeed if the blob has been modified\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    // Error case\n+    def \"IS consistent read control etag user provides old etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        // Since eTag is the only form of consistentReadControl and the blob is modified, we will throw.\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        inputStream.read()\n+\n+        then: \"Failed read\"\n+        thrown(IOException) // BlobStorageException = ConditionNotMet\n+    }\n+\n+    def \"IS consistent read control version client chooses version\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No version specified - client will lock on it.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.VERSION_ID))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        // When a versioned client is used it should still succeed if the blob has been modified\n+        blobClient.upload(new ByteArrayInputStream(getRandomByteArray(length)), length, true)\n+\n+        then:\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == randomBytes\n+    }\n+\n+    def \"IS consistent read control version user provides version\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTMwNDk2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#pullrequestreview-574530496", "createdAt": "2021-01-22T18:52:17Z", "commit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bca079967159c553a93a4a3d11bd544f847508b1", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bca079967159c553a93a4a3d11bd544f847508b1", "committedDate": "2021-01-22T19:56:22Z", "message": "PR comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1584, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}