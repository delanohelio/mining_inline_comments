{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MDM3NTEw", "number": 8121, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMToxNjoxMFrODfBKrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo0MjoyOVrODfmEMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODUxNTY3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMToxNjoxMFrOFoe1oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDoyNzo0NlrOFo9d0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjYwOA==", "bodyText": "Reviewers, please read this Javadoc carefully and ensure we are ok with the behavior specified and that it is sufficiently clear.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r377992608", "createdAt": "2020-02-12T01:16:10Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092a3e5c16948768c5a9bb55443fda97d308bca9"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5NDQxOQ==", "bodyText": "It might be helpful to highlight some of the key words like strong existence, marker blob, etc in like bold/italics?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378494419", "createdAt": "2020-02-12T20:27:46Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjYwOA=="}, "originalCommit": {"oid": "092a3e5c16948768c5a9bb55443fda97d308bca9"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODUxNjk4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/test/java/com/azure/storage/blob/nio/AzureFileSystemProviderSpec.groovy", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMToxNjo1N1rOFoe2ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDo0MzozNVrOFtvLoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjgwNA==", "bodyText": "This is a bit of a departure from how we normally do tests. It seemed fitting to me, but if others feel I should break these up into discrete tests, I can do that, too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r377992804", "createdAt": "2020-02-12T01:16:57Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/test/java/com/azure/storage/blob/nio/AzureFileSystemProviderSpec.groovy", "diffHunk": "@@ -111,4 +114,187 @@ class AzureFileSystemProviderSpec extends APISpec {\n         expect:\n         provider.getScheme() == \"azb\"\n     }\n+\n+    @Unroll\n+    def \"FileSystemProvider createDir parent exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+\n+        // Generate resource names.\n+        // Don't use default directory to ensure we honor the root.\n+        def rootName = fs.getRootDirectories().last().toString()\n+        def containerName = rootName.substring(0, rootName.length() - 1)\n+        def parent = \"\"\n+        for (int i=0; i < depth; i++) {\n+            parent += generateBlobName() + AzureFileSystem.PATH_SEPARATOR\n+        }\n+        def dirName = generateBlobName()\n+        def dirPathStr = parent + dirName\n+\n+        def dirPath = fs.getPath(rootName, dirPathStr)\n+\n+        // Generate clients to resources. Create resources as necessary\n+        def containerClient = primaryBlobServiceClient\n+            .getBlobContainerClient(containerName)\n+        /*\n+        In this case, we are putting the blob in the root directory, i.e. directly in the container, so no need to\n+        create a blob.\n+         */\n+        if (parent != \"\") {\n+            def parentClient = containerClient.getBlobClient(parent)\n+            parentClient.getAppendBlobClient().create()\n+        }\n+        def dirClient = containerClient.getBlobClient(dirPathStr)\n+\n+        when:\n+        fs.provider().createDirectory(dirPath)\n+\n+        then:\n+        dirClient.getPropertiesWithResponse(null, null, null).getValue().getMetadata()\n+            .containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+\n+        where:\n+        depth | _\n+        0     | _ // Test putting a blob in the root dir.\n+        1     | _\n+        2     | _\n+    }\n+\n+    def \"FileSystemProvider createDir relativePath\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()\n+\n+        when: \"Relative paths are resolved against the default directory\"\n+        fs.provider().createDirectory(fs.getPath(\"foo\"))\n+\n+        then:\n+        blobClient.getProperties().getMetadata().containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+    }\n+\n+    def \"FileSystemProvider createDir file already exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()\n+\n+        when: \"A file already exists at the location\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092a3e5c16948768c5a9bb55443fda97d308bca9"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0Mjk1OA==", "bodyText": "I think using the descriptions of the whens help make it clearer, I have no strong oppositions about this", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378942958", "createdAt": "2020-02-13T15:43:32Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/test/java/com/azure/storage/blob/nio/AzureFileSystemProviderSpec.groovy", "diffHunk": "@@ -111,4 +114,187 @@ class AzureFileSystemProviderSpec extends APISpec {\n         expect:\n         provider.getScheme() == \"azb\"\n     }\n+\n+    @Unroll\n+    def \"FileSystemProvider createDir parent exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+\n+        // Generate resource names.\n+        // Don't use default directory to ensure we honor the root.\n+        def rootName = fs.getRootDirectories().last().toString()\n+        def containerName = rootName.substring(0, rootName.length() - 1)\n+        def parent = \"\"\n+        for (int i=0; i < depth; i++) {\n+            parent += generateBlobName() + AzureFileSystem.PATH_SEPARATOR\n+        }\n+        def dirName = generateBlobName()\n+        def dirPathStr = parent + dirName\n+\n+        def dirPath = fs.getPath(rootName, dirPathStr)\n+\n+        // Generate clients to resources. Create resources as necessary\n+        def containerClient = primaryBlobServiceClient\n+            .getBlobContainerClient(containerName)\n+        /*\n+        In this case, we are putting the blob in the root directory, i.e. directly in the container, so no need to\n+        create a blob.\n+         */\n+        if (parent != \"\") {\n+            def parentClient = containerClient.getBlobClient(parent)\n+            parentClient.getAppendBlobClient().create()\n+        }\n+        def dirClient = containerClient.getBlobClient(dirPathStr)\n+\n+        when:\n+        fs.provider().createDirectory(dirPath)\n+\n+        then:\n+        dirClient.getPropertiesWithResponse(null, null, null).getValue().getMetadata()\n+            .containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+\n+        where:\n+        depth | _\n+        0     | _ // Test putting a blob in the root dir.\n+        1     | _\n+        2     | _\n+    }\n+\n+    def \"FileSystemProvider createDir relativePath\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()\n+\n+        when: \"Relative paths are resolved against the default directory\"\n+        fs.provider().createDirectory(fs.getPath(\"foo\"))\n+\n+        then:\n+        blobClient.getProperties().getMetadata().containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+    }\n+\n+    def \"FileSystemProvider createDir file already exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()\n+\n+        when: \"A file already exists at the location\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjgwNA=="}, "originalCommit": {"oid": "092a3e5c16948768c5a9bb55443fda97d308bca9"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMzI2NA==", "bodyText": "I'd prefer separation, as it's not clear which when/then fails when one does. Additionally, we'll stop when we encounter a single failure and we won't immediately see which specific one failed, which is useful information when initially looking at a failure.\nIf there is a way to have similar mechanics as table tests with @Unroll added, then I think this would be useful, as setup code can be complex sometimes.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r383503264", "createdAt": "2020-02-24T20:43:35Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/test/java/com/azure/storage/blob/nio/AzureFileSystemProviderSpec.groovy", "diffHunk": "@@ -111,4 +114,187 @@ class AzureFileSystemProviderSpec extends APISpec {\n         expect:\n         provider.getScheme() == \"azb\"\n     }\n+\n+    @Unroll\n+    def \"FileSystemProvider createDir parent exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+\n+        // Generate resource names.\n+        // Don't use default directory to ensure we honor the root.\n+        def rootName = fs.getRootDirectories().last().toString()\n+        def containerName = rootName.substring(0, rootName.length() - 1)\n+        def parent = \"\"\n+        for (int i=0; i < depth; i++) {\n+            parent += generateBlobName() + AzureFileSystem.PATH_SEPARATOR\n+        }\n+        def dirName = generateBlobName()\n+        def dirPathStr = parent + dirName\n+\n+        def dirPath = fs.getPath(rootName, dirPathStr)\n+\n+        // Generate clients to resources. Create resources as necessary\n+        def containerClient = primaryBlobServiceClient\n+            .getBlobContainerClient(containerName)\n+        /*\n+        In this case, we are putting the blob in the root directory, i.e. directly in the container, so no need to\n+        create a blob.\n+         */\n+        if (parent != \"\") {\n+            def parentClient = containerClient.getBlobClient(parent)\n+            parentClient.getAppendBlobClient().create()\n+        }\n+        def dirClient = containerClient.getBlobClient(dirPathStr)\n+\n+        when:\n+        fs.provider().createDirectory(dirPath)\n+\n+        then:\n+        dirClient.getPropertiesWithResponse(null, null, null).getValue().getMetadata()\n+            .containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+\n+        where:\n+        depth | _\n+        0     | _ // Test putting a blob in the root dir.\n+        1     | _\n+        2     | _\n+    }\n+\n+    def \"FileSystemProvider createDir relativePath\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()\n+\n+        when: \"Relative paths are resolved against the default directory\"\n+        fs.provider().createDirectory(fs.getPath(\"foo\"))\n+\n+        then:\n+        blobClient.getProperties().getMetadata().containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+    }\n+\n+    def \"FileSystemProvider createDir file already exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()\n+\n+        when: \"A file already exists at the location\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjgwNA=="}, "originalCommit": {"oid": "092a3e5c16948768c5a9bb55443fda97d308bca9"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTUzMTUwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozMjo1M1rOFo7z8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozMjo1M1rOFo7z8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NzMxMw==", "bodyText": "In case we later allow users to specify an account instead of individual containers, let's change This list will not change during the lifetime of this object. If containers are added to the account after initialization, they will be ignored. to Results of this list are scoped based on specifications during FileSystem initialization.\nIn this same vein, we can change If a container is deleted or otherwise becomes unavailable, its root directory will still be returned but operations to it will fail. to Containers listed are only guaranteed to have existed at some point in time. Operations on nonexistent containers will fail.. This gives us some more generic language that allows us to update implementation details later on.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378467313", "createdAt": "2020-02-12T19:32:53Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "diffHunk": "@@ -187,18 +209,30 @@ public boolean isReadOnly() {\n      */\n     @Override\n     public String getSeparator() {\n-        return \"/\";\n+        return AzureFileSystem.PATH_SEPARATOR;\n     }\n \n     /**\n+     * The list of root directories corresponds to the list of available file stores and therefore containers specified\n+     * upon initialization. A root directory always takes the form {@code \"<file-store-name>:\"}. This list will not\n+     * change during the lifetime of this object. If containers are added to the account after initialization, they\n+     * will be ignored. If a container is deleted or otherwise becomes unavailable, its root directory will still be\n+     * returned but operations to it will fail.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043a5631926c330a6c29cc27ab6798a5d40ada26"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTUzNjg2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozNDoyOVrOFo73Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozNDoyOVrOFo73Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2ODE3OA==", "bodyText": "Similar comment as above.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378468178", "createdAt": "2020-02-12T19:34:29Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystem.java", "diffHunk": "@@ -187,18 +209,30 @@ public boolean isReadOnly() {\n      */\n     @Override\n     public String getSeparator() {\n-        return \"/\";\n+        return AzureFileSystem.PATH_SEPARATOR;\n     }\n \n     /**\n+     * The list of root directories corresponds to the list of available file stores and therefore containers specified\n+     * upon initialization. A root directory always takes the form {@code \"<file-store-name>:\"}. This list will not\n+     * change during the lifetime of this object. If containers are added to the account after initialization, they\n+     * will be ignored. If a container is deleted or otherwise becomes unavailable, its root directory will still be\n+     * returned but operations to it will fail.\n+     *\n      * {@inheritDoc}\n      */\n     @Override\n     public Iterable<Path> getRootDirectories() {\n-        return null;\n+        return fileStores.keySet().stream()\n+            .map(name -> this.getPath(name + AzurePath.ROOT_DIR_SUFFIX))\n+            .collect(Collectors.toList());\n     }\n \n     /**\n+     * This list will not change during the lifetime of this object. If containers are added to the account after\n+     * initialization, they will be ignored. If a container is deleted or otherwise becomes unavailable, its\n+     * corresponding file store will still be returned but operations to it will fail until it becomes available again.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043a5631926c330a6c29cc27ab6798a5d40ada26"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTU1MzU0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozOTo0NVrOFo8BpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDozNjowNVrOFo9sxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3MDgyMQ==", "bodyText": "update: This method fulfills the nio contract... so we know what you're referencing.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378470821", "createdAt": "2020-02-12T19:39:45Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the\n+     * directory only as a container (e.g. listing) will operate on the blob-name prefix.\n+     *\n+     * This method fulfills the contract of: \"The check for the existence of the file and the creation of the directory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043a5631926c330a6c29cc27ab6798a5d40ada26"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5ODI0NA==", "bodyText": "Additionally, this whole paragraph feels a little off. It reads like you're moving to another topic before I've understood the current one. Most notably, I don't understand how we are obeying the contract from this paragraph.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378498244", "createdAt": "2020-02-12T20:36:05Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the\n+     * directory only as a container (e.g. listing) will operate on the blob-name prefix.\n+     *\n+     * This method fulfills the contract of: \"The check for the existence of the file and the creation of the directory", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3MDgyMQ=="}, "originalCommit": {"oid": "043a5631926c330a6c29cc27ab6798a5d40ada26"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTYyODc2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDowMjo1MlrOFo8xTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDowMjo1MlrOFo8xTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MzAyMw==", "bodyText": "and exists in order to accommodate maybe?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378483023", "createdAt": "2020-02-12T20:02:52Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eb73f22b154540b8f24334c9cf9376a3e6fa230"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTcwNTgyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDoyOTo1MVrOFo9hfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyOTowMFrOFqBTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5NTM1Nw==", "bodyText": "will target marker blobs and create them if they do not exist.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378495357", "createdAt": "2020-02-12T20:29:51Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b26be3c89446d039ea27797daacaa5e68cc272c2"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTg3Nw==", "bodyText": "This isn't actually true. We won't eagerly create marker blobs if we target a directory and notice there's no marker blob.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r379605877", "createdAt": "2020-02-14T19:29:00Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5NTM1Nw=="}, "originalCommit": {"oid": "b26be3c89446d039ea27797daacaa5e68cc272c2"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTcwODgwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDozMDo0OVrOFo9jSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDozMDo0OVrOFo9jSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5NTgxOA==", "bodyText": "Overloaded use of container. Unsure of a good substitute.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378495818", "createdAt": "2020-02-12T20:30:49Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the\n+     * directory only as a container (e.g. listing) will operate on the blob-name prefix.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b26be3c89446d039ea27797daacaa5e68cc272c2"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTcyNzUxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDozNzozMVrOFo9vEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTozMDoxNVrOFqBVkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5ODgzNQ==", "bodyText": "may not -> will not, as it definitely won't be empty if the directory virtually existed already.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378498835", "createdAt": "2020-02-12T20:37:31Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the\n+     * directory only as a container (e.g. listing) will operate on the blob-name prefix.\n+     *\n+     * This method fulfills the contract of: \"The check for the existence of the file and the creation of the directory\n+     * if it does not exist are a single operation that is atomic with respect to all other filesystem activities that\n+     * might affect the directory.\" The action of checking whether the parent exists, is not, however, atomic with\n+     * the creation of the directory. While it is possible that the parent may be deleted between the positive check and\n+     * the creation of the child, the creation of the child will always implicitly ensure the existence of a virtual\n+     * parent, so the child will never be left floating and unreachable. Note that we only check for weak existence of\n+     * the parent directory and only check for strong existence of an actual blob or other directory when attempting to\n+     * put an object at the given path. This split is due to limitations in the Storage service API.\n+     *\n+     * There may be some unintuitive behavior when working with directories in this file system, particularly virtual\n+     * directories(usually those not created by this file system). A virtual directory will disappear as soon as all its\n+     * children have been deleted. Furthermore, if a directory with the given path weakly exists at the time of calling\n+     * this method, this method will still return success and create a concrete directory at the target location.\n+     * In other words, it is possible to \"double create\" a directory if it first weakly exists and then is strongly\n+     * created. This is both because it is impossible to atomically check if a virtual directory exists while creating a\n+     * concrete directory and because such behavior will have minimal side effects--no files will be overwritten and the\n+     * directory will still be available for writing as intended, though it may not be empty.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b26be3c89446d039ea27797daacaa5e68cc272c2"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNjQxOA==", "bodyText": "I used \"may\" because we don't know if we're creating a new directory or double creating a virtual directory. So there are cases of calling this method when the directory will be empty.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r379606418", "createdAt": "2020-02-14T19:30:15Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the\n+     * directory only as a container (e.g. listing) will operate on the blob-name prefix.\n+     *\n+     * This method fulfills the contract of: \"The check for the existence of the file and the creation of the directory\n+     * if it does not exist are a single operation that is atomic with respect to all other filesystem activities that\n+     * might affect the directory.\" The action of checking whether the parent exists, is not, however, atomic with\n+     * the creation of the directory. While it is possible that the parent may be deleted between the positive check and\n+     * the creation of the child, the creation of the child will always implicitly ensure the existence of a virtual\n+     * parent, so the child will never be left floating and unreachable. Note that we only check for weak existence of\n+     * the parent directory and only check for strong existence of an actual blob or other directory when attempting to\n+     * put an object at the given path. This split is due to limitations in the Storage service API.\n+     *\n+     * There may be some unintuitive behavior when working with directories in this file system, particularly virtual\n+     * directories(usually those not created by this file system). A virtual directory will disappear as soon as all its\n+     * children have been deleted. Furthermore, if a directory with the given path weakly exists at the time of calling\n+     * this method, this method will still return success and create a concrete directory at the target location.\n+     * In other words, it is possible to \"double create\" a directory if it first weakly exists and then is strongly\n+     * created. This is both because it is impossible to atomically check if a virtual directory exists while creating a\n+     * concrete directory and because such behavior will have minimal side effects--no files will be overwritten and the\n+     * directory will still be available for writing as intended, though it may not be empty.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5ODgzNQ=="}, "originalCommit": {"oid": "b26be3c89446d039ea27797daacaa5e68cc272c2"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTczMjg5OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDozOToyM1rOFo9ybA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDozOToyM1rOFo9ybA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5OTY5Mg==", "bodyText": "Link to rest docs for more details on those specific properties?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378499692", "createdAt": "2020-02-12T20:39:23Z", "author": {"login": "jaschrep-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -181,11 +195,111 @@ public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> s\n     }\n \n     /**\n+     * The existence of a directory in the {@code AzureFileSystem} is defined on two levels. Weak existence is defined\n+     * by the presence of a non-zero number of blobs prefixed with the directory's path. This is also known as a virtual\n+     * directory and is in order to accommodate containers that were pre-loaded with data by another source but need to\n+     * be accessed by this file system. Strong existence is defined as the presence of a zero-length blob whose name is\n+     * the directory path with a particular metadata field indicating the blob's status as a directory and is also known\n+     * as a concrete directory. Directories created by this file system will strongly exist. Operations targeting\n+     * directories themselves as the object (e.g. setting properties) will target marker blobs. Operations using the\n+     * directory only as a container (e.g. listing) will operate on the blob-name prefix.\n+     *\n+     * This method fulfills the contract of: \"The check for the existence of the file and the creation of the directory\n+     * if it does not exist are a single operation that is atomic with respect to all other filesystem activities that\n+     * might affect the directory.\" The action of checking whether the parent exists, is not, however, atomic with\n+     * the creation of the directory. While it is possible that the parent may be deleted between the positive check and\n+     * the creation of the child, the creation of the child will always implicitly ensure the existence of a virtual\n+     * parent, so the child will never be left floating and unreachable. Note that we only check for weak existence of\n+     * the parent directory and only check for strong existence of an actual blob or other directory when attempting to\n+     * put an object at the given path. This split is due to limitations in the Storage service API.\n+     *\n+     * There may be some unintuitive behavior when working with directories in this file system, particularly virtual\n+     * directories(usually those not created by this file system). A virtual directory will disappear as soon as all its\n+     * children have been deleted. Furthermore, if a directory with the given path weakly exists at the time of calling\n+     * this method, this method will still return success and create a concrete directory at the target location.\n+     * In other words, it is possible to \"double create\" a directory if it first weakly exists and then is strongly\n+     * created. This is both because it is impossible to atomically check if a virtual directory exists while creating a\n+     * concrete directory and because such behavior will have minimal side effects--no files will be overwritten and the\n+     * directory will still be available for writing as intended, though it may not be empty.\n+     *\n+     * This method will attempt to extract standard HTTP content headers from the list of file attributes to set them\n+     * as blob headers. All other attributes will be set as blob metadata. The value of every attribute will be\n+     * converted to a {@code String} with the exception of the Content-MD5 attribute which expects a {@code byte[]}.\n+     * When extracting the content headers, the following strings will be used for comparison:\n+     * <ul>\n+     *     <li>{@code Content-Type}</li>\n+     *     <li>{@code Content-Disposition}</li>\n+     *     <li>{@code Content-Language}</li>\n+     *     <li>{@code Content-Encoding}</li>\n+     *     <li>{@code Content-MD5}</li>\n+     *     <li>{@code Cache-Control}</li>\n+     * </ul>\n+     * Note that these properties also have a particular semantic in that if one is specified, all are updated. In other\n+     * words, if any of the above is set, all those that are not set will be cleared.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b26be3c89446d039ea27797daacaa5e68cc272c2"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDU0NTc2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/implementation/util/Utility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTozODo0MVrOFpYpfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTozODo0MVrOFpYpfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkzOTc3Mw==", "bodyText": "are these constants anywhere?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378939773", "createdAt": "2020-02-13T15:38:41Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/implementation/util/Utility.java", "diffHunk": "@@ -13,4 +20,59 @@\n         logger.error(e.getMessage());\n         return e;\n     }\n+\n+    /*\n+    Note that this will remove the properties from the list of attributes as it finds them.\n+     */\n+    public static BlobHttpHeaders extractHttpHeaders(List<FileAttribute<?>> fileAttributes, ClientLogger logger) {\n+        BlobHttpHeaders headers = new BlobHttpHeaders();\n+        for (Iterator<FileAttribute<?>> it = fileAttributes.iterator(); it.hasNext();) {\n+            FileAttribute<?> attr = it.next();\n+            boolean propertyFound = true;\n+            switch (attr.name()) {\n+                case \"Content-Type\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d8f221e91c3a3df975a3429f7e130e60759f199"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDU2MTEzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob-nio/src/test/java/com/azure/storage/blob/nio/AzureFileSystemProviderSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo0MjoyOVrOFpYzQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo0MjoyOVrOFpYzQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0MjI3Mw==", "bodyText": "can we use a random name here instead of static?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8121#discussion_r378942273", "createdAt": "2020-02-13T15:42:29Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob-nio/src/test/java/com/azure/storage/blob/nio/AzureFileSystemProviderSpec.groovy", "diffHunk": "@@ -111,4 +114,187 @@ class AzureFileSystemProviderSpec extends APISpec {\n         expect:\n         provider.getScheme() == \"azb\"\n     }\n+\n+    @Unroll\n+    def \"FileSystemProvider createDir parent exists\"() {\n+        setup:\n+        def fs = createFS(config)\n+\n+        // Generate resource names.\n+        // Don't use default directory to ensure we honor the root.\n+        def rootName = fs.getRootDirectories().last().toString()\n+        def containerName = rootName.substring(0, rootName.length() - 1)\n+        def parent = \"\"\n+        for (int i=0; i < depth; i++) {\n+            parent += generateBlobName() + AzureFileSystem.PATH_SEPARATOR\n+        }\n+        def dirName = generateBlobName()\n+        def dirPathStr = parent + dirName\n+\n+        def dirPath = fs.getPath(rootName, dirPathStr)\n+\n+        // Generate clients to resources. Create resources as necessary\n+        def containerClient = primaryBlobServiceClient\n+            .getBlobContainerClient(containerName)\n+        /*\n+        In this case, we are putting the blob in the root directory, i.e. directly in the container, so no need to\n+        create a blob.\n+         */\n+        if (parent != \"\") {\n+            def parentClient = containerClient.getBlobClient(parent)\n+            parentClient.getAppendBlobClient().create()\n+        }\n+        def dirClient = containerClient.getBlobClient(dirPathStr)\n+\n+        when:\n+        fs.provider().createDirectory(dirPath)\n+\n+        then:\n+        dirClient.getPropertiesWithResponse(null, null, null).getValue().getMetadata()\n+            .containsKey(AzureFileSystemProvider.DIR_METADATA_MARKER)\n+\n+        where:\n+        depth | _\n+        0     | _ // Test putting a blob in the root dir.\n+        1     | _\n+        2     | _\n+    }\n+\n+    def \"FileSystemProvider createDir relativePath\"() {\n+        setup:\n+        def fs = createFS(config)\n+        def containerClient =\n+            primaryBlobServiceClient.getBlobContainerClient(rootToContainer(fs.getDefaultDirectory().toString()))\n+        AppendBlobClient blobClient = containerClient.getBlobClient(\"foo\").getAppendBlobClient()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d8f221e91c3a3df975a3429f7e130e60759f199"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3212, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}