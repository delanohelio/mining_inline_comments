{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NzY3NDQw", "number": 18027, "title": "Updates RetryUtil to use RetrySpec. Adds log information on expiration.", "bodyText": "Updates RetryUtil to use new RetrySpec.\nAdds log message on retry exhaustion.\nConsolidates reactor producer code.\n\nRelated to #18819", "createdAt": "2020-12-08T22:26:26Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027", "merged": true, "mergeCommit": {"oid": "d0f337ad63c98f3be72d81fded6c1be8f772e18e"}, "closed": true, "closedAt": "2021-02-01T20:26:29Z", "author": {"login": "conniey"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkR2zIgFqTU0NzY4NTI5OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABd18H9QgH2gAyNTM0NzY3NDQwOjAxNTc0OWExOTczZTkyYzQyMmU5NGYwMTFmZDVkNjY0MDI5OTQ5ODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Njg1Mjk5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#pullrequestreview-547685299", "createdAt": "2020-12-08T22:26:44Z", "commit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoyNjo0NVrOIB5FTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjoyNjo0NVrOIB5FTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NDczNA==", "bodyText": "can we remove this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538854734", "createdAt": "2020-12-08T22:26:45Z", "author": {"login": "conniey"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -177,6 +177,7 @@ com.microsoft:microsoft-opentelemetry-exporter-azuremonitor;1.0.0-beta.1;1.0.0-b\n # unreleased_<groupId>:<artifactId>;dependency-version\n # note: The unreleased dependencies will not be manipulated with the automatic PR creation code.\n unreleased_com.azure:azure-messaging-servicebus;7.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Njg5NTYw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#pullrequestreview-547689560", "createdAt": "2020-12-08T22:34:03Z", "commit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozNDowNFrOIB5VOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0OTowNVrOIB5zlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1ODgwOA==", "bodyText": "This change is happening because we want to run the connectionMono and activeEndpointState publishers concurrently?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538858808", "createdAt": "2020-12-08T22:34:04Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -138,12 +138,11 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n                 \"connectionId[%s]: Connection is disposed. Cannot get CBS node.\", connectionId))));\n         }\n \n-        final Mono<ClaimsBasedSecurityNode> cbsNodeMono =\n-            RetryUtil.withRetry(getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE),\n-                connectionOptions.getRetry().getTryTimeout(), retryPolicy)\n-            .then(Mono.fromCallable(this::getOrCreateCBSNode));\n+        final Flux<AmqpEndpointState> activeEndpointState = RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE), connectionOptions.getRetry(),\n+            \"ReactorConnection: Retries exhausted waiting for ACTIVE endpoint state on CBS node.\");\n \n-        return connectionMono.then(cbsNodeMono);\n+        return Mono.when(connectionMono, activeEndpointState).then(Mono.fromCallable(() -> getOrCreateCBSNode()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MTAxNA==", "bodyText": "Is this needed? Looks like we are just assigning a constant to a local constant", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538861014", "createdAt": "2020-12-08T22:38:10Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -228,108 +228,25 @@ public boolean removeLink(String linkName) {\n             return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n                 \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n         }\n-        TransactionCoordinator existing = transactionCoordinator.get();\n+\n+        final TransactionCoordinator existing = transactionCoordinator.get();\n         if (existing != null) {\n             logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n             return Mono.just(existing);\n         }\n \n-        return createCoordinatorSendLink(openTimeout, retryPolicy)\n-            .map(sendLink -> {\n-                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+        final String linkName = TRANSACTION_LINK_NAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzE2Mg==", "bodyText": "I've been seeing this pattern in a lot of locations, do we want to centralize it anywhere?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538863162", "createdAt": "2020-12-08T22:42:27Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -563,6 +507,30 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n         return new LinkSubscription<>(reactorReceiver, subscription);\n     }\n \n+    /**\n+     * Asynchronously waits for the session's active endpoint state.\n+     *\n+     * @return A mono that completes when the session is active.\n+     */\n+    private Mono<Void> onActiveEndpoint() {\n+        return RetryUtil.withRetry(getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NDE5NA==", "bodyText": "Does the AMQP response contain any information on backoff when the server is busy and this is a best approximation default?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538864194", "createdAt": "2020-12-08T22:44:32Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -22,6 +22,10 @@\n  * Helper class to help with retry policies.\n  */\n public class RetryUtil {\n+    private static final double JITTER_FACTOR = 0.08;\n+    // Base sleep wait time.\n+    private static final Duration SERVER_BUSY_WAIT_TIME = Duration.ofSeconds(4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NTE2Nw==", "bodyText": "When there is no delay we won't attempt retries? Would we want this instead?\nreturn Retry.max(options.getMaxRetries());", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538865167", "createdAt": "2020-12-08T22:46:29Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NjU4MQ==", "bodyText": "nit: Mind adding parentheses around the && block for easier reading", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538866581", "createdAt": "2020-12-08T22:49:05Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);\n+        }\n \n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else {\n-                    LOGGER.warning(\"Error is not a TimeoutException nor is it a retryable AMQP exception.\", error);\n+        final Duration delay = options.getDelay().plus(SERVER_BUSY_WAIT_TIME);\n+        final RetryBackoffSpec retrySpec;\n+        switch (options.getMode()) {\n+            case FIXED:\n+                retrySpec = Retry.fixedDelay(options.getMaxRetries(), delay);\n+                break;\n+            case EXPONENTIAL:\n+                retrySpec = Retry.backoff(options.getMaxRetries(), delay);\n+                break;\n+            default:\n+                LOGGER.warning(\"Unknown: '{}'. Using exponential delay. Delay: {}. Max Delay: {}. Max Retries: {}.\",\n+                    options.getMode(), options.getDelay(), options.getMaxDelay(), options.getMaxRetries());\n+                retrySpec = Retry.backoff(options.getMaxRetries(), delay);\n+                break;\n+        }\n \n-                    throw Exceptions.propagate(error);\n-                }\n-            })\n-            .flatMap(Mono::delay);\n+        return retrySpec.jitter(JITTER_FACTOR)\n+            .maxBackoff(options.getMaxDelay())\n+            .filter(error -> error instanceof TimeoutException\n+                || error instanceof AmqpException && ((AmqpException) error).isTransient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58e16ccb09a3ae41599349f1494329a63a4c5e8"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de9b2a9f8d5978040e3fa40a78cfbc112aadfbc8", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/de9b2a9f8d5978040e3fa40a78cfbc112aadfbc8", "committedDate": "2021-01-20T20:25:00Z", "message": "(WIP)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cf3cc825466edbd2a9e9df4c3ecbb22f793f01d", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2cf3cc825466edbd2a9e9df4c3ecbb22f793f01d", "committedDate": "2021-01-20T20:25:01Z", "message": "Change from protected to public."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b81bfb01b239a70fcec6b7af9cc6df25af7203ba", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b81bfb01b239a70fcec6b7af9cc6df25af7203ba", "committedDate": "2021-01-20T20:25:01Z", "message": "Aggregate new RetryUtil to use RetrySpec."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2d98fa067ea503062f31610b4eca9f99eca5cc1", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a2d98fa067ea503062f31610b4eca9f99eca5cc1", "committedDate": "2021-01-20T20:25:02Z", "message": "Fixing test break."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c891b088cdf7cbb0f2716617125f6d0044e218c1", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c891b088cdf7cbb0f2716617125f6d0044e218c1", "committedDate": "2021-01-20T20:25:03Z", "message": "Fixing test failures."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3e1476848359424ead3030bb3ec959b001decf", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fa3e1476848359424ead3030bb3ec959b001decf", "committedDate": "2021-01-20T20:25:03Z", "message": "Fixing checkstyle issues."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ad0707884986e8f39a18136971d5052247e5d57", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ad0707884986e8f39a18136971d5052247e5d57", "committedDate": "2021-01-20T20:28:05Z", "message": "Add amqp as unreleased dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c08a4de2a1bc860ac5baddef038165f883f505e7", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c08a4de2a1bc860ac5baddef038165f883f505e7", "committedDate": "2021-01-20T20:28:08Z", "message": "Fixing build break in Event Hubs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a8fec3361ce38efbbf57f63145ede493c45d0b7", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6a8fec3361ce38efbbf57f63145ede493c45d0b7", "committedDate": "2021-01-20T20:28:08Z", "message": "Fix build breaks in ReactorConnection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd84c225ae55563b7f9b22a019b086e7766645e6", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cd84c225ae55563b7f9b22a019b086e7766645e6", "committedDate": "2021-01-20T20:28:09Z", "message": "Move log message."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d126e63bf614ba69a71673151eef29feba6f307", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7d126e63bf614ba69a71673151eef29feba6f307", "committedDate": "2021-01-20T20:28:10Z", "message": "Fix log messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80aab863d919374080a1794e8df9885020569c5e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/80aab863d919374080a1794e8df9885020569c5e", "committedDate": "2021-01-20T20:28:11Z", "message": "Removing link name."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "committedDate": "2021-01-20T20:28:11Z", "message": "Fixing test issues."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b457832098e5764144585a85af03aa8df977fb8e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b457832098e5764144585a85af03aa8df977fb8e", "committedDate": "2020-12-09T20:49:37Z", "message": "Removing link name."}, "afterCommit": {"oid": "a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "committedDate": "2021-01-20T20:28:11Z", "message": "Fixing test issues."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27082f78f3f8b59ec598d0f239cdc131a2c2b18c", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/27082f78f3f8b59ec598d0f239cdc131a2c2b18c", "committedDate": "2021-01-21T01:10:32Z", "message": "Adding more tests to retryUtil"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8292774c80d796263b40073e503883181c41270b", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8292774c80d796263b40073e503883181c41270b", "committedDate": "2021-01-23T16:28:16Z", "message": "(WIP)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fa0dff105e0dffc6e951bc4b873102dc8078b37", "committedDate": "2021-01-26T19:26:29Z", "message": "Fix tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2Njk2OTI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#pullrequestreview-576696927", "createdAt": "2021-01-26T19:38:57Z", "commit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTozODo1N1rOIani0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTo1MTowN1rOIan-6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4MTc3Ng==", "bodyText": "Would changing this to a Mono.error return be a breaking change? Or does something further up the stack handle converting this into a Mono.error?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564781776", "createdAt": "2021-01-26T19:38:57Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "diffHunk": "@@ -155,7 +162,8 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n                 receiveLink.open();\n             });\n         } catch (IOException e) {\n-            throw logger.logExceptionAsError(new RuntimeException(\"Unable to open send and receive link.\", e));\n+            throw logger.logExceptionAsError(new RuntimeException(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA==", "bodyText": "This is for a larger discussion\nShould we guard timeouts on timeout periods that are zero or negative? Timeout schedules a task on the parallel scheduler by default to propagate an exception if it runs before an emission is made from the reactive stream. From this could an instantly scheduled exception operation result in side affect/unexpected behavior?\ncc: @srnagar @JonathanGiles", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564788190", "createdAt": "2021-01-26T19:49:50Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODk2OA==", "bodyText": "Based on the previous topic of no delay or zero delay resulting in no retrying, should we also check if the delay is negative?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564788968", "createdAt": "2021-01-26T19:51:07Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())\n+            .retryWhen(createRetry(retryOptions))\n+            .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())\n+            .retryWhen(createRetry(retryOptions))\n+            .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dcaac203e2c282f8547b29a71d9eca68ff33e9e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8dcaac203e2c282f8547b29a71d9eca68ff33e9e", "committedDate": "2021-01-26T21:32:00Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into try-attempt-i"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5414c94deef7b762368e7131c4cafe3206741f69", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5414c94deef7b762368e7131c4cafe3206741f69", "committedDate": "2021-01-28T22:41:51Z", "message": "Add checks for null or zero durations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe158467883cc0522227f9a0095f71cb5ea72eed", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe158467883cc0522227f9a0095f71cb5ea72eed", "committedDate": "2021-01-28T23:02:55Z", "message": "Adding more tests for retry."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2595a4bebdbac99d4d0fa47d55d4280707a37495", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2595a4bebdbac99d4d0fa47d55d4280707a37495", "committedDate": "2021-01-28T23:47:54Z", "message": "Adding opens for testing and cleaning up imports."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4ODM4MTQ4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#pullrequestreview-578838148", "createdAt": "2021-01-28T23:53:05Z", "commit": {"oid": "2595a4bebdbac99d4d0fa47d55d4280707a37495"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMzo1MzowNVrOIcPm0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMzo1MzowNVrOIcPm0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ4NjczOQ==", "bodyText": "Removing duplicated code for creating a transaction link.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566486739", "createdAt": "2021-01-28T23:53:05Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -228,108 +228,25 @@ public boolean removeLink(String linkName) {\n             return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n                 \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n         }\n-        TransactionCoordinator existing = transactionCoordinator.get();\n+\n+        final TransactionCoordinator existing = transactionCoordinator.get();\n         if (existing != null) {\n             logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n             return Mono.just(existing);\n         }\n \n-        return createCoordinatorSendLink(openTimeout, retryPolicy)\n-            .map(sendLink -> {\n-                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+        return createProducer(TRANSACTION_LINK_NAME, TRANSACTION_LINK_NAME, new Coordinator(), retryOptions, null,\n+            false)\n+            .map(link -> {\n+                final TransactionCoordinator newCoordinator = new TransactionCoordinator(link, messageSerializer);\n                 if (transactionCoordinator.compareAndSet(null, newCoordinator)) {\n-                    logger.info(\"Coordinator[{}]: Created transaction coordinator.\", TRANSACTION_LINK_NAME);\n+                    return newCoordinator;\n                 } else {\n-                    logger.info(\"linkName[{}]: Another transaction coordinator exists.\", TRANSACTION_LINK_NAME);\n+                    return transactionCoordinator.get();\n                 }\n-                return transactionCoordinator.get();\n             });\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2595a4bebdbac99d4d0fa47d55d4280707a37495"}, "originalPosition": 104}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf2e414a971128d9f465933e925b6fdc90c8296e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf2e414a971128d9f465933e925b6fdc90c8296e", "committedDate": "2021-01-29T00:13:53Z", "message": "Adding opens"}, "afterCommit": {"oid": "a9e56fbb88dbfa5c363b95987b1299c8587c5555", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a9e56fbb88dbfa5c363b95987b1299c8587c5555", "committedDate": "2021-01-29T00:29:01Z", "message": "Adding opens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b1a249a4b42a1da111dcc94264be5372d02226e", "committedDate": "2021-01-29T00:39:23Z", "message": "Removing opens. Fixing visibility."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9e56fbb88dbfa5c363b95987b1299c8587c5555", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a9e56fbb88dbfa5c363b95987b1299c8587c5555", "committedDate": "2021-01-29T00:29:01Z", "message": "Adding opens"}, "afterCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b1a249a4b42a1da111dcc94264be5372d02226e", "committedDate": "2021-01-29T00:39:23Z", "message": "Removing opens. Fixing visibility."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4ODU3OTU0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#pullrequestreview-578857954", "createdAt": "2021-01-29T00:42:51Z", "commit": {"oid": "bf2e414a971128d9f465933e925b6fdc90c8296e"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMDo0NzowN1rOIcQxMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMTowOTowM1rOIcROxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUwNTc3Nw==", "bodyText": "Check for isZero() as well and update the javadoc, error message.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566505777", "createdAt": "2021-01-29T00:47:07Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "diffHunk": "@@ -72,8 +82,15 @@ public AmqpRetryOptions setMaxRetries(int numberOfRetries) {\n      *\n      * @param delay The delay between retry attempts.\n      * @return The updated {@link AmqpRetryOptions} object.\n+     * @throws NullPointerException When {@code delay} is null.\n+     * @throws IllegalArgumentException When {@code delay} is negative.\n      */\n     public AmqpRetryOptions setDelay(Duration delay) {\n+        Objects.requireNonNull(delay, \"'delay' cannot be null.\");\n+        if (delay.isNegative()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUwNTkwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IllegalArgumentException When {@code maximumDelay} is negative.\n          \n          \n            \n                 * @throws IllegalArgumentException When {@code maximumDelay} is negative or zero.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566505908", "createdAt": "2021-01-29T00:47:30Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "diffHunk": "@@ -94,8 +119,16 @@ public AmqpRetryOptions setMaxDelay(Duration maximumDelay) {\n      *\n      * @param tryTimeout The maximum duration to wait for completion.\n      * @return The updated {@link AmqpRetryOptions} object.\n+     *\n+     * @throws NullPointerException When {@code maximumDelay} is null.\n+     * @throws IllegalArgumentException When {@code maximumDelay} is negative.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMDY3NQ==", "bodyText": "Log at debug level instead of deleting this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566510675", "createdAt": "2021-01-29T01:01:15Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AzureTokenManagerProvider.java", "diffHunk": "@@ -46,8 +46,6 @@ public AzureTokenManagerProvider(CbsAuthorizationType authorizationType, String\n     public TokenManager getTokenManager(Mono<ClaimsBasedSecurityNode> cbsNodeMono, String resource) {\n         final String scopes = getScopesFromResource(resource);\n         final String tokenAudience = String.format(Locale.US, TOKEN_AUDIENCE_FORMAT, fullyQualifiedNamespace, resource);\n-\n-        logger.info(\"Creating new token manager for audience[{}], resource[{}]\", tokenAudience, resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMzM1MQ==", "bodyText": "So, we no longer need retries for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566513351", "createdAt": "2021-01-29T01:09:03Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -368,34 +285,32 @@ public boolean removeLink(String linkName) {\n         }\n \n         final TokenManager tokenManager = tokenManagerProvider.getTokenManager(cbsNodeSupplier, entityPath);\n-        return RetryUtil.withRetry(\n-            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE), timeout, retry)\n-            .then(tokenManager.authorize().then(Mono.create(sink -> {\n-                try {\n-                    // This has to be executed using reactor dispatcher because it's possible to run into race\n-                    // conditions with proton-j.\n-                    provider.getReactorDispatcher().invoke(() -> {\n-                        final LinkSubscription<AmqpReceiveLink> computed = openReceiveLinks.compute(linkName,\n-                            (linkNameKey, existing) -> {\n-                                if (existing != null) {\n-                                    logger.info(\"linkName[{}]: Another receive link exists. Disposing of new one.\",\n-                                        linkName);\n-                                    tokenManager.close();\n-\n-                                    return existing;\n-                                }\n-\n-                                logger.info(\"Creating a new receiver link with linkName {}\", linkName);\n-                                return getSubscription(linkNameKey, entityPath, sourceFilters, receiverProperties,\n-                                    receiverDesiredCapabilities, senderSettleMode, receiverSettleMode, tokenManager);\n-                            });\n-\n-                        sink.success(computed.getLink());\n-                    });\n-                } catch (IOException e) {\n-                    sink.error(e);\n-                }\n-            })));\n+        return Mono.when(onActiveEndpoint(), tokenManager.authorize()).then(Mono.create(sink -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e"}, "originalPosition": 224}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae273fecedec4cb4ee763b9ca0f9b1908d5ccd15", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae273fecedec4cb4ee763b9ca0f9b1908d5ccd15", "committedDate": "2021-02-01T19:13:26Z", "message": "Updating code based on feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "015749a1973e92c422e94f011fd5d66402994980", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/015749a1973e92c422e94f011fd5d66402994980", "committedDate": "2021-02-01T19:18:13Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into try-attempt-i"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1418, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}