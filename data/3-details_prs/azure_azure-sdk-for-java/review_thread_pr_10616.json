{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMDkzMzE2", "number": 10616, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNjo0MFrOD5BLAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjowMTo0NVrOD5pL7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTE0NjI2OnYy", "diffSide": "RIGHT", "path": "eng/versioning/version_client.txt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNjo0MFrOGQDVLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTo1ODoxMFrOGQTvrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg==", "bodyText": "@kushagraThapar\ncom.azure:azure-cosmos-examples and azure-cosmos-benchmark are in the process is being removed as libraries. Further, they're intentionally not part of the Artifacts cosmos' ci.yml which makes them incapable of being released (this was intentional as these are never supposed to be released). There is no version change necessary here and it should be reverted.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419484972", "createdAt": "2020-05-04T14:36:40Z", "author": {"login": "JimSuplizio"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -17,8 +17,8 @@ com.azure:azure-core-serializer-json-jackson;1.0.0-beta.1;1.0.0-beta.1\n com.azure:azure-core-test;1.2.0;1.3.0-beta.1\n com.azure:azure-core-tracing-opentelemetry;1.0.0-beta.4;1.0.0-beta.5\n com.azure:azure-cosmos;4.0.1-beta.2;4.0.1-beta.3\n-com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.1\n-com.azure:azure-cosmos-benchmark;4.0.1-beta.1;4.0.1-beta.1\n+com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1Njc5Mw==", "bodyText": "@JimSuplizio - yes this is unintentional, should be reverted.\n@David-Noble-at-work - can we please revert the changes related to pom.xml ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419556793", "createdAt": "2020-05-04T16:17:25Z", "author": {"login": "kushagraThapar"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -17,8 +17,8 @@ com.azure:azure-core-serializer-json-jackson;1.0.0-beta.1;1.0.0-beta.1\n com.azure:azure-core-test;1.2.0;1.3.0-beta.1\n com.azure:azure-core-tracing-opentelemetry;1.0.0-beta.4;1.0.0-beta.5\n com.azure:azure-cosmos;4.0.1-beta.2;4.0.1-beta.3\n-com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.1\n-com.azure:azure-cosmos-benchmark;4.0.1-beta.1;4.0.1-beta.1\n+com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.3", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg=="}, "originalCommit": {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzkwMA==", "bodyText": "@kushagraThapar @JimSuplizio yep", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419753900", "createdAt": "2020-05-04T21:58:10Z", "author": {"login": "David-Noble-at-work"}, "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -17,8 +17,8 @@ com.azure:azure-core-serializer-json-jackson;1.0.0-beta.1;1.0.0-beta.1\n com.azure:azure-core-test;1.2.0;1.3.0-beta.1\n com.azure:azure-core-tracing-opentelemetry;1.0.0-beta.4;1.0.0-beta.5\n com.azure:azure-cosmos;4.0.1-beta.2;4.0.1-beta.3\n-com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.1\n-com.azure:azure-cosmos-benchmark;4.0.1-beta.1;4.0.1-beta.1\n+com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.3", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg=="}, "originalCommit": {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjkyMjUwOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjoyNTo0OVrOGQUcTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjoyNTo0OVrOGQUcTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2NTMyNA==", "bodyText": "nice addition. thank you", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419765324", "createdAt": "2020-05-04T22:25:49Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -11,6 +11,7 @@\n import com.azure.cosmos.CosmosClientException;\n import com.azure.cosmos.implementation.HttpConstants;\n import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzY4NTczOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMTo1MTozOVrOGRBlvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTowNjo1MlrOGVIpcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA==", "bodyText": "Nit : Though the error message should say \"Collection {} creation failed due to ... \" instead of Database :)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420505020", "createdAt": "2020-05-06T01:51:39Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -83,11 +88,18 @@\n         }\n \n         try {\n-            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(this.configuration.getCollectionId()).read().block().getContainer();\n+            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(\n+                this.configuration.getCollectionId()\n+            ).read().doOnError(error ->\n+                logger.error(\"Database {} creation failed due to \", this.configuration.getDatabaseId(), error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxNDM2Ng==", "bodyText": "This one bothers me and I corrected it on my local branch. I would update the PR if the benchmark tool was shipping code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424814366", "createdAt": "2020-05-14T01:04:26Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -83,11 +88,18 @@\n         }\n \n         try {\n-            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(this.configuration.getCollectionId()).read().block().getContainer();\n+            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(\n+                this.configuration.getCollectionId()\n+            ).read().doOnError(error ->\n+                logger.error(\"Database {} creation failed due to \", this.configuration.getDatabaseId(), error)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxNDk2Mg==", "bodyText": "And I updated the terminology. Collection is now container.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424814962", "createdAt": "2020-05-14T01:06:52Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -83,11 +88,18 @@\n         }\n \n         try {\n-            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(this.configuration.getCollectionId()).read().block().getContainer();\n+            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(\n+                this.configuration.getCollectionId()\n+            ).read().doOnError(error ->\n+                logger.error(\"Database {} creation failed due to \", this.configuration.getDatabaseId(), error)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzY5MzExOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMTo1NTo1N1rOGRBp5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTowMjoxN1rOGVIlEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjA4NA==", "bodyText": "Some dead code ?\nOr do you need it later ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506084", "createdAt": "2020-05-06T01:55:57Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -27,172 +34,253 @@\n import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n import java.time.Duration;\n-import java.util.ArrayDeque;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdReporter.reportIssueUnless;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+import static com.azure.cosmos.implementation.guava27.Strings.lenientFormat;\n \n /**\n- * {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections\n+ * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n  */\n @JsonSerialize(using = RntbdClientChannelPool.JsonSerializer.class)\n-public final class RntbdClientChannelPool extends SimpleChannelPool {\n+public final class RntbdClientChannelPool implements ChannelPool {\n \n     private static final TimeoutException ACQUISITION_TIMEOUT = ThrowableUtil.unknownStackTrace(\n-        new TimeoutException(\"Acquisition took longer than the configured maximum time\"),\n+        new TimeoutException(\"acquisition took longer than the configured maximum time\"),\n         RntbdClientChannelPool.class, \"<init>\");\n \n     private static final ClosedChannelException CHANNEL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire0(...)\");\n+        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_RELEASE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n         RntbdClientChannelPool.class, \"release\");\n \n+    private static final AttributeKey<RntbdClientChannelPool> POOL_KEY = AttributeKey.newInstance(\n+        RntbdClientChannelPool.class.getName());\n+\n     private static final IllegalStateException TOO_MANY_PENDING_ACQUISITIONS = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"Too many outstanding acquire operations\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"too many outstanding acquire operations\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n+\n+    private static final EventExecutor closer = new DefaultEventExecutor(new RntbdThreadFactory(\n+        \"channel-pool-closer\",\n+        true,\n+        Thread.NORM_PRIORITY));\n+\n+    private static final HashedWheelTimer acquisitionAndIdleEndpointDetectionTimer =\n+        new HashedWheelTimer(new RntbdThreadFactory(\n+            \"channel-acquisition-timer\",\n+            true,\n+            Thread.NORM_PRIORITY));\n \n     private static final Logger logger = LoggerFactory.getLogger(RntbdClientChannelPool.class);\n \n-    private final long acquisitionTimeoutNanos;\n+    private final long acquisitionTimeoutInNanos;\n+    private final Runnable acquisitionTimeoutTask;\n     private final PooledByteBufAllocatorMetric allocatorMetric;\n+    private final Bootstrap bootstrap;\n     private final EventExecutor executor;\n-    private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n+    private final ChannelHealthChecker healthChecker;\n+    // private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n     private final int maxChannels;\n     private final int maxPendingAcquisitions;\n     private final int maxRequestsPerChannel;\n+    private final ChannelPoolHandler poolHandler;\n+    private final boolean releaseHealthCheck;\n \n-    // No need to worry about synchronization as everything that modified the queue or counts is done by this.executor\n-\n-    private final Queue<AcquireTask> pendingAcquisitionQueue = new ArrayDeque<AcquireTask>();\n-    private final Runnable acquisitionTimeoutTask;\n-\n-    // Because these values can be requested on any thread...\n+    // Because state from these fields can be requested on any thread...\n \n-    private final AtomicInteger acquiredChannelCount = new AtomicInteger();\n-    private final AtomicInteger availableChannelCount = new AtomicInteger();\n+    private final AtomicReference<Timeout> acquisitionAndIdleEndpointDetectionTimeout = new AtomicReference<>();\n+    private final ConcurrentHashMap<Channel, Channel> acquiredChannels = new ConcurrentHashMap<>();\n+    private final Deque<Channel> availableChannels = new ConcurrentLinkedDeque<>();\n     private final AtomicBoolean closed = new AtomicBoolean();\n+    private final AtomicBoolean connecting = new AtomicBoolean();\n+    private final Queue<AcquireTask> pendingAcquisitions = new ConcurrentLinkedQueue<>();\n \n     /**\n-     * Initializes a newly created {@link RntbdClientChannelPool} object\n-     *  @param bootstrap the\u00a0{@link Bootstrap} that is used for connections\n-     * @param config    the {@link Config} that is used for the channel pool instance created\n+     * Initializes a newly created {@link RntbdClientChannelPool} instance.\n+     *\n+     * @param bootstrap the\u00a0{@link Bootstrap} that is used for connections.\n+     * @param config the {@link Config} that is used for the channel pool instance created.\n      */\n     RntbdClientChannelPool(final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config) {\n         this(endpoint, bootstrap, config, new RntbdClientChannelHealthChecker(config));\n     }\n \n     private RntbdClientChannelPool(\n-        final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config,\n-        final RntbdClientChannelHealthChecker healthChecker\n-    ) {\n+        final RntbdServiceEndpoint endpoint,\n+        final Bootstrap bootstrap,\n+        final Config config,\n+        final RntbdClientChannelHealthChecker healthChecker) {\n \n-        super(bootstrap, new RntbdClientChannelHandler(config, healthChecker), healthChecker, true, true);\n+        checkNotNull(endpoint, \"expected non-null endpoint\");\n+        checkNotNull(bootstrap, \"expected non-null bootstrap\");\n+        checkNotNull(config, \"expected non-null config\");\n+        checkNotNull(healthChecker, \"expected non-null healthChecker\");\n \n-        this.allocatorMetric = config.allocator().metric();\n+        this.poolHandler = new RntbdClientChannelHandler(config, healthChecker);\n         this.executor = bootstrap.config().group().next();\n-        this.maxChannels = config.maxChannelsPerEndpoint();\n-        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n-        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n-\n-        // TODO: DANOBLE: Add RntbdEndpoint.Config settings for acquisition timeout and acquisition timeout action\n-        //  Alternatively: drop acquisition timeout and acquisition timeout action\n-        //  Decision should be based on performance, reliability, and usability considerations\n+        this.healthChecker = healthChecker;\n \n-        final AcquisitionTimeoutAction acquisitionTimeoutAction = null;\n-        final long acquisitionTimeoutNanos = -1L;\n-\n-        if (acquisitionTimeoutAction == null) {\n-\n-            this.acquisitionTimeoutNanos = -1L;\n-            this.acquisitionTimeoutTask = null;\n-\n-        } else {\n-\n-            this.acquisitionTimeoutNanos = acquisitionTimeoutNanos;\n-\n-            switch (acquisitionTimeoutAction) {\n-                case FAIL:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            task.promise.setFailure(ACQUISITION_TIMEOUT);\n-                        }\n-                    };\n-                    break;\n-                case NEW:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            // Increment the acquire count and get a new Channel by delegating to super.acquire\n-                            task.acquired();\n-                            RntbdClientChannelPool.super.acquire(task.promise);\n-                        }\n-                    };\n-                    break;\n-                default:\n-                    throw new Error();\n+        this.bootstrap = bootstrap.clone().handler(new ChannelInitializer<Channel>() {\n+            @Override\n+            protected void initChannel(final Channel channel) throws Exception {\n+            checkState(channel.eventLoop().inEventLoop());\n+            RntbdClientChannelPool.this.poolHandler.channelCreated(channel);\n             }\n-        }\n-\n-        final long idleEndpointTimeout = config.idleEndpointTimeoutInNanos();\n-\n-        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n-            () -> {\n-\n-                final long currentTime = System.nanoTime();\n-                final long lastRequestTime = endpoint.lastRequestTime();\n-                final long elapsedTime = currentTime - lastRequestTime;\n-\n-                if (elapsedTime > idleEndpointTimeout) {\n+        });\n \n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\n-                            \"{} closing due to inactivity (time elapsed since last request: {} > idleEndpointTimeout: {})\",\n-                            endpoint, Duration.ofNanos(elapsedTime), Duration.ofNanos(idleEndpointTimeout));\n-                    }\n+        // TODO (DANOBLE) Consider moving or removing this.allocatorMetric\n+        //  This metric is redundant in the scope of this class and should be pulled up to RntbdServiceEndpoint or\n+        //  entirely removed.\n \n-                    endpoint.close();\n-                }\n+        this.acquisitionTimeoutInNanos = config.connectionAcquisitionTimeoutInNanos();\n+        this.allocatorMetric = config.allocator().metric();\n+        this.maxChannels = config.maxChannelsPerEndpoint();\n+        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n \n-            }, idleEndpointTimeout, idleEndpointTimeout, TimeUnit.NANOSECONDS);\n+        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n+        this.releaseHealthCheck = true;\n+\n+        this.acquisitionTimeoutTask = acquisitionTimeoutInNanos <= 0 ? null : new AcquireTimeoutTask(this) {\n+            /**\n+             * Fails a request due to a channel acquisition timeout.\n+             *\n+             * @param task a {@link AcquireTask channel acquisition task} that has timed out.\n+             */\n+            @Override\n+            public void onTimeout(AcquireTask task) {\n+                task.promise.setFailure(ACQUISITION_TIMEOUT);\n+            }\n+        };\n+\n+        newTimeout(endpoint, config.idleEndpointTimeoutInNanos(), config.requestTimerResolutionInNanos());\n+\n+//        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n+//            () -> {\n+//                final long elapsedTimeInNanos = System.nanoTime() - endpoint.lastRequestNanoTime();\n+//\n+//                if (idleEndpointTimeoutInNanos - elapsedTimeInNanos <= 0) {\n+//                    if (logger.isDebugEnabled()) {\n+//                        logger.debug(\n+//                            \"{} closing endpoint due to inactivity (elapsedTime: {} > idleEndpointTimeout: {})\",\n+//                            endpoint,\n+//                            Duration.ofNanos(elapsedTimeInNanos),\n+//                            Duration.ofNanos(idleEndpointTimeoutInNanos));\n+//                    }\n+//                    endpoint.close();\n+//                    return;\n+//                }\n+//\n+//                this.runTasksInPendingAcquisitionQueue();\n+//\n+//            }, requestTimerResolutionInNanos, requestTimerResolutionInNanos, TimeUnit.NANOSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMzg0Mg==", "bodyText": "Dead code that's now removed on my local branch. We'll get this in on my next PR which will wire up DirectConnectionConfig.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424813842", "createdAt": "2020-05-14T01:02:17Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -27,172 +34,253 @@\n import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n import java.time.Duration;\n-import java.util.ArrayDeque;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdReporter.reportIssueUnless;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+import static com.azure.cosmos.implementation.guava27.Strings.lenientFormat;\n \n /**\n- * {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections\n+ * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n  */\n @JsonSerialize(using = RntbdClientChannelPool.JsonSerializer.class)\n-public final class RntbdClientChannelPool extends SimpleChannelPool {\n+public final class RntbdClientChannelPool implements ChannelPool {\n \n     private static final TimeoutException ACQUISITION_TIMEOUT = ThrowableUtil.unknownStackTrace(\n-        new TimeoutException(\"Acquisition took longer than the configured maximum time\"),\n+        new TimeoutException(\"acquisition took longer than the configured maximum time\"),\n         RntbdClientChannelPool.class, \"<init>\");\n \n     private static final ClosedChannelException CHANNEL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire0(...)\");\n+        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_RELEASE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n         RntbdClientChannelPool.class, \"release\");\n \n+    private static final AttributeKey<RntbdClientChannelPool> POOL_KEY = AttributeKey.newInstance(\n+        RntbdClientChannelPool.class.getName());\n+\n     private static final IllegalStateException TOO_MANY_PENDING_ACQUISITIONS = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"Too many outstanding acquire operations\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"too many outstanding acquire operations\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n+\n+    private static final EventExecutor closer = new DefaultEventExecutor(new RntbdThreadFactory(\n+        \"channel-pool-closer\",\n+        true,\n+        Thread.NORM_PRIORITY));\n+\n+    private static final HashedWheelTimer acquisitionAndIdleEndpointDetectionTimer =\n+        new HashedWheelTimer(new RntbdThreadFactory(\n+            \"channel-acquisition-timer\",\n+            true,\n+            Thread.NORM_PRIORITY));\n \n     private static final Logger logger = LoggerFactory.getLogger(RntbdClientChannelPool.class);\n \n-    private final long acquisitionTimeoutNanos;\n+    private final long acquisitionTimeoutInNanos;\n+    private final Runnable acquisitionTimeoutTask;\n     private final PooledByteBufAllocatorMetric allocatorMetric;\n+    private final Bootstrap bootstrap;\n     private final EventExecutor executor;\n-    private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n+    private final ChannelHealthChecker healthChecker;\n+    // private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n     private final int maxChannels;\n     private final int maxPendingAcquisitions;\n     private final int maxRequestsPerChannel;\n+    private final ChannelPoolHandler poolHandler;\n+    private final boolean releaseHealthCheck;\n \n-    // No need to worry about synchronization as everything that modified the queue or counts is done by this.executor\n-\n-    private final Queue<AcquireTask> pendingAcquisitionQueue = new ArrayDeque<AcquireTask>();\n-    private final Runnable acquisitionTimeoutTask;\n-\n-    // Because these values can be requested on any thread...\n+    // Because state from these fields can be requested on any thread...\n \n-    private final AtomicInteger acquiredChannelCount = new AtomicInteger();\n-    private final AtomicInteger availableChannelCount = new AtomicInteger();\n+    private final AtomicReference<Timeout> acquisitionAndIdleEndpointDetectionTimeout = new AtomicReference<>();\n+    private final ConcurrentHashMap<Channel, Channel> acquiredChannels = new ConcurrentHashMap<>();\n+    private final Deque<Channel> availableChannels = new ConcurrentLinkedDeque<>();\n     private final AtomicBoolean closed = new AtomicBoolean();\n+    private final AtomicBoolean connecting = new AtomicBoolean();\n+    private final Queue<AcquireTask> pendingAcquisitions = new ConcurrentLinkedQueue<>();\n \n     /**\n-     * Initializes a newly created {@link RntbdClientChannelPool} object\n-     *  @param bootstrap the\u00a0{@link Bootstrap} that is used for connections\n-     * @param config    the {@link Config} that is used for the channel pool instance created\n+     * Initializes a newly created {@link RntbdClientChannelPool} instance.\n+     *\n+     * @param bootstrap the\u00a0{@link Bootstrap} that is used for connections.\n+     * @param config the {@link Config} that is used for the channel pool instance created.\n      */\n     RntbdClientChannelPool(final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config) {\n         this(endpoint, bootstrap, config, new RntbdClientChannelHealthChecker(config));\n     }\n \n     private RntbdClientChannelPool(\n-        final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config,\n-        final RntbdClientChannelHealthChecker healthChecker\n-    ) {\n+        final RntbdServiceEndpoint endpoint,\n+        final Bootstrap bootstrap,\n+        final Config config,\n+        final RntbdClientChannelHealthChecker healthChecker) {\n \n-        super(bootstrap, new RntbdClientChannelHandler(config, healthChecker), healthChecker, true, true);\n+        checkNotNull(endpoint, \"expected non-null endpoint\");\n+        checkNotNull(bootstrap, \"expected non-null bootstrap\");\n+        checkNotNull(config, \"expected non-null config\");\n+        checkNotNull(healthChecker, \"expected non-null healthChecker\");\n \n-        this.allocatorMetric = config.allocator().metric();\n+        this.poolHandler = new RntbdClientChannelHandler(config, healthChecker);\n         this.executor = bootstrap.config().group().next();\n-        this.maxChannels = config.maxChannelsPerEndpoint();\n-        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n-        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n-\n-        // TODO: DANOBLE: Add RntbdEndpoint.Config settings for acquisition timeout and acquisition timeout action\n-        //  Alternatively: drop acquisition timeout and acquisition timeout action\n-        //  Decision should be based on performance, reliability, and usability considerations\n+        this.healthChecker = healthChecker;\n \n-        final AcquisitionTimeoutAction acquisitionTimeoutAction = null;\n-        final long acquisitionTimeoutNanos = -1L;\n-\n-        if (acquisitionTimeoutAction == null) {\n-\n-            this.acquisitionTimeoutNanos = -1L;\n-            this.acquisitionTimeoutTask = null;\n-\n-        } else {\n-\n-            this.acquisitionTimeoutNanos = acquisitionTimeoutNanos;\n-\n-            switch (acquisitionTimeoutAction) {\n-                case FAIL:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            task.promise.setFailure(ACQUISITION_TIMEOUT);\n-                        }\n-                    };\n-                    break;\n-                case NEW:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            // Increment the acquire count and get a new Channel by delegating to super.acquire\n-                            task.acquired();\n-                            RntbdClientChannelPool.super.acquire(task.promise);\n-                        }\n-                    };\n-                    break;\n-                default:\n-                    throw new Error();\n+        this.bootstrap = bootstrap.clone().handler(new ChannelInitializer<Channel>() {\n+            @Override\n+            protected void initChannel(final Channel channel) throws Exception {\n+            checkState(channel.eventLoop().inEventLoop());\n+            RntbdClientChannelPool.this.poolHandler.channelCreated(channel);\n             }\n-        }\n-\n-        final long idleEndpointTimeout = config.idleEndpointTimeoutInNanos();\n-\n-        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n-            () -> {\n-\n-                final long currentTime = System.nanoTime();\n-                final long lastRequestTime = endpoint.lastRequestTime();\n-                final long elapsedTime = currentTime - lastRequestTime;\n-\n-                if (elapsedTime > idleEndpointTimeout) {\n+        });\n \n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\n-                            \"{} closing due to inactivity (time elapsed since last request: {} > idleEndpointTimeout: {})\",\n-                            endpoint, Duration.ofNanos(elapsedTime), Duration.ofNanos(idleEndpointTimeout));\n-                    }\n+        // TODO (DANOBLE) Consider moving or removing this.allocatorMetric\n+        //  This metric is redundant in the scope of this class and should be pulled up to RntbdServiceEndpoint or\n+        //  entirely removed.\n \n-                    endpoint.close();\n-                }\n+        this.acquisitionTimeoutInNanos = config.connectionAcquisitionTimeoutInNanos();\n+        this.allocatorMetric = config.allocator().metric();\n+        this.maxChannels = config.maxChannelsPerEndpoint();\n+        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n \n-            }, idleEndpointTimeout, idleEndpointTimeout, TimeUnit.NANOSECONDS);\n+        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n+        this.releaseHealthCheck = true;\n+\n+        this.acquisitionTimeoutTask = acquisitionTimeoutInNanos <= 0 ? null : new AcquireTimeoutTask(this) {\n+            /**\n+             * Fails a request due to a channel acquisition timeout.\n+             *\n+             * @param task a {@link AcquireTask channel acquisition task} that has timed out.\n+             */\n+            @Override\n+            public void onTimeout(AcquireTask task) {\n+                task.promise.setFailure(ACQUISITION_TIMEOUT);\n+            }\n+        };\n+\n+        newTimeout(endpoint, config.idleEndpointTimeoutInNanos(), config.requestTimerResolutionInNanos());\n+\n+//        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n+//            () -> {\n+//                final long elapsedTimeInNanos = System.nanoTime() - endpoint.lastRequestNanoTime();\n+//\n+//                if (idleEndpointTimeoutInNanos - elapsedTimeInNanos <= 0) {\n+//                    if (logger.isDebugEnabled()) {\n+//                        logger.debug(\n+//                            \"{} closing endpoint due to inactivity (elapsedTime: {} > idleEndpointTimeout: {})\",\n+//                            endpoint,\n+//                            Duration.ofNanos(elapsedTimeInNanos),\n+//                            Duration.ofNanos(idleEndpointTimeoutInNanos));\n+//                    }\n+//                    endpoint.close();\n+//                    return;\n+//                }\n+//\n+//                this.runTasksInPendingAcquisitionQueue();\n+//\n+//            }, requestTimerResolutionInNanos, requestTimerResolutionInNanos, TimeUnit.NANOSECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjA4NA=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzY5NjYxOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMTo1ODoyM1rOGRBr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTowMToxN1rOGVIkNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ==", "bodyText": "Explanation required ?\nIf not, remove the check as per the comment :)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506599", "createdAt": "2020-05-06T01:58:23Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -233,45 +349,87 @@ public boolean isClosed() {\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n             if (this.executor.inEventLoop()) {\n-                this.close0();\n+                this.doClose();\n             } else {\n-                this.executor.submit(this::close0).awaitUninterruptibly();\n+                this.executor.submit(this::doClose).awaitUninterruptibly(); // block until complete\n             }\n         }\n     }\n \n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     *\n+     * @return asynchronous result of the operation. If the operation fails, {@code channel} will be closed\n+     * automatically.\n+     */\n+    @Override\n+    public Future<Void> release(final Channel channel) {\n+        return this.release(channel, channel.eventLoop().newPromise());\n+    }\n+\n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     * @param promise a {@link Promise promise} to be notified once the release is successful; failed otherwise.\n+     *\n+     * @return a reference to {@code promise}. If the operation fails, {@code channel} will be closed automatically.\n+     */\n     @Override\n     public Future<Void> release(final Channel channel, final Promise<Void> promise) {\n \n         // We do not call this.throwIfClosed because a channel may be released back to the pool during close\n \n-        super.release(channel, this.executor.<Void>newPromise().addListener((FutureListener<Void>)future -> {\n+        checkNotNull(channel, \"expected non-null channel\");\n+        checkNotNull(promise, \"expected non-null promise\");\n \n-            checkState(this.executor.inEventLoop());\n+        Promise<Void> anotherPromise = this.executor.newPromise(); // ensures we finish in our executor's event loop\n+\n+        try {\n+            final EventLoop loop = channel.eventLoop();\n+            if (loop.inEventLoop()) {\n+                this.releaseChannel(channel, anotherPromise);\n+            } else {\n+                loop.execute(() -> this.releaseChannel(channel, anotherPromise));\n+            }\n+        } catch (Throwable cause) {\n+            if (this.executor.inEventLoop()) {\n+                this.closeChannelAndFail(channel, cause, anotherPromise);\n+            } else {\n+                this.executor.submit(() -> this.closeChannelAndFail(channel, cause, anotherPromise));\n+            }\n+        }\n+\n+        anotherPromise.addListener((FutureListener<Void>) future -> {\n+\n+            this.ensureValidRunState();\n \n             if (this.isClosed()) {\n-                // Since the pool is closed, we have no choice but to close the channel\n+                // We have no choice but to close the channel\n                 promise.setFailure(POOL_CLOSED_ON_RELEASE);\n-                channel.close();\n+                this.closeChannel(channel);\n                 return;\n             }\n \n             if (future.isSuccess()) {\n-\n-                this.decrementAndRunTaskQueue();\n+                this.runTasksInPendingAcquisitionQueue();\n                 promise.setSuccess(null);\n-\n             } else {\n-\n+                // TODO (DANOBLE) Is this check for an IllegalArgumentException required?\n+                //  Explain here, if so; otherwise remove the check.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMzUwOQ==", "bodyText": "I'd like to leave this in the code for now due to my uncertainty around why the netty devs put this into the base class from which RntbdClientChannelPool used to inherit.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424813509", "createdAt": "2020-05-14T01:00:49Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -233,45 +349,87 @@ public boolean isClosed() {\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n             if (this.executor.inEventLoop()) {\n-                this.close0();\n+                this.doClose();\n             } else {\n-                this.executor.submit(this::close0).awaitUninterruptibly();\n+                this.executor.submit(this::doClose).awaitUninterruptibly(); // block until complete\n             }\n         }\n     }\n \n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     *\n+     * @return asynchronous result of the operation. If the operation fails, {@code channel} will be closed\n+     * automatically.\n+     */\n+    @Override\n+    public Future<Void> release(final Channel channel) {\n+        return this.release(channel, channel.eventLoop().newPromise());\n+    }\n+\n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     * @param promise a {@link Promise promise} to be notified once the release is successful; failed otherwise.\n+     *\n+     * @return a reference to {@code promise}. If the operation fails, {@code channel} will be closed automatically.\n+     */\n     @Override\n     public Future<Void> release(final Channel channel, final Promise<Void> promise) {\n \n         // We do not call this.throwIfClosed because a channel may be released back to the pool during close\n \n-        super.release(channel, this.executor.<Void>newPromise().addListener((FutureListener<Void>)future -> {\n+        checkNotNull(channel, \"expected non-null channel\");\n+        checkNotNull(promise, \"expected non-null promise\");\n \n-            checkState(this.executor.inEventLoop());\n+        Promise<Void> anotherPromise = this.executor.newPromise(); // ensures we finish in our executor's event loop\n+\n+        try {\n+            final EventLoop loop = channel.eventLoop();\n+            if (loop.inEventLoop()) {\n+                this.releaseChannel(channel, anotherPromise);\n+            } else {\n+                loop.execute(() -> this.releaseChannel(channel, anotherPromise));\n+            }\n+        } catch (Throwable cause) {\n+            if (this.executor.inEventLoop()) {\n+                this.closeChannelAndFail(channel, cause, anotherPromise);\n+            } else {\n+                this.executor.submit(() -> this.closeChannelAndFail(channel, cause, anotherPromise));\n+            }\n+        }\n+\n+        anotherPromise.addListener((FutureListener<Void>) future -> {\n+\n+            this.ensureValidRunState();\n \n             if (this.isClosed()) {\n-                // Since the pool is closed, we have no choice but to close the channel\n+                // We have no choice but to close the channel\n                 promise.setFailure(POOL_CLOSED_ON_RELEASE);\n-                channel.close();\n+                this.closeChannel(channel);\n                 return;\n             }\n \n             if (future.isSuccess()) {\n-\n-                this.decrementAndRunTaskQueue();\n+                this.runTasksInPendingAcquisitionQueue();\n                 promise.setSuccess(null);\n-\n             } else {\n-\n+                // TODO (DANOBLE) Is this check for an IllegalArgumentException required?\n+                //  Explain here, if so; otherwise remove the check.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMzYyMw==", "bodyText": "I made a note to remove it with my next PR.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424813623", "createdAt": "2020-05-14T01:01:17Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -233,45 +349,87 @@ public boolean isClosed() {\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n             if (this.executor.inEventLoop()) {\n-                this.close0();\n+                this.doClose();\n             } else {\n-                this.executor.submit(this::close0).awaitUninterruptibly();\n+                this.executor.submit(this::doClose).awaitUninterruptibly(); // block until complete\n             }\n         }\n     }\n \n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     *\n+     * @return asynchronous result of the operation. If the operation fails, {@code channel} will be closed\n+     * automatically.\n+     */\n+    @Override\n+    public Future<Void> release(final Channel channel) {\n+        return this.release(channel, channel.eventLoop().newPromise());\n+    }\n+\n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     * @param promise a {@link Promise promise} to be notified once the release is successful; failed otherwise.\n+     *\n+     * @return a reference to {@code promise}. If the operation fails, {@code channel} will be closed automatically.\n+     */\n     @Override\n     public Future<Void> release(final Channel channel, final Promise<Void> promise) {\n \n         // We do not call this.throwIfClosed because a channel may be released back to the pool during close\n \n-        super.release(channel, this.executor.<Void>newPromise().addListener((FutureListener<Void>)future -> {\n+        checkNotNull(channel, \"expected non-null channel\");\n+        checkNotNull(promise, \"expected non-null promise\");\n \n-            checkState(this.executor.inEventLoop());\n+        Promise<Void> anotherPromise = this.executor.newPromise(); // ensures we finish in our executor's event loop\n+\n+        try {\n+            final EventLoop loop = channel.eventLoop();\n+            if (loop.inEventLoop()) {\n+                this.releaseChannel(channel, anotherPromise);\n+            } else {\n+                loop.execute(() -> this.releaseChannel(channel, anotherPromise));\n+            }\n+        } catch (Throwable cause) {\n+            if (this.executor.inEventLoop()) {\n+                this.closeChannelAndFail(channel, cause, anotherPromise);\n+            } else {\n+                this.executor.submit(() -> this.closeChannelAndFail(channel, cause, anotherPromise));\n+            }\n+        }\n+\n+        anotherPromise.addListener((FutureListener<Void>) future -> {\n+\n+            this.ensureValidRunState();\n \n             if (this.isClosed()) {\n-                // Since the pool is closed, we have no choice but to close the channel\n+                // We have no choice but to close the channel\n                 promise.setFailure(POOL_CLOSED_ON_RELEASE);\n-                channel.close();\n+                this.closeChannel(channel);\n                 return;\n             }\n \n             if (future.isSuccess()) {\n-\n-                this.decrementAndRunTaskQueue();\n+                this.runTasksInPendingAcquisitionQueue();\n                 promise.setSuccess(null);\n-\n             } else {\n-\n+                // TODO (DANOBLE) Is this check for an IllegalArgumentException required?\n+                //  Explain here, if so; otherwise remove the check.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 510}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzY5Nzc2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMTo1OTowMFrOGRBsgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDo1NDoxOVrOGVIdCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjc1NA==", "bodyText": "Is this intended to have no message and only params / values ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506754", "createdAt": "2020-05-06T01:59:00Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -281,126 +439,286 @@ public String toString() {\n         return RntbdObjectMapper.toString(this);\n     }\n \n+    // endregion\n+\n+    // region Privates\n+\n     /**\n-     * Offer a {@link Channel} back to the internal storage\n+     * Acquires a serviceable channel from the {@link RntbdClientChannelPool pool}.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe.\n+     * This method acquires the first channel that's both available and serviceable in LIFO order. A new channel is\n+     * created and added to the pool if and only if:\n+     * <ul>\n+     * <li>fewer than {@link #maxChannels} channels have been created ({@link #channels} < {@link #maxChannels()}))\n+     * and</li>\n+     * <li>there are no acquired channels pending release ({@link #channelsAcquired} == 0).</li>\n+     * </ul>\n+     * Under load it is possible that:\n+     * <ul>\n+     * <li>no available channels are serviceable ({@link RntbdRequestManager#pendingRequestCount()} ==\n+     * {@link #maxChannels()})</li>\n+     * <li>there are acquired channels pending release, and</li>\n+     * <li>{@link #maxChannels} channels have been created.</li>\n+     * </ul>\n+     * Under these circumstances a request to acquire a channel will be satisfied by the\n+     * {@link #acquisitionTimeoutTask} which will:\n+     * <ul>\n+     * <li>process items in the {@link #pendingAcquisitions} on each call to {@link #acquire} or {@link #release},\n+     * and</li>\n+     * <li>each {@link #acquisitionTimeoutInNanos} nanoseconds\n+     * </ul>\n+     * until a channel is acquired.\n+     *\n+     * @param promise the promise of a {@link Channel channel}.\n      *\n-     * @param channel the {@link Channel} to return to internal storage\n-     * @return {@code true}, if the {@link Channel} could be added to internal storage; otherwise {@code false}\n+     * @see #isChannelServiceable(Channel)\n+     * @see AcquireTimeoutTask\n      */\n-    @Override\n-    protected boolean offerChannel(final Channel channel) {\n-        if (super.offerChannel(channel)) {\n-            this.availableChannelCount.incrementAndGet();\n-            return true;\n+    private void acquireChannel(final Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (this.isClosed()) {\n+            promise.setFailure(POOL_CLOSED_ON_ACQUIRE);\n+            return;\n+        }\n+\n+        try {\n+            Channel candidate = this.pollChannel();\n+\n+            if (candidate != null) {\n+\n+                // Fulfill this request with our candidate, assuming it's healthy\n+                // If our candidate is unhealthy, notifyChannelHealthCheck will call us again\n+\n+                doAcquireChannel(promise, candidate);\n+                return;\n+            }\n+\n+            final int channelCount = this.channels();\n+\n+            if (channelCount < this.maxChannels) {\n+\n+                if (this.connecting.compareAndSet(false, true)) {\n+\n+                    // Fulfill this request with a new channel, assuming we can connect one\n+                    // If our connection attempt fails, notifyChannelConnect will call us again\n+\n+                    final Promise<Channel> anotherPromise = this.newChannelPromise(promise);\n+                    final ChannelFuture future = this.bootstrap.clone().attr(POOL_KEY, this).connect();\n+\n+                    if (future.isDone()) {\n+                        this.notifyChannelConnect(future, anotherPromise);\n+                    } else {\n+                        future.addListener(ignored -> this.notifyChannelConnect(future, anotherPromise));\n+                    }\n+\n+                    return;\n+                }\n+\n+            } else if (this.computeLoadFactor() > 0.90D) {\n+\n+                // All channels are swamped and we'll pick the one with the lowest pending request count\n+\n+                long pendingRequestCountMin = Long.MAX_VALUE;\n+\n+                for (Channel channel : this.availableChannels) {\n+\n+                    final RntbdRequestManager manager = channel.pipeline().get(RntbdRequestManager.class);\n+                    final long pendingRequestCount = manager.pendingRequestCount();\n+\n+                    if (pendingRequestCount < pendingRequestCountMin) {\n+                        pendingRequestCountMin = pendingRequestCount;\n+                        candidate = channel;\n+                    }\n+                }\n+\n+                assert candidate != null;\n+\n+                this.availableChannels.remove(candidate);\n+                doAcquireChannel(promise, candidate);\n+\n+                return;\n+            }\n+\n+            this.addTaskToPendingAcquisitionQueue(promise);\n+\n+        } catch (Throwable cause) {\n+            promise.tryFailure(cause);\n         }\n-        return false;\n     }\n \n     /**\n-     * Poll a {@link Channel} out of internal storage to reuse it\n+     * Add a task to the pending acquisition queue to fulfill the request for a {@link Channel channel} later.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe and this type ensures thread safety by calling\n-     * this method serially on a single-threaded EventExecutor. As a result this method need not (and should not) be\n-     * synchronized.\n+     * Tasks in the pending acquisition queue are run whenever a channel is released. This ensures that pending requests\n+     * for channels are fulfilled as soon as possible.\n      *\n-     * @return a value of {@code null}, if no {@link Channel} is ready to be reused\n-     * @see #acquire(Promise)\n+     * @param promise a {@link Promise promise} that will be completed when a {@link Channel channel} is acquired or an\n+     * error is encountered.\n+     *\n+     * @see #runTasksInPendingAcquisitionQueue\n      */\n-    @Override\n-    protected Channel pollChannel() {\n-\n-        final Channel first = super.pollChannel();\n-\n-        if (first == null) {\n-            return null;\n+    private void addTaskToPendingAcquisitionQueue(Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"{}, {}, {}, {}, {}, {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMTc4NQ==", "bodyText": "Here's what I see in the code:\n            logger.debug(\"{}, {}, {}, {}, {}, {}\",\n                OffsetDateTime.now(),\n                this.remoteAddress(),\n                this.channels(),\n                this.channelsAcquired(),\n                this.channelsAvailable(),\n                this.requestQueueLength());", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424811785", "createdAt": "2020-05-14T00:54:19Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -281,126 +439,286 @@ public String toString() {\n         return RntbdObjectMapper.toString(this);\n     }\n \n+    // endregion\n+\n+    // region Privates\n+\n     /**\n-     * Offer a {@link Channel} back to the internal storage\n+     * Acquires a serviceable channel from the {@link RntbdClientChannelPool pool}.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe.\n+     * This method acquires the first channel that's both available and serviceable in LIFO order. A new channel is\n+     * created and added to the pool if and only if:\n+     * <ul>\n+     * <li>fewer than {@link #maxChannels} channels have been created ({@link #channels} < {@link #maxChannels()}))\n+     * and</li>\n+     * <li>there are no acquired channels pending release ({@link #channelsAcquired} == 0).</li>\n+     * </ul>\n+     * Under load it is possible that:\n+     * <ul>\n+     * <li>no available channels are serviceable ({@link RntbdRequestManager#pendingRequestCount()} ==\n+     * {@link #maxChannels()})</li>\n+     * <li>there are acquired channels pending release, and</li>\n+     * <li>{@link #maxChannels} channels have been created.</li>\n+     * </ul>\n+     * Under these circumstances a request to acquire a channel will be satisfied by the\n+     * {@link #acquisitionTimeoutTask} which will:\n+     * <ul>\n+     * <li>process items in the {@link #pendingAcquisitions} on each call to {@link #acquire} or {@link #release},\n+     * and</li>\n+     * <li>each {@link #acquisitionTimeoutInNanos} nanoseconds\n+     * </ul>\n+     * until a channel is acquired.\n+     *\n+     * @param promise the promise of a {@link Channel channel}.\n      *\n-     * @param channel the {@link Channel} to return to internal storage\n-     * @return {@code true}, if the {@link Channel} could be added to internal storage; otherwise {@code false}\n+     * @see #isChannelServiceable(Channel)\n+     * @see AcquireTimeoutTask\n      */\n-    @Override\n-    protected boolean offerChannel(final Channel channel) {\n-        if (super.offerChannel(channel)) {\n-            this.availableChannelCount.incrementAndGet();\n-            return true;\n+    private void acquireChannel(final Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (this.isClosed()) {\n+            promise.setFailure(POOL_CLOSED_ON_ACQUIRE);\n+            return;\n+        }\n+\n+        try {\n+            Channel candidate = this.pollChannel();\n+\n+            if (candidate != null) {\n+\n+                // Fulfill this request with our candidate, assuming it's healthy\n+                // If our candidate is unhealthy, notifyChannelHealthCheck will call us again\n+\n+                doAcquireChannel(promise, candidate);\n+                return;\n+            }\n+\n+            final int channelCount = this.channels();\n+\n+            if (channelCount < this.maxChannels) {\n+\n+                if (this.connecting.compareAndSet(false, true)) {\n+\n+                    // Fulfill this request with a new channel, assuming we can connect one\n+                    // If our connection attempt fails, notifyChannelConnect will call us again\n+\n+                    final Promise<Channel> anotherPromise = this.newChannelPromise(promise);\n+                    final ChannelFuture future = this.bootstrap.clone().attr(POOL_KEY, this).connect();\n+\n+                    if (future.isDone()) {\n+                        this.notifyChannelConnect(future, anotherPromise);\n+                    } else {\n+                        future.addListener(ignored -> this.notifyChannelConnect(future, anotherPromise));\n+                    }\n+\n+                    return;\n+                }\n+\n+            } else if (this.computeLoadFactor() > 0.90D) {\n+\n+                // All channels are swamped and we'll pick the one with the lowest pending request count\n+\n+                long pendingRequestCountMin = Long.MAX_VALUE;\n+\n+                for (Channel channel : this.availableChannels) {\n+\n+                    final RntbdRequestManager manager = channel.pipeline().get(RntbdRequestManager.class);\n+                    final long pendingRequestCount = manager.pendingRequestCount();\n+\n+                    if (pendingRequestCount < pendingRequestCountMin) {\n+                        pendingRequestCountMin = pendingRequestCount;\n+                        candidate = channel;\n+                    }\n+                }\n+\n+                assert candidate != null;\n+\n+                this.availableChannels.remove(candidate);\n+                doAcquireChannel(promise, candidate);\n+\n+                return;\n+            }\n+\n+            this.addTaskToPendingAcquisitionQueue(promise);\n+\n+        } catch (Throwable cause) {\n+            promise.tryFailure(cause);\n         }\n-        return false;\n     }\n \n     /**\n-     * Poll a {@link Channel} out of internal storage to reuse it\n+     * Add a task to the pending acquisition queue to fulfill the request for a {@link Channel channel} later.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe and this type ensures thread safety by calling\n-     * this method serially on a single-threaded EventExecutor. As a result this method need not (and should not) be\n-     * synchronized.\n+     * Tasks in the pending acquisition queue are run whenever a channel is released. This ensures that pending requests\n+     * for channels are fulfilled as soon as possible.\n      *\n-     * @return a value of {@code null}, if no {@link Channel} is ready to be reused\n-     * @see #acquire(Promise)\n+     * @param promise a {@link Promise promise} that will be completed when a {@link Channel channel} is acquired or an\n+     * error is encountered.\n+     *\n+     * @see #runTasksInPendingAcquisitionQueue\n      */\n-    @Override\n-    protected Channel pollChannel() {\n-\n-        final Channel first = super.pollChannel();\n-\n-        if (first == null) {\n-            return null;\n+    private void addTaskToPendingAcquisitionQueue(Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"{}, {}, {}, {}, {}, {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjc1NA=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 677}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzcwMDAwOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjowMDoxNVrOGRBtwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDo1MzowM1rOGVIcBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA3NA==", "bodyText": "Another TODO. Stale code ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420507074", "createdAt": "2020-05-06T02:00:15Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -411,48 +729,389 @@ private void close0() {\n             task.promise.setFailure(new ClosedChannelException());\n         }\n \n-        // Ensure we dispatch this on another Thread as close0 will be called from the EventExecutor and we need\n-        // to ensure we will not block in an EventExecutor\n+        // NOTE: we must dispatch this request on another thread--the closer thread--as this.doClose is called on\n+        // this.executor and we need to ensure we will not block it.\n+\n+        closer.submit(() -> {\n+\n+            this.availableChannels.addAll(this.acquiredChannels.values());\n+            this.acquiredChannels.clear();\n+\n+            for (; ; ) {\n+                final Channel channel = this.pollChannel();\n+                if (channel == null) {\n+                    break;\n+                }\n+                channel.close().awaitUninterruptibly(); // block and ignore errors reported back from channel.close\n+            }\n+\n+            assert this.acquiredChannels.isEmpty() && this.availableChannels.isEmpty();\n+\n+        }).addListener(closed -> {\n+            if (!closed.isSuccess()) {\n+                logger.error(\"[{}] close failed due to \", this, closed.cause());\n+            } else {\n+                logger.debug(\"[{}] closed\", this);\n+            }\n+        });\n+    }\n+\n+    private void ensureInEventLoop() {\n+        reportIssueUnless(logger, this.executor.inEventLoop(), this,\n+            \"expected to be in event loop {}, not thread {}\",\n+            this.executor,\n+            Thread.currentThread());\n+    }\n \n-        GlobalEventExecutor.INSTANCE.execute(RntbdClientChannelPool.super::close);\n+    /**\n+     * Checks that the state of this {@link RntbdClientChannelPool pool} is a valid run state and returns the {@link\n+     * #availableChannels} available channel count.\n+     * <p>\n+     * This method reports an issue to be addressed if the state is invalid. It does not throw.\n+     */\n+    private void ensureValidRunState() {\n+\n+        this.ensureInEventLoop();\n+// TODO (DANOBLE) remove or restore this code:\n+//        final int channelsAvailable = this.channelsAvailable();\n+//        final int channelsAcquired = this.channelsAcquired();\n+//        final int channelCount = this.channels();\n+//\n+//        reportIssueUnless(logger, 0 <= channelCount && channelCount <= this.maxChannels, this,\n+//            \"expected channelCount in range [0, {}], not {}\",\n+//            this.maxChannels,\n+//            channelCount,\n+//            channelsAcquired);\n+//\n+//        return channelsAvailable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 943}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMTUyNg==", "bodyText": "I will remove this in my next PR which will wire up the DirectConnectionConfig. The change is made on my local branch right now.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424811526", "createdAt": "2020-05-14T00:53:03Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -411,48 +729,389 @@ private void close0() {\n             task.promise.setFailure(new ClosedChannelException());\n         }\n \n-        // Ensure we dispatch this on another Thread as close0 will be called from the EventExecutor and we need\n-        // to ensure we will not block in an EventExecutor\n+        // NOTE: we must dispatch this request on another thread--the closer thread--as this.doClose is called on\n+        // this.executor and we need to ensure we will not block it.\n+\n+        closer.submit(() -> {\n+\n+            this.availableChannels.addAll(this.acquiredChannels.values());\n+            this.acquiredChannels.clear();\n+\n+            for (; ; ) {\n+                final Channel channel = this.pollChannel();\n+                if (channel == null) {\n+                    break;\n+                }\n+                channel.close().awaitUninterruptibly(); // block and ignore errors reported back from channel.close\n+            }\n+\n+            assert this.acquiredChannels.isEmpty() && this.availableChannels.isEmpty();\n+\n+        }).addListener(closed -> {\n+            if (!closed.isSuccess()) {\n+                logger.error(\"[{}] close failed due to \", this, closed.cause());\n+            } else {\n+                logger.debug(\"[{}] closed\", this);\n+            }\n+        });\n+    }\n+\n+    private void ensureInEventLoop() {\n+        reportIssueUnless(logger, this.executor.inEventLoop(), this,\n+            \"expected to be in event loop {}, not thread {}\",\n+            this.executor,\n+            Thread.currentThread());\n+    }\n \n-        GlobalEventExecutor.INSTANCE.execute(RntbdClientChannelPool.super::close);\n+    /**\n+     * Checks that the state of this {@link RntbdClientChannelPool pool} is a valid run state and returns the {@link\n+     * #availableChannels} available channel count.\n+     * <p>\n+     * This method reports an issue to be addressed if the state is invalid. It does not throw.\n+     */\n+    private void ensureValidRunState() {\n+\n+        this.ensureInEventLoop();\n+// TODO (DANOBLE) remove or restore this code:\n+//        final int channelsAvailable = this.channelsAvailable();\n+//        final int channelsAcquired = this.channelsAcquired();\n+//        final int channelCount = this.channels();\n+//\n+//        reportIssueUnless(logger, 0 <= channelCount && channelCount <= this.maxChannels, this,\n+//            \"expected channelCount in range [0, {}], not {}\",\n+//            this.maxChannels,\n+//            channelCount,\n+//            channelsAcquired);\n+//\n+//        return channelsAvailable;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA3NA=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 943}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzcwMjIyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjowMTo0NVrOGRBu8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDo0NzoyMVrOGVIWVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM3Nw==", "bodyText": "Love this. \u2764\ufe0f", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420507377", "createdAt": "2020-05-06T02:01:45Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -667,12 +1329,24 @@ public void serialize(final RntbdClientChannelPool value, final JsonGenerator ge\n             generator.writeNumberField(\"channelsAcquired\", value.channelsAcquired());\n             generator.writeNumberField(\"channelsAvailable\", value.channelsAvailable());\n             generator.writeNumberField(\"requestQueueLength\", value.requestQueueLength());\n-            generator.writeNumberField(\"usedDirectMemory\", value.usedDirectMemory());\n-            generator.writeNumberField(\"usedHeapMemory\", value.usedHeapMemory());\n             generator.writeEndObject();\n             generator.writeEndObject();\n         }\n     }\n \n+    private static class StacklessIllegalStateException extends IllegalStateException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 1544}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMDA2OQ==", "bodyText": "thank you.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424810069", "createdAt": "2020-05-14T00:47:21Z", "author": {"login": "David-Noble-at-work"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -667,12 +1329,24 @@ public void serialize(final RntbdClientChannelPool value, final JsonGenerator ge\n             generator.writeNumberField(\"channelsAcquired\", value.channelsAcquired());\n             generator.writeNumberField(\"channelsAvailable\", value.channelsAvailable());\n             generator.writeNumberField(\"requestQueueLength\", value.requestQueueLength());\n-            generator.writeNumberField(\"usedDirectMemory\", value.usedDirectMemory());\n-            generator.writeNumberField(\"usedHeapMemory\", value.usedHeapMemory());\n             generator.writeEndObject();\n             generator.writeEndObject();\n         }\n     }\n \n+    private static class StacklessIllegalStateException extends IllegalStateException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM3Nw=="}, "originalCommit": {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4"}, "originalPosition": 1544}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4526, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}