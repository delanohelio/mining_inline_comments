{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMTYxMDc5", "number": 11355, "title": "Persistent service principal token cache for MSAL confidential client", "bodyText": "A summary of changes\n\nUse MSAL's token cache for confidential client credentials instead of our proprietary SimpleTokenCache\nPlug MSAL's persistence token cache into the new token cache flow for confidential client credentials, storing at msal.confidential.cache file on Windows & Linux (unprotected) and MSALConfidentialCache secret item in Keychain and Keyring\nRemove usage of SimpleTokenCache in BearerTokenAuthenticationPolicy. This is postponed to next GAed version of Azure Identity to keep backward compatibility in azure-core. Tokens will be cached twice but shouldn't hit perf too much.\nRename IdentityClient.authenticateWithMsalAccount() to IdentityClient.authenticateWithPublicClientCache(), and add IdentityClient.authenticateWithConfidentialClientCache().\nLazy creation of ConfidentialClientApplication similar to the PublicClientApplication for sharing the client instance between getToken() calls so that we can tap into the same MSAL token cache. This will be moved to the constructor together with the PublicClientApplication in the IdentityClient split task.", "createdAt": "2020-05-21T05:39:48Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355", "merged": true, "mergeCommit": {"oid": "b4161a6d8e1efaa361a41679c9b1407676e1d86b"}, "closed": true, "closedAt": "2020-06-02T18:53:46Z", "author": {"login": "jianghaolu"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjW-I-gH2gAyNDIxMTYxMDc5OmFiMTcwZTZhMmNmYzVhZGU5MmJmOGYyN2FjOTgxNWU1ZjI2ZDQ1N2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmJaqEAH2gAyNDIxMTYxMDc5OmI2MDZiNzlkZjJjMDVjNThmNjViOTI2MTFiZWNhOGM0ZDIzN2YxMzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ab170e6a2cfc5ade92bf8f27ac9815e5f26d457e", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab170e6a2cfc5ade92bf8f27ac9815e5f26d457e", "committedDate": "2020-05-21T05:39:13Z", "message": "Use MSAL token cache for confidential client credentials"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5939411318bfdf625b8410cc3f43ab2345d0654c", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5939411318bfdf625b8410cc3f43ab2345d0654c", "committedDate": "2020-05-21T06:15:18Z", "message": "Checkstyle: log exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a75ef91f4cf345892f19fe9bb6195769ed690c1", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a75ef91f4cf345892f19fe9bb6195769ed690c1", "committedDate": "2020-05-21T07:30:08Z", "message": "improve cert parse error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9bbe33ce041b5bd31a796fa07074b839f5018d3", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9bbe33ce041b5bd31a796fa07074b839f5018d3", "committedDate": "2020-05-22T01:32:46Z", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into confidentialtokencache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2146503ac00d0d184f1243c7905761f3df446831", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2146503ac00d0d184f1243c7905761f3df446831", "committedDate": "2020-05-26T23:22:40Z", "message": "Remove force refresh for confidential client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/832b1454993fe3dc61e69b09ceedf2c18218b2c8", "committedDate": "2020-05-26T23:22:49Z", "message": "Merge branch 'confidentialtokencache' of github.com:jianghaolu/azure-sdk-for-java into confidentialtokencache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjUyNzEy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#pullrequestreview-419652712", "createdAt": "2020-05-27T22:26:32Z", "commit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyNjozMlrOGbfUiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo0MzoyOVrOGbfsjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Nzg5OQ==", "bodyText": "Is there a case where authenticateWithConfidentialClientCache would return null? If not I believe these could be merged into the onErrorResume.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431477899", "createdAt": "2020-05-27T22:26:32Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTQ2MA==", "bodyText": "I don't know if we need the Mono.defer here, I believe switchIfEmpty only processes if the upstream returns empty otherwise it is never ran.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431479460", "createdAt": "2020-05-27T22:30:33Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MTM2Ng==", "bodyText": "Not needed, but given this has a lot of nesting and all other conditionals hit terminal states above could the else be removed for a regular code block?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431481366", "createdAt": "2020-05-27T22:36:01Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MjI1NQ==", "bodyText": "Thoughts on merging all these to use their super class GeneralSecurityException.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431482255", "createdAt": "2020-05-27T22:38:30Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MzA1MA==", "bodyText": "Would this be better off above attempting to retrieve the credential as this will fail without requiring IO or handling security? Basically, this is a lighter exception to have happen first.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431483050", "createdAt": "2020-05-27T22:40:42Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException\n+                    | IOException e) {\n+                    throw logger.logExceptionAsError(new RuntimeException(\n+                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+                }\n+            } else {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+            }\n+            ConfidentialClientApplication.Builder applicationBuilder =\n+                ConfidentialClientApplication.builder(clientId, credential);\n+            try {\n+                applicationBuilder = applicationBuilder.authority(authorityUrl);\n+            } catch (MalformedURLException e) {\n+                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDA0Ng==", "bodyText": "Does Mono.fromFuture wrap the thrown exception into a Mono.error or will this need to be handled as a regular exception?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431484046", "createdAt": "2020-05-27T22:43:29Z", "author": {"login": "alzimmermsft"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,19 +493,38 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 throw logger.logExceptionAsError(Exceptions.propagate(e));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    throw logger.logExceptionAsError(Exceptions.propagate(e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8"}, "originalPosition": 313}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d525f588c446825fac37a32a36a6c9fb7a9da27", "committedDate": "2020-05-27T23:24:49Z", "message": "Address Alan's feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa7369283e98bf33cc89c19ae8f82b712afc1593", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aa7369283e98bf33cc89c19ae8f82b712afc1593", "committedDate": "2020-05-27T23:19:29Z", "message": "Address Alan's feedback"}, "afterCommit": {"oid": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d525f588c446825fac37a32a36a6c9fb7a9da27", "committedDate": "2020-05-27T23:24:49Z", "message": "Address Alan's feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a10c1cc45aae05601eb1561397bfa24f52fafa82", "committedDate": "2020-05-28T04:54:39Z", "message": "Add helper to support failed completable future in java 8"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDM3MTY0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#pullrequestreview-420437164", "createdAt": "2020-05-28T19:43:56Z", "commit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo0Mzo1N1rOGcD5VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzowNDo1OVrOGcJojA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ==", "bodyText": "the logic to build httpPipelineAdapter from line 177 - 193, can be extracted in a common helper method, and used in getPublicClient / getCofidentialClient methods.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432077141", "createdAt": "2020-05-28T19:43:57Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,67 +127,143 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n-    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n-        if (publicClientApplication != null) {\n-            return publicClientApplication;\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n+            try {\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+            }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA==", "bodyText": "we'll need to plumb this change in custom Token Credential Auth policies too where a cache is being maintained.\nWe can open an issue, for now, to track this work and get that change added to Track 2 SDKs when Identity is about to GA.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432160140", "createdAt": "2020-05-28T22:31:52Z", "author": {"login": "g2vinay"}, "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -36,16 +34,15 @@ public BearerTokenAuthenticationPolicy(TokenCredential credential, String... sco\n         Objects.requireNonNull(scopes);\n         assert scopes.length > 0;\n         this.credential = credential;\n-        this.scopes = scopes;\n-        this.cache = new SimpleTokenCache(() -> credential.getToken(new TokenRequestContext().addScopes(scopes)));\n+        this.tokenRequestContext = new TokenRequestContext().addScopes(scopes);\n     }\n \n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n         if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n         }\n-        return cache.getToken()\n+        return credential.getToken(tokenRequestContext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MzUzNg==", "bodyText": "Why is this call not deferred ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432163536", "createdAt": "2020-05-28T22:41:59Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDAwNQ==", "bodyText": "Why is this call not deferred ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432164005", "createdAt": "2020-05-28T22:43:22Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredential.java", "diffHunk": "@@ -44,13 +42,15 @@\n         identityClient = new IdentityClientBuilder()\n             .tenantId(tenantId)\n             .clientId(clientId)\n+            .clientSecret(clientSecret)\n             .identityClientOptions(identityClientOptions)\n             .build();\n-        this.clientSecret = clientSecret;\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return identityClient.authenticateWithClientSecret(clientSecret, request);\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDM3MA==", "bodyText": "Indicates whether to enable ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432164370", "createdAt": "2020-05-28T22:44:37Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg==", "bodyText": "Why are we doing Exceptions.propagate and not directly converting to Runtime Exception ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432169302", "createdAt": "2020-05-28T22:59:21Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTg1Nw==", "bodyText": "Do we expect MSAL to return an expired token ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432169857", "createdAt": "2020-05-28T23:00:56Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n+                }\n+            }).map(result -> new MsalToken(result, options)));\n+    }\n+\n+    /**\n+     * Asynchronously acquire a token from the currently logged in client.\n+     *\n+     * @param request the details of the token request\n+     * @return a Publisher that emits an AccessToken\n+     */\n+    public Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters.builder(\n+                new HashSet<>(request.getScopes()));\n             try {\n-                return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                return getConfidentialClientApplication().acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n-        }).map(result -> new MsalToken(result, options))));\n+        }).map(ar -> (AccessToken) new MsalToken(ar, options))\n+            .filter(t -> !t.isExpired());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTE0OA==", "bodyText": "Is this cache name going to be same across all languages ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432171148", "createdAt": "2020-05-28T23:04:59Z", "author": {"login": "g2vinay"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClientOptions.java", "diffHunk": "@@ -24,15 +24,18 @@\n  */\n public final class IdentityClientOptions {\n     private static final int MAX_RETRY_DEFAULT_LIMIT = 3;\n-    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_PUBLIC_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_CONFIDENTIAL_CACHE_FILE_NAME = \"msal.confidential.cache\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "402109c6529f055337161b4213c2fc476f879f5a", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/402109c6529f055337161b4213c2fc476f879f5a", "committedDate": "2020-05-28T23:50:57Z", "message": "Add setter for client certificate credential builder and fix javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTc1Njc1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#pullrequestreview-420575675", "createdAt": "2020-05-29T00:18:24Z", "commit": {"oid": "402109c6529f055337161b4213c2fc476f879f5a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f224a4529f5849217906dd704083addfe17384cd", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f224a4529f5849217906dd704083addfe17384cd", "committedDate": "2020-05-29T00:28:35Z", "message": "Revert changes in azure-core for backward compatibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e33fe44957cd9997a132df0776563f4fc7ae61e8", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e33fe44957cd9997a132df0776563f4fc7ae61e8", "committedDate": "2020-05-29T01:00:18Z", "message": "Clean up HttpPipelineAdapter creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c100d5ba097af9d5ba670b34d010f25d5606681", "committedDate": "2020-05-29T01:02:38Z", "message": "new RuntimeException()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTg5OTcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#pullrequestreview-420589972", "createdAt": "2020-05-29T01:06:16Z", "commit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjczMzA4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#pullrequestreview-421273308", "createdAt": "2020-05-29T20:39:58Z", "commit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDozOTo1OFrOGcrZVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NzoxNlrOGcr1Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDMwOA==", "bodyText": "Is Mono.defer() necessary? You can simply do switchIfEmpty(identityClient.authenticateWithConfidentialClient(request)) since this gets triggered only if the cache returns empty result and doesn't have to be deferred.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432724308", "createdAt": "2020-05-29T20:39:58Z", "author": {"login": "srnagar"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNjQxOQ==", "bodyText": "This reads a bit odd. You can simplify this: An updated instance of this builder.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432726419", "createdAt": "2020-05-29T20:44:54Z", "author": {"login": "srnagar"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled indicates whether to enable using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTQ1MA==", "bodyText": "Should this throw an exception if httpClient is null and proxy options are set?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432731450", "createdAt": "2020-05-29T20:57:16Z", "author": {"login": "srnagar"}, "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -877,4 +861,28 @@ void openUrl(String url) throws IOException {\n             logger.error(\"Browser could not be opened - please open {} in a browser on this device.\", url);\n         }\n     }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private void initializeHttpPipelineAdapter() {\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n+            } else if (options.getProxyOptions() == null) {\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681"}, "originalPosition": 438}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b606b79df2c05c58f65b92611beca8c4d237f131", "author": {"user": {"login": "jianghaolu", "name": "Jianghao Lu"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b606b79df2c05c58f65b92611beca8c4d237f131", "committedDate": "2020-05-29T21:33:28Z", "message": "Simply @return docs on builders"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4010, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}