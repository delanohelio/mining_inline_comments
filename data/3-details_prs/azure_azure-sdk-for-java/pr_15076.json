{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0NTg3NDc2", "number": 15076, "title": "Service Bus naming changes", "bodyText": "Changes getAutoRenewMessageLock and getAutoRenewSessionLock to renewMessageLock and renewSessionLock\nChanges method to take ServiceBusReceivedMessage instead of a String lockToken.", "createdAt": "2020-09-11T03:17:21Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076", "merged": true, "mergeCommit": {"oid": "3ba6f191f466a04c2e9e35c1ccacf61e0d085fde"}, "closed": true, "closedAt": "2020-09-11T21:24:04Z", "author": {"login": "conniey"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHvaFWAFqTQ4NjQ5NjgyOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdH8AhpgFqTQ4NzEyNTkyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NDk2ODI4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#pullrequestreview-486496828", "createdAt": "2020-09-11T06:06:48Z", "commit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjowNjo0OFrOHQPgaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNjoxMzoxNFrOHQPo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5MzMyMQ==", "bodyText": "\"renews the specified message\" is confusing", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486793321", "createdAt": "2020-09-11T06:06:48Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NDAyNA==", "bodyText": "The above uses monoError. Why is this line different?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486794024", "createdAt": "2020-09-11T06:09:00Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NTE1Mg==", "bodyText": "Same question. The above uses monoError. This overload uses logger.logExceptionAsError().", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486795152", "createdAt": "2020-09-11T06:12:21Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NTQ4NA==", "bodyText": "same question", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486795484", "createdAt": "2020-09-11T06:13:14Z", "author": {"login": "YijunXieMS"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -885,6 +848,42 @@ public String getEntityPath() {\n                 .map(instant -> instant.atOffset(ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code sessionId} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.\n+     */\n+    public Mono<Void> renewSessionLock(String sessionId, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewSessionLock\")));\n+        } else if (!receiverOptions.isSessionReceiver()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f"}, "originalPosition": 202}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NTMxNjU1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#pullrequestreview-486531655", "createdAt": "2020-09-11T07:17:17Z", "commit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NTg2MTU1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#pullrequestreview-486586155", "createdAt": "2020-09-11T08:29:58Z", "commit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODoyOTo1OFrOHQTfOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozNjoxMFrOHQTsFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg==", "bodyText": "Why are we using ServiceBusReceivedMessage for renewing and other settlement methods? Should we use the locktoken instead as per this API view?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486858552", "createdAt": "2020-09-11T08:29:58Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1OTg5Mw==", "bodyText": "There's no lockToken in the input args? I guess this is referring to message. However, as per the API view, the actual argument should be lockToken.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486859893", "createdAt": "2020-09-11T08:32:26Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MDgwMA==", "bodyText": "Might be worth adding a log when onComplete() is called too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486860800", "createdAt": "2020-09-11T08:34:14Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";\n+        final Consumer<Throwable> throwableConsumer = onError != null\n+            ? onError\n+            : error -> logger.warning(\"Exception occurred while renewing lock token '{}'.\", lockToken, error);\n+\n+        asyncClient.renewMessageLock(message, maxLockRenewalDuration).subscribe(\n+            v -> logger.verbose(\"Completed renewing lock token: '{}'\", lockToken),\n+            throwableConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTg0Nw==", "bodyText": "Does the auto-lock renewal stop if the user settles the message?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486861847", "createdAt": "2020-09-11T08:36:10Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n+        } else if (receiverOptions.isSessionReceiver()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n+        } else if (maxLockRenewalDuration == null) {\n+            return monoError(logger, new NullPointerException(\"'maxLockRenewalDuration' cannot be null.\"));\n+        } else if (maxLockRenewalDuration.isNegative()) {\n+            return monoError(logger, new IllegalArgumentException(\"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        final LockRenewalOperation operation = new LockRenewalOperation(message.getLockToken(),\n+            maxLockRenewalDuration, false, ignored -> renewMessageLock(message));\n+        renewalContainer.addOrUpdate(message.getLockToken(), Instant.now().plus(maxLockRenewalDuration), operation);\n+\n+        return operation.getCompletionOperation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTYyMjcz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#pullrequestreview-486962273", "createdAt": "2020-09-11T16:43:32Z", "commit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo0MzozMlrOHQmIsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowNzo1MVrOHQm7Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDA4MA==", "bodyText": "Although logically lockToken will always be there but we should check for null value also.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487164080", "createdAt": "2020-09-11T16:43:32Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDkxMA==", "bodyText": "given lock -> given {@link ServiceBusReceivedMessage}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487164910", "createdAt": "2020-09-11T16:45:06Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NTU3NQ==", "bodyText": "null check for message.getLockToken()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487165575", "createdAt": "2020-09-11T16:46:18Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjU3MA==", "bodyText": "lock token -> session ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487166570", "createdAt": "2020-09-11T16:48:13Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -885,6 +847,42 @@ public String getEntityPath() {\n                 .map(instant -> instant.atOffset(ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2OTY2Mg==", "bodyText": "the lock on the specified message   This is repeated two times.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487169662", "createdAt": "2020-09-11T16:53:55Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -570,13 +524,13 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n     }\n \n     /**\n-     * Renews the lock on the specified message. The lock will be renewed based on the setting specified on the entity.\n-     * When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the server for this\n-     * receiver instance for a duration as specified during the Queue creation (LockDuration). If processing of the\n-     * message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to\n-     * the entity's LockDuration value.\n+     * Renews the lock on the specified message.the lock on the specified message. The lock will be renewed based on the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MzI3OQ==", "bodyText": "What is the reason of assigning \"null\" string to lockToken . Shouldn't  we throw NPE if it is null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487173279", "createdAt": "2020-09-11T17:00:26Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDE4NA==", "bodyText": "with the given lock : It is a bit confusing since user never gave us any lock in this API.\nSuggestion Starts the auto lock renewal for a session id.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487174184", "createdAt": "2020-09-11T17:02:12Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -601,6 +578,27 @@ public OffsetDateTime renewSessionLock(String sessionId) {\n         return asyncClient.renewSessionLock(sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDQ1NQ==", "bodyText": "lock token -> session", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487174455", "createdAt": "2020-09-11T17:02:45Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -601,6 +578,27 @@ public OffsetDateTime renewSessionLock(String sessionId) {\n         return asyncClient.renewSessionLock(sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NzAzMA==", "bodyText": "May be adding test is message.getLockToken() returns null.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487177030", "createdAt": "2020-09-11T17:07:51Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientTest.java", "diffHunk": "@@ -164,15 +166,17 @@ void autoRenewMessageLockFails() {\n         final TestPublisher<Void> publisher = TestPublisher.create();\n         final Throwable testError = new IllegalAccessException(\"Some exception\");\n \n-        when(asyncClient.getAutoRenewMessageLock(LOCK_TOKEN, maxDuration)).thenReturn(publisher.mono());\n+        when(message.getLockToken()).thenReturn(LOCK_TOKEN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ac55299c0c8b4be2bc6aeac667dc1a803597c2c", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ac55299c0c8b4be2bc6aeac667dc1a803597c2c", "committedDate": "2020-09-11T19:52:38Z", "message": "Rename from getAutoRenewMessageLock and getAutoRenewSessionLock to renewMessageLock and renewSessionLock."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42817b96fbe85b020370d37df2136dc09c7d9306", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/42817b96fbe85b020370d37df2136dc09c7d9306", "committedDate": "2020-09-11T19:52:39Z", "message": "Replace renewMessageLock with ServiceBusReceivedMessage instead of string."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71c5ff6ccf268e8463206c46be7500810a5b9968", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/71c5ff6ccf268e8463206c46be7500810a5b9968", "committedDate": "2020-09-11T19:52:39Z", "message": "Fix test failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b672dd46da0bc7c494451fa11477beab5f3bc9c3", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b672dd46da0bc7c494451fa11477beab5f3bc9c3", "committedDate": "2020-09-11T19:52:39Z", "message": "Updating to use monoError"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "023111ae08c83f3d8388610a30cda386a20fffa6", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/023111ae08c83f3d8388610a30cda386a20fffa6", "committedDate": "2020-09-11T20:58:58Z", "message": "Adding onComplete(), and updating token documentation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7740f8ac30f9a89a49962feb3c0308bdb4a55ccc", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7740f8ac30f9a89a49962feb3c0308bdb4a55ccc", "committedDate": "2020-09-11T20:59:34Z", "message": "Updating documentation for async client."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "badad4065d173c0806a16af87e1b2549a49ff67e", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/badad4065d173c0806a16af87e1b2549a49ff67e", "committedDate": "2020-09-11T20:59:43Z", "message": "Adding test cases for lock tokens."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "611f922cb4efedd3a2a5608a21e85febc508291f", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/611f922cb4efedd3a2a5608a21e85febc508291f", "committedDate": "2020-09-11T21:05:18Z", "message": "Fixing line issues."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8643bb112ee7e368851fc81810f3984893551b15", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8643bb112ee7e368851fc81810f3984893551b15", "committedDate": "2020-09-11T06:57:03Z", "message": "Updating to use monoError"}, "afterCommit": {"oid": "611f922cb4efedd3a2a5608a21e85febc508291f", "author": {"user": {"login": "conniey", "name": "Connie Yau"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/611f922cb4efedd3a2a5608a21e85febc508291f", "committedDate": "2020-09-11T21:05:18Z", "message": "Fixing line issues."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTI1OTI4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#pullrequestreview-487125928", "createdAt": "2020-09-11T21:09:35Z", "commit": {"oid": "611f922cb4efedd3a2a5608a21e85febc508291f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3628, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}