{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzNzY4MDMy", "number": 10734, "title": "SyncClient: Bug fix - Multiple Receive on same client", "bodyText": "Sync Client should be able to call receive() multiple times.", "createdAt": "2020-05-05T21:42:42Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734", "merged": true, "mergeCommit": {"oid": "6ea230ecefff540fa11a7af5fc1bc9301f106f2b"}, "closed": true, "closedAt": "2020-05-07T22:02:05Z", "author": {"login": "hemanttanwar"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcebJdpgH2gAyNDEzNzY4MDMyOjc2NzI2Mzg0ZWQyMWY3N2Y3ZTllNzNmMjYzYjA3OTFkNGI3ZTU3ZDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfEYPfAH2gAyNDEzNzY4MDMyOjZlNzNkMDFjOTExMzQ5MmI0ZWIzNjQxMWE4MzE0NzY1MGU4MjEyOGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "76726384ed21f77f7e9e73f263b0791d4b7e57d0", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/76726384ed21f77f7e9e73f263b0791d4b7e57d0", "committedDate": "2020-05-05T21:41:35Z", "message": "SyncClient: Bug fix - Multiple Receive on same client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "160171f58d90c08e15be073ef5132a8d4acfa9f7", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/160171f58d90c08e15be073ef5132a8d4acfa9f7", "committedDate": "2020-05-05T21:57:03Z", "message": "Fixing spot bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/54a03f3bafa0769d3ca5c46c86987a5264fe5795", "committedDate": "2020-05-05T22:20:35Z", "message": "improving the integration test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjIzMzE4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-406223318", "createdAt": "2020-05-05T23:29:02Z", "commit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyOTowM1rOGQ_RkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyOTowM1rOGQ_RkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzA4OQ==", "bodyText": "This isn't thread safe, in the time that you check for null, someone else could have set it. Or if it is null, and then you create it, it could possibly overwrite an existing EmitterProcessor that was set in this time.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467089", "createdAt": "2020-05-05T23:29:03Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +628,56 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjIzNTA0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-406223504", "createdAt": "2020-05-05T23:29:35Z", "commit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyOTozNVrOGQ_SSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyOTozNVrOGQ_SSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzI3NA==", "bodyText": "Will it throw if you call dispose twice?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467274", "createdAt": "2020-05-05T23:29:35Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +628,56 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjIzNTgz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-406223583", "createdAt": "2020-05-05T23:29:47Z", "commit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyOTo0N1rOGQ_SmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyOTo0N1rOGQ_SmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzM1Mg==", "bodyText": "These are for side effects.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467352", "createdAt": "2020-05-05T23:29:47Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +628,56 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n+            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n+            return;\n+        }\n+\n+        if (messageProcessor.get() == null) {\n+            EmitterProcessor<ServiceBusReceivedMessageContext> processor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false));\n+\n+            if (!messageProcessor.compareAndSet(null, processor)) {\n+                processor.dispose();\n+            }\n+\n+            logger.info(\"[{}]: Started ContinuesMessageSubscriber message subscriber for entity.\",\n+                asyncClient.getEntityPath());\n+        }\n+\n+        Disposable newSubscription = messageProcessor.get()\n+            .take(maximumMessageCount)\n+            .timeout(maxWaitTime)\n+            .doOnNext(messageContext -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/58a53d31c75349677e3fb8bc2322d2e1502f624b", "committedDate": "2020-05-06T00:34:27Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjQ4NTA5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-406248509", "createdAt": "2020-05-06T00:51:34Z", "commit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMDo1MTozNFrOGRAt0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMToxNjozN1rOGRBFzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDcwNQ==", "bodyText": "commented code should be removed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420490705", "createdAt": "2020-05-06T00:51:34Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -503,7 +509,8 @@ public ServiceBusReceivedMessage peekAt(long sequenceNumber, String sessionId) {\n \n         final Flux<ServiceBusReceivedMessageContext> messages = Flux.create(emitter -> queueWork(maxMessages,\n             maxWaitTime, emitter));\n-\n+        //queueWork(maxMessages, maxWaitTime, null);\n+        //return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MTEzMQ==", "bodyText": "Between isDisposed() check and dispose() the processor might have changed state. This is not an atomic operation, if that's what you were trying to achieve using the AtomicReference.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420491131", "createdAt": "2020-05-06T00:53:31Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +629,63 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MTE5NA==", "bodyText": "Same here, this is not an atomic operation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420491194", "createdAt": "2020-05-06T00:53:47Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +629,63 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n+            activeSubscription.dispose();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MjA4MA==", "bodyText": "Missing javadoc. Do we need this class in public API surface? This should be in implementation package.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420492080", "createdAt": "2020-05-06T00:57:15Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.azure.messaging.servicebus;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+public class SyncMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MjU3Mg==", "bodyText": "Why do we need this class? This seems to be just printing some debug info to the console.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420492572", "createdAt": "2020-05-06T00:59:15Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.azure.messaging.servicebus;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+public class SyncMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private Subscription subscription;\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        this.subscription = subscription;\n+        subscription.request(1);\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n+        System.out.println(Thread.currentThread().getName() + \" : \" + value);\n+        // Request for one more event\n+        subscription.request(1);\n+    }\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        System.out.println(\"Complete\");\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        throwable.printStackTrace();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        System.out.println(\"Cancelled\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5Njg0Nw==", "bodyText": "timeout() is not the right operator here. The maxWaitTime param specifies the maximum time to wait before receiving all messages upto maximumMessageCount. timeout() operator will reset the timer after each message is received. Also, if there is a timeout, it will throw an exception which is not what should happen. Instead, it should return all messages until the timeout occurred.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420496847", "createdAt": "2020-05-06T01:16:37Z", "author": {"login": "srnagar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +629,63 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n+            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n+            return;\n+        }\n+\n+        if (messageProcessor.get() == null) {\n+            logger.info(\"[{}]: Creating EmitterProcessor message processor for entity.\", asyncClient.getEntityPath());\n+\n+            EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false));\n+            // if some other thread have come in between, we will not reset new processor\n+            if (!messageProcessor.compareAndSet(null, newProcessor)) {\n+                newProcessor.dispose();\n+            }\n+\n+            logger.info(\"[{}]: Started EmitterProcessor message processor for entity.\",\n+                asyncClient.getEntityPath());\n+        }\n+\n+            logger.info(\"[{}]: Subscribing EmitterProcessor message processor for entity.\",\n+                asyncClient.getEntityPath());\n+\n+        Disposable newSubscription = messageProcessor.get()\n+            .take(maximumMessageCount)\n+            .timeout(maxWaitTime)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff89717fde24a5bde0e2a52628f2382763e7e02f", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ff89717fde24a5bde0e2a52628f2382763e7e02f", "committedDate": "2020-05-06T02:08:58Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52bb661dd924dc8f2aae5a141ab28698e8248eba", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/52bb661dd924dc8f2aae5a141ab28698e8248eba", "committedDate": "2020-05-06T03:08:07Z", "message": "review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjgwNzcw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-406280770", "createdAt": "2020-05-06T03:14:30Z", "commit": {"oid": "52bb661dd924dc8f2aae5a141ab28698e8248eba"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxNDozMFrOGRCtcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxNDozMFrOGRCtcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMzM3OQ==", "bodyText": "What if the existing subscription is still waiting for work? You're going to cancel it?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420523379", "createdAt": "2020-05-06T03:14:30Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +627,61 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n+            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n+            return;\n+        }\n+\n+        if (messageProcessor.get() == null) {\n+            logger.info(\"[{}]: Creating EmitterProcessor message processor for entity.\", asyncClient.getEntityPath());\n+\n+            EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false));\n+\n+            // if some other thread have come in between, we will dispose new processor\n+            if (!messageProcessor.compareAndSet(null, newProcessor)) {\n+                newProcessor.dispose();\n+            }\n+\n+            logger.info(\"[{}]: Started EmitterProcessor message processor for entity.\",\n+                asyncClient.getEntityPath());\n+        }\n+\n+        Disposable newSubscription = messageProcessor.get()\n+            .take(maximumMessageCount)\n+            .timeout(maxWaitTime)\n+            .map(message -> {\n+                emitter.next(message);\n+                return message;\n+            })\n+            .subscribe(message -> {},\n+                error -> {\n+                    logger.error(\"Error occurred while receiving messages.\", error);\n+                    emitter.error(error);\n+                },\n+                () -> emitter.complete());\n+\n+        Disposable oldSubscription = messageProcessorSubscription.getAndSet(newSubscription);\n+        if (oldSubscription != null && !oldSubscription.isDisposed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bb661dd924dc8f2aae5a141ab28698e8248eba"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57fae633d7098624559fe8317fa68a167456e33a", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/57fae633d7098624559fe8317fa68a167456e33a", "committedDate": "2020-05-06T10:47:59Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e13c33eeabba3736f78ec3e9a9f86c9c6f02ace7", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e13c33eeabba3736f78ec3e9a9f86c9c6f02ace7", "committedDate": "2020-05-06T17:36:54Z", "message": "fixing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03012020658feedb94426c0aac665d26cc229d86", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/03012020658feedb94426c0aac665d26cc229d86", "committedDate": "2020-05-06T17:42:01Z", "message": "Removing unwanted logging in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8a5345245f535569a0156294ef7e8cd0b3c411d", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e8a5345245f535569a0156294ef7e8cd0b3c411d", "committedDate": "2020-05-06T20:09:06Z", "message": "moving creation of Emitter processor out of constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baacc2e0078fff24323b63f0d5835fe003c79714", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/baacc2e0078fff24323b63f0d5835fe003c79714", "committedDate": "2020-05-06T20:16:52Z", "message": "merge master into branch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTU1NzA5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-406955709", "createdAt": "2020-05-06T20:18:55Z", "commit": {"oid": "baacc2e0078fff24323b63f0d5835fe003c79714"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDoxODo1NVrOGRj3fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDoxODo1NVrOGRj3fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NjYyMw==", "bodyText": "synchronized : This is because if multiple client are calling receive, we need to ensure that short lived sync subscriber is thread safe.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421066623", "createdAt": "2020-05-06T20:18:55Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +609,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor != null) {\n+            messageProcessor.onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baacc2e0078fff24323b63f0d5835fe003c79714"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38cd751349bde6f92765c3051aa2e6756e78b6a4", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/38cd751349bde6f92765c3051aa2e6756e78b6a4", "committedDate": "2020-05-06T20:20:57Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99418e736e4bbba82faf76cb6850aa258784f6f2", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/99418e736e4bbba82faf76cb6850aa258784f6f2", "committedDate": "2020-05-06T20:47:45Z", "message": "fix check style error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "072ea0c480d1718c7b2efdbf30c9ea12d65263c6", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/072ea0c480d1718c7b2efdbf30c9ea12d65263c6", "committedDate": "2020-05-06T21:49:09Z", "message": "Merge branch 'master' into servicebus-track2-sync-receive-multiple-times-10519"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MDA1NzY0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#pullrequestreview-407005764", "createdAt": "2020-05-06T21:37:16Z", "commit": {"oid": "99418e736e4bbba82faf76cb6850aa258784f6f2"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTozNzoxNlrOGRmXgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTo0OTo1M1rOGRmtYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNzU4Nw==", "bodyText": "The operation should be cancel(), not onComplete(). onComplete and methods like that should be done through a sink.\nvar processor = messageProcessor.getAndSet(null);\nif (processor != null) {\n   processor.cancel()\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421107587", "createdAt": "2020-05-06T21:37:16Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +611,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99418e736e4bbba82faf76cb6850aa258784f6f2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMjEzOQ==", "bodyText": "You can also synchronize on a lock object rather than on an entire class to scope down how large this critical path is.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421112139", "createdAt": "2020-05-06T21:47:32Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +609,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor != null) {\n+            messageProcessor.onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NjYyMw=="}, "originalCommit": {"oid": "baacc2e0078fff24323b63f0d5835fe003c79714"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMjgxMA==", "bodyText": "This overload fetches 256. I was hoping you'd use the overload that specifies the buffer size, so you don't accidentally consume more messages than the user wants to process. EmitterProcessor.create(prefetch, false);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421112810", "createdAt": "2020-05-06T21:49:01Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +611,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         final long id = idGenerator.getAndIncrement();\n         final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n             emitter);\n         final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-\n         logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+\n+        if (messageProcessor.get() ==  null) {\n+            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99418e736e4bbba82faf76cb6850aa258784f6f2"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMzE4NA==", "bodyText": "The general trick is to store the value from your AtomicReference operation in a local variable so you don't keep accessing it. You had already fetched its value in line 631.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421113184", "createdAt": "2020-05-06T21:49:53Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +611,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         final long id = idGenerator.getAndIncrement();\n         final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n             emitter);\n         final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-\n         logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+\n+        if (messageProcessor.get() ==  null) {\n+            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false)));\n+        }\n+\n+        messageProcessor.get().subscribe(syncSubscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99418e736e4bbba82faf76cb6850aa258784f6f2"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "committedDate": "2020-05-06T22:43:25Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66e580f24a3b22f808a5b77469b30e9952a3eb09", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/66e580f24a3b22f808a5b77469b30e9952a3eb09", "committedDate": "2020-05-06T23:10:01Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0796a28db883855b36820a1648cbb1a365c0a30d", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0796a28db883855b36820a1648cbb1a365c0a30d", "committedDate": "2020-05-07T21:42:35Z", "message": "Merge branch 'master' into servicebus-track2-sync-receive-multiple-times-10519"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e73d01c9113492b4eb36411a83147650e82128e", "author": {"user": null}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e73d01c9113492b4eb36411a83147650e82128e", "committedDate": "2020-05-07T21:43:50Z", "message": "merge master"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4559, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}