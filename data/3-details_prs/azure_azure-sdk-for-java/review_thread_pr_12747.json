{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzMzQyMjY0", "number": 12747, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjowNzoyNVrOEK94Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxNTo0N1rOELwRxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTM0OTc4OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ObservableHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjowNzoyNVrOGsURTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxNjowMVrOGsUl2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMjYzOQ==", "bodyText": "Shouldn't this return Flux.error(e) ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449122639", "createdAt": "2020-07-02T16:07:25Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ObservableHelper.java", "diffHunk": "@@ -44,4 +44,21 @@\n             return BackoffRetryUtility.executeRetry(() -> function.call(), retryPolicy);\n         }\n     }\n+\n+    static public <T> Flux<T> fluxInlineIfPossibleAsObs(Callable<Flux<T>> function, IRetryPolicy retryPolicy) {\n+\n+        if (retryPolicy == null) {\n+            // shortcut\n+            return Flux.defer(() -> {\n+                try {\n+                    return function.call();\n+                } catch (Exception e) {\n+                    return Mono.error(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d609c626775c4ddf185b42ddc73427d69b46591"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNzg5OQ==", "bodyText": "oh haha, yea you are right, I just pushed a fix for it, thanks~ copy paste error", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449127899", "createdAt": "2020-07-02T16:16:01Z", "author": {"login": "xinlian12"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ObservableHelper.java", "diffHunk": "@@ -44,4 +44,21 @@\n             return BackoffRetryUtility.executeRetry(() -> function.call(), retryPolicy);\n         }\n     }\n+\n+    static public <T> Flux<T> fluxInlineIfPossibleAsObs(Callable<Flux<T>> function, IRetryPolicy retryPolicy) {\n+\n+        if (retryPolicy == null) {\n+            // shortcut\n+            return Flux.defer(() -> {\n+                try {\n+                    return function.call();\n+                } catch (Exception e) {\n+                    return Mono.error(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMjYzOQ=="}, "originalCommit": {"oid": "6d609c626775c4ddf185b42ddc73427d69b46591"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTM3NDk1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxNDowMlrOGsUgyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxNDowMlrOGsUgyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNjYwMQ==", "bodyText": "Not sure I picked up the best places to wire up the invalid partitionExceptionRetryPolicy. Several thoughts and questions:\n\nTrying to put this logic as low as the query pipeline\nSince for parallelQuery, each partition will have its own request, so at this point, there will be no request associate with this retry policy.\nI see usually we define next policy, but in this case, I do not think we need to define any. does it make sense?\nFor default document context, it already wired up InvalidPartitionExecptionRetry, but I do not see harm to wire it again here\nCurrently, for pipelinedDocumentQuery, we have retry policy for each partition. For example throttleRetryPolicy,  does it mean each partition will retry n times? should this number be shared across all the partitions?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449126601", "createdAt": "2020-07-02T16:14:02Z", "author": {"login": "xinlian12"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -560,18 +560,39 @@ private String parentResourceLinkToQueryLink(String parentResouceLink, ResourceT\n     }\n \n     private <T extends Resource> Flux<FeedResponse<T>> createQuery(\n-            String parentResourceLink,\n+        String parentResourceLink,\n+        SqlQuerySpec sqlQuery,\n+        CosmosQueryRequestOptions options,\n+        Class<T> klass,\n+        ResourceType resourceTypeEnum) {\n+\n+        String resourceLink = parentResourceLinkToQueryLink(parentResourceLink, resourceTypeEnum);\n+        UUID activityId = Utils.randomUUID();\n+        IDocumentQueryClient queryClient = documentQueryClientImpl(RxDocumentClientImpl.this);\n+\n+        InvalidPartitionExceptionRetryPolicy invalidPartitionExceptionRetryPolicy = new InvalidPartitionExceptionRetryPolicy(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d609c626775c4ddf185b42ddc73427d69b46591"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTM5NTkzOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerQueryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxOToyNlrOGsUtug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxOToyNlrOGsUtug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyOTkxNA==", "bodyText": "this test group will run against prod endpoint.\nCreating container/deleting container is expensive against prod. We usually use emulator for such tests.\nPlease see this test class: CollectionCrudTest.java (it uses emulator for test group).\nCould you please create a new Java Test class (ContainerCreateDeleteWithSameNameTest.java) similar to CollectionCrudTest and move this test method there?\nwe need to test more scenarios (point read, write, query, change feed) on container create delete so it is better if we have a separate test class for that.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449129914", "createdAt": "2020-07-02T16:19:26Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerQueryTest.java", "diffHunk": "@@ -109,8 +110,41 @@ public void queryCollections_NoResults() throws Exception {\n         validateQuerySuccess(queryObservable.byPage(), validator);\n     }\n \n+    @Test(groups = { \"simple\" }, timeOut = TIMEOUT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d609c626775c4ddf185b42ddc73427d69b46591"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTQxMzY2OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BackoffRetryUtility.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyNDoxNVrOGsU4lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyNDoxNVrOGsU4lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjY5Mg==", "bodyText": "WOW such a compact code. Equivalent .NET one is reasonably verbose.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449132692", "createdAt": "2020-07-02T16:24:15Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BackoffRetryUtility.java", "diffHunk": "@@ -38,6 +39,17 @@\n         }).retryWhen(RetryUtils.toRetryWhenFunc(retryPolicy));\n     }\n \n+    static public <T> Flux<T> fluxExecuteRetry(Callable<Flux<T>> callbackMethod, IRetryPolicy retryPolicy) {\n+\n+        return Flux.defer(() -> {\n+            try {\n+                return callbackMethod.call();\n+            } catch (Exception e) {\n+                return Flux.error(e);\n+            }\n+        }).retryWhen(RetryUtils.toRetryWhenFunc(retryPolicy));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98495c2011262bcb440c5416522148a31a34dfa7"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDM2ODI3OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerCreateDeleteWithSameNameTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMTo1NDoxOVrOGseDdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzo1ODoxNFrOGsgA-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI4MjkzMg==", "bodyText": "given that InternalObjectNode is an internal construct, could you please not use it in the new tests?\nYou can use a Pojo Object bellow or ObjectNode.\nstatic class POJO {\n  public String mypk;\n  public String id;\n}\nI know that some of the existing old tests are using InternalObjectNode, but for new tests we should not InternalObjectNode", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449282932", "createdAt": "2020-07-02T21:54:19Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerCreateDeleteWithSameNameTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.rx;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ChangeFeedProcessor;\n+import com.azure.cosmos.ChangeFeedProcessorBuilder;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.implementation.FeedResponseListValidator;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.models.ChangeFeedProcessorOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerRequestOptions;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.CosmosPagedFlux;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ContainerCreateDeleteWithSameNameTest extends TestSuiteBase{\n+    private final static int TIMEOUT = 300000;\n+    private CosmosAsyncClient client;\n+    private CosmosAsyncDatabase createdDatabase;\n+\n+    @Factory(dataProvider = \"clientBuilders\")\n+    public ContainerCreateDeleteWithSameNameTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+        this.subscriberValidationTimeout = TIMEOUT;\n+    }\n+\n+    @Test(groups = { \"emulator\" }, timeOut = TIMEOUT)\n+    public <T> void query() throws Exception {\n+        String query = \"SELECT * FROM r\";\n+\n+        Consumer<CosmosAsyncContainer> func = (container) -> {\n+            InternalObjectNode docDefinition = getDocumentDefinition();\n+            container.createItem(docDefinition).block();\n+\n+            CosmosQueryRequestOptions requestOptions = new CosmosQueryRequestOptions();\n+            CosmosPagedFlux<InternalObjectNode> queryFlux = container.queryItems(query, requestOptions, InternalObjectNode.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88d65699caf96f1c963f87877730bc2ea82bc13c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTA2Ng==", "bodyText": "updated", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r449315066", "createdAt": "2020-07-02T23:58:14Z", "author": {"login": "xinlian12"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerCreateDeleteWithSameNameTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.rx;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ChangeFeedProcessor;\n+import com.azure.cosmos.ChangeFeedProcessorBuilder;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.implementation.FeedResponseListValidator;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.models.ChangeFeedProcessorOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerRequestOptions;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.CosmosPagedFlux;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ContainerCreateDeleteWithSameNameTest extends TestSuiteBase{\n+    private final static int TIMEOUT = 300000;\n+    private CosmosAsyncClient client;\n+    private CosmosAsyncDatabase createdDatabase;\n+\n+    @Factory(dataProvider = \"clientBuilders\")\n+    public ContainerCreateDeleteWithSameNameTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+        this.subscriberValidationTimeout = TIMEOUT;\n+    }\n+\n+    @Test(groups = { \"emulator\" }, timeOut = TIMEOUT)\n+    public <T> void query() throws Exception {\n+        String query = \"SELECT * FROM r\";\n+\n+        Consumer<CosmosAsyncContainer> func = (container) -> {\n+            InternalObjectNode docDefinition = getDocumentDefinition();\n+            container.createItem(docDefinition).block();\n+\n+            CosmosQueryRequestOptions requestOptions = new CosmosQueryRequestOptions();\n+            CosmosPagedFlux<InternalObjectNode> queryFlux = container.queryItems(query, requestOptions, InternalObjectNode.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI4MjkzMg=="}, "originalCommit": {"oid": "88d65699caf96f1c963f87877730bc2ea82bc13c"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzYwNzczOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerCreateDeleteWithSameNameTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxNTo0N1rOGteGnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxNTo0N1rOGteGnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzMjMxNg==", "bodyText": "it might be worth having this as a constant with a quick explanation for why it is needed (emulator's deletes are not instantaneous).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12747#discussion_r450332316", "createdAt": "2020-07-06T16:15:47Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ContainerCreateDeleteWithSameNameTest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.rx;\n+\n+import com.azure.cosmos.ChangeFeedProcessor;\n+import com.azure.cosmos.ChangeFeedProcessorBuilder;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.implementation.FeedResponseListValidator;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.models.ChangeFeedProcessorOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerRequestOptions;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.CosmosPagedFlux;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ContainerCreateDeleteWithSameNameTest extends TestSuiteBase {\n+    private final static int TIMEOUT = 300000;\n+    private CosmosAsyncClient client;\n+    private CosmosAsyncDatabase createdDatabase;\n+\n+    @Factory(dataProvider = \"clientBuildersWithSessionConsistency\")\n+    public ContainerCreateDeleteWithSameNameTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+        this.subscriberValidationTimeout = TIMEOUT;\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public <T> void query() throws Exception {\n+        String query = \"SELECT * FROM r\";\n+\n+        Consumer<CosmosAsyncContainer> func = (container) -> {\n+            TestObject docDefinition = getDocumentDefinition();\n+            container.createItem(docDefinition).block();\n+\n+            CosmosQueryRequestOptions requestOptions = new CosmosQueryRequestOptions();\n+            CosmosPagedFlux<TestObject> queryFlux = container.queryItems(query, requestOptions, TestObject.class);\n+            FeedResponseListValidator<TestObject> queryValidator = new FeedResponseListValidator.Builder<TestObject>()\n+                .totalSize(1)\n+                .numberOfPages(1)\n+                .build();\n+            validateQuerySuccess(queryFlux.byPage(10), queryValidator);\n+        };\n+\n+        createDeleteContainerWithSameName(func);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public <T> void readItem() throws Exception {\n+\n+        Consumer<CosmosAsyncContainer> func = (container) -> {\n+            TestObject docDefinition = getDocumentDefinition();\n+            container.createItem(docDefinition).block();\n+\n+            Mono<CosmosItemResponse<TestObject>> responseMono = container.readItem(docDefinition.getId(),\n+                new PartitionKey(docDefinition.getMypk()),\n+                new CosmosItemRequestOptions(),\n+                TestObject.class);\n+\n+            CosmosItemResponseValidator validator =\n+                new CosmosItemResponseValidator.Builder<CosmosItemResponse<TestObject>>()\n+                    .withId(docDefinition.getId())\n+                    .build();\n+\n+            this.validateItemSuccess(responseMono, validator);\n+        };\n+\n+        createDeleteContainerWithSameName(func);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public <T> void deleteItem() throws Exception {\n+\n+        Consumer<CosmosAsyncContainer> func = (container) -> {\n+            TestObject docDefinition = getDocumentDefinition();\n+            container.createItem(docDefinition).block();\n+\n+            Mono<CosmosItemResponse<Object>> deleteObservable = container.deleteItem(\n+                docDefinition.getId(),\n+                new PartitionKey(docDefinition.getMypk()),\n+                new CosmosItemRequestOptions());\n+\n+            CosmosItemResponseValidator validator =\n+                new CosmosItemResponseValidator.Builder<CosmosItemResponse<TestObject>>()\n+                    .nullResource()\n+                    .build();\n+            this.validateItemSuccess(deleteObservable, validator);\n+        };\n+\n+        createDeleteContainerWithSameName(func);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public <T> void upsertItem() throws Exception {\n+\n+        Consumer<CosmosAsyncContainer> func = (container) -> {\n+            TestObject docDefinition = getDocumentDefinition();\n+            docDefinition = container.createItem(docDefinition).block().getItem();\n+\n+            docDefinition.setProp(UUID.randomUUID().toString());\n+\n+            Mono<CosmosItemResponse<TestObject>> readObservable = container.upsertItem(docDefinition, new CosmosItemRequestOptions());\n+\n+            // Validate result\n+            CosmosItemResponseValidator validator =\n+                new CosmosItemResponseValidator.Builder<CosmosItemResponse<TestObject>>()\n+                    .withProperty(\"prop\", docDefinition.getProp())\n+                    .build();\n+\n+            this.validateItemSuccess(readObservable, validator);\n+        };\n+\n+        createDeleteContainerWithSameName(func);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public <T> void changeFeed() throws Exception {\n+\n+        ObjectMapper objectMapper = Utils.getSimpleObjectMapper();\n+        BiConsumer<CosmosAsyncContainer, CosmosAsyncContainer> func = (feedContainer, leaseContainer) -> {\n+            String hostName = RandomStringUtils.randomAlphabetic(6);\n+            int CHANGE_FEED_PROCESSOR_TIMEOUT = 5000;\n+            final int FEED_COUNT = 10;\n+            List<TestObject> createdDocuments = new ArrayList<>();\n+            Map<String, TestObject> receivedDocuments = new ConcurrentHashMap<>();\n+\n+            setupReadFeedDocuments(createdDocuments, feedContainer, FEED_COUNT);\n+\n+            ChangeFeedProcessor changeFeedProcessor = new ChangeFeedProcessorBuilder()\n+                .hostName(hostName)\n+                .handleChanges((docs) -> {\n+                    for (JsonNode item : docs) {\n+                        try {\n+                            TestObject obj = objectMapper.treeToValue(item, TestObject.class);\n+                            receivedDocuments.put(obj.getId(), obj);\n+                        } catch (JsonProcessingException e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n+                })\n+                .feedContainer(feedContainer)\n+                .leaseContainer(leaseContainer)\n+                .options(new ChangeFeedProcessorOptions()\n+                    .setLeaseRenewInterval(Duration.ofSeconds(20))\n+                    .setLeaseAcquireInterval(Duration.ofSeconds(10))\n+                    .setLeaseExpirationInterval(Duration.ofSeconds(30))\n+                    .setFeedPollDelay(Duration.ofSeconds(2))\n+                    .setLeasePrefix(\"TEST\")\n+                    .setMaxItemCount(10)\n+                    .setStartFromBeginning(true)\n+                    .setMaxScaleCount(0) // unlimited\n+                )\n+                .buildChangeFeedProcessor();\n+\n+            try {\n+                changeFeedProcessor.start().subscribeOn(Schedulers.elastic())\n+                    .timeout(Duration.ofMillis(2 * CHANGE_FEED_PROCESSOR_TIMEOUT))\n+                    .subscribe();\n+            } catch (Exception ex) {\n+                throw ex;\n+            }\n+\n+            // Wait for the feed processor to receive and process the documents.\n+            try {\n+                Thread.sleep(2 * CHANGE_FEED_PROCESSOR_TIMEOUT);\n+                assertThat(changeFeedProcessor.isStarted()).as(\"Change Feed Processor instance is running\").isTrue();\n+\n+                changeFeedProcessor.stop().subscribeOn(Schedulers.elastic()).timeout(Duration.ofMillis(CHANGE_FEED_PROCESSOR_TIMEOUT)).subscribe();\n+\n+                for (TestObject item : createdDocuments) {\n+                    assertThat(receivedDocuments.containsKey(item.getId())).as(\"Document with getId: \" + item.getId()).isTrue();\n+                }\n+\n+                // Wait for the feed processor to shutdown.\n+                Thread.sleep(CHANGE_FEED_PROCESSOR_TIMEOUT);\n+\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Interrupted exception\", e);\n+            }\n+        };\n+\n+        changeFeedCreateDeleteContainerWithSameName(func);\n+    }\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ContainerCreateDeleteWithSameNameTest() throws Exception {\n+        client = getClientBuilder().buildAsyncClient();\n+        createdDatabase = getSharedCosmosDatabase(client);\n+    }\n+\n+    @AfterClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void after_ContainerCreateDeleteWithSameNameTest() throws Exception {\n+        safeDeleteAllCollections(createdDatabase);\n+    }\n+\n+    private <T> void createDeleteContainerWithSameName(Consumer<CosmosAsyncContainer> validateFunc) throws InterruptedException {\n+        CosmosAsyncContainer container = null;\n+        try {\n+            // step1: create container\n+            String testContainerId = UUID.randomUUID().toString();\n+            CosmosContainerProperties containerProperties = getCollectionDefinition(testContainerId);\n+            container = createCollection(this.createdDatabase, containerProperties, new CosmosContainerRequestOptions());\n+\n+            // Step2: execute func\n+            validateFunc.accept(container);\n+\n+            // step3: delete the container\n+            safeDeleteCollection(container);\n+            Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5600b9410d524e0cd1ef842a57082bc8807fae4c"}, "originalPosition": 237}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3674, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}