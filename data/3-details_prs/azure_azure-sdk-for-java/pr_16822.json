{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMjkwNjYw", "number": 16822, "title": "Adding client telemetry", "bodyText": "This PR will add client telemetry on java sdk.\n\nCurrently there is no wiring with service end point with this PR.\nDefault client telemetry capturing is off (User can turn on via builder api or system property)\nIt contains phase 1 aggregations(Document CRUD/Query operation, CPU, Memory Information)\nIt does not contains phase 2 aggregations (Metadata cache refresh, Rntbd connection data points), it will come after this PR\n\nAlso closes below issue\ncloses #13488\nExample json generated by client telemetry\nSystem info\n\nOperation Info", "createdAt": "2020-10-26T20:33:04Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822", "merged": true, "mergeCommit": {"oid": "d3d49f98abe043afcdcba30f272093f3438dd2f8"}, "closed": true, "closedAt": "2020-11-20T21:00:41Z", "author": {"login": "simplynaveen20"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQ82vRgH2gAyNTEwMjkwNjYwOjBiZWY1YzI1MmQ0NWQ0YWVlNjUwZTQyZmEzODE5MTNmMTQzMGUyMTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeJ4AcgH2gAyNTEwMjkwNjYwOmM4OTEzNjUxOWI2ZmNiNWJjOTFiYWJiY2MyZTZhNWI1NGM2YTc0ODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0bef5c252d45d4aee650e42fa381913f1430e212", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0bef5c252d45d4aee650e42fa381913f1430e212", "committedDate": "2020-10-09T21:14:07Z", "message": "client telemetry changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "078f8b14ad24d9a90feb6502da48fe2698425805", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/078f8b14ad24d9a90feb6502da48fe2698425805", "committedDate": "2020-10-09T21:30:02Z", "message": "build fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "623cf696789255583db90e6665ab5c4d3b08c925", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/623cf696789255583db90e6665ab5c4d3b08c925", "committedDate": "2020-10-19T19:11:23Z", "message": "adding incremental change for client telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e214000ec233da19a95da8405c68ab2931e04f24", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e214000ec233da19a95da8405c68ab2931e04f24", "committedDate": "2020-10-19T19:13:30Z", "message": "adding incremental change for client telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68cd2ee8c418dd7d1cbf92d0a305c668a954b312", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/68cd2ee8c418dd7d1cbf92d0a305c668a954b312", "committedDate": "2020-10-19T19:22:31Z", "message": "adding incremental change for client telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ac5a0f9983e0caa62e58602c9f0db722a69a917", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ac5a0f9983e0caa62e58602c9f0db722a69a917", "committedDate": "2020-10-19T19:25:42Z", "message": "merge with masrer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96e650bc88e383ea45a5792dc73caf77955aff63", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/96e650bc88e383ea45a5792dc73caf77955aff63", "committedDate": "2020-10-20T17:53:48Z", "message": "incremental check in"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "561849ee8eeb9a7b8f39a7cd7ad9fc8aa3e43e8c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/561849ee8eeb9a7b8f39a7cd7ad9fc8aa3e43e8c", "committedDate": "2020-10-26T19:04:15Z", "message": "Incremental work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df827ea09879f2f5c4d6afa85bce17fb5f7dc3d0", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/df827ea09879f2f5c4d6afa85bce17fb5f7dc3d0", "committedDate": "2020-10-26T19:09:18Z", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e38fa29b01ab1b95f6fa75f5eb957c626cf01bf7", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e38fa29b01ab1b95f6fa75f5eb957c626cf01bf7", "committedDate": "2020-10-26T20:21:37Z", "message": "Incremental work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f96b243b10963f2e18fd0bf0ec99550897a6bfae", "committedDate": "2020-10-26T20:25:06Z", "message": "incremental work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8c1f509176246306664dc0bbbf07c7240c2fa42", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/a8c1f509176246306664dc0bbbf07c7240c2fa42", "committedDate": "2020-10-26T22:45:30Z", "message": "adding setAutoResize on cpu and memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f087a988ec3bc8836d432b1113365d84173a3096", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f087a988ec3bc8836d432b1113365d84173a3096", "committedDate": "2020-10-27T18:53:12Z", "message": "adding useragent in serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60b2e6c0ee9888856e16ac427390e82e06c9cda6", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/60b2e6c0ee9888856e16ac427390e82e06c9cda6", "committedDate": "2020-10-29T16:07:04Z", "message": "Adding test file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6c8da63c311ebbada183cb99019bcf55bb06eea4", "committedDate": "2020-10-29T16:41:03Z", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5ODk5NjY1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-519899665", "createdAt": "2020-10-29T17:17:31Z", "commit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoxNzozMVrOHqmbTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoxNzozMVrOHqmbTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw==", "bodyText": "I got this hashing from our existing partition key class, I could have done without (hash * 397) , thoughts ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514431823", "createdAt": "2020-10-29T17:17:31Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3687c02c8e112d392357bd04d36bcd902aff6005", "committedDate": "2020-10-29T17:44:04Z", "message": "adding suprression for reportpayload equals method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMjE3ODEy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-520217812", "createdAt": "2020-10-30T00:30:04Z", "commit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozMDowNFrOHqzPyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDozNzozOVrOHqzXSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MTg2Nw==", "bodyText": "We need to tag it properly through external_dependencies.txt file - see the above external dependencies for examples on how to tag it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514641867", "createdAt": "2020-10-30T00:30:04Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ==", "bodyText": "Please add java documentation to this.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642419", "createdAt": "2020-10-30T00:32:11Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "diffHunk": "@@ -579,6 +580,11 @@ public CosmosClientBuilder multipleWriteRegionsEnabled(boolean multipleWriteRegi\n         return this;\n     }\n \n+    public CosmosClientBuilder clientTelemetryEnabled(boolean clientTelemetryEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA==", "bodyText": "This is great, thank you!\nPlease mention this issue in the PR as this API solves the github issue ask: #13488", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642704", "createdAt": "2020-10-30T00:33:28Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java", "diffHunk": "@@ -281,6 +281,22 @@ CosmosException setDiagnostics(CosmosDiagnostics cosmosDiagnostics) {\n         return this;\n     }\n \n+    /**\n+     * Gets the request charge as request units (RU) consumed by the operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw==", "bodyText": "It is every 600 seconds / 10 minutes ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642843", "createdAt": "2020-10-30T00:34:04Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA==", "bodyText": "nit: What if the val is not a boolean value - this will throw an exception and might stop the application. Instead we should try catch it and just log the error and move forward with default value.\nAlso, this is an issue with other API as well - getIntValue()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643450", "createdAt": "2020-10-30T00:36:12Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg==", "bodyText": "Please include clientTelemetryEnabled in toString() API", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643572", "createdAt": "2020-10-30T00:36:47Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ConnectionPolicy.java", "diffHunk": "@@ -497,6 +500,14 @@ public ConnectionPolicy setMaxRequestsPerConnection(int maxRequestsPerConnection\n         return this;\n     }\n \n+    public boolean isClientTelemetryEnabled() {\n+        return clientTelemetryEnabled;\n+    }\n+\n+    public void setClientTelemetryEnabled(boolean clientTelemetryEnabled) {\n+        this.clientTelemetryEnabled = clientTelemetryEnabled;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ConnectionPolicy{\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ==", "bodyText": "Why are we changing the scope of this API ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643785", "createdAt": "2020-10-30T00:37:39Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -121,18 +129,28 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n     public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n                                                                                    Context context,\n                                                                                    String spanName,\n+                                                                                   String containerId,\n                                                                                    String databaseId,\n-                                                                                   String endpoint) {\n-        return traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint,\n+                                                                                   CosmosAsyncClient client,\n+                                                                                   ConsistencyLevel consistencyLevel,\n+                                                                                   OperationType operationType,\n+                                                                                   ResourceType resourceType) {\n+\n+        return publisherWithClientTelemetry(resultPublisher, context, spanName, containerId, databaseId,\n+            BridgeInternal.getServiceEndpoint(client),\n+            client,\n+            consistencyLevel,\n+            operationType,\n+            resourceType,\n             CosmosItemResponse::getStatusCode);\n     }\n \n-    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n-                                             Context context,\n-                                             String spanName,\n-                                             String databaseId,\n-                                             String endpoint,\n-                                             Function<T, Integer> statusCodeFunc) {\n+    private <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bae66233a06f0f68824ca52ee35c46be9a704e3c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bae66233a06f0f68824ca52ee35c46be9a704e3c", "committedDate": "2020-11-03T20:01:51Z", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/252850bb53ec1a08ece93613b302abeb547a161b", "committedDate": "2020-11-03T20:59:27Z", "message": "performance turning and resolving comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTExNTE5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-522911519", "createdAt": "2020-11-03T22:11:02Z", "commit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMjoxMTowMlrOHtCRYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMjoxMTowMlrOHtCRYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTE4NA==", "bodyText": "Is this dependency meant for performance tests only? Right now this is being added as a compile time dependency.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516985184", "createdAt": "2020-11-03T22:11:02Z", "author": {"login": "alzimmermsft"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -104,7 +104,12 @@ Licensed under the MIT License.\n       <scope>test</scope>\n       <version>4.2</version> <!-- {x-version-update;org.apache.commons:commons-collections4;external_dependency} -->\n     </dependency>\n-\n+    <!-- https://mvnrepository.com/artifact/org.hdrhistogram/HdrHistogram -->\n+    <dependency>\n+      <groupId>org.hdrhistogram</groupId>\n+      <artifactId>HdrHistogram</artifactId>\n+      <version>2.1.4</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NTY1Njc4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-524565678", "createdAt": "2020-11-05T18:51:04Z", "commit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo1MTowNVrOHuRldQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTozODo1OVrOHuXroA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDY2MQ==", "bodyText": "Makes sense, thanks!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284661", "createdAt": "2020-11-05T18:51:05Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDg5MA==", "bodyText": "I see, cool, thanks!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284890", "createdAt": "2020-11-05T18:51:27Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}, "originalCommit": {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA==", "bodyText": "when checking for throwable instanceof CosmosException, shouldn't we try to unwrap the exception in case the exception is of type ReactiveException ?\nSame for other places where we are checking throwable in doOnError blocks.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518286200", "createdAt": "2020-11-05T18:53:42Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ==", "bodyText": "We also treat HttpConstants.StatusCodes.NOT_MODIFIED as success code in other places in the code. Shouldn't we include that here ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518287619", "createdAt": "2020-11-05T18:56:10Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ==", "bodyText": "nit : This could be a private class if not used outside, if used outside, may be Compute can be its own class outside.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518289671", "createdAt": "2020-11-05T18:59:43Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {\n+    private Compute compute;\n+    public String getLocation() {\n+        return compute != null ? compute.getLocation() : null;\n+    }\n+\n+    public Compute getCompute() {\n+        return compute;\n+    }\n+\n+    public void setCompute(Compute compute) {\n+        this.compute = compute;\n+    }\n+\n+    static class Compute{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA==", "bodyText": "Can you please add units to the name of this constant ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290364", "createdAt": "2020-11-05T19:00:51Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw==", "bodyText": "Please add unit to the name of the constant.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290607", "createdAt": "2020-11-05T19:01:15Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ==", "bodyText": "I see, this is trace logging, while others are warning and info, is there a reason for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518293515", "createdAt": "2020-11-05T19:06:30Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA==", "bodyText": "Are we doing recursion inside flatMap ?\nThere could be a better way to do this instead of doing it though flatMap- please take a look at expand operation from project reactor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518295548", "createdAt": "2020-11-05T19:09:59Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ==", "bodyText": "where is that validation happening ?\nMay be worth mentioning here ?\nAlso, how do we plan to validate the keys specially in the set API for percentiles ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518298911", "createdAt": "2020-11-05T19:15:44Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwMDM5NQ==", "bodyText": "The notion of 397 is - usually in hashCode() we take a prime number and then use that to generate hashCode.\nI will suggest to keep it.\nCan you also please check what IntelliJ generates when you generate the hashCode with it ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518300395", "createdAt": "2020-11-05T19:17:20Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}, "originalCommit": {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw==", "bodyText": "why can't we keep it double?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518383157", "createdAt": "2020-11-05T21:36:19Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/cpu/CpuMemoryReader.java", "diffHunk": "@@ -9,44 +9,56 @@\n \n import java.lang.management.ManagementFactory;\n \n-public class CpuReader {\n-    private final static Logger logger = LoggerFactory.getLogger(CpuReader.class);\n+public class CpuMemoryReader {\n+    private final static Logger logger = LoggerFactory.getLogger(CpuMemoryReader.class);\n     private final com.sun.management.OperatingSystemMXBean operatingSystemMXBean;\n \n-    public CpuReader() {\n+    public CpuMemoryReader() {\n         java.lang.management.OperatingSystemMXBean mxBean = null;\n         try {\n             mxBean =\n                 ManagementFactory.getOperatingSystemMXBean();\n         } catch (Throwable t) {\n-            logger.error(\"failed to initialized CpuReader\", t);\n+            logger.error(\"failed to initialized CpuMemoryReader\", t);\n         }\n \n         this.operatingSystemMXBean = tryGetAs(mxBean,\n             com.sun.management.OperatingSystemMXBean.class);\n     }\n \n-    public double getSystemWideCpuUsage() {\n+    public float getSystemWideCpuUsage() {\n         try {\n             if (operatingSystemMXBean != null) {\n-                double val = operatingSystemMXBean.getSystemCpuLoad();\n+                float val = (float) operatingSystemMXBean.getSystemCpuLoad();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA==", "bodyText": "I wonder why we can't keep it double in the client telemetry as well ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518384544", "createdAt": "2020-11-05T21:38:59Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -125,11 +139,103 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n                 pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable),\n                     TracerProvider.ERROR_CODE);\n             }\n+\n+            if (pagedFluxOptions.getCosmosAsyncClient() != null &&\n+                Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(pagedFluxOptions.getCosmosAsyncClient())) &&\n+                throwable instanceof CosmosException) {\n+                CosmosException cosmosException = (CosmosException) throwable;\n+                fillClientTelemetry(pagedFluxOptions.getCosmosAsyncClient(), 0, pagedFluxOptions.getContainerId(),\n+                    pagedFluxOptions.getDatabaseId(),\n+                    pagedFluxOptions.getOperationType(), pagedFluxOptions.getResourceType(),\n+                    BridgeInternal.getContextClient(pagedFluxOptions.getCosmosAsyncClient()).getConsistencyLevel(),\n+                    (float) cosmosException.getRequestCharge(), Duration.between(startTime.get(), Instant.now()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTY3NDM0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-517167434", "createdAt": "2020-10-26T20:54:13Z", "commit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1NDoxNFrOHoh92w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMDo1MDo1NVrOHucOhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ==", "bodyText": "why aren't we capturing the exception stacktace?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261595", "createdAt": "2020-10-26T20:54:14Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA==", "bodyText": "ditto", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261680", "createdAt": "2020-10-26T20:54:21Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA==", "bodyText": "you are capturing the exception message twice.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512263648", "createdAt": "2020-10-26T20:57:54Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();\n+            }).onErrorResume(ex -> {\n+                logger.error(\"sendClientTelemetry() - Unable to send client telemetry\" +\n+                    \". Exception: {}\", ex.toString(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ==", "bodyText": "is this accessed from multiple threads?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518457521", "createdAt": "2020-11-06T00:46:02Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw==", "bodyText": "please use log instead of e.printSTackTrace", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458103", "createdAt": "2020-11-06T00:47:50Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA==", "bodyText": "ideally we should use daemon threads otherwise if executor is not shutdown correctly JVM will not terminate.\nTake a look at how rntbd sets up its daemon IO threads.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458644", "createdAt": "2020-11-06T00:49:42Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ==", "bodyText": "constant?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518459015", "createdAt": "2020-11-06T00:50:55Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_CHARGE_NAME, ClientTelemetry.REQUEST_CHARGE_UNIT);\n+        ConcurrentDoubleHistogram requestChargeHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadRequestCharge);\n+        if (requestChargeHistogram != null) {\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+        } else {\n+            requestChargeHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_CHARGE_MAX, ClientTelemetry.REQUEST_CHARGE_PRECISION);\n+            requestChargeHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadRequestCharge,\n+                requestChargeHistogram);\n+        }\n+    }\n+\n+    private ReportPayload createReportPayload(CosmosAsyncClient cosmosAsyncClient,\n+                                              CosmosDiagnostics cosmosDiagnostics,\n+                                              int statusCode,\n+                                              Integer objectSize,\n+                                              String containerId,\n+                                              String databaseId,\n+                                              OperationType operationType,\n+                                              ResourceType resourceType,\n+                                              ConsistencyLevel consistencyLevel,\n+                                              String metricsName,\n+                                              String unitName) {\n+        ReportPayload reportPayload = new ReportPayload(metricsName, unitName);\n+        reportPayload.setRegionsContacted(BridgeInternal.getRegionContacted(cosmosDiagnostics).toString());\n+        reportPayload.setConsistency(consistencyLevel == null ?\n+            BridgeInternal.getContextClient(cosmosAsyncClient).getConsistencyLevel() :\n+            consistencyLevel);\n+        if (objectSize != null) {\n+            reportPayload.setGreaterThan1Kb(objectSize > 1024);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "252850bb53ec1a08ece93613b302abeb547a161b"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80b2d75f73f2058994b5e1b5608f5a6da9438340", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/80b2d75f73f2058994b5e1b5608f5a6da9438340", "committedDate": "2020-11-10T17:32:49Z", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "committedDate": "2020-11-10T17:40:49Z", "message": "resolving comments and merge with latest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NTI4OTQ0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527528944", "createdAt": "2020-11-10T19:15:41Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU3ODY3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527657867", "createdAt": "2020-11-10T22:25:37Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNTozOFrOHwyCAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNTozOFrOHwyCAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzQwOA==", "bodyText": "I believe the cosmos_ prefix is necessary in this tag as well.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520913408", "createdAt": "2020-11-10T22:25:38Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -232,6 +236,7 @@ Licensed under the MIT License.\n                 <include>io.dropwizard.metrics:metrics-core:[4.1.0]</include> <!-- {x-include-update;cosmos_io.dropwizard.metrics:metrics-core;external_dependency} -->\n                 <include>io.micrometer:micrometer-core:[1.5.6]</include> <!-- {x-include-update;io.micrometer:micrometer-core;external_dependency} -->\n                 <include>org.slf4j:slf4j-api:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-api;external_dependency} -->\n+                <include>org.hdrhistogram:HdrHistogram</include> <!-- {x-include-update;org.hdrhistogram:HdrHistogram;external_dependency} -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjYwNjQy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527660642", "createdAt": "2020-11-10T22:30:37Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjozMDozN1rOHwyKxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjozMDozN1rOHwyKxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw==", "bodyText": "Should be getRegionsContacted?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520915653", "createdAt": "2020-11-10T22:30:37Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -70,6 +73,26 @@ public static CosmosDiagnostics createCosmosDiagnostics(DiagnosticsClientContext\n         return new CosmosDiagnostics(diagnosticsClientContext);\n     }\n \n+    @Warning(value = INTERNAL_USE_ONLY_WARNING)\n+    public static Set<URI> getRegionContacted(CosmosDiagnostics cosmosDiagnostics) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjcwMTM2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527670136", "createdAt": "2020-11-10T22:47:52Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo0Nzo1MlrOHwyo0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo0Nzo1MlrOHwyo0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA==", "bodyText": "300 instead - to stick with 5 minutes which we used everywhere else? We can adjust if needed - but why not start with the default that works reasonably well in other places?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520923344", "createdAt": "2020-11-10T22:47:52Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjczMDQw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527673040", "createdAt": "2020-11-10T22:53:21Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1MzoyMlrOHwyyDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1MzoyMlrOHwyyDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA==", "bodyText": "I think the right groups here are\n200 - 299 --> success\n400 - 499 --> client_failure\n\n= 500 --> service failure", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925708", "createdAt": "2020-11-10T22:53:22Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjczMjg3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527673287", "createdAt": "2020-11-10T22:53:50Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1Mzo1MVrOHwyy2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1Mzo1MVrOHwyy2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTkxMw==", "bodyText": "NIT ',' at teh end of the line", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925913", "createdAt": "2020-11-10T22:53:51Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Njc0MTUy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527674152", "createdAt": "2020-11-10T22:55:31Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1NTozMVrOHwy1qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo1NTozMVrOHwy1qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ==", "bodyText": "VM SKU woudl be very helpful as well?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520926635", "createdAt": "2020-11-10T22:55:31Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Njc4OTI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#pullrequestreview-527678927", "createdAt": "2020-11-10T23:04:56Z", "commit": {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/096a55afd9559b20be0169c9ee9c7c1858f2813a", "committedDate": "2020-11-13T15:54:49Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00cadd2d4b6535811e3d6f3447387831a84ebe11", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/00cadd2d4b6535811e3d6f3447387831a84ebe11", "committedDate": "2020-11-13T15:56:16Z", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9fc1870497e155351c762b0bf9a7b56f14c71f2", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9fc1870497e155351c762b0bf9a7b56f14c71f2", "committedDate": "2020-11-13T16:06:34Z", "message": "fixing build error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06cfe0d223b216ae53212eed965da9b5f0dbe268", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/06cfe0d223b216ae53212eed965da9b5f0dbe268", "committedDate": "2020-11-13T16:23:20Z", "message": "resolving build error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17b829eca5ff981b6352625f526490923e03a7b9", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/17b829eca5ff981b6352625f526490923e03a7b9", "committedDate": "2020-11-13T16:36:44Z", "message": "moving before and after from simple to emulator for telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "071f928e47bb7945ed473a391320309b96032421", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/071f928e47bb7945ed473a391320309b96032421", "committedDate": "2020-11-19T21:43:17Z", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "committedDate": "2020-11-19T21:45:17Z", "message": "merge with master and changing database field name in report payload"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1677, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}