{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTc2OTMx", "number": 11823, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0MjozNVrOEDCq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1ODoxM1rOEDC-9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjI0OTU5OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusTokenCredentialHttpPolicy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0MjozNVrOGf3iNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0MjozNVrOGf3iNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2ODkxOQ==", "bodyText": "May be we can use netty library available https://netty.io/4.1/api/io/netty/handler/codec/http/HttpHeaderNames.html#AUTHORIZATION", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11823#discussion_r436068919", "createdAt": "2020-06-05T17:42:35Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusTokenCredentialHttpPolicy.java", "diffHunk": "@@ -0,0 +1,37 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Token credential policy for authenticating with Service Bus.\n+ */\n+class ServiceBusTokenCredentialHttpPolicy implements HttpPipelinePolicy {\n+    private final TokenCredential tokenCredential;\n+\n+    /**\n+     * Creates a new credential policy using the Token credential.\n+     *\n+     * @param tokenCredential Token credential to get access token from.\n+     */\n+    ServiceBusTokenCredentialHttpPolicy(TokenCredential tokenCredential) {\n+        this.tokenCredential = tokenCredential;\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        final String url = context.getHttpRequest().getUrl().toString();\n+        return tokenCredential.getToken(new TokenRequestContext().addScopes(url)).flatMap(token -> {\n+            context.getHttpRequest().getHeaders().put(\"Authorization\", token.getToken());\n+            return next.process();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2247061901951eb4b239b26daf9d87e856764e9a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjI2OTQ1OnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusTokenCredentialHttpPolicy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0ODo1NFrOGf3uzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMzowM1rOGf4LqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjE0Mw==", "bodyText": "same as above https://netty.io/4.1/api/io/netty/handler/codec/http/HttpHeaderNames.html#AUTHORIZATION", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11823#discussion_r436072143", "createdAt": "2020-06-05T17:48:54Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusTokenCredentialHttpPolicy.java", "diffHunk": "@@ -0,0 +1,32 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Token credential policy for authenticating with service bus.\n+ */\n+public class ServiceBusTokenCredentialHttpPolicy implements HttpPipelinePolicy {\n+    private final TokenCredential tokenCredential;\n+\n+    ServiceBusTokenCredentialHttpPolicy(TokenCredential tokenCredential) {\n+        this.tokenCredential = tokenCredential;\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        final String url = context.getHttpRequest().getUrl().toString();\n+        return tokenCredential.getToken(new TokenRequestContext().addScopes(url)).flatMap(token -> {\n+            context.getHttpRequest().getHeaders().put(\"Authorization\", token.getToken());\n+            return next.process();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c63a9850b1a5987eb6f47ff5799824533855496"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTUyOA==", "bodyText": "What if they use OkHttp as their client? Now they'd be pulling in both dependencies.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11823#discussion_r436079528", "createdAt": "2020-06-05T18:03:03Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusTokenCredentialHttpPolicy.java", "diffHunk": "@@ -0,0 +1,32 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Token credential policy for authenticating with service bus.\n+ */\n+public class ServiceBusTokenCredentialHttpPolicy implements HttpPipelinePolicy {\n+    private final TokenCredential tokenCredential;\n+\n+    ServiceBusTokenCredentialHttpPolicy(TokenCredential tokenCredential) {\n+        this.tokenCredential = tokenCredential;\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        final String url = context.getHttpRequest().getUrl().toString();\n+        return tokenCredential.getToken(new TokenRequestContext().addScopes(url)).flatMap(token -> {\n+            context.getHttpRequest().getHeaders().put(\"Authorization\", token.getToken());\n+            return next.process();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjE0Mw=="}, "originalCommit": {"oid": "0c63a9850b1a5987eb6f47ff5799824533855496"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjMwMDcxOnYy", "diffSide": "RIGHT", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusManagementClientImplIntegrationTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1ODoxM1rOGf4CPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowNDoxNlrOGf4N-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzExNw==", "bodyText": "https://netty.io/4.0/api/io/netty/handler/codec/http/HttpResponseStatus.html#OK", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11823#discussion_r436077117", "createdAt": "2020-06-05T17:58:13Z", "author": {"login": "hemanttanwar"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusManagementClientImplIntegrationTests.java", "diffHunk": "@@ -0,0 +1,257 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.test.TestMode;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.TestUtils;\n+import com.azure.messaging.servicebus.implementation.models.CreateQueueBody;\n+import com.azure.messaging.servicebus.implementation.models.CreateQueueBodyContent;\n+import com.azure.messaging.servicebus.implementation.models.QueueDescriptionFeed;\n+import com.azure.messaging.servicebus.implementation.models.QueueDescriptionResponse;\n+import com.azure.messaging.servicebus.models.QueueDescription;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Integration tests for {@link ServiceBusManagementClientImpl}.\n+ */\n+class ServiceBusManagementClientImplIntegrationTests extends TestBase {\n+    private final ClientLogger logger = new ClientLogger(ServiceBusManagementClientImplIntegrationTests.class);\n+    private final ServiceBusManagementSerializer serializer = new ServiceBusManagementSerializer();\n+    private final Duration timeout = Duration.ofSeconds(30);\n+\n+    private QueuesImpl queuesClient;\n+    private ServiceBusManagementClientImpl managementClient;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        Assumptions.assumeTrue(getTestMode() != TestMode.PLAYBACK,\n+            \"Current record/playback does not support persisting XML calls.\");\n+\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(TestUtils.getConnectionString());\n+        final ServiceBusSharedKeyCredential credential = new ServiceBusSharedKeyCredential(\n+            properties.getSharedAccessKeyName(), properties.getSharedAccessKey());\n+\n+        HttpPipeline pipeline = new HttpPipelineBuilder().policies(\n+            new UserAgentPolicy(),\n+            (context, next) -> {\n+                final String url = context.getHttpRequest().getUrl().toString();\n+                return credential.getToken(new TokenRequestContext().addScopes(url)).flatMap(token -> {\n+                    context.getHttpRequest().getHeaders().put(\"Authorization\", token.getToken());\n+                    return next.process();\n+                });\n+            },\n+            new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)\n+                .addAllowedQueryParamName(\"api-version\")),\n+            new RetryPolicy()\n+        ).build();\n+\n+        managementClient = new ServiceBusManagementClientImplBuilder()\n+            .serializer(serializer)\n+            .endpoint(properties.getEndpoint().getHost())\n+            .apiVersion(\"2017-04\")\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        queuesClient = managementClient.getQueues();\n+    }\n+\n+    /**\n+     * Verifies we can get queue information.\n+     */\n+    @Test\n+    void getQueue() {\n+        // Arrange\n+        String queueName = TestUtils.getQueueName();\n+\n+        // Act & Assert\n+        StepVerifier.create(queuesClient.getWithResponseAsync(queueName, true, Context.NONE))\n+            .assertNext(response -> {\n+                final QueueDescriptionResponse deserialize = deserialize(response, QueueDescriptionResponse.class);\n+                assertNotNull(deserialize);\n+                assertNotNull(deserialize.getContent());\n+\n+                final QueueDescription properties = deserialize.getContent().getQueueDescription();\n+                assertNotNull(properties);\n+                assertFalse(properties.getLockDuration().isZero());\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies we can create a queue.\n+     */\n+    @Test\n+    void createQueue() {\n+        // Arrange\n+        String queueName = testResourceNamer.randomName(\"test\", 7);\n+        QueueDescription description = new QueueDescription().setMaxDeliveryCount(15);\n+        CreateQueueBody createEntity = new CreateQueueBody();\n+        CreateQueueBodyContent content = new CreateQueueBodyContent()\n+            .setType(\"application/xml\")\n+            .setQueueDescription(description);\n+        createEntity.setContent(content);\n+\n+        logger.info(\"Creating queue: {}\", queueName);\n+\n+        // Act & Assert\n+        StepVerifier.create(queuesClient.putWithResponseAsync(queueName, createEntity, null, Context.NONE))\n+            .assertNext(response -> {\n+                Object body = response.getValue();\n+                QueueDescription deserialize = null;\n+                try {\n+                    deserialize = new ServiceBusManagementSerializer()\n+                        .deserialize(String.valueOf(body), QueueDescription.class);\n+                } catch (IOException e) {\n+                    fail(\"An exception was thrown. \" + e);\n+                }\n+\n+                assertNotNull(deserialize);\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies we can delete a queue.\n+     */\n+    @Test\n+    void deleteQueue() {\n+        // Arrange\n+        String queueName = testResourceNamer.randomName(\"test\", 7);\n+        QueueDescription description = new QueueDescription().setMaxDeliveryCount(15);\n+        CreateQueueBody createEntity = new CreateQueueBody();\n+        CreateQueueBodyContent content = new CreateQueueBodyContent()\n+            .setType(\"application/xml\")\n+            .setQueueDescription(description);\n+        createEntity.setContent(content);\n+\n+        logger.info(\"Creating queue: {}\", queueName);\n+\n+        // This is not part of the scenario. We'll ensure it is created.\n+        Response<Object> response = queuesClient.putWithResponseAsync(queueName, createEntity, null, Context.NONE)\n+            .block(timeout);\n+        assertNotNull(response);\n+\n+        // Act & Assert\n+        StepVerifier.create(queuesClient.deleteWithResponseAsync(queueName, Context.NONE))\n+            .assertNext(deletedResponse -> assertEquals(200, deletedResponse.getStatusCode()))\n+            .verifyComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2247061901951eb4b239b26daf9d87e856764e9a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4MDEyMg==", "bodyText": "Same comment as above. You can explicitly exclude dependencies and this would tie them to netty instead of another http client.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11823#discussion_r436080122", "createdAt": "2020-06-05T18:04:16Z", "author": {"login": "conniey"}, "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusManagementClientImplIntegrationTests.java", "diffHunk": "@@ -0,0 +1,257 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.test.TestMode;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.TestUtils;\n+import com.azure.messaging.servicebus.implementation.models.CreateQueueBody;\n+import com.azure.messaging.servicebus.implementation.models.CreateQueueBodyContent;\n+import com.azure.messaging.servicebus.implementation.models.QueueDescriptionFeed;\n+import com.azure.messaging.servicebus.implementation.models.QueueDescriptionResponse;\n+import com.azure.messaging.servicebus.models.QueueDescription;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Integration tests for {@link ServiceBusManagementClientImpl}.\n+ */\n+class ServiceBusManagementClientImplIntegrationTests extends TestBase {\n+    private final ClientLogger logger = new ClientLogger(ServiceBusManagementClientImplIntegrationTests.class);\n+    private final ServiceBusManagementSerializer serializer = new ServiceBusManagementSerializer();\n+    private final Duration timeout = Duration.ofSeconds(30);\n+\n+    private QueuesImpl queuesClient;\n+    private ServiceBusManagementClientImpl managementClient;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        Assumptions.assumeTrue(getTestMode() != TestMode.PLAYBACK,\n+            \"Current record/playback does not support persisting XML calls.\");\n+\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(TestUtils.getConnectionString());\n+        final ServiceBusSharedKeyCredential credential = new ServiceBusSharedKeyCredential(\n+            properties.getSharedAccessKeyName(), properties.getSharedAccessKey());\n+\n+        HttpPipeline pipeline = new HttpPipelineBuilder().policies(\n+            new UserAgentPolicy(),\n+            (context, next) -> {\n+                final String url = context.getHttpRequest().getUrl().toString();\n+                return credential.getToken(new TokenRequestContext().addScopes(url)).flatMap(token -> {\n+                    context.getHttpRequest().getHeaders().put(\"Authorization\", token.getToken());\n+                    return next.process();\n+                });\n+            },\n+            new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)\n+                .addAllowedQueryParamName(\"api-version\")),\n+            new RetryPolicy()\n+        ).build();\n+\n+        managementClient = new ServiceBusManagementClientImplBuilder()\n+            .serializer(serializer)\n+            .endpoint(properties.getEndpoint().getHost())\n+            .apiVersion(\"2017-04\")\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        queuesClient = managementClient.getQueues();\n+    }\n+\n+    /**\n+     * Verifies we can get queue information.\n+     */\n+    @Test\n+    void getQueue() {\n+        // Arrange\n+        String queueName = TestUtils.getQueueName();\n+\n+        // Act & Assert\n+        StepVerifier.create(queuesClient.getWithResponseAsync(queueName, true, Context.NONE))\n+            .assertNext(response -> {\n+                final QueueDescriptionResponse deserialize = deserialize(response, QueueDescriptionResponse.class);\n+                assertNotNull(deserialize);\n+                assertNotNull(deserialize.getContent());\n+\n+                final QueueDescription properties = deserialize.getContent().getQueueDescription();\n+                assertNotNull(properties);\n+                assertFalse(properties.getLockDuration().isZero());\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies we can create a queue.\n+     */\n+    @Test\n+    void createQueue() {\n+        // Arrange\n+        String queueName = testResourceNamer.randomName(\"test\", 7);\n+        QueueDescription description = new QueueDescription().setMaxDeliveryCount(15);\n+        CreateQueueBody createEntity = new CreateQueueBody();\n+        CreateQueueBodyContent content = new CreateQueueBodyContent()\n+            .setType(\"application/xml\")\n+            .setQueueDescription(description);\n+        createEntity.setContent(content);\n+\n+        logger.info(\"Creating queue: {}\", queueName);\n+\n+        // Act & Assert\n+        StepVerifier.create(queuesClient.putWithResponseAsync(queueName, createEntity, null, Context.NONE))\n+            .assertNext(response -> {\n+                Object body = response.getValue();\n+                QueueDescription deserialize = null;\n+                try {\n+                    deserialize = new ServiceBusManagementSerializer()\n+                        .deserialize(String.valueOf(body), QueueDescription.class);\n+                } catch (IOException e) {\n+                    fail(\"An exception was thrown. \" + e);\n+                }\n+\n+                assertNotNull(deserialize);\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies we can delete a queue.\n+     */\n+    @Test\n+    void deleteQueue() {\n+        // Arrange\n+        String queueName = testResourceNamer.randomName(\"test\", 7);\n+        QueueDescription description = new QueueDescription().setMaxDeliveryCount(15);\n+        CreateQueueBody createEntity = new CreateQueueBody();\n+        CreateQueueBodyContent content = new CreateQueueBodyContent()\n+            .setType(\"application/xml\")\n+            .setQueueDescription(description);\n+        createEntity.setContent(content);\n+\n+        logger.info(\"Creating queue: {}\", queueName);\n+\n+        // This is not part of the scenario. We'll ensure it is created.\n+        Response<Object> response = queuesClient.putWithResponseAsync(queueName, createEntity, null, Context.NONE)\n+            .block(timeout);\n+        assertNotNull(response);\n+\n+        // Act & Assert\n+        StepVerifier.create(queuesClient.deleteWithResponseAsync(queueName, Context.NONE))\n+            .assertNext(deletedResponse -> assertEquals(200, deletedResponse.getStatusCode()))\n+            .verifyComplete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzExNw=="}, "originalCommit": {"oid": "2247061901951eb4b239b26daf9d87e856764e9a"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4004, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}